{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"flixOpt <p>Energy and Material Flow Optimization Framework</p> <p>Model, optimize, and analyze complex energy systems with a powerful Python framework designed for flexibility and performance.</p> <p> \ud83d\ude80 Get Started \ud83d\udca1 View Examples \u2b50 GitHub </p>"},{"location":"#quick-navigation","title":"Quick Navigation","text":"\ud83d\ude80 Getting Started <p>New to FlixOpt? Start here with installation and your first model</p> \ud83d\udca1 Examples Gallery <p>Explore real-world examples from simple to complex systems</p> \ud83d\udcda API Reference <p>Detailed documentation of all classes, methods, and parameters</p> \ud83d\udcd6 Recipes <p>Common patterns and best practices for modeling energy systems</p> \u222b Mathematical Notation <p>Understand the mathematical formulations behind the framework</p> \ud83d\udee3\ufe0f Roadmap <p>See what's coming next and contribute to the future of FlixOpt</p>"},{"location":"#framework-architecture","title":"\ud83c\udfd7\ufe0f Framework Architecture","text":"Conceptual Usage and IO operations of FlixOpt <p>FlixOpt provides a complete workflow for energy system optimization:</p> <ul> <li> Define your system using Python components</li> <li> Optimize with powerful solvers (HiGHS, Gurobi, CPLEX)</li> <li> Analyze results with built-in visualization tools</li> <li> Export to various formats for further analysis</li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":""},{"location":"#github","title":"GitHub","text":"<p>Report issues, request features, and contribute to the codebase</p> <p>Visit Repository \u2192</p>"},{"location":"#discussions","title":"Discussions","text":"<p>Ask questions and share your projects with the community</p> <p>Join Discussion \u2192</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Help improve FlixOpt by contributing code, docs, or examples</p> <p>Learn How \u2192</p>"},{"location":"#recent-updates","title":"Recent Updates","text":"<p>What's New in v3.0.0</p> <p>Major improvements and breaking changes. Check the Migration Guide for upgrading from v2.x.</p> <p>\ud83d\udccb See the full Release Notes for detailed version history.</p> Ready to optimize your energy system? <p> \u25b6\ufe0f Start Building </p>"},{"location":"#flixopt-energy-and-material-flow-optimization-framework","title":"FlixOpt: Energy and Material Flow Optimization Framework","text":"<p>FlixOpt is a Python framework for optimizing energy and material flow systems - from district heating networks to industrial production lines, from renewable energy portfolios to supply chain logistics.</p> <p>Start simple, scale complex: Build a working optimization model in minutes, then progressively add detail - multi-period investments, stochastic scenarios, custom constraints - without rewriting your code.</p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"Bash<pre><code>pip install flixopt\n</code></pre> <p>That's it! FlixOpt comes with the HiGHS solver included. You're ready to optimize.</p> <p>The basic workflow:</p> Python<pre><code>import flixopt as fx\n\n# 1. Define your system structure\nflow_system = fx.FlowSystem(timesteps)\nflow_system.add_elements(buses, components, effects)\n\n# 2. Create and solve\ncalculation = fx.FullCalculation(\"MyModel\", flow_system)\ncalculation.solve()\n\n# 3. Analyze results\ncalculation.results.solution\n</code></pre> <p>Get started with real examples: - \ud83d\udcda Full Documentation - \ud83d\udca1 Examples Gallery - Complete working examples from simple to complex - \ud83d\udd27 API Reference</p>"},{"location":"#why-flixopt","title":"\ud83c\udf1f Why FlixOpt?","text":""},{"location":"#progressive-enhancement-your-model-grows-with-you","title":"Progressive Enhancement - Your Model Grows With You","text":"<p>Start simple: Python<pre><code># Basic single-period model\nflow_system = fx.FlowSystem(timesteps)\nboiler = fx.Boiler(\"Boiler\", eta=0.9, ...)\n</code></pre></p> <p>Add complexity incrementally: - Investment decisions \u2192 Add <code>InvestParameters</code> to components - Multi-period planning \u2192 Add <code>periods</code> dimension to FlowSystem - Uncertainty modeling \u2192 Add <code>scenarios</code> dimension with probabilities - Custom constraints \u2192 Extend with native linopy syntax</p> <p>No refactoring required. Your component definitions stay the same - periods, scenarios, and features are added as dimensions and parameters.</p> <p>\u2192 Learn more about multi-period and stochastic modeling</p>"},{"location":"#for-everyone","title":"For Everyone","text":"<ul> <li>Beginners: High-level components that \"just work\"</li> <li>Experts: Full access to modify models with linopy</li> <li>Researchers: Quick prototyping with customization options</li> <li>Engineers: Reliable, tested components without black boxes</li> <li>Students: Clear, Pythonic interfaces for learning optimization</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<p>Multi-criteria optimization: Model costs, emissions, resource use - any custom metric. Optimize single objectives or use weighted combinations and \u03b5-constraints. \u2192 Effects documentation</p> <p>Performance at any scale: Choose calculation modes without changing your model - Full, Segmented, or Aggregated (using TSAM). \u2192 Calculation modes</p> <p>Built for reproducibility: Self-contained NetCDF result files with complete model information. Load results months later - everything is preserved. \u2192 Results documentation</p> <p>Flexible data operations: Transform FlowSystems with xarray-style operations (<code>sel()</code>, <code>resample()</code>) for multi-stage optimization.</p>"},{"location":"#what-is-flixopt","title":"\ud83c\udfaf What is FlixOpt?","text":""},{"location":"#a-general-purpose-flow-optimization-framework","title":"A General-Purpose Flow Optimization Framework","text":"<p>FlixOpt models any system involving flows and conversions:</p> <ul> <li>Energy systems: District heating/cooling, microgrids, renewable portfolios, sector coupling</li> <li>Material flows: Supply chains, production lines, chemical processes</li> <li>Integrated systems: Water-energy nexus, industrial symbiosis</li> </ul> <p>While energy systems are our primary focus, the same foundation applies universally. This enables coupling different system types within integrated models.</p>"},{"location":"#modern-foundations","title":"Modern Foundations","text":"<p>Built on linopy and xarray, FlixOpt delivers performance and transparency. Full access to variables, constraints, and model structure. Extend anything with native linopy syntax.</p>"},{"location":"#our-position","title":"Our Position","text":"<p>We bridge the gap between high-level strategic models (like FINE) and low-level dispatch tools - similar to PyPSA. FlixOpt is the sweet spot for detailed operational planning and long-term investment analysis in the same framework.</p>"},{"location":"#academic-roots","title":"Academic Roots","text":"<p>Originally developed at TU Dresden for the SMARTBIOGRID project (funded by the German Federal Ministry for Economic Affairs and Energy, FKZ: 03KB159B). FlixOpt evolved from the MATLAB-based flixOptMat framework while incorporating best practices from oemof/solph.</p>"},{"location":"#roadmap","title":"\ud83d\udee3\ufe0f Roadmap","text":"<p>FlixOpt aims to be the most accessible, flexible, and universal Python framework for energy and material flow optimization. We believe optimization modeling should be approachable for beginners yet powerful for experts, minimizing context switching between different planning horizons.</p> <p>Current focus: - Enhanced component library (sector coupling, hydrogen, thermal networks) - Examples showcasing multi-period and stochastic modeling - Advanced result analysis and visualization</p> <p>Future vision: - Modeling to generate alternatives (MGA) for robust decision-making - Advanced stochastic optimization (two-stage, CVaR) - Community ecosystem of user-contributed components</p> <p>\u2192 Full roadmap and vision</p>"},{"location":"#installation","title":"\ud83d\udee0\ufe0f Installation","text":""},{"location":"#basic-installation","title":"Basic Installation","text":"Bash<pre><code>pip install flixopt\n</code></pre> <p>Includes the HiGHS solver - you're ready to optimize immediately.</p>"},{"location":"#full-installation","title":"Full Installation","text":"<p>For additional features (interactive network visualization, time series aggregation):</p> Bash<pre><code>pip install \"flixopt[full]\"\n</code></pre>"},{"location":"#solver-support","title":"Solver Support","text":"<p>FlixOpt supports many solvers via linopy: HiGHS (included), Gurobi, CPLEX, CBC, GLPK, and more.</p> <p>\u2192 Installation guide</p>"},{"location":"#contributing_1","title":"\ud83e\udd1d Contributing","text":"<p>FlixOpt thrives on community input. Whether you're fixing bugs, adding components, improving docs, or sharing use cases - we welcome your contributions.</p> <p>\u2192 Contribution guide</p>"},{"location":"#citation","title":"\ud83d\udcd6 Citation","text":"<p>If FlixOpt supports your research or project, please cite:</p> <ul> <li>Main Citation: DOI:10.18086/eurosun.2022.04.07</li> <li>Short Overview: DOI:10.13140/RG.2.2.14948.24969</li> </ul>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>MIT License - See LICENSE for details.</p>"},{"location":"contribute/","title":"Contributing to the Project","text":"<p>We warmly welcome contributions from the community! This guide will help you get started with contributing to our project.</p>"},{"location":"contribute/#development-setup","title":"Development Setup","text":"<ol> <li>Clone the repository <code>git clone https://github.com/flixOpt/flixopt.git</code></li> <li>Install the development dependencies <code>pip install -e \".[dev]\"</code></li> <li>Install pre-commit hooks <code>pre-commit install</code> (one-time setup)</li> <li>Run <code>pytest</code> to ensure your code passes all tests</li> </ol>"},{"location":"contribute/#code-quality","title":"Code Quality","text":"<p>We use Ruff for linting and formatting. After the one-time setup above, code quality checks run automatically on every commit.</p> <p>To run manually: - <code>ruff check --fix .</code> to check and fix linting issues - <code>ruff format .</code> to format code or - <code>pre-commit run</code> or <code>pre-commit run --all-files</code> to trigger all checks</p>"},{"location":"contribute/#documentation-optional","title":"Documentation (Optional)","text":"<p>FlixOpt uses mkdocs to generate documentation. To work on documentation: Bash<pre><code>pip install -e \".[docs]\"\nmkdocs serve\n</code></pre> Then navigate to http://127.0.0.1:8000/</p>"},{"location":"contribute/#testing","title":"Testing","text":"<ul> <li><code>pytest</code> to run the test suite</li> <li>You can also run the provided python script <code>run_all_test.py</code></li> </ul>"},{"location":"contribute/#best-practices","title":"Best practices","text":""},{"location":"contribute/#coding-guidelines","title":"Coding Guidelines","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Write clear, commented code</li> <li>Include type hints</li> <li>Create or update tests for new functionality</li> <li>Ensure 100% test coverage for new code</li> </ul>"},{"location":"contribute/#branches-releases","title":"Branches &amp; Releases","text":"<p>New features should be branched from <code>main</code> into <code>feature/*</code> As stated, we follow Semantic Versioning. Releases are created manually from the <code>main</code> branch.</p>"},{"location":"getting-started/","title":"Getting Started with FlixOpt","text":"<p>This guide will help you install FlixOpt, understand its basic concepts, and run your first optimization model.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#basic-installation","title":"Basic Installation","text":"<p>Install FlixOpt directly into your environment using pip:</p> Bash<pre><code>pip install flixopt\n</code></pre> <p>This provides the core functionality with the HiGHS solver included.</p>"},{"location":"getting-started/#full-installation","title":"Full Installation","text":"<p>For all features including interactive network visualizations and time series aggregation:</p> Bash<pre><code>pip install \"flixopt[full]\"\n</code></pre>"},{"location":"getting-started/#basic-workflow","title":"Basic Workflow","text":"<p>Working with FlixOpt follows a general pattern:</p> <ol> <li>Create a <code>FlowSystem</code> with a time series</li> <li>Define <code>Effects</code> (costs, emissions, etc.)</li> <li>Define <code>Buses</code> as connection points in your system</li> <li>Add <code>Components</code> like converters, storage, sources/sinks with their Flows</li> <li>Run <code>Calculations</code> to optimize your system</li> <li>Analyze <code>Results</code> using built-in or external visualization tools</li> </ol>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you've installed FlixOpt and understand the basic workflow, you can:</p> <ul> <li>Learn about the core concepts of FlixOpt</li> <li>Explore some examples</li> <li>Check the API reference for detailed documentation</li> </ul>"},{"location":"roadmap/","title":"Roadmap and Vision","text":""},{"location":"roadmap/#our-vision","title":"\ud83c\udfaf Our Vision","text":"<p>FlixOpt aims to be the most accessible, flexible, and universal Python framework for energy and material flow optimization.</p> <p>We believe optimization modeling should be approachable for beginners yet powerful for experts, minimizing context switching between short-term dispatch and long-term investment planning.</p>"},{"location":"roadmap/#short-term-next-6-months","title":"\ud83d\ude80 Short-term (Next 6 months)","text":"<ul> <li>Recipe collection - Community-driven library of common modeling patterns, data manipulation techniques, and optimization strategies</li> <li>Examples of stochastic and multi-period modeling - The new v3.0 features currently lack comprehensive showcases</li> <li>Advanced result analysis - Automated reporting and enhanced visualization options</li> <li>Interactive tutorials - Browser-based, reactive tutorials for learning FlixOpt without local installation using Marimo</li> </ul>"},{"location":"roadmap/#medium-term-6-12-months","title":"\ud83d\udd2e Medium-term (6-12 months)","text":"<ul> <li>Modeling to Generate Alternatives (MGA) - Built-in support for exploring near-optimal solution spaces to produce more robust, diverse solutions under uncertainty. See PyPSA and Calliope for reference implementations</li> <li>Advanced stochastic optimization - Build sophisticated new <code>Calculation</code> classes to perform different stochastic optimization approaches, like PyPSA's two-stage stochastic programming and risk preferences with Conditional Value-at-Risk (CVaR)</li> <li>Enhanced component library - More pre-built, domain-specific components (sector coupling, hydrogen systems, thermal networks, demand-side management)</li> </ul>"},{"location":"roadmap/#long-term-12-months","title":"\ud83c\udf1f Long-term (12+ months)","text":"<ul> <li>Showcase universal applicability - FlixOpt already handles any flow-based system (supply chains, water networks, production planning, chemical processes) - we need more examples and domain-specific component libraries to demonstrate this</li> <li>Community ecosystem - Rich library of user-contributed components, examples, and domain-specific extensions</li> </ul>"},{"location":"roadmap/#how-to-help","title":"\ud83e\udd1d How to Help","text":"<ul> <li>Code: Implement features, fix bugs, add tests</li> <li>Docs: Write tutorials, improve examples, create case studies</li> <li>Components: Contribute domain-specific components</li> <li>Feedback: Report issues, join discussions</li> </ul> <p>See our contribution guide to get started.</p>"},{"location":"roadmap/#release-philosophy","title":"\ud83d\udcc5 Release Philosophy","text":"<p>FlixOpt follows semantic versioning: - Major (v3\u2192v4): Breaking changes, major features - Minor (v3.0\u2192v3.1): New features, backward compatible - Patch (v3.0.0\u2192v3.0.1): Bug fixes only</p> <p>Target: Patch releases as needed, minor releases every 2-3 months.</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>This section contains the documentation for all modules and classes in flixopt. For more information on how to use the classes and functions, see the User Guide section.</p>"},{"location":"api-reference/aggregation/","title":"Aggregation","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation","title":"flixopt.aggregation","text":"<p>This module contains the Aggregation functionality for the flixopt framework. Through this, aggregating TimeSeriesData is possible.</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation-attributes","title":"Attributes","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation-classes","title":"Classes","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation","title":"Aggregation","text":"Python<pre><code>Aggregation(original_data: DataFrame, hours_per_time_step: Scalar, hours_per_period: Scalar, nr_of_periods: int = 8, weights: dict[str, float] | None = None, time_series_for_high_peaks: list[str] | None = None, time_series_for_low_peaks: list[str] | None = None)\n</code></pre> <p>aggregation organizing class</p> <p>Parameters:</p> Name Type Description Default <code>original_data</code> <code>DataFrame</code> <p>The original data to aggregate</p> required <code>hours_per_time_step</code> <code>Scalar</code> <p>The duration of each timestep in hours.</p> required <code>hours_per_period</code> <code>Scalar</code> <p>The duration of each period in hours.</p> required <code>nr_of_periods</code> <code>int</code> <p>The number of typical periods to use in the aggregation.</p> <code>8</code> <code>weights</code> <code>dict[str, float] | None</code> <p>The weights for aggregation. If None, all time series are equally weighted.</p> <code>None</code> <code>time_series_for_high_peaks</code> <code>list[str] | None</code> <p>List of time series to use for explicitly selecting periods with high values.</p> <code>None</code> <code>time_series_for_low_peaks</code> <code>list[str] | None</code> <p>List of time series to use for explicitly selecting periods with low values.</p> <code>None</code>"},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation-functions","title":"Functions","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation.cluster","title":"cluster","text":"Python<pre><code>cluster() -&gt; None\n</code></pre> <p>Durchf\u00fchrung der Zeitreihenaggregation</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation.get_cluster_indices","title":"get_cluster_indices","text":"Python<pre><code>get_cluster_indices() -&gt; dict[str, list[np.ndarray]]\n</code></pre> <p>Generates a dictionary that maps each cluster to a list of index vectors representing the time steps assigned to that cluster for each period.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, list[ndarray]]</code> <p>{cluster_0: [index_vector_3, index_vector_7, ...],    cluster_1: [index_vector_1],    ...}</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation.get_equation_indices","title":"get_equation_indices","text":"Python<pre><code>get_equation_indices(skip_first_index_of_period: bool = True) -&gt; tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Generates pairs of indices for the equations by comparing index vectors of the same cluster. If <code>skip_first_index_of_period</code> is True, the first index of each period is skipped.</p> <p>Parameters:</p> Name Type Description Default <code>skip_first_index_of_period</code> <code>bool</code> <p>Whether to include or skip the first index of each period.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>tuple[np.ndarray, np.ndarray]: Two arrays of indices.</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationParameters","title":"AggregationParameters","text":"Python<pre><code>AggregationParameters(hours_per_period: float, nr_of_periods: int, fix_storage_flows: bool, aggregate_data_and_fix_non_binary_vars: bool, percentage_of_period_freedom: float = 0, penalty_of_period_freedom: float = 0, time_series_for_high_peaks: list[TimeSeriesData] | None = None, time_series_for_low_peaks: list[TimeSeriesData] | None = None)\n</code></pre> <p>Initializes aggregation parameters for time series data</p> <p>Parameters:</p> Name Type Description Default <code>hours_per_period</code> <code>float</code> <p>Duration of each period in hours.</p> required <code>nr_of_periods</code> <code>int</code> <p>Number of typical periods to use in the aggregation.</p> required <code>fix_storage_flows</code> <code>bool</code> <p>Whether to aggregate storage flows (load/unload); if other flows are fixed, fixing storage flows is usually not required.</p> required <code>aggregate_data_and_fix_non_binary_vars</code> <code>bool</code> <p>Whether to aggregate all time series data, which allows to fix all time series variables (like flow_rate), or only fix binary variables. If False non time_series data is changed!! If True, the mathematical Problem is simplified even further.</p> required <code>percentage_of_period_freedom</code> <code>float</code> <p>Specifies the maximum percentage (0\u2013100) of binary values within each period that can deviate as \"free variables\", chosen by the solver (default is 0). This allows binary variables to be 'partly equated' between aggregated periods.</p> <code>0</code> <code>penalty_of_period_freedom</code> <code>float</code> <p>The penalty associated with each \"free variable\"; defaults to 0. Added to Penalty</p> <code>0</code> <code>time_series_for_high_peaks</code> <code>list[TimeSeriesData] | None</code> <p>List of TimeSeriesData to use for explicitly selecting periods with high values.</p> <code>None</code> <code>time_series_for_low_peaks</code> <code>list[TimeSeriesData] | None</code> <p>List of TimeSeriesData to use for explicitly selecting periods with low values.</p> <code>None</code>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationParameters-functions","title":"Functions","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel","title":"AggregationModel","text":"Python<pre><code>AggregationModel(model: FlowSystemModel, aggregation_parameters: AggregationParameters, flow_system: FlowSystem, aggregation_data: Aggregation, components_to_clusterize: list[Component] | None)\n</code></pre> <p>               Bases: <code>Submodel</code></p> <p>The AggregationModel holds equations and variables related to the Aggregation of a FlowSystem. It creates Equations that equates indices of variables, and introduces penalties related to binary variables, that escape the equation to their related binaries in other periods</p> <p>Modeling-Element for \"index-equating\"-equations</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel-attributes","title":"Attributes","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.variables_direct","title":"variables_direct  <code>property</code>","text":"Python<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"Python<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel-functions","title":"Functions","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.add_variables","title":"add_variables","text":"Python<pre><code>add_variables(short_name: str = None, **kwargs) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.add_constraints","title":"add_constraints","text":"Python<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.register_variable","title":"register_variable","text":"Python<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.register_constraint","title":"register_constraint","text":"Python<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.get","title":"get","text":"Python<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation-functions","title":"Functions","text":""},{"location":"api-reference/calculation/","title":"Calculation","text":""},{"location":"api-reference/calculation/#flixopt.calculation","title":"flixopt.calculation","text":"<p>This module contains the Calculation functionality for the flixopt framework. It is used to calculate a FlowSystemModel for a given FlowSystem through a solver. There are three different Calculation types:     1. FullCalculation: Calculates the FlowSystemModel for the full FlowSystem     2. AggregatedCalculation: Calculates the FlowSystemModel for the full FlowSystem, but aggregates the TimeSeriesData.         This simplifies the mathematical model and usually speeds up the solving process.     3. SegmentedCalculation: Solves a FlowSystemModel for each individual Segment of the FlowSystem.</p>"},{"location":"api-reference/calculation/#flixopt.calculation-attributes","title":"Attributes","text":""},{"location":"api-reference/calculation/#flixopt.calculation-classes","title":"Classes","text":""},{"location":"api-reference/calculation/#flixopt.calculation.Calculation","title":"Calculation","text":"Python<pre><code>Calculation(name: str, flow_system: FlowSystem, active_timesteps: Annotated[DatetimeIndex | None, 'DEPRECATED: Use flow_system.sel(time=...) or flow_system.isel(time=...) instead'] = None, folder: Path | None = None, normalize_weights: bool = True)\n</code></pre> <p>class for defined way of solving a flow_system optimization</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>folder</code> <code>Path | None</code> <p>folder where results should be saved. If None, then the current working directory is used.</p> <code>None</code> <code>normalize_weights</code> <code>bool</code> <p>Whether to automatically normalize the weights (periods and scenarios) to sum up to 1 when solving.</p> <code>True</code> <code>active_timesteps</code> <code>Annotated[DatetimeIndex | None, 'DEPRECATED: Use flow_system.sel(time=...) or flow_system.isel(time=...) instead']</code> <p>Deprecated. Use FlowSystem.sel(time=...) or FlowSystem.isel(time=...) instead.</p> <code>None</code>"},{"location":"api-reference/calculation/#flixopt.calculation.FullCalculation","title":"FullCalculation","text":"Python<pre><code>FullCalculation(name: str, flow_system: FlowSystem, active_timesteps: Annotated[DatetimeIndex | None, 'DEPRECATED: Use flow_system.sel(time=...) or flow_system.isel(time=...) instead'] = None, folder: Path | None = None, normalize_weights: bool = True)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>FullCalculation solves the complete optimization problem using all time steps.</p> <p>This is the most comprehensive calculation type that considers every time step in the optimization, providing the most accurate but computationally intensive solution.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>folder</code> <code>Path | None</code> <p>folder where results should be saved. If None, then the current working directory is used.</p> <code>None</code> <code>normalize_weights</code> <code>bool</code> <p>Whether to automatically normalize the weights (periods and scenarios) to sum up to 1 when solving.</p> <code>True</code> <code>active_timesteps</code> <code>Annotated[DatetimeIndex | None, 'DEPRECATED: Use flow_system.sel(time=...) or flow_system.isel(time=...) instead']</code> <p>Deprecated. Use FlowSystem.sel(time=...) or FlowSystem.isel(time=...) instead.</p> <code>None</code>"},{"location":"api-reference/calculation/#flixopt.calculation.FullCalculation-functions","title":"Functions","text":""},{"location":"api-reference/calculation/#flixopt.calculation.FullCalculation.fix_sizes","title":"fix_sizes","text":"Python<pre><code>fix_sizes(ds: Dataset, decimal_rounding: int | None = 5) -&gt; FullCalculation\n</code></pre> <p>Fix the sizes of the calculations to specified values.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>The dataset that contains the variable names mapped to their sizes. If None, the dataset is loaded from the results.</p> required <code>decimal_rounding</code> <code>int | None</code> <p>The number of decimal places to round the sizes to. If no rounding is applied, numerical errors might lead to infeasibility.</p> <code>5</code>"},{"location":"api-reference/calculation/#flixopt.calculation.AggregatedCalculation","title":"AggregatedCalculation","text":"Python<pre><code>AggregatedCalculation(name: str, flow_system: FlowSystem, aggregation_parameters: AggregationParameters, components_to_clusterize: list[Component] | None = None, active_timesteps: Annotated[DatetimeIndex | None, 'DEPRECATED: Use flow_system.sel(time=...) or flow_system.isel(time=...) instead'] = None, folder: Path | None = None)\n</code></pre> <p>               Bases: <code>FullCalculation</code></p> <p>AggregatedCalculation reduces computational complexity by clustering time series into typical periods.</p> <p>This calculation approach aggregates time series data using clustering techniques (tsam) to identify representative time periods, significantly reducing computation time while maintaining solution accuracy.</p> Note <p>The quality of the solution depends on the choice of aggregation parameters. The optimal parameters depend on the specific problem and the characteristics of the time series data. For more information, refer to the tsam documentation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>FlowSystem to be optimized</p> required <code>aggregation_parameters</code> <code>AggregationParameters</code> <p>Parameters for aggregation. See AggregationParameters class documentation</p> required <code>components_to_clusterize</code> <code>list[Component] | None</code> <p>list of Components to perform aggregation on. If None, all components are aggregated. This equalizes variables in the components according to the typical periods computed in the aggregation</p> <code>None</code> <code>active_timesteps</code> <code>Annotated[DatetimeIndex | None, 'DEPRECATED: Use flow_system.sel(time=...) or flow_system.isel(time=...) instead']</code> <p>DatetimeIndex of timesteps to use for calculation. If None, all timesteps are used</p> <code>None</code> <code>folder</code> <code>Path | None</code> <p>Folder where results should be saved. If None, current working directory is used</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>aggregation</code> <code>Aggregation | None</code> <p>Contains the clustered time series data</p> <code>aggregation_model</code> <code>AggregationModel | None</code> <p>Contains Variables and Constraints that equalize clusters of the time series data</p>"},{"location":"api-reference/calculation/#flixopt.calculation.AggregatedCalculation-functions","title":"Functions","text":""},{"location":"api-reference/calculation/#flixopt.calculation.AggregatedCalculation.calculate_aggregation_weights","title":"calculate_aggregation_weights  <code>classmethod</code>","text":"Python<pre><code>calculate_aggregation_weights(ds: Dataset) -&gt; dict[str, float]\n</code></pre> <p>Calculate weights for all datavars in the dataset. Weights are pulled from the attrs of the datavars.</p>"},{"location":"api-reference/calculation/#flixopt.calculation.AggregatedCalculation.fix_sizes","title":"fix_sizes","text":"Python<pre><code>fix_sizes(ds: Dataset, decimal_rounding: int | None = 5) -&gt; FullCalculation\n</code></pre> <p>Fix the sizes of the calculations to specified values.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>The dataset that contains the variable names mapped to their sizes. If None, the dataset is loaded from the results.</p> required <code>decimal_rounding</code> <code>int | None</code> <p>The number of decimal places to round the sizes to. If no rounding is applied, numerical errors might lead to infeasibility.</p> <code>5</code>"},{"location":"api-reference/calculation/#flixopt.calculation.SegmentedCalculation","title":"SegmentedCalculation","text":"Python<pre><code>SegmentedCalculation(name: str, flow_system: FlowSystem, timesteps_per_segment: int, overlap_timesteps: int, nr_of_previous_values: int = 1, folder: Path | None = None)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>Solve large optimization problems by dividing time horizon into (overlapping) segments.</p> <p>This class addresses memory and computational limitations of large-scale optimization problems by decomposing the time horizon into smaller overlapping segments that are solved sequentially. Each segment uses final values from the previous segment as initial conditions, ensuring dynamic continuity across the solution.</p> Key Concepts <p>Temporal Decomposition: Divides long time horizons into manageable segments Overlapping Windows: Segments share timesteps to improve storage dynamics Value Transfer: Final states of one segment become initial states of the next Sequential Solving: Each segment solved independently but with coupling</p> Limitations and Constraints <p>Investment Parameters: InvestParameters are not supported in segmented calculations as investment decisions must be made for the entire time horizon, not per segment.</p> <p>Global Constraints: Time-horizon-wide constraints (flow_hours_total_min/max, load_factor_min/max) may produce suboptimal results as they cannot be enforced globally across segments.</p> <p>Storage Dynamics: While overlap helps, storage optimization may be suboptimal compared to full-horizon solutions due to limited foresight in each segment.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the calculation, used in result files and logging.</p> required <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to optimize, containing all components, flows, and buses.</p> required <code>timesteps_per_segment</code> <code>int</code> <p>Number of timesteps in each segment (excluding overlap). Must be &gt; 2 to avoid internal side effects. Larger values provide better optimization at the cost of memory and computation time.</p> required <code>overlap_timesteps</code> <code>int</code> <p>Number of additional timesteps added to each segment. Improves storage optimization by providing lookahead. Higher values improve solution quality but increase computational cost.</p> required <code>nr_of_previous_values</code> <code>int</code> <p>Number of previous timestep values to transfer between segments for initialization. Typically 1 is sufficient.</p> <code>1</code> <code>folder</code> <code>Path | None</code> <p>Directory for saving results. Defaults to current working directory + 'results'.</p> <code>None</code> <p>Examples:</p> <p>Annual optimization with monthly segments:</p> Python<pre><code># 8760 hours annual data with monthly segments (730 hours) and 48-hour overlap\nsegmented_calc = SegmentedCalculation(\n    name='annual_energy_system',\n    flow_system=energy_system,\n    timesteps_per_segment=730,  # ~1 month\n    overlap_timesteps=48,  # 2 days overlap\n    folder=Path('results/segmented'),\n)\nsegmented_calc.do_modeling_and_solve(solver='gurobi')\n</code></pre> <p>Weekly optimization with daily overlap:</p> Python<pre><code># Weekly segments for detailed operational planning\nweekly_calc = SegmentedCalculation(\n    name='weekly_operations',\n    flow_system=industrial_system,\n    timesteps_per_segment=168,  # 1 week (hourly data)\n    overlap_timesteps=24,  # 1 day overlap\n    nr_of_previous_values=1,\n)\n</code></pre> <p>Large-scale system with minimal overlap:</p> Python<pre><code># Large system with minimal overlap for computational efficiency\nlarge_calc = SegmentedCalculation(\n    name='large_scale_grid',\n    flow_system=grid_system,\n    timesteps_per_segment=100,  # Shorter segments\n    overlap_timesteps=5,  # Minimal overlap\n)\n</code></pre> Design Considerations <p>Segment Size: Balance between solution quality and computational efficiency. Larger segments provide better optimization but require more memory and time.</p> <p>Overlap Duration: More overlap improves storage dynamics and reduces end-effects but increases computational cost. Typically 5-10% of segment length.</p> <p>Storage Systems: Systems with large storage components benefit from longer overlaps to capture charge/discharge cycles effectively.</p> <p>Investment Decisions: Use FullCalculation for problems requiring investment optimization, as SegmentedCalculation cannot handle investment parameters.</p> Common Use Cases <ul> <li>Annual Planning: Long-term planning with seasonal variations</li> <li>Large Networks: Spatially or temporally large energy systems</li> <li>Memory-Limited Systems: When full optimization exceeds available memory</li> <li>Operational Planning: Detailed short-term optimization with limited foresight</li> <li>Sensitivity Analysis: Quick approximate solutions for parameter studies</li> </ul> Performance Tips <ul> <li>Start with FullCalculation and use this class if memory issues occur</li> <li>Use longer overlaps for systems with significant storage</li> <li>Monitor solution quality at segment boundaries for discontinuities</li> </ul> Warning <p>The evaluation of the solution is a bit more complex than FullCalculation or AggregatedCalculation due to the overlapping individual solutions.</p>"},{"location":"api-reference/calculation/#flixopt.calculation.SegmentedCalculation-attributes","title":"Attributes","text":""},{"location":"api-reference/calculation/#flixopt.calculation.SegmentedCalculation.start_values_of_segments","title":"start_values_of_segments  <code>property</code>","text":"Python<pre><code>start_values_of_segments: list[dict[str, Any]]\n</code></pre> <p>Gives an overview of the start values of all Segments</p>"},{"location":"api-reference/calculation/#flixopt.calculation-functions","title":"Functions","text":""},{"location":"api-reference/color_processing/","title":"Color processing","text":""},{"location":"api-reference/color_processing/#flixopt.color_processing","title":"flixopt.color_processing","text":"<p>Simplified color handling for visualization.</p> <p>This module provides clean color processing that transforms various input formats into a label-to-color mapping dictionary, without needing to know about the plotting engine.</p>"},{"location":"api-reference/color_processing/#flixopt.color_processing-functions","title":"Functions","text":""},{"location":"api-reference/color_processing/#flixopt.color_processing.process_colors","title":"process_colors","text":"Python<pre><code>process_colors(colors: None | str | list[str] | dict[str, str], labels: list[str], default_colorscale: str = 'turbo') -&gt; dict[str, str]\n</code></pre> <p>Process color input and return a label-to-color mapping.</p> <p>This function takes flexible color input and always returns a dictionary mapping each label to a specific color string. The plotting engine can then use this mapping as needed.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>None | str | list[str] | dict[str, str]</code> <p>Color specification in one of four formats: - None: Use the default colorscale - str: Name of a colorscale (e.g., 'turbo', 'plasma', 'Set1', 'portland') - list[str]: List of color strings (hex, named colors, etc.) - dict[str, str]: Direct label-to-color mapping</p> required <code>labels</code> <code>list[str]</code> <p>List of labels that need colors assigned</p> required <code>default_colorscale</code> <code>str</code> <p>Fallback colorscale name if requested scale not found</p> <code>'turbo'</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary mapping each label to a color string</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; # Using None - applies default colorscale\n&gt;&gt;&gt; process_colors(None, ['A', 'B', 'C'])\n{'A': '#0d0887', 'B': '#7e03a8', 'C': '#cc4778'}\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Using a colorscale name\n&gt;&gt;&gt; process_colors('plasma', ['A', 'B', 'C'])\n{'A': '#0d0887', 'B': '#7e03a8', 'C': '#cc4778'}\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Using a list of colors\n&gt;&gt;&gt; process_colors(['red', 'blue', 'green'], ['A', 'B', 'C'])\n{'A': 'red', 'B': 'blue', 'C': 'green'}\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; # Using a pre-made mapping\n&gt;&gt;&gt; process_colors({'A': 'red', 'B': 'blue'}, ['A', 'B', 'C'])\n{'A': 'red', 'B': 'blue', 'C': '#0d0887'}  # C gets color from default scale\n</code></pre>"},{"location":"api-reference/commons/","title":"Commons","text":""},{"location":"api-reference/commons/#flixopt.commons","title":"flixopt.commons","text":"<p>This module makes the commonly used classes and functions available in the flixopt framework.</p>"},{"location":"api-reference/commons/#flixopt.commons-classes","title":"Classes","text":""},{"location":"api-reference/commons/#flixopt.commons.AggregationParameters","title":"AggregationParameters","text":"Python<pre><code>AggregationParameters(hours_per_period: float, nr_of_periods: int, fix_storage_flows: bool, aggregate_data_and_fix_non_binary_vars: bool, percentage_of_period_freedom: float = 0, penalty_of_period_freedom: float = 0, time_series_for_high_peaks: list[TimeSeriesData] | None = None, time_series_for_low_peaks: list[TimeSeriesData] | None = None)\n</code></pre> <p>Initializes aggregation parameters for time series data</p> <p>Parameters:</p> Name Type Description Default <code>hours_per_period</code> <code>float</code> <p>Duration of each period in hours.</p> required <code>nr_of_periods</code> <code>int</code> <p>Number of typical periods to use in the aggregation.</p> required <code>fix_storage_flows</code> <code>bool</code> <p>Whether to aggregate storage flows (load/unload); if other flows are fixed, fixing storage flows is usually not required.</p> required <code>aggregate_data_and_fix_non_binary_vars</code> <code>bool</code> <p>Whether to aggregate all time series data, which allows to fix all time series variables (like flow_rate), or only fix binary variables. If False non time_series data is changed!! If True, the mathematical Problem is simplified even further.</p> required <code>percentage_of_period_freedom</code> <code>float</code> <p>Specifies the maximum percentage (0\u2013100) of binary values within each period that can deviate as \"free variables\", chosen by the solver (default is 0). This allows binary variables to be 'partly equated' between aggregated periods.</p> <code>0</code> <code>penalty_of_period_freedom</code> <code>float</code> <p>The penalty associated with each \"free variable\"; defaults to 0. Added to Penalty</p> <code>0</code> <code>time_series_for_high_peaks</code> <code>list[TimeSeriesData] | None</code> <p>List of TimeSeriesData to use for explicitly selecting periods with high values.</p> <code>None</code> <code>time_series_for_low_peaks</code> <code>list[TimeSeriesData] | None</code> <p>List of TimeSeriesData to use for explicitly selecting periods with low values.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.AggregationParameters-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.AggregatedCalculation","title":"AggregatedCalculation","text":"Python<pre><code>AggregatedCalculation(name: str, flow_system: FlowSystem, aggregation_parameters: AggregationParameters, components_to_clusterize: list[Component] | None = None, active_timesteps: Annotated[DatetimeIndex | None, 'DEPRECATED: Use flow_system.sel(time=...) or flow_system.isel(time=...) instead'] = None, folder: Path | None = None)\n</code></pre> <p>               Bases: <code>FullCalculation</code></p> <p>AggregatedCalculation reduces computational complexity by clustering time series into typical periods.</p> <p>This calculation approach aggregates time series data using clustering techniques (tsam) to identify representative time periods, significantly reducing computation time while maintaining solution accuracy.</p> Note <p>The quality of the solution depends on the choice of aggregation parameters. The optimal parameters depend on the specific problem and the characteristics of the time series data. For more information, refer to the tsam documentation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>FlowSystem to be optimized</p> required <code>aggregation_parameters</code> <code>AggregationParameters</code> <p>Parameters for aggregation. See AggregationParameters class documentation</p> required <code>components_to_clusterize</code> <code>list[Component] | None</code> <p>list of Components to perform aggregation on. If None, all components are aggregated. This equalizes variables in the components according to the typical periods computed in the aggregation</p> <code>None</code> <code>active_timesteps</code> <code>Annotated[DatetimeIndex | None, 'DEPRECATED: Use flow_system.sel(time=...) or flow_system.isel(time=...) instead']</code> <p>DatetimeIndex of timesteps to use for calculation. If None, all timesteps are used</p> <code>None</code> <code>folder</code> <code>Path | None</code> <p>Folder where results should be saved. If None, current working directory is used</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>aggregation</code> <code>Aggregation | None</code> <p>Contains the clustered time series data</p> <code>aggregation_model</code> <code>AggregationModel | None</code> <p>Contains Variables and Constraints that equalize clusters of the time series data</p>"},{"location":"api-reference/commons/#flixopt.commons.AggregatedCalculation-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.AggregatedCalculation.fix_sizes","title":"fix_sizes","text":"Python<pre><code>fix_sizes(ds: Dataset, decimal_rounding: int | None = 5) -&gt; FullCalculation\n</code></pre> <p>Fix the sizes of the calculations to specified values.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>The dataset that contains the variable names mapped to their sizes. If None, the dataset is loaded from the results.</p> required <code>decimal_rounding</code> <code>int | None</code> <p>The number of decimal places to round the sizes to. If no rounding is applied, numerical errors might lead to infeasibility.</p> <code>5</code>"},{"location":"api-reference/commons/#flixopt.commons.AggregatedCalculation.calculate_aggregation_weights","title":"calculate_aggregation_weights  <code>classmethod</code>","text":"Python<pre><code>calculate_aggregation_weights(ds: Dataset) -&gt; dict[str, float]\n</code></pre> <p>Calculate weights for all datavars in the dataset. Weights are pulled from the attrs of the datavars.</p>"},{"location":"api-reference/commons/#flixopt.commons.FullCalculation","title":"FullCalculation","text":"Python<pre><code>FullCalculation(name: str, flow_system: FlowSystem, active_timesteps: Annotated[DatetimeIndex | None, 'DEPRECATED: Use flow_system.sel(time=...) or flow_system.isel(time=...) instead'] = None, folder: Path | None = None, normalize_weights: bool = True)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>FullCalculation solves the complete optimization problem using all time steps.</p> <p>This is the most comprehensive calculation type that considers every time step in the optimization, providing the most accurate but computationally intensive solution.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>folder</code> <code>Path | None</code> <p>folder where results should be saved. If None, then the current working directory is used.</p> <code>None</code> <code>normalize_weights</code> <code>bool</code> <p>Whether to automatically normalize the weights (periods and scenarios) to sum up to 1 when solving.</p> <code>True</code> <code>active_timesteps</code> <code>Annotated[DatetimeIndex | None, 'DEPRECATED: Use flow_system.sel(time=...) or flow_system.isel(time=...) instead']</code> <p>Deprecated. Use FlowSystem.sel(time=...) or FlowSystem.isel(time=...) instead.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.FullCalculation-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.FullCalculation.fix_sizes","title":"fix_sizes","text":"Python<pre><code>fix_sizes(ds: Dataset, decimal_rounding: int | None = 5) -&gt; FullCalculation\n</code></pre> <p>Fix the sizes of the calculations to specified values.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>The dataset that contains the variable names mapped to their sizes. If None, the dataset is loaded from the results.</p> required <code>decimal_rounding</code> <code>int | None</code> <p>The number of decimal places to round the sizes to. If no rounding is applied, numerical errors might lead to infeasibility.</p> <code>5</code>"},{"location":"api-reference/commons/#flixopt.commons.SegmentedCalculation","title":"SegmentedCalculation","text":"Python<pre><code>SegmentedCalculation(name: str, flow_system: FlowSystem, timesteps_per_segment: int, overlap_timesteps: int, nr_of_previous_values: int = 1, folder: Path | None = None)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>Solve large optimization problems by dividing time horizon into (overlapping) segments.</p> <p>This class addresses memory and computational limitations of large-scale optimization problems by decomposing the time horizon into smaller overlapping segments that are solved sequentially. Each segment uses final values from the previous segment as initial conditions, ensuring dynamic continuity across the solution.</p> Key Concepts <p>Temporal Decomposition: Divides long time horizons into manageable segments Overlapping Windows: Segments share timesteps to improve storage dynamics Value Transfer: Final states of one segment become initial states of the next Sequential Solving: Each segment solved independently but with coupling</p> Limitations and Constraints <p>Investment Parameters: InvestParameters are not supported in segmented calculations as investment decisions must be made for the entire time horizon, not per segment.</p> <p>Global Constraints: Time-horizon-wide constraints (flow_hours_total_min/max, load_factor_min/max) may produce suboptimal results as they cannot be enforced globally across segments.</p> <p>Storage Dynamics: While overlap helps, storage optimization may be suboptimal compared to full-horizon solutions due to limited foresight in each segment.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the calculation, used in result files and logging.</p> required <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to optimize, containing all components, flows, and buses.</p> required <code>timesteps_per_segment</code> <code>int</code> <p>Number of timesteps in each segment (excluding overlap). Must be &gt; 2 to avoid internal side effects. Larger values provide better optimization at the cost of memory and computation time.</p> required <code>overlap_timesteps</code> <code>int</code> <p>Number of additional timesteps added to each segment. Improves storage optimization by providing lookahead. Higher values improve solution quality but increase computational cost.</p> required <code>nr_of_previous_values</code> <code>int</code> <p>Number of previous timestep values to transfer between segments for initialization. Typically 1 is sufficient.</p> <code>1</code> <code>folder</code> <code>Path | None</code> <p>Directory for saving results. Defaults to current working directory + 'results'.</p> <code>None</code> <p>Examples:</p> <p>Annual optimization with monthly segments:</p> Python<pre><code># 8760 hours annual data with monthly segments (730 hours) and 48-hour overlap\nsegmented_calc = SegmentedCalculation(\n    name='annual_energy_system',\n    flow_system=energy_system,\n    timesteps_per_segment=730,  # ~1 month\n    overlap_timesteps=48,  # 2 days overlap\n    folder=Path('results/segmented'),\n)\nsegmented_calc.do_modeling_and_solve(solver='gurobi')\n</code></pre> <p>Weekly optimization with daily overlap:</p> Python<pre><code># Weekly segments for detailed operational planning\nweekly_calc = SegmentedCalculation(\n    name='weekly_operations',\n    flow_system=industrial_system,\n    timesteps_per_segment=168,  # 1 week (hourly data)\n    overlap_timesteps=24,  # 1 day overlap\n    nr_of_previous_values=1,\n)\n</code></pre> <p>Large-scale system with minimal overlap:</p> Python<pre><code># Large system with minimal overlap for computational efficiency\nlarge_calc = SegmentedCalculation(\n    name='large_scale_grid',\n    flow_system=grid_system,\n    timesteps_per_segment=100,  # Shorter segments\n    overlap_timesteps=5,  # Minimal overlap\n)\n</code></pre> Design Considerations <p>Segment Size: Balance between solution quality and computational efficiency. Larger segments provide better optimization but require more memory and time.</p> <p>Overlap Duration: More overlap improves storage dynamics and reduces end-effects but increases computational cost. Typically 5-10% of segment length.</p> <p>Storage Systems: Systems with large storage components benefit from longer overlaps to capture charge/discharge cycles effectively.</p> <p>Investment Decisions: Use FullCalculation for problems requiring investment optimization, as SegmentedCalculation cannot handle investment parameters.</p> Common Use Cases <ul> <li>Annual Planning: Long-term planning with seasonal variations</li> <li>Large Networks: Spatially or temporally large energy systems</li> <li>Memory-Limited Systems: When full optimization exceeds available memory</li> <li>Operational Planning: Detailed short-term optimization with limited foresight</li> <li>Sensitivity Analysis: Quick approximate solutions for parameter studies</li> </ul> Performance Tips <ul> <li>Start with FullCalculation and use this class if memory issues occur</li> <li>Use longer overlaps for systems with significant storage</li> <li>Monitor solution quality at segment boundaries for discontinuities</li> </ul> Warning <p>The evaluation of the solution is a bit more complex than FullCalculation or AggregatedCalculation due to the overlapping individual solutions.</p>"},{"location":"api-reference/commons/#flixopt.commons.SegmentedCalculation-attributes","title":"Attributes","text":""},{"location":"api-reference/commons/#flixopt.commons.SegmentedCalculation.start_values_of_segments","title":"start_values_of_segments  <code>property</code>","text":"Python<pre><code>start_values_of_segments: list[dict[str, Any]]\n</code></pre> <p>Gives an overview of the start values of all Segments</p>"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter","title":"LinearConverter","text":"Python<pre><code>LinearConverter(label: str, inputs: list[Flow], outputs: list[Flow], on_off_parameters: OnOffParameters | None = None, conversion_factors: list[dict[str, TemporalDataUser]] | None = None, piecewise_conversion: PiecewiseConversion | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Converts input-Flows into output-Flows via linear conversion factors.</p> <p>LinearConverter models equipment that transforms one or more input flows into one or more output flows through linear relationships. This includes heat exchangers, electrical converters, chemical reactors, and other equipment where the relationship between inputs and outputs can be expressed as linear equations.</p> <p>The component supports two modeling approaches: simple conversion factors for straightforward linear relationships, or piecewise conversion for complex non-linear behavior approximated through piecewise linear segments.</p> Mathematical Formulation <p>See the complete mathematical model in the documentation: LinearConverter</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow]</code> <p>list of input Flows that feed into the converter.</p> required <code>outputs</code> <code>list[Flow]</code> <p>list of output Flows that are produced by the converter.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Information about on and off state of LinearConverter. Component is On/Off if all connected Flows are On/Off. This induces an On-Variable (binary) in all Flows! If possible, use OnOffParameters in a single Flow instead to keep the number of binary variables low.</p> <code>None</code> <code>conversion_factors</code> <code>list[dict[str, TemporalDataUser]] | None</code> <p>Linear relationships between flows expressed as a list of dictionaries. Each dictionary maps flow labels to their coefficients in one linear equation. The number of conversion factors must be less than the total number of flows to ensure degrees of freedom &gt; 0. Either 'conversion_factors' OR 'piecewise_conversion' can be used, but not both. For examples also look into the linear_converters.py file.</p> <code>None</code> <code>piecewise_conversion</code> <code>PiecewiseConversion | None</code> <p>Define piecewise linear relationships between flow rates of different flows. Enables modeling of non-linear conversion behavior through linear approximation. Either 'conversion_factors' or 'piecewise_conversion' can be used, but not both.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally, but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Simple 1:1 heat exchanger with 95% efficiency:</p> Python<pre><code>heat_exchanger = LinearConverter(\n    label='primary_hx',\n    inputs=[hot_water_in],\n    outputs=[hot_water_out],\n    conversion_factors=[{'hot_water_in': 0.95, 'hot_water_out': 1}],\n)\n</code></pre> <p>Multi-input heat pump with COP=3:</p> Python<pre><code>heat_pump = LinearConverter(\n    label='air_source_hp',\n    inputs=[electricity_in],\n    outputs=[heat_output],\n    conversion_factors=[{'electricity_in': 3, 'heat_output': 1}],\n)\n</code></pre> <p>Combined heat and power (CHP) unit with multiple outputs:</p> Python<pre><code>chp_unit = LinearConverter(\n    label='gas_chp',\n    inputs=[natural_gas],\n    outputs=[electricity_out, heat_out],\n    conversion_factors=[\n        {'natural_gas': 0.35, 'electricity_out': 1},\n        {'natural_gas': 0.45, 'heat_out': 1},\n    ],\n)\n</code></pre> <p>Electrolyzer with multiple conversion relationships:</p> Python<pre><code>electrolyzer = LinearConverter(\n    label='pem_electrolyzer',\n    inputs=[electricity_in, water_in],\n    outputs=[hydrogen_out, oxygen_out],\n    conversion_factors=[\n        {'electricity_in': 1, 'hydrogen_out': 50},  # 50 kWh/kg H2\n        {'water_in': 1, 'hydrogen_out': 9},  # 9 kg H2O/kg H2\n        {'hydrogen_out': 8, 'oxygen_out': 1},  # Mass balance\n    ],\n)\n</code></pre> <p>Complex converter with piecewise efficiency:</p> Python<pre><code>variable_efficiency_converter = LinearConverter(\n    label='variable_converter',\n    inputs=[fuel_in],\n    outputs=[power_out],\n    piecewise_conversion=PiecewiseConversion(\n        {\n            'fuel_in': Piecewise(\n                [\n                    Piece(0, 10),  # Low load operation\n                    Piece(10, 25),  # High load operation\n                ]\n            ),\n            'power_out': Piecewise(\n                [\n                    Piece(0, 3.5),  # Lower efficiency at part load\n                    Piece(3.5, 10),  # Higher efficiency at full load\n                ]\n            ),\n        }\n    ),\n)\n</code></pre> Note <p>Conversion factors define linear relationships where the sum of (coefficient \u00d7 flow_rate) equals zero for each equation: factor1\u00d7flow1 + factor2\u00d7flow2 + ... = 0 Conversion factors define linear relationships: <code>{flow1: a1, flow2: a2, ...}</code> yields <code>a1\u00d7flow_rate1 + a2\u00d7flow_rate2 + ... = 0</code>. Note: The input format may be unintuitive. For example, <code>{\"electricity\": 1, \"H2\": 50}</code> implies <code>1\u00d7electricity = 50\u00d7H2</code>, i.e., 50 units of electricity produce 1 unit of H2.</p> <p>The system must have fewer conversion factors than total flows (degrees of freedom &gt; 0) to avoid over-constraining the problem. For n total flows, use at most n-1 conversion factors.</p> <p>When using piecewise_conversion, the converter operates on one piece at a time, with binary variables determining which piece is active.</p>"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.LinearConverter.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.Sink","title":"Sink","text":"Python<pre><code>Sink(label: str, inputs: list[Flow] | None = None, meta_data: dict | None = None, prevent_simultaneous_flow_rates: bool = False, **kwargs)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Sink consumes energy or material flows from the system.</p> <p>Sinks represent demand points like electrical loads, heat demands, material consumption, or any system boundary where flows terminate. They provide unlimited consumption capability subject to flow constraints, demand patterns and effects.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>Input-flows into the sink. Can be single flow or list of flows for sinks consuming multiple commodities or services.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, only one input flow can be active at a time. Useful for modeling mutually exclusive consumption options. Default is False.</p> <code>False</code> <p>Examples:</p> <p>Simple electrical demand:</p> Python<pre><code>electrical_load = Sink(label='building_load', inputs=[electricity_demand_flow])\n</code></pre> <p>Heat demand with time-varying profile:</p> Python<pre><code>heat_demand = Sink(\n    label='district_heating_load',\n    inputs=[\n        Flow(\n            label='heat_consumption',\n            bus=heat_bus,\n            fixed_relative_profile=hourly_heat_profile,  # Demand profile\n            size=2000,  # Peak demand of 2000 kW\n        )\n    ],\n)\n</code></pre> <p>Multi-energy building with switching capabilities:</p> Python<pre><code>flexible_building = Sink(\n    label='smart_building',\n    inputs=[electricity_heating, gas_heating, heat_pump_heating],\n    prevent_simultaneous_flow_rates=True,  # Can only use one heating mode\n)\n</code></pre> <p>Industrial process with variable demand:</p> Python<pre><code>factory_load = Sink(\n    label='manufacturing_plant',\n    inputs=[\n        Flow(\n            label='electricity_process',\n            bus=electricity_bus,\n            size=5000,  # Base electrical load\n            effects_per_flow_hour={'cost': -0.1},  # Value of service (negative cost)\n        ),\n        Flow(\n            label='steam_process',\n            bus=steam_bus,\n            size=3000,  # Process steam demand\n            fixed_relative_profile=production_schedule,\n        ),\n    ],\n)\n</code></pre> Deprecated <p>The deprecated <code>sink</code> kwarg is accepted for compatibility but will be removed in future releases.</p> <p>Initialize a Sink (consumes flow from the system).</p> <p>Supports legacy <code>sink=</code> keyword for backward compatibility (deprecated): if <code>sink</code> is provided it is used as the single input flow and a DeprecationWarning is issued; specifying both <code>inputs</code> and <code>sink</code> raises ValueError.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Unique element label.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>Input flows for the sink.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Arbitrary metadata attached to the element.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, prevents simultaneous nonzero flow rates across the element's inputs by wiring that restriction into the base Component setup.</p> <code>False</code> Note <p>The deprecated <code>sink</code> kwarg is accepted for compatibility but will be removed in future releases.</p>"},{"location":"api-reference/commons/#flixopt.commons.Sink-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Sink.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.Sink.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Sink.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.Sink.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.Sink.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.Sink.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Sink.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.Source","title":"Source","text":"Python<pre><code>Source(label: str, outputs: list[Flow] | None = None, meta_data: dict | None = None, prevent_simultaneous_flow_rates: bool = False, **kwargs)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Source generates or provides energy or material flows into the system.</p> <p>Sources represent supply points like power plants, fuel suppliers, renewable energy sources, or any system boundary where flows originate. They provide unlimited supply capability subject to flow constraints, demand patterns and effects.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>outputs</code> <code>list[Flow] | None</code> <p>Output-flows from the source. Can be single flow or list of flows for sources providing multiple commodities or services.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, only one output flow can be active at a time. Useful for modeling mutually exclusive supply options. Default is False.</p> <code>False</code> <p>Examples:</p> <p>Simple electricity grid connection:</p> Python<pre><code>grid_source = Source(label='electrical_grid', outputs=[grid_electricity_flow])\n</code></pre> <p>Natural gas supply with cost and capacity constraints:</p> Python<pre><code>gas_supply = Source(\n    label='gas_network',\n    outputs=[\n        Flow(\n            label='natural_gas_flow',\n            bus=gas_bus,\n            size=1000,  # Maximum 1000 kW supply capacity\n            effects_per_flow_hour={'cost': 0.04},  # \u20ac0.04/kWh gas cost\n        )\n    ],\n)\n</code></pre> <p>Multi-fuel power plant with switching constraints:</p> Python<pre><code>multi_fuel_plant = Source(\n    label='flexible_generator',\n    outputs=[coal_electricity, gas_electricity, biomass_electricity],\n    prevent_simultaneous_flow_rates=True,  # Can only use one fuel at a time\n)\n</code></pre> <p>Renewable energy source with investment optimization:</p> Python<pre><code>solar_farm = Source(\n    label='solar_pv',\n    outputs=[\n        Flow(\n            label='solar_power',\n            bus=electricity_bus,\n            size=InvestParameters(\n                minimum_size=0,\n                maximum_size=50000,  # Up to 50 MW\n                specific_effects={'cost': 800},  # \u20ac800/kW installed\n                fix_effects={'cost': 100000},  # \u20ac100k development costs\n            ),\n            fixed_relative_profile=solar_profile,  # Hourly generation profile\n        )\n    ],\n)\n</code></pre> Deprecated <p>The deprecated <code>source</code> kwarg is accepted for compatibility but will be removed in future releases.</p>"},{"location":"api-reference/commons/#flixopt.commons.Source-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Source.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.Source.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Source.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.Source.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.Source.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.Source.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Source.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink","title":"SourceAndSink","text":"Python<pre><code>SourceAndSink(label: str, inputs: list[Flow] | None = None, outputs: list[Flow] | None = None, prevent_simultaneous_flow_rates: bool = True, meta_data: dict | None = None, **kwargs)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A SourceAndSink combines both supply and demand capabilities in a single component.</p> <p>SourceAndSink components can both consume AND provide energy or material flows from and to the system, making them ideal for modeling markets, (simple) storage facilities, or bidirectional grid connections where buying and selling occur at the same location.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>Input-flows into the SourceAndSink representing consumption/demand side.</p> <code>None</code> <code>outputs</code> <code>list[Flow] | None</code> <p>Output-flows from the SourceAndSink representing supply/generation side.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, prevents simultaneous input and output flows. This enforces that the component operates either as a source OR sink at any given time, but not both simultaneously. Default is True.</p> <code>True</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Electricity market connection (buy/sell to grid):</p> Python<pre><code>electricity_market = SourceAndSink(\n    label='grid_connection',\n    inputs=[electricity_purchase],  # Buy from grid\n    outputs=[electricity_sale],  # Sell to grid\n    prevent_simultaneous_flow_rates=True,  # Can't buy and sell simultaneously\n)\n</code></pre> <p>Natural gas storage facility:</p> Python<pre><code>gas_storage_facility = SourceAndSink(\n    label='underground_gas_storage',\n    inputs=[gas_injection_flow],  # Inject gas into storage\n    outputs=[gas_withdrawal_flow],  # Withdraw gas from storage\n    prevent_simultaneous_flow_rates=True,  # Injection or withdrawal, not both\n)\n</code></pre> <p>District heating network connection:</p> Python<pre><code>dh_connection = SourceAndSink(\n    label='district_heating_tie',\n    inputs=[heat_purchase_flow],  # Purchase heat from network\n    outputs=[heat_sale_flow],  # Sell excess heat to network\n    prevent_simultaneous_flow_rates=False,  # May allow simultaneous flows\n)\n</code></pre> <p>Industrial waste heat exchange:</p> Python<pre><code>waste_heat_exchange = SourceAndSink(\n    label='industrial_heat_hub',\n    inputs=[\n        waste_heat_input_a,  # Receive waste heat from process A\n        waste_heat_input_b,  # Receive waste heat from process B\n    ],\n    outputs=[\n        useful_heat_supply_c,  # Supply heat to process C\n        useful_heat_supply_d,  # Supply heat to process D\n    ],\n    prevent_simultaneous_flow_rates=False,  # Multiple simultaneous flows allowed\n)\n</code></pre> Note <p>When prevent_simultaneous_flow_rates is True, binary variables are created to ensure mutually exclusive operation between input and output flows, which increases computational complexity but reflects realistic market or storage operation constraints.</p> <p>SourceAndSink is particularly useful for modeling: - Energy markets with bidirectional trading - Storage facilities with injection/withdrawal operations - Grid tie points with import/export capabilities - Waste exchange networks with multiple participants</p> Deprecated <p>The deprecated <code>sink</code> and <code>source</code> kwargs are accepted for compatibility but will be removed in future releases.</p>"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.Storage","title":"Storage","text":"Python<pre><code>Storage(label: str, charging: Flow, discharging: Flow, capacity_in_flow_hours: PeriodicDataUser | InvestParameters, relative_minimum_charge_state: TemporalDataUser = 0, relative_maximum_charge_state: TemporalDataUser = 1, initial_charge_state: PeriodicDataUser | Literal['lastValueOfSim'] = 0, minimal_final_charge_state: PeriodicDataUser | None = None, maximal_final_charge_state: PeriodicDataUser | None = None, relative_minimum_final_charge_state: PeriodicDataUser | None = None, relative_maximum_final_charge_state: PeriodicDataUser | None = None, eta_charge: TemporalDataUser = 1, eta_discharge: TemporalDataUser = 1, relative_loss_per_hour: TemporalDataUser = 0, prevent_simultaneous_charge_and_discharge: bool = True, balanced: bool = False, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Storage models the temporary storage and release of energy or material.</p> <p>Storages have one incoming and one outgoing Flow, each with configurable efficiency factors. They maintain a charge state variable that represents the stored amount, bounded by capacity limits and evolving over time based on charging, discharging, and self-discharge losses.</p> <p>The storage model handles complex temporal dynamics including initial conditions, final state constraints, and time-varying parameters. It supports both fixed-size and investment-optimized storage systems with comprehensive techno-economic modeling.</p> Mathematical Formulation <p>See the complete mathematical model in the documentation: Storage</p> <ul> <li>Equation (1): Charge state bounds</li> <li>Equation (3): Storage balance (charge state evolution)</li> </ul> <p>Variable Mapping:     - <code>capacity_in_flow_hours</code> \u2192 C (storage capacity)     - <code>charge_state</code> \u2192 c(t_i) (state of charge at time t_i)     - <code>relative_loss_per_hour</code> \u2192 \u010b_rel,loss (self-discharge rate)     - <code>eta_charge</code> \u2192 \u03b7_in (charging efficiency)     - <code>eta_discharge</code> \u2192 \u03b7_out (discharging efficiency)</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Element identifier used in the FlowSystem.</p> required <code>charging</code> <code>Flow</code> <p>Incoming flow for loading the storage.</p> required <code>discharging</code> <code>Flow</code> <p>Outgoing flow for unloading the storage.</p> required <code>capacity_in_flow_hours</code> <code>PeriodicDataUser | InvestParameters</code> <p>Storage capacity in flow-hours (kWh, m\u00b3, kg). Scalar for fixed size or InvestParameters for optimization.</p> required <code>relative_minimum_charge_state</code> <code>TemporalDataUser</code> <p>Minimum charge state (0-1). Default: 0.</p> <code>0</code> <code>relative_maximum_charge_state</code> <code>TemporalDataUser</code> <p>Maximum charge state (0-1). Default: 1.</p> <code>1</code> <code>initial_charge_state</code> <code>PeriodicDataUser | Literal['lastValueOfSim']</code> <p>Charge at start. Numeric or 'lastValueOfSim'. Default: 0.</p> <code>0</code> <code>minimal_final_charge_state</code> <code>PeriodicDataUser | None</code> <p>Minimum absolute charge required at end (optional).</p> <code>None</code> <code>maximal_final_charge_state</code> <code>PeriodicDataUser | None</code> <p>Maximum absolute charge allowed at end (optional).</p> <code>None</code> <code>relative_minimum_final_charge_state</code> <code>PeriodicDataUser | None</code> <p>Minimum relative charge at end. Defaults to last value of relative_minimum_charge_state.</p> <code>None</code> <code>relative_maximum_final_charge_state</code> <code>PeriodicDataUser | None</code> <p>Maximum relative charge at end. Defaults to last value of relative_maximum_charge_state.</p> <code>None</code> <code>eta_charge</code> <code>TemporalDataUser</code> <p>Charging efficiency (0-1). Default: 1.</p> <code>1</code> <code>eta_discharge</code> <code>TemporalDataUser</code> <p>Discharging efficiency (0-1). Default: 1.</p> <code>1</code> <code>relative_loss_per_hour</code> <code>TemporalDataUser</code> <p>Self-discharge per hour (0-0.1). Default: 0.</p> <code>0</code> <code>prevent_simultaneous_charge_and_discharge</code> <code>bool</code> <p>Prevent charging and discharging simultaneously. Adds binary variables. Default: True.</p> <code>True</code> <code>meta_data</code> <code>dict | None</code> <p>Additional information stored in results. Python native types only.</p> <code>None</code> <p>Examples:</p> <p>Battery energy storage system:</p> Python<pre><code>battery = Storage(\n    label='lithium_battery',\n    charging=battery_charge_flow,\n    discharging=battery_discharge_flow,\n    capacity_in_flow_hours=100,  # 100 kWh capacity\n    eta_charge=0.95,  # 95% charging efficiency\n    eta_discharge=0.95,  # 95% discharging efficiency\n    relative_loss_per_hour=0.001,  # 0.1% loss per hour\n    relative_minimum_charge_state=0.1,  # Never below 10% SOC\n    relative_maximum_charge_state=0.9,  # Never above 90% SOC\n)\n</code></pre> <p>Thermal storage with cycling constraints:</p> Python<pre><code>thermal_storage = Storage(\n    label='hot_water_tank',\n    charging=heat_input,\n    discharging=heat_output,\n    capacity_in_flow_hours=500,  # 500 kWh thermal capacity\n    initial_charge_state=250,  # Start half full\n    # Impact of temperature on energy capacity\n    relative_maximum_charge_state=water_temperature_spread / rated_temeprature_spread,\n    eta_charge=0.90,  # Heat exchanger losses\n    eta_discharge=0.85,  # Distribution losses\n    relative_loss_per_hour=0.02,  # 2% thermal loss per hour\n    prevent_simultaneous_charge_and_discharge=True,\n)\n</code></pre> <p>Pumped hydro storage with investment optimization:</p> Python<pre><code>pumped_hydro = Storage(\n    label='pumped_hydro',\n    charging=pump_flow,\n    discharging=turbine_flow,\n    capacity_in_flow_hours=InvestParameters(\n        minimum_size=1000,  # Minimum economic scale\n        maximum_size=10000,  # Site constraints\n        specific_effects={'cost': 150},  # \u20ac150/MWh capacity\n        fix_effects={'cost': 50_000_000},  # \u20ac50M fixed costs\n    ),\n    eta_charge=0.85,  # Pumping efficiency\n    eta_discharge=0.90,  # Turbine efficiency\n    initial_charge_state='lastValueOfSim',  # Ensuring no deficit compared to start\n    relative_loss_per_hour=0.0001,  # Minimal evaporation\n)\n</code></pre> <p>Material storage with inventory management:</p> Python<pre><code>fuel_storage = Storage(\n    label='natural_gas_storage',\n    charging=gas_injection,\n    discharging=gas_withdrawal,\n    capacity_in_flow_hours=10000,  # 10,000 m\u00b3 storage volume\n    initial_charge_state=3000,  # Start with 3,000 m\u00b3\n    minimal_final_charge_state=1000,  # Strategic reserve\n    maximal_final_charge_state=9000,  # Prevent overflow\n    eta_charge=0.98,  # Compression losses\n    eta_discharge=0.95,  # Pressure reduction losses\n    relative_loss_per_hour=0.0005,  # 0.05% leakage per hour\n    prevent_simultaneous_charge_and_discharge=False,  # Allow flow-through\n)\n</code></pre> Note <p>Mathematical formulation: See Storage for charge state evolution equations and balance constraints.</p> <p>Efficiency parameters (eta_charge, eta_discharge) are dimensionless (0-1 range). The relative_loss_per_hour represents exponential decay per hour.</p> <p>Binary variables: When prevent_simultaneous_charge_and_discharge is True, binary variables enforce mutual exclusivity, increasing solution time but preventing unrealistic simultaneous charging and discharging.</p> <p>Units: Flow rates and charge states are related by the concept of 'flow hours' (=flow_rate * time). With flow rates in kW, the charge state is therefore (usually) kWh. With flow rates in m3/h, the charge state is therefore in m3.</p>"},{"location":"api-reference/commons/#flixopt.commons.Storage-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Storage.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.Storage.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Storage.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.Storage.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.Storage.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.Storage.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Storage.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.Transmission","title":"Transmission","text":"Python<pre><code>Transmission(label: str, in1: Flow, out1: Flow, in2: Flow | None = None, out2: Flow | None = None, relative_losses: TemporalDataUser | None = None, absolute_losses: TemporalDataUser | None = None, on_off_parameters: OnOffParameters = None, prevent_simultaneous_flows_in_both_directions: bool = True, balanced: bool = False, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Models transmission infrastructure that transports flows between two locations with losses.</p> <p>Transmission components represent physical infrastructure like pipes, cables, transmission lines, or conveyor systems that transport energy or materials between two points. They can model both unidirectional and bidirectional flow with configurable loss mechanisms and operational constraints.</p> <p>The component supports complex transmission scenarios including relative losses (proportional to flow), absolute losses (fixed when active), and bidirectional operation with flow direction constraints.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>in1</code> <code>Flow</code> <p>The primary inflow (side A). Pass InvestParameters here for capacity optimization.</p> required <code>out1</code> <code>Flow</code> <p>The primary outflow (side B).</p> required <code>in2</code> <code>Flow | None</code> <p>Optional secondary inflow (side B) for bidirectional operation. If in1 has InvestParameters, in2 will automatically have matching capacity.</p> <code>None</code> <code>out2</code> <code>Flow | None</code> <p>Optional secondary outflow (side A) for bidirectional operation.</p> <code>None</code> <code>relative_losses</code> <code>TemporalDataUser | None</code> <p>Proportional losses as fraction of throughput (e.g., 0.02 for 2% loss). Applied as: output = input \u00d7 (1 - relative_losses)</p> <code>None</code> <code>absolute_losses</code> <code>TemporalDataUser | None</code> <p>Fixed losses that occur when transmission is active. Automatically creates binary variables for on/off states.</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>prevent_simultaneous_flows_in_both_directions</code> <code>bool</code> <p>If True, prevents simultaneous flow in both directions. Increases binary variables but reflects physical reality for most transmission systems. Default is True.</p> <code>True</code> <code>balanced</code> <code>bool</code> <p>Whether to equate the size of the in1 and in2 Flow. Needs InvestParameters in both Flows.</p> <code>False</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Simple electrical transmission line:</p> Python<pre><code>power_line = Transmission(\n    label='110kv_line',\n    in1=substation_a_out,\n    out1=substation_b_in,\n    relative_losses=0.03,  # 3% line losses\n)\n</code></pre> <p>Bidirectional natural gas pipeline:</p> Python<pre><code>gas_pipeline = Transmission(\n    label='interstate_pipeline',\n    in1=compressor_station_a,\n    out1=distribution_hub_b,\n    in2=compressor_station_b,\n    out2=distribution_hub_a,\n    relative_losses=0.005,  # 0.5% friction losses\n    absolute_losses=50,  # 50 kW compressor power when active\n    prevent_simultaneous_flows_in_both_directions=True,\n)\n</code></pre> <p>District heating network with investment optimization:</p> Python<pre><code>heating_network = Transmission(\n    label='dh_main_line',\n    in1=Flow(\n        label='heat_supply',\n        bus=central_plant_bus,\n        size=InvestParameters(\n            minimum_size=1000,  # Minimum 1 MW capacity\n            maximum_size=10000,  # Maximum 10 MW capacity\n            specific_effects={'cost': 200},  # \u20ac200/kW capacity\n            fix_effects={'cost': 500000},  # \u20ac500k fixed installation\n        ),\n    ),\n    out1=district_heat_demand,\n    relative_losses=0.15,  # 15% thermal losses in distribution\n)\n</code></pre> <p>Material conveyor with on/off operation:</p> Python<pre><code>conveyor_belt = Transmission(\n    label='material_transport',\n    in1=loading_station,\n    out1=unloading_station,\n    absolute_losses=25,  # 25 kW motor power when running\n    on_off_parameters=OnOffParameters(\n        effects_per_switch_on={'maintenance': 0.1},\n        consecutive_on_hours_min=2,  # Minimum 2-hour operation\n        switch_on_total_max=10,  # Maximum 10 starts per day\n    ),\n)\n</code></pre> Note <p>The transmission equation balances flows with losses: output_flow = input_flow \u00d7 (1 - relative_losses) - absolute_losses</p> <p>For bidirectional transmission, each direction has independent loss calculations.</p> <p>When using InvestParameters on in1, the capacity automatically applies to in2 to maintain consistent bidirectional capacity without additional investment variables.</p> <p>Absolute losses force the creation of binary on/off variables, which increases computational complexity but enables realistic modeling of equipment with standby power consumption.</p>"},{"location":"api-reference/commons/#flixopt.commons.Transmission-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Transmission.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.Transmission.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Transmission.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.Transmission.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.Transmission.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.Transmission.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Transmission.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG","title":"CONFIG","text":"<p>Configuration for flixopt library.</p> <p>Always call <code>CONFIG.apply()</code> after changes.</p> <p>Attributes:</p> Name Type Description <code>Logging</code> <p>Logging configuration.</p> <code>Modeling</code> <p>Optimization modeling parameters.</p> <code>config_name</code> <code>str</code> <p>Configuration name.</p> <p>Examples:</p> Python<pre><code>CONFIG.Logging.console = True\nCONFIG.Logging.level = 'DEBUG'\nCONFIG.apply()\n</code></pre> <p>Load from YAML file:</p> YAML<pre><code>logging:\n  level: DEBUG\n  console: true\n  file: app.log\n</code></pre>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG-classes","title":"Classes","text":""},{"location":"api-reference/commons/#flixopt.commons.CONFIG.Logging","title":"Logging","text":"<p>Logging configuration.</p> <p>Silent by default. Enable via <code>console=True</code> or <code>file='path'</code>.</p> <p>Attributes:</p> Name Type Description <code>level</code> <code>Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']</code> <p>Logging level.</p> <code>file</code> <code>str | None</code> <p>Log file path for file logging.</p> <code>console</code> <code>bool | Literal['stdout', 'stderr']</code> <p>Enable console output.</p> <code>rich</code> <code>bool</code> <p>Use Rich library for enhanced output.</p> <code>max_file_size</code> <code>int</code> <p>Max file size before rotation.</p> <code>backup_count</code> <code>int</code> <p>Number of backup files to keep.</p> <code>date_format</code> <code>str</code> <p>Date/time format string.</p> <code>format</code> <code>str</code> <p>Log message format string.</p> <code>console_width</code> <code>int</code> <p>Console width for Rich handler.</p> <code>show_path</code> <code>bool</code> <p>Show file paths in messages.</p> <code>show_logger_name</code> <code>bool</code> <p>Show logger name in messages.</p> <code>Colors</code> <code>bool</code> <p>ANSI color codes for log levels.</p> <p>Examples:</p> Python<pre><code># File logging with rotation\nCONFIG.Logging.file = 'app.log'\nCONFIG.Logging.max_file_size = 5_242_880  # 5MB\nCONFIG.apply()\n\n# Rich handler with stdout\nCONFIG.Logging.console = True  # or 'stdout'\nCONFIG.Logging.rich = True\nCONFIG.apply()\n\n# Console output to stderr\nCONFIG.Logging.console = 'stderr'\nCONFIG.apply()\n</code></pre>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG.Logging-classes","title":"Classes","text":"Colors \u00b6 <p>ANSI color codes for log levels.</p> <p>Attributes:</p> Name Type Description <code>DEBUG</code> <code>str</code> <p>ANSI color for DEBUG level.</p> <code>INFO</code> <code>str</code> <p>ANSI color for INFO level.</p> <code>WARNING</code> <code>str</code> <p>ANSI color for WARNING level.</p> <code>ERROR</code> <code>str</code> <p>ANSI color for ERROR level.</p> <code>CRITICAL</code> <code>str</code> <p>ANSI color for CRITICAL level.</p> <p>Examples:</p> Python<pre><code>CONFIG.Logging.Colors.INFO = '\\033[32m'  # Green\nCONFIG.Logging.Colors.ERROR = '\\033[1m\\033[31m'  # Bold red\nCONFIG.apply()\n</code></pre> Common ANSI codes <ul> <li>'\\033[30m' - Black</li> <li>'\\033[31m' - Red</li> <li>'\\033[32m' - Green</li> <li>'\\033[33m' - Yellow</li> <li>'\\033[34m' - Blue</li> <li>'\\033[35m' - Magenta</li> <li>'\\033[36m' - Cyan</li> <li>'\\033[37m' - White</li> <li>'\\033[90m' - Bright Black/Gray</li> <li>'\\033[0m' - Reset to default</li> <li>'\\033[1m\\033[3Xm' - Bold (replace X with color code 0-7)</li> <li>'\\033[2m\\033[3Xm' - Dim (replace X with color code 0-7)</li> </ul>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG.Modeling","title":"Modeling","text":"<p>Optimization modeling parameters.</p> <p>Attributes:</p> Name Type Description <code>big</code> <code>int</code> <p>Large number for big-M constraints.</p> <code>epsilon</code> <code>float</code> <p>Tolerance for numerical comparisons.</p> <code>big_binary_bound</code> <code>int</code> <p>Upper bound for binary constraints.</p>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG.Plotting","title":"Plotting","text":"<p>Plotting configuration.</p> <p>Configure backends via environment variables: - Matplotlib: Set <code>MPLBACKEND</code> environment variable (e.g., 'Agg', 'TkAgg') - Plotly: Set <code>PLOTLY_RENDERER</code> or use <code>plotly.io.renderers.default</code></p> <p>Attributes:</p> Name Type Description <code>default_show</code> <code>bool</code> <p>Default value for the <code>show</code> parameter in plot methods.</p> <code>default_engine</code> <code>Literal['plotly', 'matplotlib']</code> <p>Default plotting engine.</p> <code>default_dpi</code> <code>int</code> <p>Default DPI for saved plots.</p> <code>default_facet_cols</code> <code>int</code> <p>Default number of columns for faceted plots.</p> <code>default_sequential_colorscale</code> <code>str</code> <p>Default colorscale for heatmaps and continuous data.</p> <code>default_qualitative_colorscale</code> <code>str</code> <p>Default colormap for categorical plots (bar/line/area charts).</p> <p>Examples:</p> Python<pre><code># Set consistent theming\nCONFIG.Plotting.plotly_template = 'plotly_dark'\nCONFIG.apply()\n\n# Configure default export and color settings\nCONFIG.Plotting.default_dpi = 600\nCONFIG.Plotting.default_sequential_colorscale = 'plasma'\nCONFIG.Plotting.default_qualitative_colorscale = 'Dark24'\nCONFIG.apply()\n</code></pre>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.CONFIG.reset","title":"reset  <code>classmethod</code>","text":"Python<pre><code>reset()\n</code></pre> <p>Reset all configuration values to defaults.</p>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG.apply","title":"apply  <code>classmethod</code>","text":"Python<pre><code>apply()\n</code></pre> <p>Apply current configuration to logging system.</p>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG.load_from_file","title":"load_from_file  <code>classmethod</code>","text":"Python<pre><code>load_from_file(config_file: str | Path)\n</code></pre> <p>Load configuration from YAML file and apply it.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str | Path</code> <p>Path to the YAML configuration file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the config file does not exist.</p>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG.to_dict","title":"to_dict  <code>classmethod</code>","text":"Python<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the configuration class into a dictionary for JSON serialization.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the current configuration.</p>"},{"location":"api-reference/commons/#flixopt.commons.TimeSeriesData","title":"TimeSeriesData","text":"Python<pre><code>TimeSeriesData(*args: Any, aggregation_group: str | None = None, aggregation_weight: float | None = None, agg_group: str | None = None, agg_weight: float | None = None, **kwargs: Any)\n</code></pre> <p>               Bases: <code>DataArray</code></p> <p>Minimal TimeSeriesData that inherits from xr.DataArray with aggregation metadata.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments passed to DataArray</p> <code>()</code> <code>aggregation_group</code> <code>str | None</code> <p>Aggregation group name</p> <code>None</code> <code>aggregation_weight</code> <code>float | None</code> <p>Aggregation weight (0-1)</p> <code>None</code> <code>agg_group</code> <code>str | None</code> <p>Deprecated, use aggregation_group instead</p> <code>None</code> <code>agg_weight</code> <code>float | None</code> <p>Deprecated, use aggregation_weight instead</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to DataArray</p> <code>{}</code>"},{"location":"api-reference/commons/#flixopt.commons.TimeSeriesData-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.TimeSeriesData.fit_to_coords","title":"fit_to_coords","text":"Python<pre><code>fit_to_coords(coords: dict[str, Index], name: str | None = None) -&gt; TimeSeriesData\n</code></pre> <p>Fit the data to the given coordinates. Returns a new TimeSeriesData object if the current coords are different.</p>"},{"location":"api-reference/commons/#flixopt.commons.TimeSeriesData.from_dataarray","title":"from_dataarray  <code>classmethod</code>","text":"Python<pre><code>from_dataarray(da: DataArray, aggregation_group: str | None = None, aggregation_weight: float | None = None)\n</code></pre> <p>Create TimeSeriesData from DataArray, extracting metadata from attrs.</p>"},{"location":"api-reference/commons/#flixopt.commons.TimeSeriesData.is_timeseries_data","title":"is_timeseries_data  <code>classmethod</code>","text":"Python<pre><code>is_timeseries_data(obj) -&gt; bool\n</code></pre> <p>Check if an object is TimeSeriesData.</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect","title":"Effect","text":"Python<pre><code>Effect(label: str, unit: str, description: str, meta_data: dict | None = None, is_standard: bool = False, is_objective: bool = False, share_from_temporal: TemporalEffectsUser | None = None, share_from_periodic: PeriodicEffectsUser | None = None, minimum_temporal: PeriodicEffectsUser | None = None, maximum_temporal: PeriodicEffectsUser | None = None, minimum_periodic: PeriodicEffectsUser | None = None, maximum_periodic: PeriodicEffectsUser | None = None, minimum_per_hour: TemporalDataUser | None = None, maximum_per_hour: TemporalDataUser | None = None, minimum_total: Scalar | None = None, maximum_total: Scalar | None = None, **kwargs)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Represents system-wide impacts like costs, emissions, resource consumption, or other effects.</p> <p>Effects capture the broader impacts of system operation and investment decisions beyond the primary energy/material flows. Each Effect accumulates contributions from Components, Flows, and other system elements. One Effect is typically chosen as the optimization objective, while others can serve as constraints or tracking metrics.</p> <p>Effects support comprehensive modeling including operational and investment contributions, cross-effect relationships (e.g., carbon pricing), and flexible constraint formulation.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>unit</code> <code>str</code> <p>The unit of the effect (e.g., '\u20ac', 'kg_CO2', 'kWh_primary', 'm\u00b2'). This is informative only and does not affect optimization calculations.</p> required <code>description</code> <code>str</code> <p>Descriptive name explaining what this effect represents.</p> required <code>is_standard</code> <code>bool</code> <p>If True, this is a standard effect allowing direct value input without effect dictionaries. Used for simplified effect specification (and less boilerplate code).</p> <code>False</code> <code>is_objective</code> <code>bool</code> <p>If True, this effect serves as the optimization objective function. Only one effect can be marked as objective per optimization.</p> <code>False</code> <code>share_from_temporal</code> <code>TemporalEffectsUser | None</code> <p>Temporal cross-effect contributions. Maps temporal contributions from other effects to this effect</p> <code>None</code> <code>share_from_periodic</code> <code>PeriodicEffectsUser | None</code> <p>Periodic cross-effect contributions. Maps periodic contributions from other effects to this effect.</p> <code>None</code> <code>minimum_temporal</code> <code>PeriodicEffectsUser | None</code> <p>Minimum allowed total contribution across all timesteps.</p> <code>None</code> <code>maximum_temporal</code> <code>PeriodicEffectsUser | None</code> <p>Maximum allowed total contribution across all timesteps.</p> <code>None</code> <code>minimum_per_hour</code> <code>TemporalDataUser | None</code> <p>Minimum allowed contribution per hour.</p> <code>None</code> <code>maximum_per_hour</code> <code>TemporalDataUser | None</code> <p>Maximum allowed contribution per hour.</p> <code>None</code> <code>minimum_periodic</code> <code>PeriodicEffectsUser | None</code> <p>Minimum allowed total periodic contribution.</p> <code>None</code> <code>maximum_periodic</code> <code>PeriodicEffectsUser | None</code> <p>Maximum allowed total periodic contribution.</p> <code>None</code> <code>minimum_total</code> <code>Scalar | None</code> <p>Minimum allowed total effect (temporal + periodic combined).</p> <code>None</code> <code>maximum_total</code> <code>Scalar | None</code> <p>Maximum allowed total effect (temporal + periodic combined).</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Deprecated Parameters (for backwards compatibility):     minimum_operation: Use <code>minimum_temporal</code> instead.     maximum_operation: Use <code>maximum_temporal</code> instead.     minimum_invest: Use <code>minimum_periodic</code> instead.     maximum_invest: Use <code>maximum_periodic</code> instead.     minimum_operation_per_hour: Use <code>minimum_per_hour</code> instead.     maximum_operation_per_hour: Use <code>maximum_per_hour</code> instead.</p> <p>Examples:</p> <p>Basic cost objective:</p> Python<pre><code>cost_effect = Effect(\n    label='system_costs',\n    unit='\u20ac',\n    description='Total system costs',\n    is_objective=True,\n)\n</code></pre> <p>CO2 emissions:</p> Python<pre><code>co2_effect = Effect(\n    label='CO2',\n    unit='kg_CO2',\n    description='Carbon dioxide emissions',\n    maximum_total=1_000_000,  # 1000 t CO2 annual limit\n)\n</code></pre> <p>Land use constraint:</p> Python<pre><code>land_use = Effect(\n    label='land_usage',\n    unit='m\u00b2',\n    description='Land area requirement',\n    maximum_total=50_000,  # Maximum 5 hectares available\n)\n</code></pre> <p>Primary energy tracking:</p> Python<pre><code>primary_energy = Effect(\n    label='primary_energy',\n    unit='kWh_primary',\n    description='Primary energy consumption',\n)\n</code></pre> <p>Cost objective with carbon and primary energy pricing:</p> Text Only<pre><code>```python\ncost_effect = Effect(\n    label='system_costs',\n    unit='\u20ac',\n    description='Total system costs',\n    is_objective=True,\n    share_from_temporal={\n        'primary_energy': 0.08,  # 0.08 \u20ac/kWh_primary\n        'CO2': 0.2,  # Carbon pricing: 0.2 \u20ac/kg_CO2 into costs if used on a cost effect\n    },\n)\n```\n\nWater consumption with tiered constraints:\n\n```python\nwater_usage = Effect(\n    label='water_consumption',\n    unit='m\u00b3',\n    description='Industrial water usage',\n    minimum_per_hour=10,  # Minimum 10 m\u00b3/h for process stability\n    maximum_per_hour=500,  # Maximum 500 m\u00b3/h capacity limit\n    maximum_total=100_000,  # Annual permit limit: 100,000 m\u00b3\n)\n```\n</code></pre> Note <p>Effect bounds can be None to indicate no constraint in that direction.</p> <p>Cross-effect relationships enable sophisticated modeling like carbon pricing, resource valuation, or multi-criteria optimization with weighted objectives.</p> <p>The unit field is purely informational - ensure dimensional consistency across all contributions to each effect manually.</p> <p>Effects are accumulated as: - Total = \u03a3(temporal contributions) + \u03a3(periodic contributions)</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect-attributes","title":"Attributes","text":""},{"location":"api-reference/commons/#flixopt.commons.Effect.minimum_operation","title":"minimum_operation  <code>property</code> <code>writable</code>","text":"Python<pre><code>minimum_operation\n</code></pre> <p>DEPRECATED: Use 'minimum_temporal' property instead.</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.maximum_operation","title":"maximum_operation  <code>property</code> <code>writable</code>","text":"Python<pre><code>maximum_operation\n</code></pre> <p>DEPRECATED: Use 'maximum_temporal' property instead.</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.minimum_invest","title":"minimum_invest  <code>property</code> <code>writable</code>","text":"Python<pre><code>minimum_invest\n</code></pre> <p>DEPRECATED: Use 'minimum_periodic' property instead.</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.maximum_invest","title":"maximum_invest  <code>property</code> <code>writable</code>","text":"Python<pre><code>maximum_invest\n</code></pre> <p>DEPRECATED: Use 'maximum_periodic' property instead.</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.minimum_operation_per_hour","title":"minimum_operation_per_hour  <code>property</code> <code>writable</code>","text":"Python<pre><code>minimum_operation_per_hour\n</code></pre> <p>DEPRECATED: Use 'minimum_per_hour' property instead.</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.maximum_operation_per_hour","title":"maximum_operation_per_hour  <code>property</code> <code>writable</code>","text":"Python<pre><code>maximum_operation_per_hour\n</code></pre> <p>DEPRECATED: Use 'maximum_per_hour' property instead.</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Effect.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.Bus","title":"Bus","text":"Python<pre><code>Bus(label: str, excess_penalty_per_flow_hour: TemporalDataUser | None = 100000.0, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Buses represent nodal balances between flow rates, serving as connection points.</p> <p>A Bus enforces energy or material balance constraints where the sum of all incoming flows must equal the sum of all outgoing flows at each time step. Buses represent physical or logical connection points for energy carriers (electricity, heat, gas) or material flows between different Components.</p> Mathematical Formulation <p>See the complete mathematical model in the documentation: Bus</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>excess_penalty_per_flow_hour</code> <code>TemporalDataUser | None</code> <p>Penalty costs for bus balance violations. When None, no excess/deficit is allowed (hard constraint). When set to a value &gt; 0, allows bus imbalances at penalty cost. Default is 1e5 (high penalty).</p> <code>100000.0</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Electrical bus with strict balance:</p> Python<pre><code>electricity_bus = Bus(\n    label='main_electrical_bus',\n    excess_penalty_per_flow_hour=None,  # No imbalance allowed\n)\n</code></pre> <p>Heat network with penalty for imbalances:</p> Python<pre><code>heat_network = Bus(\n    label='district_heating_network',\n    excess_penalty_per_flow_hour=1000,  # \u20ac1000/MWh penalty for imbalance\n)\n</code></pre> <p>Material flow with time-varying penalties:</p> Python<pre><code>material_hub = Bus(\n    label='material_processing_hub',\n    excess_penalty_per_flow_hour=waste_disposal_costs,  # Time series\n)\n</code></pre> Note <p>The bus balance equation enforced is: \u03a3(inflows) = \u03a3(outflows) + excess - deficit</p> <p>When excess_penalty_per_flow_hour is None, excess and deficit are forced to zero. When a penalty cost is specified, the optimization can choose to violate the balance if economically beneficial, paying the penalty. The penalty is added to the objective directly.</p> <p>Empty <code>inputs</code> and <code>outputs</code> lists are initialized and populated automatically by the FlowSystem during system setup.</p>"},{"location":"api-reference/commons/#flixopt.commons.Bus-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Bus.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.Bus.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Bus.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.Bus.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.Bus.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.Bus.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Bus.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.Flow","title":"Flow","text":"Python<pre><code>Flow(label: str, bus: str, size: Scalar | InvestParameters = None, fixed_relative_profile: TemporalDataUser | None = None, relative_minimum: TemporalDataUser = 0, relative_maximum: TemporalDataUser = 1, effects_per_flow_hour: TemporalEffectsUser | None = None, on_off_parameters: OnOffParameters | None = None, flow_hours_total_max: Scalar | None = None, flow_hours_total_min: Scalar | None = None, load_factor_min: Scalar | None = None, load_factor_max: Scalar | None = None, previous_flow_rate: Scalar | list[Scalar] | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Define a directed flow of energy or material between bus and component.</p> <p>A Flow represents the transfer of energy (electricity, heat, fuel) or material between a Bus and a Component in a specific direction. The flow rate is the primary optimization variable, with constraints and costs defined through various parameters. Flows can have fixed or variable sizes, operational constraints, and complex on/off behavior.</p> Key Concepts <p>Flow Rate: The instantaneous rate of energy/material transfer (optimization variable) [kW, m\u00b3/h, kg/h] Flow Hours: Amount of energy/material transferred per timestep. [kWh, m\u00b3, kg] Flow Size: The maximum capacity or nominal rating of the flow [kW, m\u00b3/h, kg/h] Relative Bounds: Flow rate limits expressed as fractions of flow size</p> Integration with Parameter Classes <ul> <li>InvestParameters: Used for <code>size</code> when flow Size is an investment decision</li> <li>OnOffParameters: Used for <code>on_off_parameters</code> when flow has discrete states</li> </ul> Mathematical Formulation <p>See the complete mathematical model in the documentation: Flow</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Unique flow identifier within its component.</p> required <code>bus</code> <code>str</code> <p>Bus label this flow connects to.</p> required <code>size</code> <code>Scalar | InvestParameters</code> <p>Flow capacity. Scalar, InvestParameters, or None (uses CONFIG.Modeling.big).</p> <code>None</code> <code>relative_minimum</code> <code>TemporalDataUser</code> <p>Minimum flow rate as fraction of size (0-1). Default: 0.</p> <code>0</code> <code>relative_maximum</code> <code>TemporalDataUser</code> <p>Maximum flow rate as fraction of size. Default: 1.</p> <code>1</code> <code>load_factor_min</code> <code>Scalar | None</code> <p>Minimum average utilization (0-1). Default: 0.</p> <code>None</code> <code>load_factor_max</code> <code>Scalar | None</code> <p>Maximum average utilization (0-1). Default: 1.</p> <code>None</code> <code>effects_per_flow_hour</code> <code>TemporalEffectsUser | None</code> <p>Operational costs/impacts per flow-hour. Dict mapping effect names to values (e.g., {'cost': 45, 'CO2': 0.8}).</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Binary operation constraints (OnOffParameters). Default: None.</p> <code>None</code> <code>flow_hours_total_max</code> <code>Scalar | None</code> <p>Maximum cumulative flow-hours. Alternative to load_factor_max.</p> <code>None</code> <code>flow_hours_total_min</code> <code>Scalar | None</code> <p>Minimum cumulative flow-hours. Alternative to load_factor_min.</p> <code>None</code> <code>fixed_relative_profile</code> <code>TemporalDataUser | None</code> <p>Predetermined pattern as fraction of size. Flow rate = size \u00d7 fixed_relative_profile(t).</p> <code>None</code> <code>previous_flow_rate</code> <code>Scalar | list[Scalar] | None</code> <p>Initial flow state for on/off dynamics. Default: None (off).</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Additional info stored in results. Python native types only.</p> <code>None</code> <p>Examples:</p> <p>Basic power flow with fixed capacity:</p> Python<pre><code>generator_output = Flow(\n    label='electricity_out',\n    bus='electricity_grid',\n    size=100,  # 100 MW capacity\n    relative_minimum=0.4,  # Cannot operate below 40 MW\n    effects_per_flow_hour={'fuel_cost': 45, 'co2_emissions': 0.8},\n)\n</code></pre> <p>Investment decision for battery capacity:</p> Python<pre><code>battery_flow = Flow(\n    label='electricity_storage',\n    bus='electricity_grid',\n    size=InvestParameters(\n        minimum_size=10,  # Minimum 10 MWh\n        maximum_size=100,  # Maximum 100 MWh\n        specific_effects={'cost': 150_000},  # \u20ac150k/MWh annualized\n    ),\n)\n</code></pre> <p>Heat pump with startup costs and minimum run times:</p> Python<pre><code>heat_pump = Flow(\n    label='heat_output',\n    bus='heating_network',\n    size=50,  # 50 kW thermal\n    relative_minimum=0.3,  # Minimum 15 kW output when on\n    effects_per_flow_hour={'electricity_cost': 25, 'maintenance': 2},\n    on_off_parameters=OnOffParameters(\n        effects_per_switch_on={'startup_cost': 100, 'wear': 0.1},\n        consecutive_on_hours_min=2,  # Must run at least 2 hours\n        consecutive_off_hours_min=1,  # Must stay off at least 1 hour\n        switch_on_total_max=200,  # Maximum 200 starts per period\n    ),\n)\n</code></pre> <p>Fixed renewable generation profile:</p> Python<pre><code>solar_generation = Flow(\n    label='solar_power',\n    bus='electricity_grid',\n    size=25,  # 25 MW installed capacity\n    fixed_relative_profile=np.array([0, 0.1, 0.4, 0.8, 0.9, 0.7, 0.3, 0.1, 0]),\n    effects_per_flow_hour={'maintenance_costs': 5},  # \u20ac5/MWh maintenance\n)\n</code></pre> <p>Industrial process with annual utilization limits:</p> Python<pre><code>production_line = Flow(\n    label='product_output',\n    bus='product_market',\n    size=1000,  # 1000 units/hour capacity\n    load_factor_min=0.6,  # Must achieve 60% annual utilization\n    load_factor_max=0.85,  # Cannot exceed 85% for maintenance\n    effects_per_flow_hour={'variable_cost': 12, 'quality_control': 0.5},\n)\n</code></pre> Design Considerations <p>Size vs Load Factors: Use <code>flow_hours_total_min/max</code> for absolute limits, <code>load_factor_min/max</code> for utilization-based constraints.</p> <p>Relative Bounds: Set <code>relative_minimum &gt; 0</code> only when equipment cannot operate below that level. Use <code>on_off_parameters</code> for discrete on/off behavior.</p> <p>Fixed Profiles: Use <code>fixed_relative_profile</code> for known exact patterns, <code>relative_maximum</code> for upper bounds on optimization variables.</p> Notes <ul> <li>Default size (CONFIG.Modeling.big) is used when size=None</li> <li>list inputs for previous_flow_rate are converted to NumPy arrays</li> <li>Flow direction is determined by component input/output designation</li> </ul> Deprecated <p>Passing Bus objects to <code>bus</code> parameter. Use bus label strings instead.</p>"},{"location":"api-reference/commons/#flixopt.commons.Flow-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Flow.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.Flow.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Flow.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.Flow.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.Flow.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.Flow.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Flow.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem","title":"FlowSystem","text":"Python<pre><code>FlowSystem(timesteps: DatetimeIndex, periods: Index | None = None, scenarios: Index | None = None, hours_of_last_timestep: float | None = None, hours_of_previous_timesteps: int | float | ndarray | None = None, weights: PeriodicDataUser | None = None, scenario_independent_sizes: bool | list[str] = True, scenario_independent_flow_rates: bool | list[str] = False)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>A FlowSystem organizes the high level Elements (Components, Buses &amp; Effects).</p> <p>This is the main container class that users work with to build and manage their System.</p> <p>Parameters:</p> Name Type Description Default <code>timesteps</code> <code>DatetimeIndex</code> <p>The timesteps of the model.</p> required <code>periods</code> <code>Index | None</code> <p>The periods of the model.</p> <code>None</code> <code>scenarios</code> <code>Index | None</code> <p>The scenarios of the model.</p> <code>None</code> <code>hours_of_last_timestep</code> <code>float | None</code> <p>The duration of the last time step. Uses the last time interval if not specified</p> <code>None</code> <code>hours_of_previous_timesteps</code> <code>int | float | ndarray | None</code> <p>The duration of previous timesteps. If None, the first time increment of time_series is used. This is needed to calculate previous durations (for example consecutive_on_hours). If you use an array, take care that its long enough to cover all previous values!</p> <code>None</code> <code>weights</code> <code>PeriodicDataUser | None</code> <p>The weights of each period and scenario. If None, all scenarios have the same weight (normalized to 1). Its recommended to normalize the weights to sum up to 1.</p> <code>None</code> <code>scenario_independent_sizes</code> <code>bool | list[str]</code> <p>Controls whether investment sizes are equalized across scenarios. - True: All sizes are shared/equalized across scenarios - False: All sizes are optimized separately per scenario - list[str]: Only specified components (by label_full) are equalized across scenarios</p> <code>True</code> <code>scenario_independent_flow_rates</code> <code>bool | list[str]</code> <p>Controls whether flow rates are equalized across scenarios. - True: All flow rates are shared/equalized across scenarios - False: All flow rates are optimized separately per scenario - list[str]: Only specified flows (by label_full) are equalized across scenarios</p> <code>False</code> Notes <ul> <li>Creates an empty registry for components and buses, an empty EffectCollection, and a placeholder for a SystemModel.</li> <li>The instance starts disconnected (self._connected_and_transformed == False) and will be connected_and_transformed automatically when trying to solve a calculation.</li> </ul>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem-attributes","title":"Attributes","text":""},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.scenario_independent_sizes","title":"scenario_independent_sizes  <code>property</code> <code>writable</code>","text":"Python<pre><code>scenario_independent_sizes: bool | list[str]\n</code></pre> <p>Controls whether investment sizes are equalized across scenarios.</p> <p>Returns:</p> Type Description <code>bool | list[str]</code> <p>bool or list[str]: Configuration for scenario-independent sizing</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.scenario_independent_flow_rates","title":"scenario_independent_flow_rates  <code>property</code> <code>writable</code>","text":"Python<pre><code>scenario_independent_flow_rates: bool | list[str]\n</code></pre> <p>Controls whether flow rates are equalized across scenarios.</p> <p>Returns:</p> Type Description <code>bool | list[str]</code> <p>bool or list[str]: Configuration for scenario-independent flow rates</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.transform_data","title":"transform_data","text":"Python<pre><code>transform_data(flow_system: FlowSystem, name_prefix: str = '') -&gt; None\n</code></pre> <p>Transform the data of the interface to match the FlowSystem's dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem containing timing and dimensional information</p> required <code>name_prefix</code> <code>str</code> <p>The prefix to use for the names of the variables. Defaults to '', which results in no prefix.</p> <code>''</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.calculate_hours_per_timestep","title":"calculate_hours_per_timestep  <code>staticmethod</code>","text":"Python<pre><code>calculate_hours_per_timestep(timesteps_extra: DatetimeIndex) -&gt; xr.DataArray\n</code></pre> <p>Calculate duration of each timestep as a 1D DataArray.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the FlowSystem to an xarray Dataset. Ensures FlowSystem is connected before serialization.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with structure in attributes</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; FlowSystem\n</code></pre> <p>Create a FlowSystem from an xarray Dataset. Handles FlowSystem-specific reconstruction logic.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the FlowSystem data</p> required <p>Returns:</p> Type Description <code>FlowSystem</code> <p>FlowSystem instance</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the FlowSystem to a NetCDF file. Ensures FlowSystem is connected before saving.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the netCDF file.</p> required <code>compression</code> <code>int</code> <p>The compression level to use when saving the file.</p> <code>0</code>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get FlowSystem structure. Ensures FlowSystem is connected before getting structure.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the flow system to a JSON file. Ensures FlowSystem is connected before saving.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.fit_to_model_coords","title":"fit_to_model_coords","text":"Python<pre><code>fit_to_model_coords(name: str, data: TemporalDataUser | PeriodicDataUser | None, dims: Collection[FlowSystemDimensions] | None = None) -&gt; TemporalData | PeriodicData | None\n</code></pre> <p>Fit data to model coordinate system (currently time, but extensible).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the data</p> required <code>data</code> <code>TemporalDataUser | PeriodicDataUser | None</code> <p>Data to fit to model coordinates</p> required <code>dims</code> <code>Collection[FlowSystemDimensions] | None</code> <p>Collection of dimension names to use for fitting. If None, all dimensions are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>TemporalData | PeriodicData | None</code> <p>xr.DataArray aligned to model coordinate system. If data is None, returns None.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.fit_effects_to_model_coords","title":"fit_effects_to_model_coords","text":"Python<pre><code>fit_effects_to_model_coords(label_prefix: str | None, effect_values: TemporalEffectsUser | PeriodicEffectsUser | None, label_suffix: str | None = None, dims: Collection[FlowSystemDimensions] | None = None, delimiter: str = '|') -&gt; TemporalEffects | PeriodicEffects | None\n</code></pre> <p>Transform EffectValues from the user to Internal Datatypes aligned with model coordinates.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.connect_and_transform","title":"connect_and_transform","text":"Python<pre><code>connect_and_transform()\n</code></pre> <p>Transform data for all elements using the new simplified approach.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.add_elements","title":"add_elements","text":"Python<pre><code>add_elements(*elements: Element) -&gt; None\n</code></pre> <p>Add Components(Storages, Boilers, Heatpumps, ...), Buses or Effects to the FlowSystem</p> <p>Parameters:</p> Name Type Description Default <code>*elements</code> <code>Element</code> <p>childs of  Element like Boiler, HeatPump, Bus,... modeling Elements</p> <code>()</code>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.create_model","title":"create_model","text":"Python<pre><code>create_model(normalize_weights: bool = True) -&gt; FlowSystemModel\n</code></pre> <p>Create a linopy model from the FlowSystem.</p> <p>Parameters:</p> Name Type Description Default <code>normalize_weights</code> <code>bool</code> <p>Whether to automatically normalize the weights (periods and scenarios) to sum up to 1 when solving.</p> <code>True</code>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.plot_network","title":"plot_network","text":"Python<pre><code>plot_network(path: bool | str | Path = 'flow_system.html', controls: bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']] = True, show: bool | None = None) -&gt; pyvis.network.Network | None\n</code></pre> <p>Visualizes the network structure of a FlowSystem using PyVis, saving it as an interactive HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>bool | str | Path</code> <p>Path to save the HTML visualization. - <code>False</code>: Visualization is created but not saved. - <code>str</code> or <code>Path</code>: Specifies file path (default: 'flow_system.html').</p> <code>'flow_system.html'</code> <code>controls</code> <code>bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]</code> <p>UI controls to add to the visualization. - <code>True</code>: Enables all available controls. - <code>List</code>: Specify controls, e.g., ['nodes', 'layout']. - Options: 'nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer'.</p> <code>True</code> <code>show</code> <code>bool | None</code> <p>Whether to open the visualization in the web browser.</p> <code>None</code> <p>Returns: - 'pyvis.network.Network' | None: The <code>Network</code> instance representing the visualization, or <code>None</code> if <code>pyvis</code> is not installed.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; flow_system.plot_network()\n&gt;&gt;&gt; flow_system.plot_network(show=False)\n&gt;&gt;&gt; flow_system.plot_network(path='output/custom_network.html', controls=['nodes', 'layout'])\n</code></pre> <p>Notes: - This function requires <code>pyvis</code>. If not installed, the function prints a warning and returns <code>None</code>. - Nodes are styled based on type (e.g., circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.start_network_app","title":"start_network_app","text":"Python<pre><code>start_network_app()\n</code></pre> <p>Visualizes the network structure of a FlowSystem using Dash, Cytoscape, and networkx. Requires optional dependencies: dash, dash-cytoscape, dash-daq, networkx, flask, werkzeug.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.stop_network_app","title":"stop_network_app","text":"Python<pre><code>stop_network_app()\n</code></pre> <p>Stop the network visualization server.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.sel","title":"sel","text":"Python<pre><code>sel(time: str | slice | list[str] | Timestamp | DatetimeIndex | None = None, period: int | slice | list[int] | Index | None = None, scenario: str | slice | list[str] | Index | None = None) -&gt; FlowSystem\n</code></pre> <p>Select a subset of the flowsystem by the time coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>str | slice | list[str] | Timestamp | DatetimeIndex | None</code> <p>Time selection (e.g., slice('2023-01-01', '2023-12-31'), '2023-06-15', or list of times)</p> <code>None</code> <code>period</code> <code>int | slice | list[int] | Index | None</code> <p>Period selection (e.g., slice(2023, 2024), or list of periods)</p> <code>None</code> <code>scenario</code> <code>str | slice | list[str] | Index | None</code> <p>Scenario selection (e.g., slice('scenario1', 'scenario2'), or list of scenarios)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>New FlowSystem with selected data</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.isel","title":"isel","text":"Python<pre><code>isel(time: int | slice | list[int] | None = None, period: int | slice | list[int] | None = None, scenario: int | slice | list[int] | None = None) -&gt; FlowSystem\n</code></pre> <p>Select a subset of the flowsystem by integer indices.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>int | slice | list[int] | None</code> <p>Time selection by integer index (e.g., slice(0, 100), 50, or [0, 5, 10])</p> <code>None</code> <code>period</code> <code>int | slice | list[int] | None</code> <p>Period selection by integer index (e.g., slice(0, 100), 50, or [0, 5, 10])</p> <code>None</code> <code>scenario</code> <code>int | slice | list[int] | None</code> <p>Scenario selection by integer index (e.g., slice(0, 3), 50, or [0, 5, 10])</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>New FlowSystem with selected data</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.resample","title":"resample","text":"Python<pre><code>resample(time: str, method: Literal['mean', 'sum', 'max', 'min', 'first', 'last', 'std', 'var', 'median', 'count'] = 'mean', **kwargs: Any) -&gt; FlowSystem\n</code></pre> <p>Create a resampled FlowSystem by resampling data along the time dimension (like xr.Dataset.resample()). Only resamples data variables that have a time dimension.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>str</code> <p>Resampling frequency (e.g., '3h', '2D', '1M')</p> required <code>method</code> <code>Literal['mean', 'sum', 'max', 'min', 'first', 'last', 'std', 'var', 'median', 'count']</code> <p>Resampling method. Recommended: 'mean', 'first', 'last', 'max', 'min'</p> <code>'mean'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to xarray.resample()</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>New FlowSystem with resampled data</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters","title":"InvestParameters","text":"Python<pre><code>InvestParameters(fixed_size: PeriodicDataUser | None = None, minimum_size: PeriodicDataUser | None = None, maximum_size: PeriodicDataUser | None = None, mandatory: bool = False, effects_of_investment: PeriodicEffectsUser | None = None, effects_of_investment_per_size: PeriodicEffectsUser | None = None, effects_of_retirement: PeriodicEffectsUser | None = None, piecewise_effects_of_investment: PiecewiseEffects | None = None, linked_periods: PeriodicDataUser | tuple[int, int] | None = None, **kwargs)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define investment decision parameters with flexible sizing and effect modeling.</p> <p>This class models investment decisions in optimization problems, supporting both binary (invest/don't invest) and continuous sizing choices with comprehensive cost structures. It enables realistic representation of investment economics including fixed costs, scale effects, and divestment penalties.</p> Investment Decision Types <p>Binary Investments: Fixed size investments creating yes/no decisions (e.g., install a specific generator, build a particular facility)</p> <p>Continuous Sizing: Variable size investments with minimum/maximum bounds (e.g., battery capacity from 10-1000 kWh, pipeline diameter optimization)</p> Cost Modeling Approaches <ul> <li>Fixed Effects: One-time costs independent of size (permits, connections)</li> <li>Specific Effects: Linear costs proportional to size (\u20ac/kW, \u20ac/m\u00b2)</li> <li>Piecewise Effects: Non-linear relationships (bulk discounts, learning curves)</li> <li>Divestment Effects: Penalties for not investing (demolition, opportunity costs)</li> </ul> Mathematical Formulation <p>See the complete mathematical model in the documentation: InvestParameters</p> <p>Parameters:</p> Name Type Description Default <code>fixed_size</code> <code>PeriodicDataUser | None</code> <p>Creates binary decision at this exact size. None allows continuous sizing.</p> <code>None</code> <code>minimum_size</code> <code>PeriodicDataUser | None</code> <p>Lower bound for continuous sizing. Default: CONFIG.Modeling.epsilon. Ignored if fixed_size is specified.</p> <code>None</code> <code>maximum_size</code> <code>PeriodicDataUser | None</code> <p>Upper bound for continuous sizing. Default: CONFIG.Modeling.big. Ignored if fixed_size is specified.</p> <code>None</code> <code>mandatory</code> <code>bool</code> <p>Controls whether investment is required. When True, forces investment to occur (useful for mandatory upgrades or replacement decisions). When False (default), optimization can choose not to invest. With multiple periods, at least one period has to have an investment.</p> <code>False</code> <code>effects_of_investment</code> <code>PeriodicEffectsUser | None</code> <p>Fixed costs if investment is made, regardless of size. Dict: {'effect_name': value} (e.g., {'cost': 10000}).</p> <code>None</code> <code>effects_of_investment_per_size</code> <code>PeriodicEffectsUser | None</code> <p>Variable costs proportional to size (per-unit costs). Dict: {'effect_name': value/unit} (e.g., {'cost': 1200}).</p> <code>None</code> <code>piecewise_effects_of_investment</code> <code>PiecewiseEffects | None</code> <p>Non-linear costs using PiecewiseEffects. Combinable with effects_of_investment and effects_of_investment_per_size.</p> <code>None</code> <code>effects_of_retirement</code> <code>PeriodicEffectsUser | None</code> <p>Costs incurred if NOT investing (demolition, penalties). Dict: {'effect_name': value}.</p> <code>None</code> <code>linked_periods</code> <code>PeriodicDataUser | tuple[int, int] | None</code> <p>Describes which periods are linked. 1 means linked, 0 means size=0. None means no linked periods. For convenience, pass a tuple containing the first and last period (2025, 2039), linking them and those in between</p> <code>None</code> Deprecated Args <p>fix_effects: Deprecated. Use <code>effects_of_investment</code> instead.     Will be removed in version 4.0. specific_effects: Deprecated. Use <code>effects_of_investment_per_size</code> instead.     Will be removed in version 4.0. divest_effects: Deprecated. Use <code>effects_of_retirement</code> instead.     Will be removed in version 4.0. piecewise_effects: Deprecated. Use <code>piecewise_effects_of_investment</code> instead.     Will be removed in version 4.0. optional: DEPRECATED. Use <code>mandatory</code> instead. Opposite of <code>mandatory</code>.     Will be removed in version 4.0.</p> Cost Annualization Requirements <p>All cost values must be properly weighted to match the optimization model's time horizon. For long-term investments, the cost values should be annualized to the corresponding operation time (annuity).</p> <ul> <li>Use equivalent annual cost (capital cost / equipment lifetime)</li> <li>Apply appropriate discount rates for present value calculations</li> <li>Account for inflation, escalation, and financing costs</li> </ul> <p>Example: \u20ac1M equipment with 20-year life \u2192 \u20ac50k/year fixed cost</p> <p>Examples:</p> <p>Simple binary investment (solar panels):</p> Python<pre><code>solar_investment = InvestParameters(\n    fixed_size=100,  # 100 kW system (binary decision)\n    mandatory=False,  # Investment is optional\n    effects_of_investment={\n        'cost': 25000,  # Installation and permitting costs\n        'CO2': -50000,  # Avoided emissions over lifetime\n    },\n    effects_of_investment_per_size={\n        'cost': 1200,  # \u20ac1200/kW for panels (annualized)\n        'CO2': -800,  # kg CO2 avoided per kW annually\n    },\n)\n</code></pre> <p>Flexible sizing with economies of scale:</p> Python<pre><code>battery_investment = InvestParameters(\n    minimum_size=10,  # Minimum viable system size (kWh)\n    maximum_size=1000,  # Maximum installable capacity\n    mandatory=False,  # Investment is optional\n    effects_of_investment={\n        'cost': 5000,  # Grid connection and control system\n        'installation_time': 2,  # Days for fixed components\n    },\n    piecewise_effects_of_investment=PiecewiseEffects(\n        piecewise_origin=Piecewise(\n            [\n                Piece(0, 100),  # Small systems\n                Piece(100, 500),  # Medium systems\n                Piece(500, 1000),  # Large systems\n            ]\n        ),\n        piecewise_shares={\n            'cost': Piecewise(\n                [\n                    Piece(800, 750),  # High cost/kWh for small systems\n                    Piece(750, 600),  # Medium cost/kWh\n                    Piece(600, 500),  # Bulk discount for large systems\n                ]\n            )\n        },\n    ),\n)\n</code></pre> <p>Mandatory replacement with retirement costs:</p> Python<pre><code>boiler_replacement = InvestParameters(\n    minimum_size=50,\n    maximum_size=200,\n    mandatory=False,  # Can choose not to replace\n    effects_of_investment={\n        'cost': 15000,  # Installation costs\n        'disruption': 3,  # Days of downtime\n    },\n    effects_of_investment_per_size={\n        'cost': 400,  # \u20ac400/kW capacity\n        'maintenance': 25,  # Annual maintenance per kW\n    },\n    effects_of_retirement={\n        'cost': 8000,  # Demolition if not replaced\n        'environmental': 100,  # Disposal fees\n    },\n)\n</code></pre> <p>Multi-technology comparison:</p> Python<pre><code># Gas turbine option\ngas_turbine = InvestParameters(\n    fixed_size=50,  # MW\n    effects_of_investment={'cost': 2500000, 'CO2': 1250000},\n    effects_of_investment_per_size={'fuel_cost': 45, 'maintenance': 12},\n)\n\n# Wind farm option\nwind_farm = InvestParameters(\n    minimum_size=20,\n    maximum_size=100,\n    effects_of_investment={'cost': 1000000, 'CO2': -5000000},\n    effects_of_investment_per_size={'cost': 1800000, 'land_use': 0.5},\n)\n</code></pre> <p>Technology learning curve:</p> Python<pre><code>hydrogen_electrolyzer = InvestParameters(\n    minimum_size=1,\n    maximum_size=50,  # MW\n    piecewise_effects_of_investment=PiecewiseEffects(\n        piecewise_origin=Piecewise(\n            [\n                Piece(0, 5),  # Small scale: early adoption\n                Piece(5, 20),  # Medium scale: cost reduction\n                Piece(20, 50),  # Large scale: mature technology\n            ]\n        ),\n        piecewise_shares={\n            'capex': Piecewise(\n                [\n                    Piece(2000, 1800),  # Learning reduces costs\n                    Piece(1800, 1400),  # Continued cost reduction\n                    Piece(1400, 1200),  # Technology maturity\n                ]\n            ),\n            'efficiency': Piecewise(\n                [\n                    Piece(65, 68),  # Improving efficiency\n                    Piece(68, 72),  # with scale and experience\n                    Piece(72, 75),  # Best efficiency at scale\n                ]\n            ),\n        },\n    ),\n)\n</code></pre> Common Use Cases <ul> <li>Power generation: Plant sizing, technology selection, retrofit decisions</li> <li>Industrial equipment: Capacity expansion, efficiency upgrades, replacements</li> <li>Infrastructure: Network expansion, facility construction, system upgrades</li> <li>Energy storage: Battery sizing, pumped hydro, compressed air systems</li> <li>Transportation: Fleet expansion, charging infrastructure, modal shifts</li> <li>Buildings: HVAC systems, insulation upgrades, renewable integration</li> </ul>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters-attributes","title":"Attributes","text":""},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.optional","title":"optional  <code>property</code> <code>writable</code>","text":"Python<pre><code>optional: bool\n</code></pre> <p>DEPRECATED: Use 'mandatory' property instead. Returns the opposite of 'mandatory'.</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.fix_effects","title":"fix_effects  <code>property</code>","text":"Python<pre><code>fix_effects: PeriodicEffectsUser\n</code></pre> <p>Deprecated property. Use effects_of_investment instead.</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.specific_effects","title":"specific_effects  <code>property</code>","text":"Python<pre><code>specific_effects: PeriodicEffectsUser\n</code></pre> <p>Deprecated property. Use effects_of_investment_per_size instead.</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.divest_effects","title":"divest_effects  <code>property</code>","text":"Python<pre><code>divest_effects: PeriodicEffectsUser\n</code></pre> <p>Deprecated property. Use effects_of_retirement instead.</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.piecewise_effects","title":"piecewise_effects  <code>property</code>","text":"Python<pre><code>piecewise_effects: PiecewiseEffects | None\n</code></pre> <p>Deprecated property. Use piecewise_effects_of_investment instead.</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters","title":"OnOffParameters","text":"Python<pre><code>OnOffParameters(effects_per_switch_on: TemporalEffectsUser | None = None, effects_per_running_hour: TemporalEffectsUser | None = None, on_hours_total_min: int | None = None, on_hours_total_max: int | None = None, consecutive_on_hours_min: TemporalDataUser | None = None, consecutive_on_hours_max: TemporalDataUser | None = None, consecutive_off_hours_min: TemporalDataUser | None = None, consecutive_off_hours_max: TemporalDataUser | None = None, switch_on_total_max: int | None = None, force_switch_on: bool = False)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define operational constraints and effects for binary on/off equipment behavior.</p> <p>This class models equipment that operates in discrete states (on/off) rather than continuous operation, capturing realistic operational constraints and associated costs. It handles complex equipment behavior including startup costs, minimum run times, cycling limitations, and maintenance scheduling requirements.</p> Key Modeling Capabilities <p>Switching Costs: One-time costs for starting equipment (fuel, wear, labor) Runtime Constraints: Minimum and maximum continuous operation periods Cycling Limits: Maximum number of starts to prevent excessive wear Operating Hours: Total runtime limits and requirements over time horizon</p> Typical Equipment Applications <ul> <li>Power Plants: Combined cycle units, steam turbines with startup costs</li> <li>Industrial Processes: Batch reactors, furnaces with thermal cycling</li> <li>HVAC Systems: Chillers, boilers with minimum run times</li> <li>Backup Equipment: Emergency generators, standby systems</li> <li>Process Equipment: Compressors, pumps with operational constraints</li> </ul> Mathematical Formulation <p>See the complete mathematical model in the documentation: OnOffParameters</p> <p>Parameters:</p> Name Type Description Default <code>effects_per_switch_on</code> <code>TemporalEffectsUser | None</code> <p>Costs or impacts incurred for each transition from off state (var_on=0) to on state (var_on=1). Represents startup costs, wear and tear, or other switching impacts. Dictionary mapping effect names to values (e.g., {'cost': 500, 'maintenance_hours': 2}).</p> <code>None</code> <code>effects_per_running_hour</code> <code>TemporalEffectsUser | None</code> <p>Ongoing costs or impacts while equipment operates in the on state. Includes fuel costs, labor, consumables, or emissions. Dictionary mapping effect names to hourly values (e.g., {'fuel_cost': 45}).</p> <code>None</code> <code>on_hours_total_min</code> <code>int | None</code> <p>Minimum total operating hours across the entire time horizon. Ensures equipment meets minimum utilization requirements or contractual obligations (e.g., power purchase agreements, maintenance schedules).</p> <code>None</code> <code>on_hours_total_max</code> <code>int | None</code> <p>Maximum total operating hours across the entire time horizon. Limits equipment usage due to maintenance schedules, fuel availability, environmental permits, or equipment lifetime constraints.</p> <code>None</code> <code>consecutive_on_hours_min</code> <code>TemporalDataUser | None</code> <p>Minimum continuous operating duration once started. Models minimum run times due to thermal constraints, process stability, or efficiency considerations. Can be time-varying to reflect different constraints across the planning horizon.</p> <code>None</code> <code>consecutive_on_hours_max</code> <code>TemporalDataUser | None</code> <p>Maximum continuous operating duration in one campaign. Models mandatory maintenance intervals, process batch sizes, or equipment thermal limits requiring periodic shutdowns.</p> <code>None</code> <code>consecutive_off_hours_min</code> <code>TemporalDataUser | None</code> <p>Minimum continuous shutdown duration between operations. Models cooling periods, maintenance requirements, or process constraints that prevent immediate restart after shutdown.</p> <code>None</code> <code>consecutive_off_hours_max</code> <code>TemporalDataUser | None</code> <p>Maximum continuous shutdown duration before mandatory restart. Models equipment preservation, process stability, or contractual requirements for minimum activity levels.</p> <code>None</code> <code>switch_on_total_max</code> <code>int | None</code> <p>Maximum number of startup operations across the time horizon. Limits equipment cycling to reduce wear, maintenance costs, or comply with operational constraints (e.g., grid stability requirements).</p> <code>None</code> <code>force_switch_on</code> <code>bool</code> <p>When True, creates switch-on variables even without explicit switch_on_total_max constraint. Useful for tracking or reporting startup events without enforcing limits.</p> <code>False</code> Note <p>Time Series Boundary Handling: The final time period constraints for consecutive_on_hours_min/max and consecutive_off_hours_min/max are not enforced, allowing the optimization to end with ongoing campaigns that may be shorter than the specified minimums or longer than maximums.</p> <p>Examples:</p> <p>Combined cycle power plant with startup costs and minimum run time:</p> Python<pre><code>power_plant_operation = OnOffParameters(\n    effects_per_switch_on={\n        'startup_cost': 25000,  # \u20ac25,000 per startup\n        'startup_fuel': 150,  # GJ natural gas for startup\n        'startup_time': 4,  # Hours to reach full output\n        'maintenance_impact': 0.1,  # Fractional life consumption\n    },\n    effects_per_running_hour={\n        'fixed_om': 125,  # Fixed O&amp;M costs while running\n        'auxiliary_power': 2.5,  # MW parasitic loads\n    },\n    consecutive_on_hours_min=8,  # Minimum 8-hour run once started\n    consecutive_off_hours_min=4,  # Minimum 4-hour cooling period\n    on_hours_total_max=6000,  # Annual operating limit\n)\n</code></pre> <p>Industrial batch process with cycling limits:</p> Python<pre><code>batch_reactor = OnOffParameters(\n    effects_per_switch_on={\n        'setup_cost': 1500,  # Labor and materials for startup\n        'catalyst_consumption': 5,  # kg catalyst per batch\n        'cleaning_chemicals': 200,  # L cleaning solution\n    },\n    effects_per_running_hour={\n        'steam': 2.5,  # t/h process steam\n        'electricity': 150,  # kWh electrical load\n        'cooling_water': 50,  # m\u00b3/h cooling water\n    },\n    consecutive_on_hours_min=12,  # Minimum batch size (12 hours)\n    consecutive_on_hours_max=24,  # Maximum batch size (24 hours)\n    consecutive_off_hours_min=6,  # Cleaning and setup time\n    switch_on_total_max=200,  # Maximum 200 batches per period\n    on_hours_total_max=4000,  # Maximum production time\n)\n</code></pre> <p>HVAC system with thermostat control and maintenance:</p> Python<pre><code>hvac_operation = OnOffParameters(\n    effects_per_switch_on={\n        'compressor_wear': 0.5,  # Hours of compressor life per start\n        'inrush_current': 15,  # kW peak demand on startup\n    },\n    effects_per_running_hour={\n        'electricity': 25,  # kW electrical consumption\n        'maintenance': 0.12,  # \u20ac/hour maintenance reserve\n    },\n    consecutive_on_hours_min=1,  # Minimum 1-hour run to avoid cycling\n    consecutive_off_hours_min=0.5,  # 30-minute minimum off time\n    switch_on_total_max=2000,  # Limit cycling for compressor life\n    on_hours_total_min=2000,  # Minimum operation for humidity control\n    on_hours_total_max=5000,  # Maximum operation for energy budget\n)\n</code></pre> <p>Backup generator with testing and maintenance requirements:</p> Python<pre><code>backup_generator = OnOffParameters(\n    effects_per_switch_on={\n        'fuel_priming': 50,  # L diesel for system priming\n        'wear_factor': 1.0,  # Start cycles impact on maintenance\n        'testing_labor': 2,  # Hours technician time per test\n    },\n    effects_per_running_hour={\n        'fuel_consumption': 180,  # L/h diesel consumption\n        'emissions_permit': 15,  # \u20ac emissions allowance cost\n        'noise_penalty': 25,  # \u20ac noise compliance cost\n    },\n    consecutive_on_hours_min=0.5,  # Minimum test duration (30 min)\n    consecutive_off_hours_max=720,  # Maximum 30 days between tests\n    switch_on_total_max=52,  # Weekly testing limit\n    on_hours_total_min=26,  # Minimum annual testing (0.5h \u00d7 52)\n    on_hours_total_max=200,  # Maximum runtime (emergencies + tests)\n)\n</code></pre> <p>Peak shaving battery with cycling degradation:</p> Python<pre><code>battery_cycling = OnOffParameters(\n    effects_per_switch_on={\n        'cycle_degradation': 0.01,  # % capacity loss per cycle\n        'inverter_startup': 0.5,  # kWh losses during startup\n    },\n    effects_per_running_hour={\n        'standby_losses': 2,  # kW standby consumption\n        'cooling': 5,  # kW thermal management\n        'inverter_losses': 8,  # kW conversion losses\n    },\n    consecutive_on_hours_min=1,  # Minimum discharge duration\n    consecutive_on_hours_max=4,  # Maximum continuous discharge\n    consecutive_off_hours_min=1,  # Minimum rest between cycles\n    switch_on_total_max=365,  # Daily cycling limit\n    force_switch_on=True,  # Track all cycling events\n)\n</code></pre> Common Use Cases <ul> <li>Power generation: Thermal plant cycling, renewable curtailment, grid services</li> <li>Industrial processes: Batch production, maintenance scheduling, equipment rotation</li> <li>Buildings: HVAC control, lighting systems, elevator operations</li> <li>Transportation: Fleet management, charging infrastructure, maintenance windows</li> <li>Storage systems: Battery cycling, pumped hydro, compressed air systems</li> <li>Emergency equipment: Backup generators, safety systems, emergency lighting</li> </ul>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters-attributes","title":"Attributes","text":""},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.use_off","title":"use_off  <code>property</code>","text":"Python<pre><code>use_off: bool\n</code></pre> <p>Proxy: whether OFF variable is required</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.use_consecutive_on_hours","title":"use_consecutive_on_hours  <code>property</code>","text":"Python<pre><code>use_consecutive_on_hours: bool\n</code></pre> <p>Determines whether a Variable for consecutive on hours is needed or not</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.use_consecutive_off_hours","title":"use_consecutive_off_hours  <code>property</code>","text":"Python<pre><code>use_consecutive_off_hours: bool\n</code></pre> <p>Determines whether a Variable for consecutive off hours is needed or not</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.use_switch_on","title":"use_switch_on  <code>property</code>","text":"Python<pre><code>use_switch_on: bool\n</code></pre> <p>Determines whether a variable for switch_on is needed or not</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.Piece","title":"Piece","text":"Python<pre><code>Piece(start: TemporalDataUser, end: TemporalDataUser)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a single linear segment with specified domain boundaries.</p> <p>This class represents one linear segment that will be combined with other pieces to form complete piecewise linear functions. Each piece defines a domain interval [start, end] where a linear relationship applies.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>TemporalDataUser</code> <p>Lower bound of the domain interval for this linear segment. Can be scalar values or time series arrays for time-varying boundaries.</p> required <code>end</code> <code>TemporalDataUser</code> <p>Upper bound of the domain interval for this linear segment. Can be scalar values or time series arrays for time-varying boundaries.</p> required <p>Examples:</p> <p>Basic piece for equipment efficiency curve:</p> Python<pre><code># Single segment from 40% to 80% load\nefficiency_segment = Piece(start=40, end=80)\n</code></pre> <p>Piece with time-varying boundaries:</p> Python<pre><code># Capacity limits that change seasonally\nseasonal_piece = Piece(\n    start=np.array([10, 20, 30, 25]),  # Minimum capacity by season\n    end=np.array([80, 100, 90, 70]),  # Maximum capacity by season\n)\n</code></pre> <p>Fixed operating point (start equals end):</p> Python<pre><code># Equipment that operates at exactly 50 MW\nfixed_output = Piece(start=50, end=50)\n</code></pre> Note <p>Individual pieces are building blocks that gain meaning when combined into Piecewise functions. See the Piecewise class for information about how pieces interact and relate to each other.</p>"},{"location":"api-reference/commons/#flixopt.commons.Piece-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Piece.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.Piece.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Piece.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.Piece.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.Piece.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.Piece.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Piece.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.Piecewise","title":"Piecewise","text":"Python<pre><code>Piecewise(pieces: list[Piece])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a Piecewise, consisting of a list of Pieces.</p> <p>Parameters:</p> Name Type Description Default <code>pieces</code> <code>list[Piece]</code> <p>list of Piece objects defining the linear segments. The arrangement and relationships between pieces determine the function behavior: - Touching pieces (end of one = start of next) ensure continuity - Gaps between pieces create forbidden regions - Overlapping pieces provide an extra choice for the optimizer</p> required Piece Relationship Patterns <p>Touching Pieces (Continuous Function): Pieces that share boundary points create smooth, continuous functions without gaps or overlaps.</p> <p>Gaps Between Pieces (Forbidden Regions): Non-contiguous pieces with gaps represent forbidden regions. For example minimum load requirements or safety zones.</p> <p>Overlapping Pieces (Flexible Operation): Pieces with overlapping domains provide optimization flexibility, allowing the solver to choose which segment to operate in.</p> <p>Examples:</p> <p>Continuous efficiency curve (touching pieces):</p> Python<pre><code>efficiency_curve = Piecewise(\n    [\n        Piece(start=0, end=25),  # Low load: 0-25 MW\n        Piece(start=25, end=75),  # Medium load: 25-75 MW (touches at 25)\n        Piece(start=75, end=100),  # High load: 75-100 MW (touches at 75)\n    ]\n)\n</code></pre> <p>Equipment with forbidden operating range (gap):</p> Python<pre><code>turbine_operation = Piecewise(\n    [\n        Piece(start=0, end=0),  # Off state (point operation)\n        Piece(start=40, end=100),  # Operating range (gap: 0-40 forbidden)\n    ]\n)\n</code></pre> <p>Flexible operation with overlapping options:</p> Python<pre><code>flexible_operation = Piecewise(\n    [\n        Piece(start=20, end=60),  # Standard efficiency mode\n        Piece(start=50, end=90),  # High efficiency mode (overlap: 50-60)\n    ]\n)\n</code></pre> <p>Tiered pricing structure:</p> Python<pre><code>electricity_pricing = Piecewise(\n    [\n        Piece(start=0, end=100),  # Tier 1: 0-100 kWh\n        Piece(start=100, end=500),  # Tier 2: 100-500 kWh\n        Piece(start=500, end=1000),  # Tier 3: 500-1000 kWh\n    ]\n)\n</code></pre> <p>Seasonal capacity variation:</p> Python<pre><code>seasonal_capacity = Piecewise(\n    [\n        Piece(start=[10, 15, 20, 12], end=[80, 90, 85, 75]),  # Varies by time\n    ]\n)\n</code></pre> Container Operations <p>The Piecewise class supports standard Python container operations:</p> Python<pre><code>piecewise = Piecewise([piece1, piece2, piece3])\n\nlen(piecewise)  # Returns number of pieces (3)\npiecewise[0]  # Access first piece\nfor piece in piecewise:  # Iterate over all pieces\n    print(piece.start, piece.end)\n</code></pre> Validation Considerations <ul> <li>Pieces are typically ordered by their start values</li> <li>Check for unintended gaps that might create infeasible regions</li> <li>Consider whether overlaps provide desired flexibility or create ambiguity</li> <li>Ensure time-varying pieces have consistent dimensions</li> </ul> Common Use Cases <ul> <li>Power plants: Heat rate curves, efficiency vs load, emissions profiles</li> <li>HVAC systems: COP vs temperature, capacity vs conditions</li> <li>Industrial processes: Conversion rates vs throughput, quality vs speed</li> <li>Financial modeling: Tiered rates, progressive taxes, bulk discounts</li> <li>Transportation: Fuel efficiency curves, capacity vs speed</li> <li>Storage systems: Efficiency vs state of charge, power vs energy</li> <li>Renewable energy: Output vs weather conditions, curtailment strategies</li> </ul>"},{"location":"api-reference/commons/#flixopt.commons.Piecewise-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Piecewise.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.Piecewise.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Piecewise.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.Piecewise.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.Piecewise.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.Piecewise.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.Piecewise.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion","title":"PiecewiseConversion","text":"Python<pre><code>PiecewiseConversion(piecewises: dict[str, Piecewise])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define coordinated piecewise linear relationships between multiple flows.</p> <p>This class models conversion processes where multiple flows (inputs, outputs, auxiliaries) have synchronized piecewise relationships. All flows change together based on the same operating point, enabling accurate modeling of complex equipment with variable performance characteristics.</p> Multi-Flow Coordination <p>All piecewise functions must have matching piece structures (same number of pieces with compatible domains) to ensure synchronized operation. When the equipment operates at a given point, ALL flows scale proportionally within their respective pieces.</p> Mathematical Formulation <p>See the complete mathematical model in the documentation: Piecewise</p> <p>Parameters:</p> Name Type Description Default <code>piecewises</code> <code>dict[str, Piecewise]</code> <p>Dictionary mapping flow labels to their Piecewise functions. Keys are flow identifiers (e.g., 'electricity_in', 'heat_out', 'fuel_consumed'). Values are Piecewise objects that define each flow's behavior. Critical Requirement: All Piecewise objects must have the same number of pieces with compatible domains to ensure consistent operation.</p> required Operating Point Coordination <p>When equipment operates at any point within a piece, all flows scale proportionally within their corresponding pieces. This ensures realistic equipment behavior where efficiency, consumption, and production rates all change together.</p> <p>Examples:</p> <p>Heat pump with coordinated efficiency changes:</p> Python<pre><code>heat_pump_pc = PiecewiseConversion(\n    {\n        'electricity_in': Piecewise(\n            [\n                Piece(0, 10),  # Low load: 0-10 kW electricity\n                Piece(10, 25),  # High load: 10-25 kW electricity\n            ]\n        ),\n        'heat_out': Piecewise(\n            [\n                Piece(0, 35),  # Low load COP=3.5: 0-35 kW heat\n                Piece(35, 75),  # High load COP=3.0: 35-75 kW heat\n            ]\n        ),\n        'cooling_water': Piecewise(\n            [\n                Piece(0, 2.5),  # Low load: 0-2.5 m\u00b3/h cooling\n                Piece(2.5, 6),  # High load: 2.5-6 m\u00b3/h cooling\n            ]\n        ),\n    }\n)\n# At 15 kW electricity \u2192 52.5 kW heat + 3.75 m\u00b3/h cooling water\n</code></pre> <p>Combined cycle power plant with synchronized flows:</p> Python<pre><code>power_plant_pc = PiecewiseConversion(\n    {\n        'natural_gas': Piecewise(\n            [\n                Piece(150, 300),  # Part load: 150-300 MW_th fuel\n                Piece(300, 500),  # Full load: 300-500 MW_th fuel\n            ]\n        ),\n        'electricity': Piecewise(\n            [\n                Piece(60, 135),  # Part load: 60-135 MW_e (45% efficiency)\n                Piece(135, 250),  # Full load: 135-250 MW_e (50% efficiency)\n            ]\n        ),\n        'steam_export': Piecewise(\n            [\n                Piece(20, 35),  # Part load: 20-35 MW_th steam\n                Piece(35, 50),  # Full load: 35-50 MW_th steam\n            ]\n        ),\n        'co2_emissions': Piecewise(\n            [\n                Piece(30, 60),  # Part load: 30-60 t/h CO2\n                Piece(60, 100),  # Full load: 60-100 t/h CO2\n            ]\n        ),\n    }\n)\n</code></pre> <p>Chemical reactor with multiple products and waste:</p> Python<pre><code>reactor_pc = PiecewiseConversion(\n    {\n        'feedstock': Piecewise(\n            [\n                Piece(10, 50),  # Small batch: 10-50 kg/h\n                Piece(50, 200),  # Large batch: 50-200 kg/h\n            ]\n        ),\n        'product_A': Piecewise(\n            [\n                Piece(7, 35),  # Small batch: 70% yield\n                Piece(35, 140),  # Large batch: 70% yield\n            ]\n        ),\n        'product_B': Piecewise(\n            [\n                Piece(2, 10),  # Small batch: 20% yield\n                Piece(10, 45),  # Large batch: 22.5% yield (improved)\n            ]\n        ),\n        'waste_stream': Piecewise(\n            [\n                Piece(1, 5),  # Small batch: 10% waste\n                Piece(5, 15),  # Large batch: 7.5% waste (efficiency)\n            ]\n        ),\n    }\n)\n</code></pre> <p>Equipment with discrete operating modes:</p> Python<pre><code>compressor_pc = PiecewiseConversion(\n    {\n        'electricity': Piecewise(\n            [\n                Piece(0, 0),  # Off mode: no consumption\n                Piece(45, 45),  # Low mode: fixed 45 kW\n                Piece(85, 85),  # High mode: fixed 85 kW\n            ]\n        ),\n        'compressed_air': Piecewise(\n            [\n                Piece(0, 0),  # Off mode: no production\n                Piece(250, 250),  # Low mode: 250 Nm\u00b3/h\n                Piece(500, 500),  # High mode: 500 Nm\u00b3/h\n            ]\n        ),\n    }\n)\n</code></pre> <p>Equipment with forbidden operating range:</p> Python<pre><code>steam_turbine_pc = PiecewiseConversion(\n    {\n        'steam_in': Piecewise(\n            [\n                Piece(0, 100),  # Low pressure operation\n                Piece(200, 500),  # High pressure (gap: 100-200 forbidden)\n            ]\n        ),\n        'electricity_out': Piecewise(\n            [\n                Piece(0, 30),  # Low pressure: poor efficiency\n                Piece(80, 220),  # High pressure: good efficiency\n            ]\n        ),\n        'condensate_out': Piecewise(\n            [\n                Piece(0, 100),  # Low pressure condensate\n                Piece(200, 500),  # High pressure condensate\n            ]\n        ),\n    }\n)\n</code></pre> Design Patterns <p>Forbidden Ranges: Use gaps between pieces to model equipment that cannot operate in certain ranges (e.g., minimum loads, unstable regions).</p> <p>Discrete Modes: Use pieces with identical start/end values to model equipment with fixed operating points (e.g., on/off, discrete speeds).</p> <p>Efficiency Changes: Coordinate input and output pieces to reflect changing conversion efficiency across operating ranges.</p> Common Use Cases <ul> <li>Power generation: Multi-fuel plants, cogeneration systems, renewable hybrids</li> <li>HVAC systems: Heat pumps, chillers with variable COP and auxiliary loads</li> <li>Industrial processes: Multi-product reactors, separation units, heat exchangers</li> <li>Transportation: Multi-modal systems, hybrid vehicles, charging infrastructure</li> <li>Water treatment: Multi-stage processes with varying energy and chemical needs</li> <li>Energy storage: Systems with efficiency changes and auxiliary power requirements</li> </ul>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.items","title":"items","text":"Python<pre><code>items()\n</code></pre> <p>Return an iterator over (flow_label, Piecewise) pairs stored in this PiecewiseConversion.</p> <p>This is a thin convenience wrapper around the internal mapping and yields the same view as dict.items(), where each key is a flow label (str) and each value is a Piecewise.</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects","title":"PiecewiseEffects","text":"Python<pre><code>PiecewiseEffects(piecewise_origin: Piecewise, piecewise_shares: dict[str, Piecewise])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define how a single decision variable contributes to system effects with piecewise rates.</p> <p>This class models situations where a decision variable (the origin) generates different types of system effects (costs, emissions, resource consumption) at rates that change non-linearly with the variable's operating level. Unlike PiecewiseConversion which coordinates multiple flows, PiecewiseEffects focuses on how one variable impacts multiple system-wide effects.</p> <p>Key Concept - Origin vs. Effects:     - Origin: The primary decision variable (e.g., production level, capacity, size)     - Shares: The amounts which this variable contributes to different system effects</p> Relationship to PiecewiseConversion <p>PiecewiseConversion: Models synchronized relationships between multiple flow variables (e.g., fuel_in, electricity_out, emissions_out all coordinated).</p> <p>PiecewiseEffects: Models how one variable contributes to system-wide effects at variable rates (e.g., production_level \u2192 costs, emissions, resources).</p> <p>Parameters:</p> Name Type Description Default <code>piecewise_origin</code> <code>Piecewise</code> <p>Piecewise function defining the behavior of the primary decision variable. This establishes the operating domain and ranges.</p> required <code>piecewise_shares</code> <code>dict[str, Piecewise]</code> <p>Dictionary mapping effect names to their rate functions. Keys are effect identifiers (e.g., 'cost_per_unit', 'CO2_intensity'). Values are Piecewise objects defining the contribution rate per unit of the origin variable at different operating levels.</p> required Mathematical Relationship <p>For each effect: Total_Effect = Origin_Variable \u00d7 Share_Rate(Origin_Level)</p> <p>This enables modeling of: - Economies of scale (decreasing unit costs with volume) - Learning curves (improving efficiency with experience) - Threshold effects (changing rates at different scales) - Progressive pricing (increasing rates with consumption)</p> <p>Examples:</p> <p>Manufacturing with economies of scale:</p> Python<pre><code>production_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(0, 1000),  # Small scale: 0-1000 units/month\n            Piece(1000, 5000),  # Medium scale: 1000-5000 units/month\n            Piece(5000, 10000),  # Large scale: 5000-10000 units/month\n        ]\n    ),\n    piecewise_shares={\n        'unit_cost': Piecewise(\n            [\n                Piece(50, 45),  # \u20ac50-45/unit (scale benefits)\n                Piece(45, 35),  # \u20ac45-35/unit (bulk materials)\n                Piece(35, 30),  # \u20ac35-30/unit (automation benefits)\n            ]\n        ),\n        'labor_hours': Piecewise(\n            [\n                Piece(2.5, 2.0),  # 2.5-2.0 hours/unit (learning curve)\n                Piece(2.0, 1.5),  # 2.0-1.5 hours/unit (efficiency gains)\n                Piece(1.5, 1.2),  # 1.5-1.2 hours/unit (specialization)\n            ]\n        ),\n        'CO2_intensity': Piecewise(\n            [\n                Piece(15, 12),  # 15-12 kg CO2/unit (process optimization)\n                Piece(12, 9),  # 12-9 kg CO2/unit (equipment efficiency)\n                Piece(9, 7),  # 9-7 kg CO2/unit (renewable energy)\n            ]\n        ),\n    },\n)\n</code></pre> <p>Power generation with load-dependent characteristics:</p> Python<pre><code>generator_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(50, 200),  # Part load operation: 50-200 MW\n            Piece(200, 350),  # Rated operation: 200-350 MW\n            Piece(350, 400),  # Overload operation: 350-400 MW\n        ]\n    ),\n    piecewise_shares={\n        'fuel_rate': Piecewise(\n            [\n                Piece(12.0, 10.5),  # Heat rate: 12.0-10.5 GJ/MWh (part load penalty)\n                Piece(10.5, 9.8),  # Heat rate: 10.5-9.8 GJ/MWh (optimal efficiency)\n                Piece(9.8, 11.2),  # Heat rate: 9.8-11.2 GJ/MWh (overload penalty)\n            ]\n        ),\n        'maintenance_factor': Piecewise(\n            [\n                Piece(0.8, 1.0),  # Low stress operation\n                Piece(1.0, 1.0),  # Design operation\n                Piece(1.0, 1.5),  # High stress operation\n            ]\n        ),\n        'NOx_rate': Piecewise(\n            [\n                Piece(0.20, 0.15),  # NOx: 0.20-0.15 kg/MWh\n                Piece(0.15, 0.12),  # NOx: 0.15-0.12 kg/MWh (optimal combustion)\n                Piece(0.12, 0.25),  # NOx: 0.12-0.25 kg/MWh (overload penalties)\n            ]\n        ),\n    },\n)\n</code></pre> <p>Progressive utility pricing structure:</p> Python<pre><code>electricity_billing = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(0, 200),  # Basic usage: 0-200 kWh/month\n            Piece(200, 800),  # Standard usage: 200-800 kWh/month\n            Piece(800, 2000),  # High usage: 800-2000 kWh/month\n        ]\n    ),\n    piecewise_shares={\n        'energy_rate': Piecewise(\n            [\n                Piece(0.12, 0.12),  # Basic rate: \u20ac0.12/kWh\n                Piece(0.18, 0.18),  # Standard rate: \u20ac0.18/kWh\n                Piece(0.28, 0.28),  # Premium rate: \u20ac0.28/kWh\n            ]\n        ),\n        'carbon_tax': Piecewise(\n            [\n                Piece(0.02, 0.02),  # Low carbon tax: \u20ac0.02/kWh\n                Piece(0.03, 0.03),  # Medium carbon tax: \u20ac0.03/kWh\n                Piece(0.05, 0.05),  # High carbon tax: \u20ac0.05/kWh\n            ]\n        ),\n    },\n)\n</code></pre> <p>Data center with capacity-dependent efficiency:</p> Python<pre><code>datacenter_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(100, 500),  # Low utilization: 100-500 servers\n            Piece(500, 2000),  # Medium utilization: 500-2000 servers\n            Piece(2000, 5000),  # High utilization: 2000-5000 servers\n        ]\n    ),\n    piecewise_shares={\n        'power_per_server': Piecewise(\n            [\n                Piece(0.8, 0.6),  # 0.8-0.6 kW/server (inefficient cooling)\n                Piece(0.6, 0.4),  # 0.6-0.4 kW/server (optimal efficiency)\n                Piece(0.4, 0.5),  # 0.4-0.5 kW/server (thermal limits)\n            ]\n        ),\n        'cooling_overhead': Piecewise(\n            [\n                Piece(0.4, 0.3),  # 40%-30% cooling overhead\n                Piece(0.3, 0.2),  # 30%-20% cooling overhead\n                Piece(0.2, 0.25),  # 20%-25% cooling overhead\n            ]\n        ),\n    },\n)\n</code></pre> Design Patterns <p>Economies of Scale: Decreasing unit costs/impacts with increased scale Learning Curves: Improving efficiency rates with experience/volume Threshold Effects: Step changes in rates at specific operating levels Progressive Pricing: Increasing rates for higher consumption levels Capacity Utilization: Optimal efficiency at design points, penalties at extremes</p> Common Use Cases <ul> <li>Manufacturing: Production scaling, learning effects, quality improvements</li> <li>Energy systems: Generator efficiency curves, renewable capacity factors</li> <li>Logistics: Transportation rates, warehouse utilization, delivery optimization</li> <li>Utilities: Progressive pricing, infrastructure cost allocation</li> <li>Financial services: Risk premiums, transaction fees, volume discounts</li> <li>Environmental modeling: Pollution intensity, resource consumption rates</li> </ul>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/commons/#flixopt.commons-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.change_logging_level","title":"change_logging_level","text":"Python<pre><code>change_logging_level(level_name: Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'])\n</code></pre> <p>Change the logging level for the flixopt logger and all its handlers.</p> <p>.. deprecated:: 2.1.11     Use <code>CONFIG.Logging.level = level_name</code> and <code>CONFIG.apply()</code> instead.     This function will be removed in version 3.0.0.</p> <p>Parameters:</p> Name Type Description Default <code>level_name</code> <code>Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']</code> <p>The logging level to set.</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; change_logging_level('DEBUG')  # deprecated\n&gt;&gt;&gt; # Use this instead:\n&gt;&gt;&gt; CONFIG.Logging.level = 'DEBUG'\n&gt;&gt;&gt; CONFIG.apply()\n</code></pre>"},{"location":"api-reference/components/","title":"Components","text":""},{"location":"api-reference/components/#flixopt.components","title":"flixopt.components","text":"<p>This module contains the basic components of the flixopt framework.</p>"},{"location":"api-reference/components/#flixopt.components-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components-classes","title":"Classes","text":""},{"location":"api-reference/components/#flixopt.components.LinearConverter","title":"LinearConverter","text":"Python<pre><code>LinearConverter(label: str, inputs: list[Flow], outputs: list[Flow], on_off_parameters: OnOffParameters | None = None, conversion_factors: list[dict[str, TemporalDataUser]] | None = None, piecewise_conversion: PiecewiseConversion | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Converts input-Flows into output-Flows via linear conversion factors.</p> <p>LinearConverter models equipment that transforms one or more input flows into one or more output flows through linear relationships. This includes heat exchangers, electrical converters, chemical reactors, and other equipment where the relationship between inputs and outputs can be expressed as linear equations.</p> <p>The component supports two modeling approaches: simple conversion factors for straightforward linear relationships, or piecewise conversion for complex non-linear behavior approximated through piecewise linear segments.</p> Mathematical Formulation <p>See the complete mathematical model in the documentation: LinearConverter</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow]</code> <p>list of input Flows that feed into the converter.</p> required <code>outputs</code> <code>list[Flow]</code> <p>list of output Flows that are produced by the converter.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Information about on and off state of LinearConverter. Component is On/Off if all connected Flows are On/Off. This induces an On-Variable (binary) in all Flows! If possible, use OnOffParameters in a single Flow instead to keep the number of binary variables low.</p> <code>None</code> <code>conversion_factors</code> <code>list[dict[str, TemporalDataUser]] | None</code> <p>Linear relationships between flows expressed as a list of dictionaries. Each dictionary maps flow labels to their coefficients in one linear equation. The number of conversion factors must be less than the total number of flows to ensure degrees of freedom &gt; 0. Either 'conversion_factors' OR 'piecewise_conversion' can be used, but not both. For examples also look into the linear_converters.py file.</p> <code>None</code> <code>piecewise_conversion</code> <code>PiecewiseConversion | None</code> <p>Define piecewise linear relationships between flow rates of different flows. Enables modeling of non-linear conversion behavior through linear approximation. Either 'conversion_factors' or 'piecewise_conversion' can be used, but not both.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally, but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Simple 1:1 heat exchanger with 95% efficiency:</p> Python<pre><code>heat_exchanger = LinearConverter(\n    label='primary_hx',\n    inputs=[hot_water_in],\n    outputs=[hot_water_out],\n    conversion_factors=[{'hot_water_in': 0.95, 'hot_water_out': 1}],\n)\n</code></pre> <p>Multi-input heat pump with COP=3:</p> Python<pre><code>heat_pump = LinearConverter(\n    label='air_source_hp',\n    inputs=[electricity_in],\n    outputs=[heat_output],\n    conversion_factors=[{'electricity_in': 3, 'heat_output': 1}],\n)\n</code></pre> <p>Combined heat and power (CHP) unit with multiple outputs:</p> Python<pre><code>chp_unit = LinearConverter(\n    label='gas_chp',\n    inputs=[natural_gas],\n    outputs=[electricity_out, heat_out],\n    conversion_factors=[\n        {'natural_gas': 0.35, 'electricity_out': 1},\n        {'natural_gas': 0.45, 'heat_out': 1},\n    ],\n)\n</code></pre> <p>Electrolyzer with multiple conversion relationships:</p> Python<pre><code>electrolyzer = LinearConverter(\n    label='pem_electrolyzer',\n    inputs=[electricity_in, water_in],\n    outputs=[hydrogen_out, oxygen_out],\n    conversion_factors=[\n        {'electricity_in': 1, 'hydrogen_out': 50},  # 50 kWh/kg H2\n        {'water_in': 1, 'hydrogen_out': 9},  # 9 kg H2O/kg H2\n        {'hydrogen_out': 8, 'oxygen_out': 1},  # Mass balance\n    ],\n)\n</code></pre> <p>Complex converter with piecewise efficiency:</p> Python<pre><code>variable_efficiency_converter = LinearConverter(\n    label='variable_converter',\n    inputs=[fuel_in],\n    outputs=[power_out],\n    piecewise_conversion=PiecewiseConversion(\n        {\n            'fuel_in': Piecewise(\n                [\n                    Piece(0, 10),  # Low load operation\n                    Piece(10, 25),  # High load operation\n                ]\n            ),\n            'power_out': Piecewise(\n                [\n                    Piece(0, 3.5),  # Lower efficiency at part load\n                    Piece(3.5, 10),  # Higher efficiency at full load\n                ]\n            ),\n        }\n    ),\n)\n</code></pre> Note <p>Conversion factors define linear relationships where the sum of (coefficient \u00d7 flow_rate) equals zero for each equation: factor1\u00d7flow1 + factor2\u00d7flow2 + ... = 0 Conversion factors define linear relationships: <code>{flow1: a1, flow2: a2, ...}</code> yields <code>a1\u00d7flow_rate1 + a2\u00d7flow_rate2 + ... = 0</code>. Note: The input format may be unintuitive. For example, <code>{\"electricity\": 1, \"H2\": 50}</code> implies <code>1\u00d7electricity = 50\u00d7H2</code>, i.e., 50 units of electricity produce 1 unit of H2.</p> <p>The system must have fewer conversion factors than total flows (degrees of freedom &gt; 0) to avoid over-constraining the problem. For n total flows, use at most n-1 conversion factors.</p> <p>When using piecewise_conversion, the converter operates on one piece at a time, with binary variables determining which piece is active.</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.LinearConverter.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/components/#flixopt.components.Storage","title":"Storage","text":"Python<pre><code>Storage(label: str, charging: Flow, discharging: Flow, capacity_in_flow_hours: PeriodicDataUser | InvestParameters, relative_minimum_charge_state: TemporalDataUser = 0, relative_maximum_charge_state: TemporalDataUser = 1, initial_charge_state: PeriodicDataUser | Literal['lastValueOfSim'] = 0, minimal_final_charge_state: PeriodicDataUser | None = None, maximal_final_charge_state: PeriodicDataUser | None = None, relative_minimum_final_charge_state: PeriodicDataUser | None = None, relative_maximum_final_charge_state: PeriodicDataUser | None = None, eta_charge: TemporalDataUser = 1, eta_discharge: TemporalDataUser = 1, relative_loss_per_hour: TemporalDataUser = 0, prevent_simultaneous_charge_and_discharge: bool = True, balanced: bool = False, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Storage models the temporary storage and release of energy or material.</p> <p>Storages have one incoming and one outgoing Flow, each with configurable efficiency factors. They maintain a charge state variable that represents the stored amount, bounded by capacity limits and evolving over time based on charging, discharging, and self-discharge losses.</p> <p>The storage model handles complex temporal dynamics including initial conditions, final state constraints, and time-varying parameters. It supports both fixed-size and investment-optimized storage systems with comprehensive techno-economic modeling.</p> Mathematical Formulation <p>See the complete mathematical model in the documentation: Storage</p> <ul> <li>Equation (1): Charge state bounds</li> <li>Equation (3): Storage balance (charge state evolution)</li> </ul> <p>Variable Mapping:     - <code>capacity_in_flow_hours</code> \u2192 C (storage capacity)     - <code>charge_state</code> \u2192 c(t_i) (state of charge at time t_i)     - <code>relative_loss_per_hour</code> \u2192 \u010b_rel,loss (self-discharge rate)     - <code>eta_charge</code> \u2192 \u03b7_in (charging efficiency)     - <code>eta_discharge</code> \u2192 \u03b7_out (discharging efficiency)</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Element identifier used in the FlowSystem.</p> required <code>charging</code> <code>Flow</code> <p>Incoming flow for loading the storage.</p> required <code>discharging</code> <code>Flow</code> <p>Outgoing flow for unloading the storage.</p> required <code>capacity_in_flow_hours</code> <code>PeriodicDataUser | InvestParameters</code> <p>Storage capacity in flow-hours (kWh, m\u00b3, kg). Scalar for fixed size or InvestParameters for optimization.</p> required <code>relative_minimum_charge_state</code> <code>TemporalDataUser</code> <p>Minimum charge state (0-1). Default: 0.</p> <code>0</code> <code>relative_maximum_charge_state</code> <code>TemporalDataUser</code> <p>Maximum charge state (0-1). Default: 1.</p> <code>1</code> <code>initial_charge_state</code> <code>PeriodicDataUser | Literal['lastValueOfSim']</code> <p>Charge at start. Numeric or 'lastValueOfSim'. Default: 0.</p> <code>0</code> <code>minimal_final_charge_state</code> <code>PeriodicDataUser | None</code> <p>Minimum absolute charge required at end (optional).</p> <code>None</code> <code>maximal_final_charge_state</code> <code>PeriodicDataUser | None</code> <p>Maximum absolute charge allowed at end (optional).</p> <code>None</code> <code>relative_minimum_final_charge_state</code> <code>PeriodicDataUser | None</code> <p>Minimum relative charge at end. Defaults to last value of relative_minimum_charge_state.</p> <code>None</code> <code>relative_maximum_final_charge_state</code> <code>PeriodicDataUser | None</code> <p>Maximum relative charge at end. Defaults to last value of relative_maximum_charge_state.</p> <code>None</code> <code>eta_charge</code> <code>TemporalDataUser</code> <p>Charging efficiency (0-1). Default: 1.</p> <code>1</code> <code>eta_discharge</code> <code>TemporalDataUser</code> <p>Discharging efficiency (0-1). Default: 1.</p> <code>1</code> <code>relative_loss_per_hour</code> <code>TemporalDataUser</code> <p>Self-discharge per hour (0-0.1). Default: 0.</p> <code>0</code> <code>prevent_simultaneous_charge_and_discharge</code> <code>bool</code> <p>Prevent charging and discharging simultaneously. Adds binary variables. Default: True.</p> <code>True</code> <code>meta_data</code> <code>dict | None</code> <p>Additional information stored in results. Python native types only.</p> <code>None</code> <p>Examples:</p> <p>Battery energy storage system:</p> Python<pre><code>battery = Storage(\n    label='lithium_battery',\n    charging=battery_charge_flow,\n    discharging=battery_discharge_flow,\n    capacity_in_flow_hours=100,  # 100 kWh capacity\n    eta_charge=0.95,  # 95% charging efficiency\n    eta_discharge=0.95,  # 95% discharging efficiency\n    relative_loss_per_hour=0.001,  # 0.1% loss per hour\n    relative_minimum_charge_state=0.1,  # Never below 10% SOC\n    relative_maximum_charge_state=0.9,  # Never above 90% SOC\n)\n</code></pre> <p>Thermal storage with cycling constraints:</p> Python<pre><code>thermal_storage = Storage(\n    label='hot_water_tank',\n    charging=heat_input,\n    discharging=heat_output,\n    capacity_in_flow_hours=500,  # 500 kWh thermal capacity\n    initial_charge_state=250,  # Start half full\n    # Impact of temperature on energy capacity\n    relative_maximum_charge_state=water_temperature_spread / rated_temeprature_spread,\n    eta_charge=0.90,  # Heat exchanger losses\n    eta_discharge=0.85,  # Distribution losses\n    relative_loss_per_hour=0.02,  # 2% thermal loss per hour\n    prevent_simultaneous_charge_and_discharge=True,\n)\n</code></pre> <p>Pumped hydro storage with investment optimization:</p> Python<pre><code>pumped_hydro = Storage(\n    label='pumped_hydro',\n    charging=pump_flow,\n    discharging=turbine_flow,\n    capacity_in_flow_hours=InvestParameters(\n        minimum_size=1000,  # Minimum economic scale\n        maximum_size=10000,  # Site constraints\n        specific_effects={'cost': 150},  # \u20ac150/MWh capacity\n        fix_effects={'cost': 50_000_000},  # \u20ac50M fixed costs\n    ),\n    eta_charge=0.85,  # Pumping efficiency\n    eta_discharge=0.90,  # Turbine efficiency\n    initial_charge_state='lastValueOfSim',  # Ensuring no deficit compared to start\n    relative_loss_per_hour=0.0001,  # Minimal evaporation\n)\n</code></pre> <p>Material storage with inventory management:</p> Python<pre><code>fuel_storage = Storage(\n    label='natural_gas_storage',\n    charging=gas_injection,\n    discharging=gas_withdrawal,\n    capacity_in_flow_hours=10000,  # 10,000 m\u00b3 storage volume\n    initial_charge_state=3000,  # Start with 3,000 m\u00b3\n    minimal_final_charge_state=1000,  # Strategic reserve\n    maximal_final_charge_state=9000,  # Prevent overflow\n    eta_charge=0.98,  # Compression losses\n    eta_discharge=0.95,  # Pressure reduction losses\n    relative_loss_per_hour=0.0005,  # 0.05% leakage per hour\n    prevent_simultaneous_charge_and_discharge=False,  # Allow flow-through\n)\n</code></pre> Note <p>Mathematical formulation: See Storage for charge state evolution equations and balance constraints.</p> <p>Efficiency parameters (eta_charge, eta_discharge) are dimensionless (0-1 range). The relative_loss_per_hour represents exponential decay per hour.</p> <p>Binary variables: When prevent_simultaneous_charge_and_discharge is True, binary variables enforce mutual exclusivity, increasing solution time but preventing unrealistic simultaneous charging and discharging.</p> <p>Units: Flow rates and charge states are related by the concept of 'flow hours' (=flow_rate * time). With flow rates in kW, the charge state is therefore (usually) kWh. With flow rates in m3/h, the charge state is therefore in m3.</p>"},{"location":"api-reference/components/#flixopt.components.Storage-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Storage.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/components/#flixopt.components.Storage.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Storage.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/components/#flixopt.components.Storage.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/components/#flixopt.components.Storage.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/components/#flixopt.components.Storage.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Storage.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/components/#flixopt.components.Transmission","title":"Transmission","text":"Python<pre><code>Transmission(label: str, in1: Flow, out1: Flow, in2: Flow | None = None, out2: Flow | None = None, relative_losses: TemporalDataUser | None = None, absolute_losses: TemporalDataUser | None = None, on_off_parameters: OnOffParameters = None, prevent_simultaneous_flows_in_both_directions: bool = True, balanced: bool = False, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Models transmission infrastructure that transports flows between two locations with losses.</p> <p>Transmission components represent physical infrastructure like pipes, cables, transmission lines, or conveyor systems that transport energy or materials between two points. They can model both unidirectional and bidirectional flow with configurable loss mechanisms and operational constraints.</p> <p>The component supports complex transmission scenarios including relative losses (proportional to flow), absolute losses (fixed when active), and bidirectional operation with flow direction constraints.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>in1</code> <code>Flow</code> <p>The primary inflow (side A). Pass InvestParameters here for capacity optimization.</p> required <code>out1</code> <code>Flow</code> <p>The primary outflow (side B).</p> required <code>in2</code> <code>Flow | None</code> <p>Optional secondary inflow (side B) for bidirectional operation. If in1 has InvestParameters, in2 will automatically have matching capacity.</p> <code>None</code> <code>out2</code> <code>Flow | None</code> <p>Optional secondary outflow (side A) for bidirectional operation.</p> <code>None</code> <code>relative_losses</code> <code>TemporalDataUser | None</code> <p>Proportional losses as fraction of throughput (e.g., 0.02 for 2% loss). Applied as: output = input \u00d7 (1 - relative_losses)</p> <code>None</code> <code>absolute_losses</code> <code>TemporalDataUser | None</code> <p>Fixed losses that occur when transmission is active. Automatically creates binary variables for on/off states.</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>prevent_simultaneous_flows_in_both_directions</code> <code>bool</code> <p>If True, prevents simultaneous flow in both directions. Increases binary variables but reflects physical reality for most transmission systems. Default is True.</p> <code>True</code> <code>balanced</code> <code>bool</code> <p>Whether to equate the size of the in1 and in2 Flow. Needs InvestParameters in both Flows.</p> <code>False</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Simple electrical transmission line:</p> Python<pre><code>power_line = Transmission(\n    label='110kv_line',\n    in1=substation_a_out,\n    out1=substation_b_in,\n    relative_losses=0.03,  # 3% line losses\n)\n</code></pre> <p>Bidirectional natural gas pipeline:</p> Python<pre><code>gas_pipeline = Transmission(\n    label='interstate_pipeline',\n    in1=compressor_station_a,\n    out1=distribution_hub_b,\n    in2=compressor_station_b,\n    out2=distribution_hub_a,\n    relative_losses=0.005,  # 0.5% friction losses\n    absolute_losses=50,  # 50 kW compressor power when active\n    prevent_simultaneous_flows_in_both_directions=True,\n)\n</code></pre> <p>District heating network with investment optimization:</p> Python<pre><code>heating_network = Transmission(\n    label='dh_main_line',\n    in1=Flow(\n        label='heat_supply',\n        bus=central_plant_bus,\n        size=InvestParameters(\n            minimum_size=1000,  # Minimum 1 MW capacity\n            maximum_size=10000,  # Maximum 10 MW capacity\n            specific_effects={'cost': 200},  # \u20ac200/kW capacity\n            fix_effects={'cost': 500000},  # \u20ac500k fixed installation\n        ),\n    ),\n    out1=district_heat_demand,\n    relative_losses=0.15,  # 15% thermal losses in distribution\n)\n</code></pre> <p>Material conveyor with on/off operation:</p> Python<pre><code>conveyor_belt = Transmission(\n    label='material_transport',\n    in1=loading_station,\n    out1=unloading_station,\n    absolute_losses=25,  # 25 kW motor power when running\n    on_off_parameters=OnOffParameters(\n        effects_per_switch_on={'maintenance': 0.1},\n        consecutive_on_hours_min=2,  # Minimum 2-hour operation\n        switch_on_total_max=10,  # Maximum 10 starts per day\n    ),\n)\n</code></pre> Note <p>The transmission equation balances flows with losses: output_flow = input_flow \u00d7 (1 - relative_losses) - absolute_losses</p> <p>For bidirectional transmission, each direction has independent loss calculations.</p> <p>When using InvestParameters on in1, the capacity automatically applies to in2 to maintain consistent bidirectional capacity without additional investment variables.</p> <p>Absolute losses force the creation of binary on/off variables, which increases computational complexity but enables realistic modeling of equipment with standby power consumption.</p>"},{"location":"api-reference/components/#flixopt.components.Transmission-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Transmission.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel","title":"TransmissionModel","text":"Python<pre><code>TransmissionModel(model: FlowSystemModel, element: Transmission)\n</code></pre> <p>               Bases: <code>ComponentModel</code></p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.TransmissionModel.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.variables_direct","title":"variables_direct  <code>property</code>","text":"Python<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"Python<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.previous_states","title":"previous_states  <code>property</code>","text":"Python<pre><code>previous_states: DataArray | None\n</code></pre> <p>Previous state of the component, derived from its flows</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.TransmissionModel.create_transmission_equation","title":"create_transmission_equation","text":"Python<pre><code>create_transmission_equation(name: str, in_flow: Flow, out_flow: Flow) -&gt; linopy.Constraint\n</code></pre> <p>Creates an Equation for the Transmission efficiency and adds it to the model</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.add_variables","title":"add_variables","text":"Python<pre><code>add_variables(short_name: str = None, **kwargs) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.add_constraints","title":"add_constraints","text":"Python<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.register_variable","title":"register_variable","text":"Python<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.register_constraint","title":"register_constraint","text":"Python<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.get","title":"get","text":"Python<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel","title":"StorageModel","text":"Python<pre><code>StorageModel(model: FlowSystemModel, element: Storage)\n</code></pre> <p>               Bases: <code>ComponentModel</code></p> <p>Submodel of Storage</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.StorageModel.investment","title":"investment  <code>property</code>","text":"Python<pre><code>investment: InvestmentModel | None\n</code></pre> <p>OnOff feature</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.charge_state","title":"charge_state  <code>property</code>","text":"Python<pre><code>charge_state: Variable\n</code></pre> <p>Charge state variable</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.netto_discharge","title":"netto_discharge  <code>property</code>","text":"Python<pre><code>netto_discharge: Variable\n</code></pre> <p>Netto discharge variable</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.variables_direct","title":"variables_direct  <code>property</code>","text":"Python<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"Python<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.previous_states","title":"previous_states  <code>property</code>","text":"Python<pre><code>previous_states: DataArray | None\n</code></pre> <p>Previous state of the component, derived from its flows</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.StorageModel.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.add_variables","title":"add_variables","text":"Python<pre><code>add_variables(short_name: str = None, **kwargs) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.add_constraints","title":"add_constraints","text":"Python<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.register_variable","title":"register_variable","text":"Python<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.register_constraint","title":"register_constraint","text":"Python<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.get","title":"get","text":"Python<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink","title":"SourceAndSink","text":"Python<pre><code>SourceAndSink(label: str, inputs: list[Flow] | None = None, outputs: list[Flow] | None = None, prevent_simultaneous_flow_rates: bool = True, meta_data: dict | None = None, **kwargs)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A SourceAndSink combines both supply and demand capabilities in a single component.</p> <p>SourceAndSink components can both consume AND provide energy or material flows from and to the system, making them ideal for modeling markets, (simple) storage facilities, or bidirectional grid connections where buying and selling occur at the same location.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>Input-flows into the SourceAndSink representing consumption/demand side.</p> <code>None</code> <code>outputs</code> <code>list[Flow] | None</code> <p>Output-flows from the SourceAndSink representing supply/generation side.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, prevents simultaneous input and output flows. This enforces that the component operates either as a source OR sink at any given time, but not both simultaneously. Default is True.</p> <code>True</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Electricity market connection (buy/sell to grid):</p> Python<pre><code>electricity_market = SourceAndSink(\n    label='grid_connection',\n    inputs=[electricity_purchase],  # Buy from grid\n    outputs=[electricity_sale],  # Sell to grid\n    prevent_simultaneous_flow_rates=True,  # Can't buy and sell simultaneously\n)\n</code></pre> <p>Natural gas storage facility:</p> Python<pre><code>gas_storage_facility = SourceAndSink(\n    label='underground_gas_storage',\n    inputs=[gas_injection_flow],  # Inject gas into storage\n    outputs=[gas_withdrawal_flow],  # Withdraw gas from storage\n    prevent_simultaneous_flow_rates=True,  # Injection or withdrawal, not both\n)\n</code></pre> <p>District heating network connection:</p> Python<pre><code>dh_connection = SourceAndSink(\n    label='district_heating_tie',\n    inputs=[heat_purchase_flow],  # Purchase heat from network\n    outputs=[heat_sale_flow],  # Sell excess heat to network\n    prevent_simultaneous_flow_rates=False,  # May allow simultaneous flows\n)\n</code></pre> <p>Industrial waste heat exchange:</p> Python<pre><code>waste_heat_exchange = SourceAndSink(\n    label='industrial_heat_hub',\n    inputs=[\n        waste_heat_input_a,  # Receive waste heat from process A\n        waste_heat_input_b,  # Receive waste heat from process B\n    ],\n    outputs=[\n        useful_heat_supply_c,  # Supply heat to process C\n        useful_heat_supply_d,  # Supply heat to process D\n    ],\n    prevent_simultaneous_flow_rates=False,  # Multiple simultaneous flows allowed\n)\n</code></pre> Note <p>When prevent_simultaneous_flow_rates is True, binary variables are created to ensure mutually exclusive operation between input and output flows, which increases computational complexity but reflects realistic market or storage operation constraints.</p> <p>SourceAndSink is particularly useful for modeling: - Energy markets with bidirectional trading - Storage facilities with injection/withdrawal operations - Grid tie points with import/export capabilities - Waste exchange networks with multiple participants</p> Deprecated <p>The deprecated <code>sink</code> and <code>source</code> kwargs are accepted for compatibility but will be removed in future releases.</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.SourceAndSink.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/components/#flixopt.components.Source","title":"Source","text":"Python<pre><code>Source(label: str, outputs: list[Flow] | None = None, meta_data: dict | None = None, prevent_simultaneous_flow_rates: bool = False, **kwargs)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Source generates or provides energy or material flows into the system.</p> <p>Sources represent supply points like power plants, fuel suppliers, renewable energy sources, or any system boundary where flows originate. They provide unlimited supply capability subject to flow constraints, demand patterns and effects.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>outputs</code> <code>list[Flow] | None</code> <p>Output-flows from the source. Can be single flow or list of flows for sources providing multiple commodities or services.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, only one output flow can be active at a time. Useful for modeling mutually exclusive supply options. Default is False.</p> <code>False</code> <p>Examples:</p> <p>Simple electricity grid connection:</p> Python<pre><code>grid_source = Source(label='electrical_grid', outputs=[grid_electricity_flow])\n</code></pre> <p>Natural gas supply with cost and capacity constraints:</p> Python<pre><code>gas_supply = Source(\n    label='gas_network',\n    outputs=[\n        Flow(\n            label='natural_gas_flow',\n            bus=gas_bus,\n            size=1000,  # Maximum 1000 kW supply capacity\n            effects_per_flow_hour={'cost': 0.04},  # \u20ac0.04/kWh gas cost\n        )\n    ],\n)\n</code></pre> <p>Multi-fuel power plant with switching constraints:</p> Python<pre><code>multi_fuel_plant = Source(\n    label='flexible_generator',\n    outputs=[coal_electricity, gas_electricity, biomass_electricity],\n    prevent_simultaneous_flow_rates=True,  # Can only use one fuel at a time\n)\n</code></pre> <p>Renewable energy source with investment optimization:</p> Python<pre><code>solar_farm = Source(\n    label='solar_pv',\n    outputs=[\n        Flow(\n            label='solar_power',\n            bus=electricity_bus,\n            size=InvestParameters(\n                minimum_size=0,\n                maximum_size=50000,  # Up to 50 MW\n                specific_effects={'cost': 800},  # \u20ac800/kW installed\n                fix_effects={'cost': 100000},  # \u20ac100k development costs\n            ),\n            fixed_relative_profile=solar_profile,  # Hourly generation profile\n        )\n    ],\n)\n</code></pre> Deprecated <p>The deprecated <code>source</code> kwarg is accepted for compatibility but will be removed in future releases.</p>"},{"location":"api-reference/components/#flixopt.components.Source-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Source.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/components/#flixopt.components.Source.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Source.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/components/#flixopt.components.Source.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/components/#flixopt.components.Source.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/components/#flixopt.components.Source.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Source.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/components/#flixopt.components.Sink","title":"Sink","text":"Python<pre><code>Sink(label: str, inputs: list[Flow] | None = None, meta_data: dict | None = None, prevent_simultaneous_flow_rates: bool = False, **kwargs)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Sink consumes energy or material flows from the system.</p> <p>Sinks represent demand points like electrical loads, heat demands, material consumption, or any system boundary where flows terminate. They provide unlimited consumption capability subject to flow constraints, demand patterns and effects.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>Input-flows into the sink. Can be single flow or list of flows for sinks consuming multiple commodities or services.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, only one input flow can be active at a time. Useful for modeling mutually exclusive consumption options. Default is False.</p> <code>False</code> <p>Examples:</p> <p>Simple electrical demand:</p> Python<pre><code>electrical_load = Sink(label='building_load', inputs=[electricity_demand_flow])\n</code></pre> <p>Heat demand with time-varying profile:</p> Python<pre><code>heat_demand = Sink(\n    label='district_heating_load',\n    inputs=[\n        Flow(\n            label='heat_consumption',\n            bus=heat_bus,\n            fixed_relative_profile=hourly_heat_profile,  # Demand profile\n            size=2000,  # Peak demand of 2000 kW\n        )\n    ],\n)\n</code></pre> <p>Multi-energy building with switching capabilities:</p> Python<pre><code>flexible_building = Sink(\n    label='smart_building',\n    inputs=[electricity_heating, gas_heating, heat_pump_heating],\n    prevent_simultaneous_flow_rates=True,  # Can only use one heating mode\n)\n</code></pre> <p>Industrial process with variable demand:</p> Python<pre><code>factory_load = Sink(\n    label='manufacturing_plant',\n    inputs=[\n        Flow(\n            label='electricity_process',\n            bus=electricity_bus,\n            size=5000,  # Base electrical load\n            effects_per_flow_hour={'cost': -0.1},  # Value of service (negative cost)\n        ),\n        Flow(\n            label='steam_process',\n            bus=steam_bus,\n            size=3000,  # Process steam demand\n            fixed_relative_profile=production_schedule,\n        ),\n    ],\n)\n</code></pre> Deprecated <p>The deprecated <code>sink</code> kwarg is accepted for compatibility but will be removed in future releases.</p> <p>Initialize a Sink (consumes flow from the system).</p> <p>Supports legacy <code>sink=</code> keyword for backward compatibility (deprecated): if <code>sink</code> is provided it is used as the single input flow and a DeprecationWarning is issued; specifying both <code>inputs</code> and <code>sink</code> raises ValueError.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Unique element label.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>Input flows for the sink.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Arbitrary metadata attached to the element.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, prevents simultaneous nonzero flow rates across the element's inputs by wiring that restriction into the base Component setup.</p> <code>False</code> Note <p>The deprecated <code>sink</code> kwarg is accepted for compatibility but will be removed in future releases.</p>"},{"location":"api-reference/components/#flixopt.components.Sink-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Sink.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/components/#flixopt.components.Sink.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Sink.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/components/#flixopt.components.Sink.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/components/#flixopt.components.Sink.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/components/#flixopt.components.Sink.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Sink.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/components/#flixopt.components-functions","title":"Functions","text":""},{"location":"api-reference/config/","title":"Config","text":""},{"location":"api-reference/config/#flixopt.config","title":"flixopt.config","text":""},{"location":"api-reference/config/#flixopt.config-classes","title":"Classes","text":""},{"location":"api-reference/config/#flixopt.config.CONFIG","title":"CONFIG","text":"<p>Configuration for flixopt library.</p> <p>Always call <code>CONFIG.apply()</code> after changes.</p> <p>Attributes:</p> Name Type Description <code>Logging</code> <p>Logging configuration.</p> <code>Modeling</code> <p>Optimization modeling parameters.</p> <code>config_name</code> <code>str</code> <p>Configuration name.</p> <p>Examples:</p> Python<pre><code>CONFIG.Logging.console = True\nCONFIG.Logging.level = 'DEBUG'\nCONFIG.apply()\n</code></pre> <p>Load from YAML file:</p> YAML<pre><code>logging:\n  level: DEBUG\n  console: true\n  file: app.log\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG-classes","title":"Classes","text":""},{"location":"api-reference/config/#flixopt.config.CONFIG.Logging","title":"Logging","text":"<p>Logging configuration.</p> <p>Silent by default. Enable via <code>console=True</code> or <code>file='path'</code>.</p> <p>Attributes:</p> Name Type Description <code>level</code> <code>Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']</code> <p>Logging level.</p> <code>file</code> <code>str | None</code> <p>Log file path for file logging.</p> <code>console</code> <code>bool | Literal['stdout', 'stderr']</code> <p>Enable console output.</p> <code>rich</code> <code>bool</code> <p>Use Rich library for enhanced output.</p> <code>max_file_size</code> <code>int</code> <p>Max file size before rotation.</p> <code>backup_count</code> <code>int</code> <p>Number of backup files to keep.</p> <code>date_format</code> <code>str</code> <p>Date/time format string.</p> <code>format</code> <code>str</code> <p>Log message format string.</p> <code>console_width</code> <code>int</code> <p>Console width for Rich handler.</p> <code>show_path</code> <code>bool</code> <p>Show file paths in messages.</p> <code>show_logger_name</code> <code>bool</code> <p>Show logger name in messages.</p> <code>Colors</code> <code>bool</code> <p>ANSI color codes for log levels.</p> <p>Examples:</p> Python<pre><code># File logging with rotation\nCONFIG.Logging.file = 'app.log'\nCONFIG.Logging.max_file_size = 5_242_880  # 5MB\nCONFIG.apply()\n\n# Rich handler with stdout\nCONFIG.Logging.console = True  # or 'stdout'\nCONFIG.Logging.rich = True\nCONFIG.apply()\n\n# Console output to stderr\nCONFIG.Logging.console = 'stderr'\nCONFIG.apply()\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG.Logging-classes","title":"Classes","text":"Colors \u00b6 <p>ANSI color codes for log levels.</p> <p>Attributes:</p> Name Type Description <code>DEBUG</code> <code>str</code> <p>ANSI color for DEBUG level.</p> <code>INFO</code> <code>str</code> <p>ANSI color for INFO level.</p> <code>WARNING</code> <code>str</code> <p>ANSI color for WARNING level.</p> <code>ERROR</code> <code>str</code> <p>ANSI color for ERROR level.</p> <code>CRITICAL</code> <code>str</code> <p>ANSI color for CRITICAL level.</p> <p>Examples:</p> Python<pre><code>CONFIG.Logging.Colors.INFO = '\\033[32m'  # Green\nCONFIG.Logging.Colors.ERROR = '\\033[1m\\033[31m'  # Bold red\nCONFIG.apply()\n</code></pre> Common ANSI codes <ul> <li>'\\033[30m' - Black</li> <li>'\\033[31m' - Red</li> <li>'\\033[32m' - Green</li> <li>'\\033[33m' - Yellow</li> <li>'\\033[34m' - Blue</li> <li>'\\033[35m' - Magenta</li> <li>'\\033[36m' - Cyan</li> <li>'\\033[37m' - White</li> <li>'\\033[90m' - Bright Black/Gray</li> <li>'\\033[0m' - Reset to default</li> <li>'\\033[1m\\033[3Xm' - Bold (replace X with color code 0-7)</li> <li>'\\033[2m\\033[3Xm' - Dim (replace X with color code 0-7)</li> </ul>"},{"location":"api-reference/config/#flixopt.config.CONFIG.Modeling","title":"Modeling","text":"<p>Optimization modeling parameters.</p> <p>Attributes:</p> Name Type Description <code>big</code> <code>int</code> <p>Large number for big-M constraints.</p> <code>epsilon</code> <code>float</code> <p>Tolerance for numerical comparisons.</p> <code>big_binary_bound</code> <code>int</code> <p>Upper bound for binary constraints.</p>"},{"location":"api-reference/config/#flixopt.config.CONFIG.Plotting","title":"Plotting","text":"<p>Plotting configuration.</p> <p>Configure backends via environment variables: - Matplotlib: Set <code>MPLBACKEND</code> environment variable (e.g., 'Agg', 'TkAgg') - Plotly: Set <code>PLOTLY_RENDERER</code> or use <code>plotly.io.renderers.default</code></p> <p>Attributes:</p> Name Type Description <code>default_show</code> <code>bool</code> <p>Default value for the <code>show</code> parameter in plot methods.</p> <code>default_engine</code> <code>Literal['plotly', 'matplotlib']</code> <p>Default plotting engine.</p> <code>default_dpi</code> <code>int</code> <p>Default DPI for saved plots.</p> <code>default_facet_cols</code> <code>int</code> <p>Default number of columns for faceted plots.</p> <code>default_sequential_colorscale</code> <code>str</code> <p>Default colorscale for heatmaps and continuous data.</p> <code>default_qualitative_colorscale</code> <code>str</code> <p>Default colormap for categorical plots (bar/line/area charts).</p> <p>Examples:</p> Python<pre><code># Set consistent theming\nCONFIG.Plotting.plotly_template = 'plotly_dark'\nCONFIG.apply()\n\n# Configure default export and color settings\nCONFIG.Plotting.default_dpi = 600\nCONFIG.Plotting.default_sequential_colorscale = 'plasma'\nCONFIG.Plotting.default_qualitative_colorscale = 'Dark24'\nCONFIG.apply()\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG-functions","title":"Functions","text":""},{"location":"api-reference/config/#flixopt.config.CONFIG.reset","title":"reset  <code>classmethod</code>","text":"Python<pre><code>reset()\n</code></pre> <p>Reset all configuration values to defaults.</p>"},{"location":"api-reference/config/#flixopt.config.CONFIG.apply","title":"apply  <code>classmethod</code>","text":"Python<pre><code>apply()\n</code></pre> <p>Apply current configuration to logging system.</p>"},{"location":"api-reference/config/#flixopt.config.CONFIG.load_from_file","title":"load_from_file  <code>classmethod</code>","text":"Python<pre><code>load_from_file(config_file: str | Path)\n</code></pre> <p>Load configuration from YAML file and apply it.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str | Path</code> <p>Path to the YAML configuration file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the config file does not exist.</p>"},{"location":"api-reference/config/#flixopt.config.CONFIG.to_dict","title":"to_dict  <code>classmethod</code>","text":"Python<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the configuration class into a dictionary for JSON serialization.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the current configuration.</p>"},{"location":"api-reference/config/#flixopt.config.MultilineFormatter","title":"MultilineFormatter","text":"Python<pre><code>MultilineFormatter(fmt: str = '%(message)s', datefmt: str | None = None, show_logger_name: bool = False)\n</code></pre> <p>               Bases: <code>Formatter</code></p> <p>Formatter that handles multi-line messages with consistent prefixes.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>Log message format string.</p> <code>'%(message)s'</code> <code>datefmt</code> <code>str | None</code> <p>Date/time format string.</p> <code>None</code> <code>show_logger_name</code> <code>bool</code> <p>Show logger name in log messages.</p> <code>False</code>"},{"location":"api-reference/config/#flixopt.config.ColoredMultilineFormatter","title":"ColoredMultilineFormatter","text":"Python<pre><code>ColoredMultilineFormatter(fmt: str | None = None, datefmt: str | None = None, colors: dict[str, str] | None = None, show_logger_name: bool = False)\n</code></pre> <p>               Bases: <code>MultilineFormatter</code></p> <p>Formatter that adds ANSI colors to multi-line log messages.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str | None</code> <p>Log message format string.</p> <code>None</code> <code>datefmt</code> <code>str | None</code> <p>Date/time format string.</p> <code>None</code> <code>colors</code> <code>dict[str, str] | None</code> <p>Dictionary of ANSI color codes for each log level.</p> <code>None</code> <code>show_logger_name</code> <code>bool</code> <p>Show logger name in log messages.</p> <code>False</code>"},{"location":"api-reference/config/#flixopt.config-functions","title":"Functions","text":""},{"location":"api-reference/config/#flixopt.config.change_logging_level","title":"change_logging_level","text":"Python<pre><code>change_logging_level(level_name: Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'])\n</code></pre> <p>Change the logging level for the flixopt logger and all its handlers.</p> <p>.. deprecated:: 2.1.11     Use <code>CONFIG.Logging.level = level_name</code> and <code>CONFIG.apply()</code> instead.     This function will be removed in version 3.0.0.</p> <p>Parameters:</p> Name Type Description Default <code>level_name</code> <code>Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']</code> <p>The logging level to set.</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; change_logging_level('DEBUG')  # deprecated\n&gt;&gt;&gt; # Use this instead:\n&gt;&gt;&gt; CONFIG.Logging.level = 'DEBUG'\n&gt;&gt;&gt; CONFIG.apply()\n</code></pre>"},{"location":"api-reference/core/","title":"Core","text":""},{"location":"api-reference/core/#flixopt.core","title":"flixopt.core","text":"<p>This module contains the core functionality of the flixopt framework. It provides Datatypes, logging functionality, and some functions to transform data structures.</p>"},{"location":"api-reference/core/#flixopt.core-attributes","title":"Attributes","text":""},{"location":"api-reference/core/#flixopt.core.Scalar","title":"Scalar  <code>module-attribute</code>","text":"Python<pre><code>Scalar = int | float\n</code></pre> <p>A single number, either integer or float.</p>"},{"location":"api-reference/core/#flixopt.core.PeriodicDataUser","title":"PeriodicDataUser  <code>module-attribute</code>","text":"Python<pre><code>PeriodicDataUser = int | float | integer | floating | ndarray | Series | DataFrame | DataArray\n</code></pre> <p>User data which has no time dimension. Internally converted to a Scalar or an xr.DataArray without a time dimension.</p>"},{"location":"api-reference/core/#flixopt.core.PeriodicData","title":"PeriodicData  <code>module-attribute</code>","text":"Python<pre><code>PeriodicData = DataArray\n</code></pre> <p>Internally used datatypes for periodic data.</p>"},{"location":"api-reference/core/#flixopt.core.FlowSystemDimensions","title":"FlowSystemDimensions  <code>module-attribute</code>","text":"Python<pre><code>FlowSystemDimensions = Literal['time', 'period', 'scenario']\n</code></pre> <p>Possible dimensions of a FlowSystem.</p>"},{"location":"api-reference/core/#flixopt.core.TemporalDataUser","title":"TemporalDataUser  <code>module-attribute</code>","text":"Python<pre><code>TemporalDataUser = int | float | integer | floating | ndarray | Series | DataFrame | DataArray | TimeSeriesData\n</code></pre> <p>User data which might have a time dimension. Internally converted to an xr.DataArray with time dimension.</p>"},{"location":"api-reference/core/#flixopt.core.TemporalData","title":"TemporalData  <code>module-attribute</code>","text":"Python<pre><code>TemporalData = DataArray | TimeSeriesData\n</code></pre> <p>Internally used datatypes for temporal data (data with a time dimension).</p>"},{"location":"api-reference/core/#flixopt.core-classes","title":"Classes","text":""},{"location":"api-reference/core/#flixopt.core.PlausibilityError","title":"PlausibilityError","text":"<p>               Bases: <code>Exception</code></p> <p>Error for a failing Plausibility check.</p>"},{"location":"api-reference/core/#flixopt.core.ConversionError","title":"ConversionError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for data conversion errors.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesData","title":"TimeSeriesData","text":"Python<pre><code>TimeSeriesData(*args: Any, aggregation_group: str | None = None, aggregation_weight: float | None = None, agg_group: str | None = None, agg_weight: float | None = None, **kwargs: Any)\n</code></pre> <p>               Bases: <code>DataArray</code></p> <p>Minimal TimeSeriesData that inherits from xr.DataArray with aggregation metadata.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments passed to DataArray</p> <code>()</code> <code>aggregation_group</code> <code>str | None</code> <p>Aggregation group name</p> <code>None</code> <code>aggregation_weight</code> <code>float | None</code> <p>Aggregation weight (0-1)</p> <code>None</code> <code>agg_group</code> <code>str | None</code> <p>Deprecated, use aggregation_group instead</p> <code>None</code> <code>agg_weight</code> <code>float | None</code> <p>Deprecated, use aggregation_weight instead</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to DataArray</p> <code>{}</code>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesData-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.TimeSeriesData.fit_to_coords","title":"fit_to_coords","text":"Python<pre><code>fit_to_coords(coords: dict[str, Index], name: str | None = None) -&gt; TimeSeriesData\n</code></pre> <p>Fit the data to the given coordinates. Returns a new TimeSeriesData object if the current coords are different.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesData.from_dataarray","title":"from_dataarray  <code>classmethod</code>","text":"Python<pre><code>from_dataarray(da: DataArray, aggregation_group: str | None = None, aggregation_weight: float | None = None)\n</code></pre> <p>Create TimeSeriesData from DataArray, extracting metadata from attrs.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesData.is_timeseries_data","title":"is_timeseries_data  <code>classmethod</code>","text":"Python<pre><code>is_timeseries_data(obj) -&gt; bool\n</code></pre> <p>Check if an object is TimeSeriesData.</p>"},{"location":"api-reference/core/#flixopt.core.DataConverter","title":"DataConverter","text":"<p>Converts various data types into xarray.DataArray with specified target coordinates.</p> <p>This converter handles intelligent dimension matching and broadcasting to ensure the output DataArray always conforms to the specified coordinate structure.</p> <p>Supported input types: - Scalars: int, float, np.number (broadcast to all target dimensions) - 1D data: np.ndarray, pd.Series, single-column DataFrame (matched by length/index) - Multi-dimensional arrays: np.ndarray, DataFrame (matched by shape) - xr.DataArray: validated and potentially broadcast to target dimensions</p> <p>The converter uses smart matching strategies: - Series: matched by exact index comparison - 1D arrays: matched by length to target coordinates - Multi-dimensional arrays: matched by shape permutation analysis - DataArrays: validated for compatibility and broadcast as needed</p>"},{"location":"api-reference/core/#flixopt.core.DataConverter-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.DataConverter.to_dataarray","title":"to_dataarray  <code>classmethod</code>","text":"Python<pre><code>to_dataarray(data: int | float | bool | integer | floating | bool_ | ndarray | Series | DataFrame | DataArray, coords: dict[str, Index] | None = None) -&gt; xr.DataArray\n</code></pre> <p>Convert various data types to xarray.DataArray with specified target coordinates.</p> <p>This is the main conversion method that intelligently handles different input types and ensures the result conforms to the specified coordinate structure through smart dimension matching and broadcasting.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>int | float | bool | integer | floating | bool_ | ndarray | Series | DataFrame | DataArray</code> <p>Input data to convert. Supported types: - Scalars: int, float, bool, np.integer, np.floating, np.bool_ - Arrays: np.ndarray (1D and multi-dimensional) - Pandas: pd.Series, pd.DataFrame - xarray: xr.DataArray</p> required <code>coords</code> <code>dict[str, Index] | None</code> <p>Target coordinate specification as {dimension_name: coordinate_index}.    All coordinate indices must be pandas.Index objects.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray conforming to the target coordinate specification,</p> <code>DataArray</code> <p>with input data appropriately matched and broadcast</p> <p>Raises:</p> Type Description <code>ConversionError</code> <p>If data type is unsupported, conversion fails,            or broadcasting to target coordinates is impossible</p> <p>Examples:</p>"},{"location":"api-reference/core/#flixopt.core.DataConverter.to_dataarray--scalar-broadcasting","title":"Scalar broadcasting","text":"Python Console Session<pre><code>&gt;&gt;&gt; coords = {'x': pd.Index([1, 2, 3]), 'y': pd.Index(['a', 'b'])}\n&gt;&gt;&gt; converter.to_dataarray(42, coords)\n# Returns: DataArray with shape (3, 2), all values = 42\n</code></pre>"},{"location":"api-reference/core/#flixopt.core.DataConverter.to_dataarray--series-index-matching","title":"Series index matching","text":"Python Console Session<pre><code>&gt;&gt;&gt; series = pd.Series([10, 20, 30], index=[1, 2, 3])\n&gt;&gt;&gt; converter.to_dataarray(series, coords)\n# Returns: DataArray matched to 'x' dimension, broadcast to 'y'\n</code></pre>"},{"location":"api-reference/core/#flixopt.core.DataConverter.to_dataarray--array-shape-matching","title":"Array shape matching","text":"Python Console Session<pre><code>&gt;&gt;&gt; array = np.array([[1, 2], [3, 4], [5, 6]])  # Shape (3, 2)\n&gt;&gt;&gt; converter.to_dataarray(array, coords)\n# Returns: DataArray with dimensions ('x', 'y') based on shape\n</code></pre>"},{"location":"api-reference/core/#flixopt.core-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.get_dataarray_stats","title":"get_dataarray_stats","text":"Python<pre><code>get_dataarray_stats(arr: DataArray) -&gt; dict\n</code></pre> <p>Generate statistical summary of a DataArray.</p>"},{"location":"api-reference/core/#flixopt.core.drop_constant_arrays","title":"drop_constant_arrays","text":"Python<pre><code>drop_constant_arrays(ds: Dataset, dim: str = 'time', drop_arrays_without_dim: bool = True) -&gt; xr.Dataset\n</code></pre> <p>Drop variables with constant values along a dimension.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Input dataset to filter.</p> required <code>dim</code> <code>str</code> <p>Dimension along which to check for constant values.</p> <code>'time'</code> <code>drop_arrays_without_dim</code> <code>bool</code> <p>If True, also drop variables that don't have the specified dimension.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset with constant variables removed.</p>"},{"location":"api-reference/effects/","title":"Effects","text":""},{"location":"api-reference/effects/#flixopt.effects","title":"flixopt.effects","text":"<p>This module contains the effects of the flixopt framework. Furthermore, it contains the EffectCollection, which is used to collect all effects of a system. Different Datatypes are used to represent the effects with assigned values by the user, which are then transformed into the internal data structure.</p>"},{"location":"api-reference/effects/#flixopt.effects-attributes","title":"Attributes","text":""},{"location":"api-reference/effects/#flixopt.effects.TemporalEffectsUser","title":"TemporalEffectsUser  <code>module-attribute</code>","text":"Python<pre><code>TemporalEffectsUser = TemporalDataUser | dict[str, TemporalDataUser]\n</code></pre> <p>This datatype is used to define a temporal share to an effect by a certain attribute.</p>"},{"location":"api-reference/effects/#flixopt.effects.PeriodicEffectsUser","title":"PeriodicEffectsUser  <code>module-attribute</code>","text":"Python<pre><code>PeriodicEffectsUser = PeriodicDataUser | dict[str, PeriodicDataUser]\n</code></pre> <p>This datatype is used to define a scalar share to an effect by a certain attribute.</p>"},{"location":"api-reference/effects/#flixopt.effects.TemporalEffects","title":"TemporalEffects  <code>module-attribute</code>","text":"Python<pre><code>TemporalEffects = dict[str, TemporalData]\n</code></pre> <p>This datatype is used internally to handle temporal shares to an effect.</p>"},{"location":"api-reference/effects/#flixopt.effects.PeriodicEffects","title":"PeriodicEffects  <code>module-attribute</code>","text":"Python<pre><code>PeriodicEffects = dict[str, Scalar]\n</code></pre> <p>This datatype is used internally to handle scalar shares to an effect.</p>"},{"location":"api-reference/effects/#flixopt.effects-classes","title":"Classes","text":""},{"location":"api-reference/effects/#flixopt.effects.Effect","title":"Effect","text":"Python<pre><code>Effect(label: str, unit: str, description: str, meta_data: dict | None = None, is_standard: bool = False, is_objective: bool = False, share_from_temporal: TemporalEffectsUser | None = None, share_from_periodic: PeriodicEffectsUser | None = None, minimum_temporal: PeriodicEffectsUser | None = None, maximum_temporal: PeriodicEffectsUser | None = None, minimum_periodic: PeriodicEffectsUser | None = None, maximum_periodic: PeriodicEffectsUser | None = None, minimum_per_hour: TemporalDataUser | None = None, maximum_per_hour: TemporalDataUser | None = None, minimum_total: Scalar | None = None, maximum_total: Scalar | None = None, **kwargs)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Represents system-wide impacts like costs, emissions, resource consumption, or other effects.</p> <p>Effects capture the broader impacts of system operation and investment decisions beyond the primary energy/material flows. Each Effect accumulates contributions from Components, Flows, and other system elements. One Effect is typically chosen as the optimization objective, while others can serve as constraints or tracking metrics.</p> <p>Effects support comprehensive modeling including operational and investment contributions, cross-effect relationships (e.g., carbon pricing), and flexible constraint formulation.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>unit</code> <code>str</code> <p>The unit of the effect (e.g., '\u20ac', 'kg_CO2', 'kWh_primary', 'm\u00b2'). This is informative only and does not affect optimization calculations.</p> required <code>description</code> <code>str</code> <p>Descriptive name explaining what this effect represents.</p> required <code>is_standard</code> <code>bool</code> <p>If True, this is a standard effect allowing direct value input without effect dictionaries. Used for simplified effect specification (and less boilerplate code).</p> <code>False</code> <code>is_objective</code> <code>bool</code> <p>If True, this effect serves as the optimization objective function. Only one effect can be marked as objective per optimization.</p> <code>False</code> <code>share_from_temporal</code> <code>TemporalEffectsUser | None</code> <p>Temporal cross-effect contributions. Maps temporal contributions from other effects to this effect</p> <code>None</code> <code>share_from_periodic</code> <code>PeriodicEffectsUser | None</code> <p>Periodic cross-effect contributions. Maps periodic contributions from other effects to this effect.</p> <code>None</code> <code>minimum_temporal</code> <code>PeriodicEffectsUser | None</code> <p>Minimum allowed total contribution across all timesteps.</p> <code>None</code> <code>maximum_temporal</code> <code>PeriodicEffectsUser | None</code> <p>Maximum allowed total contribution across all timesteps.</p> <code>None</code> <code>minimum_per_hour</code> <code>TemporalDataUser | None</code> <p>Minimum allowed contribution per hour.</p> <code>None</code> <code>maximum_per_hour</code> <code>TemporalDataUser | None</code> <p>Maximum allowed contribution per hour.</p> <code>None</code> <code>minimum_periodic</code> <code>PeriodicEffectsUser | None</code> <p>Minimum allowed total periodic contribution.</p> <code>None</code> <code>maximum_periodic</code> <code>PeriodicEffectsUser | None</code> <p>Maximum allowed total periodic contribution.</p> <code>None</code> <code>minimum_total</code> <code>Scalar | None</code> <p>Minimum allowed total effect (temporal + periodic combined).</p> <code>None</code> <code>maximum_total</code> <code>Scalar | None</code> <p>Maximum allowed total effect (temporal + periodic combined).</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Deprecated Parameters (for backwards compatibility):     minimum_operation: Use <code>minimum_temporal</code> instead.     maximum_operation: Use <code>maximum_temporal</code> instead.     minimum_invest: Use <code>minimum_periodic</code> instead.     maximum_invest: Use <code>maximum_periodic</code> instead.     minimum_operation_per_hour: Use <code>minimum_per_hour</code> instead.     maximum_operation_per_hour: Use <code>maximum_per_hour</code> instead.</p> <p>Examples:</p> <p>Basic cost objective:</p> Python<pre><code>cost_effect = Effect(\n    label='system_costs',\n    unit='\u20ac',\n    description='Total system costs',\n    is_objective=True,\n)\n</code></pre> <p>CO2 emissions:</p> Python<pre><code>co2_effect = Effect(\n    label='CO2',\n    unit='kg_CO2',\n    description='Carbon dioxide emissions',\n    maximum_total=1_000_000,  # 1000 t CO2 annual limit\n)\n</code></pre> <p>Land use constraint:</p> Python<pre><code>land_use = Effect(\n    label='land_usage',\n    unit='m\u00b2',\n    description='Land area requirement',\n    maximum_total=50_000,  # Maximum 5 hectares available\n)\n</code></pre> <p>Primary energy tracking:</p> Python<pre><code>primary_energy = Effect(\n    label='primary_energy',\n    unit='kWh_primary',\n    description='Primary energy consumption',\n)\n</code></pre> <p>Cost objective with carbon and primary energy pricing:</p> Text Only<pre><code>```python\ncost_effect = Effect(\n    label='system_costs',\n    unit='\u20ac',\n    description='Total system costs',\n    is_objective=True,\n    share_from_temporal={\n        'primary_energy': 0.08,  # 0.08 \u20ac/kWh_primary\n        'CO2': 0.2,  # Carbon pricing: 0.2 \u20ac/kg_CO2 into costs if used on a cost effect\n    },\n)\n```\n\nWater consumption with tiered constraints:\n\n```python\nwater_usage = Effect(\n    label='water_consumption',\n    unit='m\u00b3',\n    description='Industrial water usage',\n    minimum_per_hour=10,  # Minimum 10 m\u00b3/h for process stability\n    maximum_per_hour=500,  # Maximum 500 m\u00b3/h capacity limit\n    maximum_total=100_000,  # Annual permit limit: 100,000 m\u00b3\n)\n```\n</code></pre> Note <p>Effect bounds can be None to indicate no constraint in that direction.</p> <p>Cross-effect relationships enable sophisticated modeling like carbon pricing, resource valuation, or multi-criteria optimization with weighted objectives.</p> <p>The unit field is purely informational - ensure dimensional consistency across all contributions to each effect manually.</p> <p>Effects are accumulated as: - Total = \u03a3(temporal contributions) + \u03a3(periodic contributions)</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect-attributes","title":"Attributes","text":""},{"location":"api-reference/effects/#flixopt.effects.Effect.minimum_operation","title":"minimum_operation  <code>property</code> <code>writable</code>","text":"Python<pre><code>minimum_operation\n</code></pre> <p>DEPRECATED: Use 'minimum_temporal' property instead.</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.maximum_operation","title":"maximum_operation  <code>property</code> <code>writable</code>","text":"Python<pre><code>maximum_operation\n</code></pre> <p>DEPRECATED: Use 'maximum_temporal' property instead.</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.minimum_invest","title":"minimum_invest  <code>property</code> <code>writable</code>","text":"Python<pre><code>minimum_invest\n</code></pre> <p>DEPRECATED: Use 'minimum_periodic' property instead.</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.maximum_invest","title":"maximum_invest  <code>property</code> <code>writable</code>","text":"Python<pre><code>maximum_invest\n</code></pre> <p>DEPRECATED: Use 'maximum_periodic' property instead.</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.minimum_operation_per_hour","title":"minimum_operation_per_hour  <code>property</code> <code>writable</code>","text":"Python<pre><code>minimum_operation_per_hour\n</code></pre> <p>DEPRECATED: Use 'minimum_per_hour' property instead.</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.maximum_operation_per_hour","title":"maximum_operation_per_hour  <code>property</code> <code>writable</code>","text":"Python<pre><code>maximum_operation_per_hour\n</code></pre> <p>DEPRECATED: Use 'maximum_per_hour' property instead.</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.Effect.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollection","title":"EffectCollection","text":"Python<pre><code>EffectCollection(*effects: Effect)\n</code></pre> <p>Handling all Effects</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollection-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectCollection.create_effect_values_dict","title":"create_effect_values_dict","text":"Python<pre><code>create_effect_values_dict(effect_values_user: PeriodicEffectsUser | TemporalEffectsUser) -&gt; dict[str, Scalar | TemporalDataUser] | None\n</code></pre> <p>Converts effect values into a dictionary. If a scalar is provided, it is associated with a default effect type.</p> <p>Examples:</p> Python<pre><code>effect_values_user = 20                               -&gt; {'&lt;standard_effect_label&gt;': 20}\neffect_values_user = {None: 20}                       -&gt; {'&lt;standard_effect_label&gt;': 20}\neffect_values_user = None                             -&gt; None\neffect_values_user = {'effect1': 20, 'effect2': 0.3}  -&gt; {'effect1': 20, 'effect2': 0.3}\n</code></pre> <p>Returns:</p> Name Type Description <code>dict[str, Scalar | TemporalDataUser] | None</code> <p>A dictionary keyed by effect label, or None if input is None.</p> <code>Note</code> <code>dict[str, Scalar | TemporalDataUser] | None</code> <p>a standard effect must be defined when passing scalars or None labels.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel","title":"EffectCollectionModel","text":"Python<pre><code>EffectCollectionModel(model: FlowSystemModel, effects: EffectCollection)\n</code></pre> <p>               Bases: <code>Submodel</code></p> <p>Handling all Effects</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel-attributes","title":"Attributes","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.variables_direct","title":"variables_direct  <code>property</code>","text":"Python<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"Python<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.add_variables","title":"add_variables","text":"Python<pre><code>add_variables(short_name: str = None, **kwargs) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.add_constraints","title":"add_constraints","text":"Python<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.register_variable","title":"register_variable","text":"Python<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.register_constraint","title":"register_constraint","text":"Python<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.get","title":"get","text":"Python<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/effects/#flixopt.effects-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.calculate_all_conversion_paths","title":"calculate_all_conversion_paths","text":"Python<pre><code>calculate_all_conversion_paths(conversion_dict: dict[str, dict[str, Scalar | DataArray]]) -&gt; dict[tuple[str, str], xr.DataArray]\n</code></pre> <p>Calculates all possible direct and indirect conversion factors between units/domains. This function uses Breadth-First Search (BFS) to find all possible conversion paths between different units or domains in a conversion graph. It computes both direct conversions (explicitly provided in the input) and indirect conversions (derived through intermediate units). Args:     conversion_dict: A nested dictionary where:         - Outer keys represent origin units/domains         - Inner dictionaries map target units/domains to their conversion factors         - Conversion factors can be integers, floats, or numpy arrays Returns:     A dictionary mapping (origin, target) tuples to their respective conversion factors.     Each key is a tuple of strings representing the origin and target units/domains.     Each value is the conversion factor (int, float, or numpy array) from origin to target.</p>"},{"location":"api-reference/effects/#flixopt.effects.detect_cycles","title":"detect_cycles","text":"Python<pre><code>detect_cycles(graph: dict[str, list[str]]) -&gt; list[list[str]]\n</code></pre> <p>Detects cycles in a directed graph using DFS.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>dict[str, list[str]]</code> <p>Adjacency list representation of the graph</p> required <p>Returns:</p> Type Description <code>list[list[str]]</code> <p>List of cycles found, where each cycle is a list of nodes</p>"},{"location":"api-reference/effects/#flixopt.effects.tuples_to_adjacency_list","title":"tuples_to_adjacency_list","text":"Python<pre><code>tuples_to_adjacency_list(edges: list[tuple[str, str]]) -&gt; dict[str, list[str]]\n</code></pre> <p>Converts a list of edge tuples (source, target) to an adjacency list representation.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>list[tuple[str, str]]</code> <p>List of (source, target) tuples representing directed edges</p> required <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>Dictionary mapping each source node to a list of its target nodes</p>"},{"location":"api-reference/elements/","title":"Elements","text":""},{"location":"api-reference/elements/#flixopt.elements","title":"flixopt.elements","text":"<p>This module contains the basic elements of the flixopt framework.</p>"},{"location":"api-reference/elements/#flixopt.elements-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements-classes","title":"Classes","text":""},{"location":"api-reference/elements/#flixopt.elements.Component","title":"Component","text":"Python<pre><code>Component(label: str, inputs: list[Flow] | None = None, outputs: list[Flow] | None = None, on_off_parameters: OnOffParameters | None = None, prevent_simultaneous_flows: list[Flow] | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Base class for all system components that transform, convert, or process flows.</p> <p>Components are the active elements in energy systems that define how input and output Flows interact with each other. They represent equipment, processes, or logical operations that transform energy or materials between different states, carriers, or locations.</p> <p>Components serve as connection points between Buses through their associated Flows, enabling the modeling of complex energy system topologies and operational constraints.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>list of input Flows feeding into the component. These represent energy/material consumption by the component.</p> <code>None</code> <code>outputs</code> <code>list[Flow] | None</code> <p>list of output Flows leaving the component. These represent energy/material production by the component.</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Defines binary operation constraints and costs when the component has discrete on/off states. Creates binary variables for all connected Flows. For better performance, prefer defining OnOffParameters on individual Flows when possible.</p> <code>None</code> <code>prevent_simultaneous_flows</code> <code>list[Flow] | None</code> <p>list of Flows that cannot be active simultaneously. Creates binary variables to enforce mutual exclusivity. Use sparingly as it increases computational complexity.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> Note <p>Component operational state is determined by its connected Flows: - Component is \"on\" if ANY of its Flows is active (flow_rate &gt; 0) - Component is \"off\" only when ALL Flows are inactive (flow_rate = 0)</p> <p>Binary variables and constraints: - on_off_parameters creates binary variables for ALL connected Flows - prevent_simultaneous_flows creates binary variables for specified Flows - For better computational performance, prefer Flow-level OnOffParameters</p> <p>Component is an abstract base class. In practice, use specialized subclasses: - LinearConverter: Linear input/output relationships - Storage: Temporal energy/material storage - Transmission: Transport between locations - Source/Sink: System boundaries</p>"},{"location":"api-reference/elements/#flixopt.elements.Component-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Component.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus","title":"Bus","text":"Python<pre><code>Bus(label: str, excess_penalty_per_flow_hour: TemporalDataUser | None = 100000.0, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Buses represent nodal balances between flow rates, serving as connection points.</p> <p>A Bus enforces energy or material balance constraints where the sum of all incoming flows must equal the sum of all outgoing flows at each time step. Buses represent physical or logical connection points for energy carriers (electricity, heat, gas) or material flows between different Components.</p> Mathematical Formulation <p>See the complete mathematical model in the documentation: Bus</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>excess_penalty_per_flow_hour</code> <code>TemporalDataUser | None</code> <p>Penalty costs for bus balance violations. When None, no excess/deficit is allowed (hard constraint). When set to a value &gt; 0, allows bus imbalances at penalty cost. Default is 1e5 (high penalty).</p> <code>100000.0</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Electrical bus with strict balance:</p> Python<pre><code>electricity_bus = Bus(\n    label='main_electrical_bus',\n    excess_penalty_per_flow_hour=None,  # No imbalance allowed\n)\n</code></pre> <p>Heat network with penalty for imbalances:</p> Python<pre><code>heat_network = Bus(\n    label='district_heating_network',\n    excess_penalty_per_flow_hour=1000,  # \u20ac1000/MWh penalty for imbalance\n)\n</code></pre> <p>Material flow with time-varying penalties:</p> Python<pre><code>material_hub = Bus(\n    label='material_processing_hub',\n    excess_penalty_per_flow_hour=waste_disposal_costs,  # Time series\n)\n</code></pre> Note <p>The bus balance equation enforced is: \u03a3(inflows) = \u03a3(outflows) + excess - deficit</p> <p>When excess_penalty_per_flow_hour is None, excess and deficit are forced to zero. When a penalty cost is specified, the optimization can choose to violate the balance if economically beneficial, paying the penalty. The penalty is added to the objective directly.</p> <p>Empty <code>inputs</code> and <code>outputs</code> lists are initialized and populated automatically by the FlowSystem during system setup.</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Bus.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/elements/#flixopt.elements.Connection","title":"Connection","text":"Python<pre><code>Connection()\n</code></pre> <p>This class is not yet implemented!</p>"},{"location":"api-reference/elements/#flixopt.elements.Connection-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Flow","title":"Flow","text":"Python<pre><code>Flow(label: str, bus: str, size: Scalar | InvestParameters = None, fixed_relative_profile: TemporalDataUser | None = None, relative_minimum: TemporalDataUser = 0, relative_maximum: TemporalDataUser = 1, effects_per_flow_hour: TemporalEffectsUser | None = None, on_off_parameters: OnOffParameters | None = None, flow_hours_total_max: Scalar | None = None, flow_hours_total_min: Scalar | None = None, load_factor_min: Scalar | None = None, load_factor_max: Scalar | None = None, previous_flow_rate: Scalar | list[Scalar] | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Define a directed flow of energy or material between bus and component.</p> <p>A Flow represents the transfer of energy (electricity, heat, fuel) or material between a Bus and a Component in a specific direction. The flow rate is the primary optimization variable, with constraints and costs defined through various parameters. Flows can have fixed or variable sizes, operational constraints, and complex on/off behavior.</p> Key Concepts <p>Flow Rate: The instantaneous rate of energy/material transfer (optimization variable) [kW, m\u00b3/h, kg/h] Flow Hours: Amount of energy/material transferred per timestep. [kWh, m\u00b3, kg] Flow Size: The maximum capacity or nominal rating of the flow [kW, m\u00b3/h, kg/h] Relative Bounds: Flow rate limits expressed as fractions of flow size</p> Integration with Parameter Classes <ul> <li>InvestParameters: Used for <code>size</code> when flow Size is an investment decision</li> <li>OnOffParameters: Used for <code>on_off_parameters</code> when flow has discrete states</li> </ul> Mathematical Formulation <p>See the complete mathematical model in the documentation: Flow</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Unique flow identifier within its component.</p> required <code>bus</code> <code>str</code> <p>Bus label this flow connects to.</p> required <code>size</code> <code>Scalar | InvestParameters</code> <p>Flow capacity. Scalar, InvestParameters, or None (uses CONFIG.Modeling.big).</p> <code>None</code> <code>relative_minimum</code> <code>TemporalDataUser</code> <p>Minimum flow rate as fraction of size (0-1). Default: 0.</p> <code>0</code> <code>relative_maximum</code> <code>TemporalDataUser</code> <p>Maximum flow rate as fraction of size. Default: 1.</p> <code>1</code> <code>load_factor_min</code> <code>Scalar | None</code> <p>Minimum average utilization (0-1). Default: 0.</p> <code>None</code> <code>load_factor_max</code> <code>Scalar | None</code> <p>Maximum average utilization (0-1). Default: 1.</p> <code>None</code> <code>effects_per_flow_hour</code> <code>TemporalEffectsUser | None</code> <p>Operational costs/impacts per flow-hour. Dict mapping effect names to values (e.g., {'cost': 45, 'CO2': 0.8}).</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Binary operation constraints (OnOffParameters). Default: None.</p> <code>None</code> <code>flow_hours_total_max</code> <code>Scalar | None</code> <p>Maximum cumulative flow-hours. Alternative to load_factor_max.</p> <code>None</code> <code>flow_hours_total_min</code> <code>Scalar | None</code> <p>Minimum cumulative flow-hours. Alternative to load_factor_min.</p> <code>None</code> <code>fixed_relative_profile</code> <code>TemporalDataUser | None</code> <p>Predetermined pattern as fraction of size. Flow rate = size \u00d7 fixed_relative_profile(t).</p> <code>None</code> <code>previous_flow_rate</code> <code>Scalar | list[Scalar] | None</code> <p>Initial flow state for on/off dynamics. Default: None (off).</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Additional info stored in results. Python native types only.</p> <code>None</code> <p>Examples:</p> <p>Basic power flow with fixed capacity:</p> Python<pre><code>generator_output = Flow(\n    label='electricity_out',\n    bus='electricity_grid',\n    size=100,  # 100 MW capacity\n    relative_minimum=0.4,  # Cannot operate below 40 MW\n    effects_per_flow_hour={'fuel_cost': 45, 'co2_emissions': 0.8},\n)\n</code></pre> <p>Investment decision for battery capacity:</p> Python<pre><code>battery_flow = Flow(\n    label='electricity_storage',\n    bus='electricity_grid',\n    size=InvestParameters(\n        minimum_size=10,  # Minimum 10 MWh\n        maximum_size=100,  # Maximum 100 MWh\n        specific_effects={'cost': 150_000},  # \u20ac150k/MWh annualized\n    ),\n)\n</code></pre> <p>Heat pump with startup costs and minimum run times:</p> Python<pre><code>heat_pump = Flow(\n    label='heat_output',\n    bus='heating_network',\n    size=50,  # 50 kW thermal\n    relative_minimum=0.3,  # Minimum 15 kW output when on\n    effects_per_flow_hour={'electricity_cost': 25, 'maintenance': 2},\n    on_off_parameters=OnOffParameters(\n        effects_per_switch_on={'startup_cost': 100, 'wear': 0.1},\n        consecutive_on_hours_min=2,  # Must run at least 2 hours\n        consecutive_off_hours_min=1,  # Must stay off at least 1 hour\n        switch_on_total_max=200,  # Maximum 200 starts per period\n    ),\n)\n</code></pre> <p>Fixed renewable generation profile:</p> Python<pre><code>solar_generation = Flow(\n    label='solar_power',\n    bus='electricity_grid',\n    size=25,  # 25 MW installed capacity\n    fixed_relative_profile=np.array([0, 0.1, 0.4, 0.8, 0.9, 0.7, 0.3, 0.1, 0]),\n    effects_per_flow_hour={'maintenance_costs': 5},  # \u20ac5/MWh maintenance\n)\n</code></pre> <p>Industrial process with annual utilization limits:</p> Python<pre><code>production_line = Flow(\n    label='product_output',\n    bus='product_market',\n    size=1000,  # 1000 units/hour capacity\n    load_factor_min=0.6,  # Must achieve 60% annual utilization\n    load_factor_max=0.85,  # Cannot exceed 85% for maintenance\n    effects_per_flow_hour={'variable_cost': 12, 'quality_control': 0.5},\n)\n</code></pre> Design Considerations <p>Size vs Load Factors: Use <code>flow_hours_total_min/max</code> for absolute limits, <code>load_factor_min/max</code> for utilization-based constraints.</p> <p>Relative Bounds: Set <code>relative_minimum &gt; 0</code> only when equipment cannot operate below that level. Use <code>on_off_parameters</code> for discrete on/off behavior.</p> <p>Fixed Profiles: Use <code>fixed_relative_profile</code> for known exact patterns, <code>relative_maximum</code> for upper bounds on optimization variables.</p> Notes <ul> <li>Default size (CONFIG.Modeling.big) is used when size=None</li> <li>list inputs for previous_flow_rate are converted to NumPy arrays</li> <li>Flow direction is determined by component input/output designation</li> </ul> Deprecated <p>Passing Bus objects to <code>bus</code> parameter. Use bus label strings instead.</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Flow.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel","title":"FlowModel","text":"Python<pre><code>FlowModel(model: FlowSystemModel, element: Flow)\n</code></pre> <p>               Bases: <code>ElementModel</code></p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements.FlowModel.flow_rate","title":"flow_rate  <code>property</code>","text":"Python<pre><code>flow_rate: Variable\n</code></pre> <p>Main flow rate variable</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.total_flow_hours","title":"total_flow_hours  <code>property</code>","text":"Python<pre><code>total_flow_hours: Variable\n</code></pre> <p>Total flow hours variable</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.absolute_flow_rate_bounds","title":"absolute_flow_rate_bounds  <code>property</code>","text":"Python<pre><code>absolute_flow_rate_bounds: tuple[TemporalData, TemporalData]\n</code></pre> <p>Returns the absolute bounds the flow_rate can reach. Further constraining might be needed</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.on_off","title":"on_off  <code>property</code>","text":"Python<pre><code>on_off: OnOffModel | None\n</code></pre> <p>OnOff feature</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.investment","title":"investment  <code>property</code>","text":"Python<pre><code>investment: InvestmentModel | None\n</code></pre> <p>OnOff feature</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.previous_states","title":"previous_states  <code>property</code>","text":"Python<pre><code>previous_states: TemporalData | None\n</code></pre> <p>Previous states of the flow rate</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.variables_direct","title":"variables_direct  <code>property</code>","text":"Python<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"Python<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.FlowModel.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.add_variables","title":"add_variables","text":"Python<pre><code>add_variables(short_name: str = None, **kwargs) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.add_constraints","title":"add_constraints","text":"Python<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.register_variable","title":"register_variable","text":"Python<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.register_constraint","title":"register_constraint","text":"Python<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.get","title":"get","text":"Python<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel","title":"ComponentModel","text":"Python<pre><code>ComponentModel(model: FlowSystemModel, element: Component)\n</code></pre> <p>               Bases: <code>ElementModel</code></p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.previous_states","title":"previous_states  <code>property</code>","text":"Python<pre><code>previous_states: DataArray | None\n</code></pre> <p>Previous state of the component, derived from its flows</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.variables_direct","title":"variables_direct  <code>property</code>","text":"Python<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"Python<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.add_variables","title":"add_variables","text":"Python<pre><code>add_variables(short_name: str = None, **kwargs) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.add_constraints","title":"add_constraints","text":"Python<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.register_variable","title":"register_variable","text":"Python<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.register_constraint","title":"register_constraint","text":"Python<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.get","title":"get","text":"Python<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/elements/#flixopt.elements-functions","title":"Functions","text":""},{"location":"api-reference/features/","title":"Features","text":""},{"location":"api-reference/features/#flixopt.features","title":"flixopt.features","text":"<p>This module contains the features of the flixopt framework. Features extend the functionality of Elements.</p>"},{"location":"api-reference/features/#flixopt.features-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features-classes","title":"Classes","text":""},{"location":"api-reference/features/#flixopt.features.InvestmentModel","title":"InvestmentModel","text":"Python<pre><code>InvestmentModel(model: FlowSystemModel, label_of_element: str, parameters: InvestParameters, label_of_model: str | None = None)\n</code></pre> <p>               Bases: <code>Submodel</code></p> <p>This feature model is used to model the investment of a variable. It applies the corresponding bounds to the variable and the on/off state of the variable.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FlowSystemModel</code> <p>The optimization model instance</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>parameters</code> <code>InvestParameters</code> <p>The parameters of the feature model.</p> required <code>label_of_model</code> <code>str | None</code> <p>The label of the model. This is needed to construct the full label of the model.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.InvestmentModel.size","title":"size  <code>property</code>","text":"Python<pre><code>size: Variable\n</code></pre> <p>Investment size variable</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.invested","title":"invested  <code>property</code>","text":"Python<pre><code>invested: Variable | None\n</code></pre> <p>Binary investment decision variable</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.variables_direct","title":"variables_direct  <code>property</code>","text":"Python<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"Python<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.InvestmentModel.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.add_variables","title":"add_variables","text":"Python<pre><code>add_variables(short_name: str = None, **kwargs) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.add_constraints","title":"add_constraints","text":"Python<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.register_variable","title":"register_variable","text":"Python<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.register_constraint","title":"register_constraint","text":"Python<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.get","title":"get","text":"Python<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel","title":"OnOffModel","text":"Python<pre><code>OnOffModel(model: FlowSystemModel, label_of_element: str, parameters: OnOffParameters, on_variable: Variable, previous_states: TemporalData | None, label_of_model: str | None = None)\n</code></pre> <p>               Bases: <code>Submodel</code></p> <p>OnOff model using factory patterns</p> <p>This feature model is used to model the on/off state of flow_rate(s). It does not matter of the flow_rates are bounded by a size variable or by a hard bound. THe used bound here is the absolute highest/lowest bound!</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FlowSystemModel</code> <p>The optimization model instance</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>parameters</code> <code>OnOffParameters</code> <p>The parameters of the feature model.</p> required <code>on_variable</code> <code>Variable</code> <p>The variable that determines the on state</p> required <code>previous_states</code> <code>TemporalData | None</code> <p>The previous flow_rates</p> required <code>label_of_model</code> <code>str | None</code> <p>The label of the model. This is needed to construct the full label of the model.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.OnOffModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.OnOffModel.on_hours_total","title":"on_hours_total  <code>property</code>","text":"Python<pre><code>on_hours_total: Variable\n</code></pre> <p>Total on hours variable</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.off","title":"off  <code>property</code>","text":"Python<pre><code>off: Variable | None\n</code></pre> <p>Binary off state variable</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.switch_on","title":"switch_on  <code>property</code>","text":"Python<pre><code>switch_on: Variable | None\n</code></pre> <p>Switch on variable</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.switch_off","title":"switch_off  <code>property</code>","text":"Python<pre><code>switch_off: Variable | None\n</code></pre> <p>Switch off variable</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.switch_on_nr","title":"switch_on_nr  <code>property</code>","text":"Python<pre><code>switch_on_nr: Variable | None\n</code></pre> <p>Number of switch-ons variable</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.consecutive_on_hours","title":"consecutive_on_hours  <code>property</code>","text":"Python<pre><code>consecutive_on_hours: Variable | None\n</code></pre> <p>Consecutive on hours variable</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.consecutive_off_hours","title":"consecutive_off_hours  <code>property</code>","text":"Python<pre><code>consecutive_off_hours: Variable | None\n</code></pre> <p>Consecutive off hours variable</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.variables_direct","title":"variables_direct  <code>property</code>","text":"Python<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"Python<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.OnOffModel.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.add_variables","title":"add_variables","text":"Python<pre><code>add_variables(short_name: str = None, **kwargs) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.add_constraints","title":"add_constraints","text":"Python<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.register_variable","title":"register_variable","text":"Python<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.register_constraint","title":"register_constraint","text":"Python<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.get","title":"get","text":"Python<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel","title":"PieceModel","text":"Python<pre><code>PieceModel(model: FlowSystemModel, label_of_element: str, label_of_model: str, dims: FlowSystemDimensions | None)\n</code></pre> <p>               Bases: <code>Submodel</code></p> <p>Class for modeling a linear piece of one or more variables in parallel</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.PieceModel.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.variables_direct","title":"variables_direct  <code>property</code>","text":"Python<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"Python<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.PieceModel.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.add_variables","title":"add_variables","text":"Python<pre><code>add_variables(short_name: str = None, **kwargs) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.add_constraints","title":"add_constraints","text":"Python<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.register_variable","title":"register_variable","text":"Python<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.register_constraint","title":"register_constraint","text":"Python<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.get","title":"get","text":"Python<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel","title":"PiecewiseModel","text":"Python<pre><code>PiecewiseModel(model: FlowSystemModel, label_of_element: str, label_of_model: str, piecewise_variables: dict[str, Piecewise], zero_point: bool | Variable | None, dims: FlowSystemDimensions | None)\n</code></pre> <p>               Bases: <code>Submodel</code></p> <p>Modeling a Piecewise relation between miultiple variables. The relation is defined by a list of Pieces, which are assigned to the variables. Each Piece is a tuple of (start, end).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FlowSystemModel</code> <p>The FlowSystemModel that is used to create the model.</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>label_of_model</code> <code>str</code> <p>The label of the model. Used to construct the full label of the model.</p> required <code>piecewise_variables</code> <code>dict[str, Piecewise]</code> <p>The variables to which the Pieces are assigned.</p> required <code>zero_point</code> <code>bool | Variable | None</code> <p>A variable that can be used to define a zero point for the Piecewise relation. If None or False, no zero point is defined.</p> required <code>dims</code> <code>FlowSystemDimensions | None</code> <p>The dimensions used for variable creation. If None, all dimensions are used.</p> required"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.variables_direct","title":"variables_direct  <code>property</code>","text":"Python<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"Python<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.add_variables","title":"add_variables","text":"Python<pre><code>add_variables(short_name: str = None, **kwargs) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.add_constraints","title":"add_constraints","text":"Python<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.register_variable","title":"register_variable","text":"Python<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.register_constraint","title":"register_constraint","text":"Python<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.get","title":"get","text":"Python<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel","title":"ShareAllocationModel","text":"Python<pre><code>ShareAllocationModel(model: FlowSystemModel, dims: list[FlowSystemDimensions], label_of_element: str | None = None, label_of_model: str | None = None, total_max: Scalar | None = None, total_min: Scalar | None = None, max_per_hour: TemporalData | None = None, min_per_hour: TemporalData | None = None)\n</code></pre> <p>               Bases: <code>Submodel</code></p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.variables_direct","title":"variables_direct  <code>property</code>","text":"Python<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"Python<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.add_share","title":"add_share","text":"Python<pre><code>add_share(name: str, expression: LinearExpression, dims: list[FlowSystemDimensions] | None = None)\n</code></pre> <p>Add a share to the share allocation model. If the share already exists, the expression is added to the existing share. The expression is added to the right hand side (rhs) of the constraint. The variable representing the total share is on the left hand side (lhs) of the constraint. var_total = sum(expressions)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the share.</p> required <code>expression</code> <code>LinearExpression</code> <p>The expression of the share. Added to the right hand side of the constraint.</p> required <code>dims</code> <code>list[FlowSystemDimensions] | None</code> <p>The dimensions of the share. Defaults to all dimensions. Dims are ordered automatically</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.add_variables","title":"add_variables","text":"Python<pre><code>add_variables(short_name: str = None, **kwargs) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.add_constraints","title":"add_constraints","text":"Python<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.register_variable","title":"register_variable","text":"Python<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.register_constraint","title":"register_constraint","text":"Python<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.get","title":"get","text":"Python<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/flow_system/","title":"Flow system","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system","title":"flixopt.flow_system","text":"<p>This module contains the FlowSystem class, which is used to collect instances of many other classes by the end User.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system-attributes","title":"Attributes","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system-classes","title":"Classes","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem","title":"FlowSystem","text":"Python<pre><code>FlowSystem(timesteps: DatetimeIndex, periods: Index | None = None, scenarios: Index | None = None, hours_of_last_timestep: float | None = None, hours_of_previous_timesteps: int | float | ndarray | None = None, weights: PeriodicDataUser | None = None, scenario_independent_sizes: bool | list[str] = True, scenario_independent_flow_rates: bool | list[str] = False)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>A FlowSystem organizes the high level Elements (Components, Buses &amp; Effects).</p> <p>This is the main container class that users work with to build and manage their System.</p> <p>Parameters:</p> Name Type Description Default <code>timesteps</code> <code>DatetimeIndex</code> <p>The timesteps of the model.</p> required <code>periods</code> <code>Index | None</code> <p>The periods of the model.</p> <code>None</code> <code>scenarios</code> <code>Index | None</code> <p>The scenarios of the model.</p> <code>None</code> <code>hours_of_last_timestep</code> <code>float | None</code> <p>The duration of the last time step. Uses the last time interval if not specified</p> <code>None</code> <code>hours_of_previous_timesteps</code> <code>int | float | ndarray | None</code> <p>The duration of previous timesteps. If None, the first time increment of time_series is used. This is needed to calculate previous durations (for example consecutive_on_hours). If you use an array, take care that its long enough to cover all previous values!</p> <code>None</code> <code>weights</code> <code>PeriodicDataUser | None</code> <p>The weights of each period and scenario. If None, all scenarios have the same weight (normalized to 1). Its recommended to normalize the weights to sum up to 1.</p> <code>None</code> <code>scenario_independent_sizes</code> <code>bool | list[str]</code> <p>Controls whether investment sizes are equalized across scenarios. - True: All sizes are shared/equalized across scenarios - False: All sizes are optimized separately per scenario - list[str]: Only specified components (by label_full) are equalized across scenarios</p> <code>True</code> <code>scenario_independent_flow_rates</code> <code>bool | list[str]</code> <p>Controls whether flow rates are equalized across scenarios. - True: All flow rates are shared/equalized across scenarios - False: All flow rates are optimized separately per scenario - list[str]: Only specified flows (by label_full) are equalized across scenarios</p> <code>False</code> Notes <ul> <li>Creates an empty registry for components and buses, an empty EffectCollection, and a placeholder for a SystemModel.</li> <li>The instance starts disconnected (self._connected_and_transformed == False) and will be connected_and_transformed automatically when trying to solve a calculation.</li> </ul>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem-attributes","title":"Attributes","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.scenario_independent_sizes","title":"scenario_independent_sizes  <code>property</code> <code>writable</code>","text":"Python<pre><code>scenario_independent_sizes: bool | list[str]\n</code></pre> <p>Controls whether investment sizes are equalized across scenarios.</p> <p>Returns:</p> Type Description <code>bool | list[str]</code> <p>bool or list[str]: Configuration for scenario-independent sizing</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.scenario_independent_flow_rates","title":"scenario_independent_flow_rates  <code>property</code> <code>writable</code>","text":"Python<pre><code>scenario_independent_flow_rates: bool | list[str]\n</code></pre> <p>Controls whether flow rates are equalized across scenarios.</p> <p>Returns:</p> Type Description <code>bool | list[str]</code> <p>bool or list[str]: Configuration for scenario-independent flow rates</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem-functions","title":"Functions","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.calculate_hours_per_timestep","title":"calculate_hours_per_timestep  <code>staticmethod</code>","text":"Python<pre><code>calculate_hours_per_timestep(timesteps_extra: DatetimeIndex) -&gt; xr.DataArray\n</code></pre> <p>Calculate duration of each timestep as a 1D DataArray.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the FlowSystem to an xarray Dataset. Ensures FlowSystem is connected before serialization.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with structure in attributes</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; FlowSystem\n</code></pre> <p>Create a FlowSystem from an xarray Dataset. Handles FlowSystem-specific reconstruction logic.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the FlowSystem data</p> required <p>Returns:</p> Type Description <code>FlowSystem</code> <p>FlowSystem instance</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the FlowSystem to a NetCDF file. Ensures FlowSystem is connected before saving.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the netCDF file.</p> required <code>compression</code> <code>int</code> <p>The compression level to use when saving the file.</p> <code>0</code>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get FlowSystem structure. Ensures FlowSystem is connected before getting structure.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the flow system to a JSON file. Ensures FlowSystem is connected before saving.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.fit_to_model_coords","title":"fit_to_model_coords","text":"Python<pre><code>fit_to_model_coords(name: str, data: TemporalDataUser | PeriodicDataUser | None, dims: Collection[FlowSystemDimensions] | None = None) -&gt; TemporalData | PeriodicData | None\n</code></pre> <p>Fit data to model coordinate system (currently time, but extensible).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the data</p> required <code>data</code> <code>TemporalDataUser | PeriodicDataUser | None</code> <p>Data to fit to model coordinates</p> required <code>dims</code> <code>Collection[FlowSystemDimensions] | None</code> <p>Collection of dimension names to use for fitting. If None, all dimensions are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>TemporalData | PeriodicData | None</code> <p>xr.DataArray aligned to model coordinate system. If data is None, returns None.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.fit_effects_to_model_coords","title":"fit_effects_to_model_coords","text":"Python<pre><code>fit_effects_to_model_coords(label_prefix: str | None, effect_values: TemporalEffectsUser | PeriodicEffectsUser | None, label_suffix: str | None = None, dims: Collection[FlowSystemDimensions] | None = None, delimiter: str = '|') -&gt; TemporalEffects | PeriodicEffects | None\n</code></pre> <p>Transform EffectValues from the user to Internal Datatypes aligned with model coordinates.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.connect_and_transform","title":"connect_and_transform","text":"Python<pre><code>connect_and_transform()\n</code></pre> <p>Transform data for all elements using the new simplified approach.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.add_elements","title":"add_elements","text":"Python<pre><code>add_elements(*elements: Element) -&gt; None\n</code></pre> <p>Add Components(Storages, Boilers, Heatpumps, ...), Buses or Effects to the FlowSystem</p> <p>Parameters:</p> Name Type Description Default <code>*elements</code> <code>Element</code> <p>childs of  Element like Boiler, HeatPump, Bus,... modeling Elements</p> <code>()</code>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.create_model","title":"create_model","text":"Python<pre><code>create_model(normalize_weights: bool = True) -&gt; FlowSystemModel\n</code></pre> <p>Create a linopy model from the FlowSystem.</p> <p>Parameters:</p> Name Type Description Default <code>normalize_weights</code> <code>bool</code> <p>Whether to automatically normalize the weights (periods and scenarios) to sum up to 1 when solving.</p> <code>True</code>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.plot_network","title":"plot_network","text":"Python<pre><code>plot_network(path: bool | str | Path = 'flow_system.html', controls: bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']] = True, show: bool | None = None) -&gt; pyvis.network.Network | None\n</code></pre> <p>Visualizes the network structure of a FlowSystem using PyVis, saving it as an interactive HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>bool | str | Path</code> <p>Path to save the HTML visualization. - <code>False</code>: Visualization is created but not saved. - <code>str</code> or <code>Path</code>: Specifies file path (default: 'flow_system.html').</p> <code>'flow_system.html'</code> <code>controls</code> <code>bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]</code> <p>UI controls to add to the visualization. - <code>True</code>: Enables all available controls. - <code>List</code>: Specify controls, e.g., ['nodes', 'layout']. - Options: 'nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer'.</p> <code>True</code> <code>show</code> <code>bool | None</code> <p>Whether to open the visualization in the web browser.</p> <code>None</code> <p>Returns: - 'pyvis.network.Network' | None: The <code>Network</code> instance representing the visualization, or <code>None</code> if <code>pyvis</code> is not installed.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; flow_system.plot_network()\n&gt;&gt;&gt; flow_system.plot_network(show=False)\n&gt;&gt;&gt; flow_system.plot_network(path='output/custom_network.html', controls=['nodes', 'layout'])\n</code></pre> <p>Notes: - This function requires <code>pyvis</code>. If not installed, the function prints a warning and returns <code>None</code>. - Nodes are styled based on type (e.g., circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.start_network_app","title":"start_network_app","text":"Python<pre><code>start_network_app()\n</code></pre> <p>Visualizes the network structure of a FlowSystem using Dash, Cytoscape, and networkx. Requires optional dependencies: dash, dash-cytoscape, dash-daq, networkx, flask, werkzeug.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.stop_network_app","title":"stop_network_app","text":"Python<pre><code>stop_network_app()\n</code></pre> <p>Stop the network visualization server.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.sel","title":"sel","text":"Python<pre><code>sel(time: str | slice | list[str] | Timestamp | DatetimeIndex | None = None, period: int | slice | list[int] | Index | None = None, scenario: str | slice | list[str] | Index | None = None) -&gt; FlowSystem\n</code></pre> <p>Select a subset of the flowsystem by the time coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>str | slice | list[str] | Timestamp | DatetimeIndex | None</code> <p>Time selection (e.g., slice('2023-01-01', '2023-12-31'), '2023-06-15', or list of times)</p> <code>None</code> <code>period</code> <code>int | slice | list[int] | Index | None</code> <p>Period selection (e.g., slice(2023, 2024), or list of periods)</p> <code>None</code> <code>scenario</code> <code>str | slice | list[str] | Index | None</code> <p>Scenario selection (e.g., slice('scenario1', 'scenario2'), or list of scenarios)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>New FlowSystem with selected data</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.isel","title":"isel","text":"Python<pre><code>isel(time: int | slice | list[int] | None = None, period: int | slice | list[int] | None = None, scenario: int | slice | list[int] | None = None) -&gt; FlowSystem\n</code></pre> <p>Select a subset of the flowsystem by integer indices.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>int | slice | list[int] | None</code> <p>Time selection by integer index (e.g., slice(0, 100), 50, or [0, 5, 10])</p> <code>None</code> <code>period</code> <code>int | slice | list[int] | None</code> <p>Period selection by integer index (e.g., slice(0, 100), 50, or [0, 5, 10])</p> <code>None</code> <code>scenario</code> <code>int | slice | list[int] | None</code> <p>Scenario selection by integer index (e.g., slice(0, 3), 50, or [0, 5, 10])</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>New FlowSystem with selected data</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.resample","title":"resample","text":"Python<pre><code>resample(time: str, method: Literal['mean', 'sum', 'max', 'min', 'first', 'last', 'std', 'var', 'median', 'count'] = 'mean', **kwargs: Any) -&gt; FlowSystem\n</code></pre> <p>Create a resampled FlowSystem by resampling data along the time dimension (like xr.Dataset.resample()). Only resamples data variables that have a time dimension.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>str</code> <p>Resampling frequency (e.g., '3h', '2D', '1M')</p> required <code>method</code> <code>Literal['mean', 'sum', 'max', 'min', 'first', 'last', 'std', 'var', 'median', 'count']</code> <p>Resampling method. Recommended: 'mean', 'first', 'last', 'max', 'min'</p> <code>'mean'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to xarray.resample()</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>New FlowSystem with resampled data</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.transform_data","title":"transform_data","text":"Python<pre><code>transform_data(flow_system: FlowSystem, name_prefix: str = '') -&gt; None\n</code></pre> <p>Transform the data of the interface to match the FlowSystem's dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem containing timing and dimensional information</p> required <code>name_prefix</code> <code>str</code> <p>The prefix to use for the names of the variables. Defaults to '', which results in no prefix.</p> <code>''</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/interface/","title":"Interface","text":""},{"location":"api-reference/interface/#flixopt.interface","title":"flixopt.interface","text":"<p>This module contains classes to collect Parameters for the Investment and OnOff decisions. These are tightly connected to features.py</p>"},{"location":"api-reference/interface/#flixopt.interface-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixopt.interface-classes","title":"Classes","text":""},{"location":"api-reference/interface/#flixopt.interface.Piece","title":"Piece","text":"Python<pre><code>Piece(start: TemporalDataUser, end: TemporalDataUser)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a single linear segment with specified domain boundaries.</p> <p>This class represents one linear segment that will be combined with other pieces to form complete piecewise linear functions. Each piece defines a domain interval [start, end] where a linear relationship applies.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>TemporalDataUser</code> <p>Lower bound of the domain interval for this linear segment. Can be scalar values or time series arrays for time-varying boundaries.</p> required <code>end</code> <code>TemporalDataUser</code> <p>Upper bound of the domain interval for this linear segment. Can be scalar values or time series arrays for time-varying boundaries.</p> required <p>Examples:</p> <p>Basic piece for equipment efficiency curve:</p> Python<pre><code># Single segment from 40% to 80% load\nefficiency_segment = Piece(start=40, end=80)\n</code></pre> <p>Piece with time-varying boundaries:</p> Python<pre><code># Capacity limits that change seasonally\nseasonal_piece = Piece(\n    start=np.array([10, 20, 30, 25]),  # Minimum capacity by season\n    end=np.array([80, 100, 90, 70]),  # Maximum capacity by season\n)\n</code></pre> <p>Fixed operating point (start equals end):</p> Python<pre><code># Equipment that operates at exactly 50 MW\nfixed_output = Piece(start=50, end=50)\n</code></pre> Note <p>Individual pieces are building blocks that gain meaning when combined into Piecewise functions. See the Piecewise class for information about how pieces interact and relate to each other.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.Piece.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise","title":"Piecewise","text":"Python<pre><code>Piecewise(pieces: list[Piece])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a Piecewise, consisting of a list of Pieces.</p> <p>Parameters:</p> Name Type Description Default <code>pieces</code> <code>list[Piece]</code> <p>list of Piece objects defining the linear segments. The arrangement and relationships between pieces determine the function behavior: - Touching pieces (end of one = start of next) ensure continuity - Gaps between pieces create forbidden regions - Overlapping pieces provide an extra choice for the optimizer</p> required Piece Relationship Patterns <p>Touching Pieces (Continuous Function): Pieces that share boundary points create smooth, continuous functions without gaps or overlaps.</p> <p>Gaps Between Pieces (Forbidden Regions): Non-contiguous pieces with gaps represent forbidden regions. For example minimum load requirements or safety zones.</p> <p>Overlapping Pieces (Flexible Operation): Pieces with overlapping domains provide optimization flexibility, allowing the solver to choose which segment to operate in.</p> <p>Examples:</p> <p>Continuous efficiency curve (touching pieces):</p> Python<pre><code>efficiency_curve = Piecewise(\n    [\n        Piece(start=0, end=25),  # Low load: 0-25 MW\n        Piece(start=25, end=75),  # Medium load: 25-75 MW (touches at 25)\n        Piece(start=75, end=100),  # High load: 75-100 MW (touches at 75)\n    ]\n)\n</code></pre> <p>Equipment with forbidden operating range (gap):</p> Python<pre><code>turbine_operation = Piecewise(\n    [\n        Piece(start=0, end=0),  # Off state (point operation)\n        Piece(start=40, end=100),  # Operating range (gap: 0-40 forbidden)\n    ]\n)\n</code></pre> <p>Flexible operation with overlapping options:</p> Python<pre><code>flexible_operation = Piecewise(\n    [\n        Piece(start=20, end=60),  # Standard efficiency mode\n        Piece(start=50, end=90),  # High efficiency mode (overlap: 50-60)\n    ]\n)\n</code></pre> <p>Tiered pricing structure:</p> Python<pre><code>electricity_pricing = Piecewise(\n    [\n        Piece(start=0, end=100),  # Tier 1: 0-100 kWh\n        Piece(start=100, end=500),  # Tier 2: 100-500 kWh\n        Piece(start=500, end=1000),  # Tier 3: 500-1000 kWh\n    ]\n)\n</code></pre> <p>Seasonal capacity variation:</p> Python<pre><code>seasonal_capacity = Piecewise(\n    [\n        Piece(start=[10, 15, 20, 12], end=[80, 90, 85, 75]),  # Varies by time\n    ]\n)\n</code></pre> Container Operations <p>The Piecewise class supports standard Python container operations:</p> Python<pre><code>piecewise = Piecewise([piece1, piece2, piece3])\n\nlen(piecewise)  # Returns number of pieces (3)\npiecewise[0]  # Access first piece\nfor piece in piecewise:  # Iterate over all pieces\n    print(piece.start, piece.end)\n</code></pre> Validation Considerations <ul> <li>Pieces are typically ordered by their start values</li> <li>Check for unintended gaps that might create infeasible regions</li> <li>Consider whether overlaps provide desired flexibility or create ambiguity</li> <li>Ensure time-varying pieces have consistent dimensions</li> </ul> Common Use Cases <ul> <li>Power plants: Heat rate curves, efficiency vs load, emissions profiles</li> <li>HVAC systems: COP vs temperature, capacity vs conditions</li> <li>Industrial processes: Conversion rates vs throughput, quality vs speed</li> <li>Financial modeling: Tiered rates, progressive taxes, bulk discounts</li> <li>Transportation: Fuel efficiency curves, capacity vs speed</li> <li>Storage systems: Efficiency vs state of charge, power vs energy</li> <li>Renewable energy: Output vs weather conditions, curtailment strategies</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.Piecewise.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion","title":"PiecewiseConversion","text":"Python<pre><code>PiecewiseConversion(piecewises: dict[str, Piecewise])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define coordinated piecewise linear relationships between multiple flows.</p> <p>This class models conversion processes where multiple flows (inputs, outputs, auxiliaries) have synchronized piecewise relationships. All flows change together based on the same operating point, enabling accurate modeling of complex equipment with variable performance characteristics.</p> Multi-Flow Coordination <p>All piecewise functions must have matching piece structures (same number of pieces with compatible domains) to ensure synchronized operation. When the equipment operates at a given point, ALL flows scale proportionally within their respective pieces.</p> Mathematical Formulation <p>See the complete mathematical model in the documentation: Piecewise</p> <p>Parameters:</p> Name Type Description Default <code>piecewises</code> <code>dict[str, Piecewise]</code> <p>Dictionary mapping flow labels to their Piecewise functions. Keys are flow identifiers (e.g., 'electricity_in', 'heat_out', 'fuel_consumed'). Values are Piecewise objects that define each flow's behavior. Critical Requirement: All Piecewise objects must have the same number of pieces with compatible domains to ensure consistent operation.</p> required Operating Point Coordination <p>When equipment operates at any point within a piece, all flows scale proportionally within their corresponding pieces. This ensures realistic equipment behavior where efficiency, consumption, and production rates all change together.</p> <p>Examples:</p> <p>Heat pump with coordinated efficiency changes:</p> Python<pre><code>heat_pump_pc = PiecewiseConversion(\n    {\n        'electricity_in': Piecewise(\n            [\n                Piece(0, 10),  # Low load: 0-10 kW electricity\n                Piece(10, 25),  # High load: 10-25 kW electricity\n            ]\n        ),\n        'heat_out': Piecewise(\n            [\n                Piece(0, 35),  # Low load COP=3.5: 0-35 kW heat\n                Piece(35, 75),  # High load COP=3.0: 35-75 kW heat\n            ]\n        ),\n        'cooling_water': Piecewise(\n            [\n                Piece(0, 2.5),  # Low load: 0-2.5 m\u00b3/h cooling\n                Piece(2.5, 6),  # High load: 2.5-6 m\u00b3/h cooling\n            ]\n        ),\n    }\n)\n# At 15 kW electricity \u2192 52.5 kW heat + 3.75 m\u00b3/h cooling water\n</code></pre> <p>Combined cycle power plant with synchronized flows:</p> Python<pre><code>power_plant_pc = PiecewiseConversion(\n    {\n        'natural_gas': Piecewise(\n            [\n                Piece(150, 300),  # Part load: 150-300 MW_th fuel\n                Piece(300, 500),  # Full load: 300-500 MW_th fuel\n            ]\n        ),\n        'electricity': Piecewise(\n            [\n                Piece(60, 135),  # Part load: 60-135 MW_e (45% efficiency)\n                Piece(135, 250),  # Full load: 135-250 MW_e (50% efficiency)\n            ]\n        ),\n        'steam_export': Piecewise(\n            [\n                Piece(20, 35),  # Part load: 20-35 MW_th steam\n                Piece(35, 50),  # Full load: 35-50 MW_th steam\n            ]\n        ),\n        'co2_emissions': Piecewise(\n            [\n                Piece(30, 60),  # Part load: 30-60 t/h CO2\n                Piece(60, 100),  # Full load: 60-100 t/h CO2\n            ]\n        ),\n    }\n)\n</code></pre> <p>Chemical reactor with multiple products and waste:</p> Python<pre><code>reactor_pc = PiecewiseConversion(\n    {\n        'feedstock': Piecewise(\n            [\n                Piece(10, 50),  # Small batch: 10-50 kg/h\n                Piece(50, 200),  # Large batch: 50-200 kg/h\n            ]\n        ),\n        'product_A': Piecewise(\n            [\n                Piece(7, 35),  # Small batch: 70% yield\n                Piece(35, 140),  # Large batch: 70% yield\n            ]\n        ),\n        'product_B': Piecewise(\n            [\n                Piece(2, 10),  # Small batch: 20% yield\n                Piece(10, 45),  # Large batch: 22.5% yield (improved)\n            ]\n        ),\n        'waste_stream': Piecewise(\n            [\n                Piece(1, 5),  # Small batch: 10% waste\n                Piece(5, 15),  # Large batch: 7.5% waste (efficiency)\n            ]\n        ),\n    }\n)\n</code></pre> <p>Equipment with discrete operating modes:</p> Python<pre><code>compressor_pc = PiecewiseConversion(\n    {\n        'electricity': Piecewise(\n            [\n                Piece(0, 0),  # Off mode: no consumption\n                Piece(45, 45),  # Low mode: fixed 45 kW\n                Piece(85, 85),  # High mode: fixed 85 kW\n            ]\n        ),\n        'compressed_air': Piecewise(\n            [\n                Piece(0, 0),  # Off mode: no production\n                Piece(250, 250),  # Low mode: 250 Nm\u00b3/h\n                Piece(500, 500),  # High mode: 500 Nm\u00b3/h\n            ]\n        ),\n    }\n)\n</code></pre> <p>Equipment with forbidden operating range:</p> Python<pre><code>steam_turbine_pc = PiecewiseConversion(\n    {\n        'steam_in': Piecewise(\n            [\n                Piece(0, 100),  # Low pressure operation\n                Piece(200, 500),  # High pressure (gap: 100-200 forbidden)\n            ]\n        ),\n        'electricity_out': Piecewise(\n            [\n                Piece(0, 30),  # Low pressure: poor efficiency\n                Piece(80, 220),  # High pressure: good efficiency\n            ]\n        ),\n        'condensate_out': Piecewise(\n            [\n                Piece(0, 100),  # Low pressure condensate\n                Piece(200, 500),  # High pressure condensate\n            ]\n        ),\n    }\n)\n</code></pre> Design Patterns <p>Forbidden Ranges: Use gaps between pieces to model equipment that cannot operate in certain ranges (e.g., minimum loads, unstable regions).</p> <p>Discrete Modes: Use pieces with identical start/end values to model equipment with fixed operating points (e.g., on/off, discrete speeds).</p> <p>Efficiency Changes: Coordinate input and output pieces to reflect changing conversion efficiency across operating ranges.</p> Common Use Cases <ul> <li>Power generation: Multi-fuel plants, cogeneration systems, renewable hybrids</li> <li>HVAC systems: Heat pumps, chillers with variable COP and auxiliary loads</li> <li>Industrial processes: Multi-product reactors, separation units, heat exchangers</li> <li>Transportation: Multi-modal systems, hybrid vehicles, charging infrastructure</li> <li>Water treatment: Multi-stage processes with varying energy and chemical needs</li> <li>Energy storage: Systems with efficiency changes and auxiliary power requirements</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.items","title":"items","text":"Python<pre><code>items()\n</code></pre> <p>Return an iterator over (flow_label, Piecewise) pairs stored in this PiecewiseConversion.</p> <p>This is a thin convenience wrapper around the internal mapping and yields the same view as dict.items(), where each key is a flow label (str) and each value is a Piecewise.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects","title":"PiecewiseEffects","text":"Python<pre><code>PiecewiseEffects(piecewise_origin: Piecewise, piecewise_shares: dict[str, Piecewise])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define how a single decision variable contributes to system effects with piecewise rates.</p> <p>This class models situations where a decision variable (the origin) generates different types of system effects (costs, emissions, resource consumption) at rates that change non-linearly with the variable's operating level. Unlike PiecewiseConversion which coordinates multiple flows, PiecewiseEffects focuses on how one variable impacts multiple system-wide effects.</p> <p>Key Concept - Origin vs. Effects:     - Origin: The primary decision variable (e.g., production level, capacity, size)     - Shares: The amounts which this variable contributes to different system effects</p> Relationship to PiecewiseConversion <p>PiecewiseConversion: Models synchronized relationships between multiple flow variables (e.g., fuel_in, electricity_out, emissions_out all coordinated).</p> <p>PiecewiseEffects: Models how one variable contributes to system-wide effects at variable rates (e.g., production_level \u2192 costs, emissions, resources).</p> <p>Parameters:</p> Name Type Description Default <code>piecewise_origin</code> <code>Piecewise</code> <p>Piecewise function defining the behavior of the primary decision variable. This establishes the operating domain and ranges.</p> required <code>piecewise_shares</code> <code>dict[str, Piecewise]</code> <p>Dictionary mapping effect names to their rate functions. Keys are effect identifiers (e.g., 'cost_per_unit', 'CO2_intensity'). Values are Piecewise objects defining the contribution rate per unit of the origin variable at different operating levels.</p> required Mathematical Relationship <p>For each effect: Total_Effect = Origin_Variable \u00d7 Share_Rate(Origin_Level)</p> <p>This enables modeling of: - Economies of scale (decreasing unit costs with volume) - Learning curves (improving efficiency with experience) - Threshold effects (changing rates at different scales) - Progressive pricing (increasing rates with consumption)</p> <p>Examples:</p> <p>Manufacturing with economies of scale:</p> Python<pre><code>production_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(0, 1000),  # Small scale: 0-1000 units/month\n            Piece(1000, 5000),  # Medium scale: 1000-5000 units/month\n            Piece(5000, 10000),  # Large scale: 5000-10000 units/month\n        ]\n    ),\n    piecewise_shares={\n        'unit_cost': Piecewise(\n            [\n                Piece(50, 45),  # \u20ac50-45/unit (scale benefits)\n                Piece(45, 35),  # \u20ac45-35/unit (bulk materials)\n                Piece(35, 30),  # \u20ac35-30/unit (automation benefits)\n            ]\n        ),\n        'labor_hours': Piecewise(\n            [\n                Piece(2.5, 2.0),  # 2.5-2.0 hours/unit (learning curve)\n                Piece(2.0, 1.5),  # 2.0-1.5 hours/unit (efficiency gains)\n                Piece(1.5, 1.2),  # 1.5-1.2 hours/unit (specialization)\n            ]\n        ),\n        'CO2_intensity': Piecewise(\n            [\n                Piece(15, 12),  # 15-12 kg CO2/unit (process optimization)\n                Piece(12, 9),  # 12-9 kg CO2/unit (equipment efficiency)\n                Piece(9, 7),  # 9-7 kg CO2/unit (renewable energy)\n            ]\n        ),\n    },\n)\n</code></pre> <p>Power generation with load-dependent characteristics:</p> Python<pre><code>generator_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(50, 200),  # Part load operation: 50-200 MW\n            Piece(200, 350),  # Rated operation: 200-350 MW\n            Piece(350, 400),  # Overload operation: 350-400 MW\n        ]\n    ),\n    piecewise_shares={\n        'fuel_rate': Piecewise(\n            [\n                Piece(12.0, 10.5),  # Heat rate: 12.0-10.5 GJ/MWh (part load penalty)\n                Piece(10.5, 9.8),  # Heat rate: 10.5-9.8 GJ/MWh (optimal efficiency)\n                Piece(9.8, 11.2),  # Heat rate: 9.8-11.2 GJ/MWh (overload penalty)\n            ]\n        ),\n        'maintenance_factor': Piecewise(\n            [\n                Piece(0.8, 1.0),  # Low stress operation\n                Piece(1.0, 1.0),  # Design operation\n                Piece(1.0, 1.5),  # High stress operation\n            ]\n        ),\n        'NOx_rate': Piecewise(\n            [\n                Piece(0.20, 0.15),  # NOx: 0.20-0.15 kg/MWh\n                Piece(0.15, 0.12),  # NOx: 0.15-0.12 kg/MWh (optimal combustion)\n                Piece(0.12, 0.25),  # NOx: 0.12-0.25 kg/MWh (overload penalties)\n            ]\n        ),\n    },\n)\n</code></pre> <p>Progressive utility pricing structure:</p> Python<pre><code>electricity_billing = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(0, 200),  # Basic usage: 0-200 kWh/month\n            Piece(200, 800),  # Standard usage: 200-800 kWh/month\n            Piece(800, 2000),  # High usage: 800-2000 kWh/month\n        ]\n    ),\n    piecewise_shares={\n        'energy_rate': Piecewise(\n            [\n                Piece(0.12, 0.12),  # Basic rate: \u20ac0.12/kWh\n                Piece(0.18, 0.18),  # Standard rate: \u20ac0.18/kWh\n                Piece(0.28, 0.28),  # Premium rate: \u20ac0.28/kWh\n            ]\n        ),\n        'carbon_tax': Piecewise(\n            [\n                Piece(0.02, 0.02),  # Low carbon tax: \u20ac0.02/kWh\n                Piece(0.03, 0.03),  # Medium carbon tax: \u20ac0.03/kWh\n                Piece(0.05, 0.05),  # High carbon tax: \u20ac0.05/kWh\n            ]\n        ),\n    },\n)\n</code></pre> <p>Data center with capacity-dependent efficiency:</p> Python<pre><code>datacenter_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(100, 500),  # Low utilization: 100-500 servers\n            Piece(500, 2000),  # Medium utilization: 500-2000 servers\n            Piece(2000, 5000),  # High utilization: 2000-5000 servers\n        ]\n    ),\n    piecewise_shares={\n        'power_per_server': Piecewise(\n            [\n                Piece(0.8, 0.6),  # 0.8-0.6 kW/server (inefficient cooling)\n                Piece(0.6, 0.4),  # 0.6-0.4 kW/server (optimal efficiency)\n                Piece(0.4, 0.5),  # 0.4-0.5 kW/server (thermal limits)\n            ]\n        ),\n        'cooling_overhead': Piecewise(\n            [\n                Piece(0.4, 0.3),  # 40%-30% cooling overhead\n                Piece(0.3, 0.2),  # 30%-20% cooling overhead\n                Piece(0.2, 0.25),  # 20%-25% cooling overhead\n            ]\n        ),\n    },\n)\n</code></pre> Design Patterns <p>Economies of Scale: Decreasing unit costs/impacts with increased scale Learning Curves: Improving efficiency rates with experience/volume Threshold Effects: Step changes in rates at specific operating levels Progressive Pricing: Increasing rates for higher consumption levels Capacity Utilization: Optimal efficiency at design points, penalties at extremes</p> Common Use Cases <ul> <li>Manufacturing: Production scaling, learning effects, quality improvements</li> <li>Energy systems: Generator efficiency curves, renewable capacity factors</li> <li>Logistics: Transportation rates, warehouse utilization, delivery optimization</li> <li>Utilities: Progressive pricing, infrastructure cost allocation</li> <li>Financial services: Risk premiums, transaction fees, volume discounts</li> <li>Environmental modeling: Pollution intensity, resource consumption rates</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters","title":"InvestParameters","text":"Python<pre><code>InvestParameters(fixed_size: PeriodicDataUser | None = None, minimum_size: PeriodicDataUser | None = None, maximum_size: PeriodicDataUser | None = None, mandatory: bool = False, effects_of_investment: PeriodicEffectsUser | None = None, effects_of_investment_per_size: PeriodicEffectsUser | None = None, effects_of_retirement: PeriodicEffectsUser | None = None, piecewise_effects_of_investment: PiecewiseEffects | None = None, linked_periods: PeriodicDataUser | tuple[int, int] | None = None, **kwargs)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define investment decision parameters with flexible sizing and effect modeling.</p> <p>This class models investment decisions in optimization problems, supporting both binary (invest/don't invest) and continuous sizing choices with comprehensive cost structures. It enables realistic representation of investment economics including fixed costs, scale effects, and divestment penalties.</p> Investment Decision Types <p>Binary Investments: Fixed size investments creating yes/no decisions (e.g., install a specific generator, build a particular facility)</p> <p>Continuous Sizing: Variable size investments with minimum/maximum bounds (e.g., battery capacity from 10-1000 kWh, pipeline diameter optimization)</p> Cost Modeling Approaches <ul> <li>Fixed Effects: One-time costs independent of size (permits, connections)</li> <li>Specific Effects: Linear costs proportional to size (\u20ac/kW, \u20ac/m\u00b2)</li> <li>Piecewise Effects: Non-linear relationships (bulk discounts, learning curves)</li> <li>Divestment Effects: Penalties for not investing (demolition, opportunity costs)</li> </ul> Mathematical Formulation <p>See the complete mathematical model in the documentation: InvestParameters</p> <p>Parameters:</p> Name Type Description Default <code>fixed_size</code> <code>PeriodicDataUser | None</code> <p>Creates binary decision at this exact size. None allows continuous sizing.</p> <code>None</code> <code>minimum_size</code> <code>PeriodicDataUser | None</code> <p>Lower bound for continuous sizing. Default: CONFIG.Modeling.epsilon. Ignored if fixed_size is specified.</p> <code>None</code> <code>maximum_size</code> <code>PeriodicDataUser | None</code> <p>Upper bound for continuous sizing. Default: CONFIG.Modeling.big. Ignored if fixed_size is specified.</p> <code>None</code> <code>mandatory</code> <code>bool</code> <p>Controls whether investment is required. When True, forces investment to occur (useful for mandatory upgrades or replacement decisions). When False (default), optimization can choose not to invest. With multiple periods, at least one period has to have an investment.</p> <code>False</code> <code>effects_of_investment</code> <code>PeriodicEffectsUser | None</code> <p>Fixed costs if investment is made, regardless of size. Dict: {'effect_name': value} (e.g., {'cost': 10000}).</p> <code>None</code> <code>effects_of_investment_per_size</code> <code>PeriodicEffectsUser | None</code> <p>Variable costs proportional to size (per-unit costs). Dict: {'effect_name': value/unit} (e.g., {'cost': 1200}).</p> <code>None</code> <code>piecewise_effects_of_investment</code> <code>PiecewiseEffects | None</code> <p>Non-linear costs using PiecewiseEffects. Combinable with effects_of_investment and effects_of_investment_per_size.</p> <code>None</code> <code>effects_of_retirement</code> <code>PeriodicEffectsUser | None</code> <p>Costs incurred if NOT investing (demolition, penalties). Dict: {'effect_name': value}.</p> <code>None</code> <code>linked_periods</code> <code>PeriodicDataUser | tuple[int, int] | None</code> <p>Describes which periods are linked. 1 means linked, 0 means size=0. None means no linked periods. For convenience, pass a tuple containing the first and last period (2025, 2039), linking them and those in between</p> <code>None</code> Deprecated Args <p>fix_effects: Deprecated. Use <code>effects_of_investment</code> instead.     Will be removed in version 4.0. specific_effects: Deprecated. Use <code>effects_of_investment_per_size</code> instead.     Will be removed in version 4.0. divest_effects: Deprecated. Use <code>effects_of_retirement</code> instead.     Will be removed in version 4.0. piecewise_effects: Deprecated. Use <code>piecewise_effects_of_investment</code> instead.     Will be removed in version 4.0. optional: DEPRECATED. Use <code>mandatory</code> instead. Opposite of <code>mandatory</code>.     Will be removed in version 4.0.</p> Cost Annualization Requirements <p>All cost values must be properly weighted to match the optimization model's time horizon. For long-term investments, the cost values should be annualized to the corresponding operation time (annuity).</p> <ul> <li>Use equivalent annual cost (capital cost / equipment lifetime)</li> <li>Apply appropriate discount rates for present value calculations</li> <li>Account for inflation, escalation, and financing costs</li> </ul> <p>Example: \u20ac1M equipment with 20-year life \u2192 \u20ac50k/year fixed cost</p> <p>Examples:</p> <p>Simple binary investment (solar panels):</p> Python<pre><code>solar_investment = InvestParameters(\n    fixed_size=100,  # 100 kW system (binary decision)\n    mandatory=False,  # Investment is optional\n    effects_of_investment={\n        'cost': 25000,  # Installation and permitting costs\n        'CO2': -50000,  # Avoided emissions over lifetime\n    },\n    effects_of_investment_per_size={\n        'cost': 1200,  # \u20ac1200/kW for panels (annualized)\n        'CO2': -800,  # kg CO2 avoided per kW annually\n    },\n)\n</code></pre> <p>Flexible sizing with economies of scale:</p> Python<pre><code>battery_investment = InvestParameters(\n    minimum_size=10,  # Minimum viable system size (kWh)\n    maximum_size=1000,  # Maximum installable capacity\n    mandatory=False,  # Investment is optional\n    effects_of_investment={\n        'cost': 5000,  # Grid connection and control system\n        'installation_time': 2,  # Days for fixed components\n    },\n    piecewise_effects_of_investment=PiecewiseEffects(\n        piecewise_origin=Piecewise(\n            [\n                Piece(0, 100),  # Small systems\n                Piece(100, 500),  # Medium systems\n                Piece(500, 1000),  # Large systems\n            ]\n        ),\n        piecewise_shares={\n            'cost': Piecewise(\n                [\n                    Piece(800, 750),  # High cost/kWh for small systems\n                    Piece(750, 600),  # Medium cost/kWh\n                    Piece(600, 500),  # Bulk discount for large systems\n                ]\n            )\n        },\n    ),\n)\n</code></pre> <p>Mandatory replacement with retirement costs:</p> Python<pre><code>boiler_replacement = InvestParameters(\n    minimum_size=50,\n    maximum_size=200,\n    mandatory=False,  # Can choose not to replace\n    effects_of_investment={\n        'cost': 15000,  # Installation costs\n        'disruption': 3,  # Days of downtime\n    },\n    effects_of_investment_per_size={\n        'cost': 400,  # \u20ac400/kW capacity\n        'maintenance': 25,  # Annual maintenance per kW\n    },\n    effects_of_retirement={\n        'cost': 8000,  # Demolition if not replaced\n        'environmental': 100,  # Disposal fees\n    },\n)\n</code></pre> <p>Multi-technology comparison:</p> Python<pre><code># Gas turbine option\ngas_turbine = InvestParameters(\n    fixed_size=50,  # MW\n    effects_of_investment={'cost': 2500000, 'CO2': 1250000},\n    effects_of_investment_per_size={'fuel_cost': 45, 'maintenance': 12},\n)\n\n# Wind farm option\nwind_farm = InvestParameters(\n    minimum_size=20,\n    maximum_size=100,\n    effects_of_investment={'cost': 1000000, 'CO2': -5000000},\n    effects_of_investment_per_size={'cost': 1800000, 'land_use': 0.5},\n)\n</code></pre> <p>Technology learning curve:</p> Python<pre><code>hydrogen_electrolyzer = InvestParameters(\n    minimum_size=1,\n    maximum_size=50,  # MW\n    piecewise_effects_of_investment=PiecewiseEffects(\n        piecewise_origin=Piecewise(\n            [\n                Piece(0, 5),  # Small scale: early adoption\n                Piece(5, 20),  # Medium scale: cost reduction\n                Piece(20, 50),  # Large scale: mature technology\n            ]\n        ),\n        piecewise_shares={\n            'capex': Piecewise(\n                [\n                    Piece(2000, 1800),  # Learning reduces costs\n                    Piece(1800, 1400),  # Continued cost reduction\n                    Piece(1400, 1200),  # Technology maturity\n                ]\n            ),\n            'efficiency': Piecewise(\n                [\n                    Piece(65, 68),  # Improving efficiency\n                    Piece(68, 72),  # with scale and experience\n                    Piece(72, 75),  # Best efficiency at scale\n                ]\n            ),\n        },\n    ),\n)\n</code></pre> Common Use Cases <ul> <li>Power generation: Plant sizing, technology selection, retrofit decisions</li> <li>Industrial equipment: Capacity expansion, efficiency upgrades, replacements</li> <li>Infrastructure: Network expansion, facility construction, system upgrades</li> <li>Energy storage: Battery sizing, pumped hydro, compressed air systems</li> <li>Transportation: Fleet expansion, charging infrastructure, modal shifts</li> <li>Buildings: HVAC systems, insulation upgrades, renewable integration</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.optional","title":"optional  <code>property</code> <code>writable</code>","text":"Python<pre><code>optional: bool\n</code></pre> <p>DEPRECATED: Use 'mandatory' property instead. Returns the opposite of 'mandatory'.</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.fix_effects","title":"fix_effects  <code>property</code>","text":"Python<pre><code>fix_effects: PeriodicEffectsUser\n</code></pre> <p>Deprecated property. Use effects_of_investment instead.</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.specific_effects","title":"specific_effects  <code>property</code>","text":"Python<pre><code>specific_effects: PeriodicEffectsUser\n</code></pre> <p>Deprecated property. Use effects_of_investment_per_size instead.</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.divest_effects","title":"divest_effects  <code>property</code>","text":"Python<pre><code>divest_effects: PeriodicEffectsUser\n</code></pre> <p>Deprecated property. Use effects_of_retirement instead.</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.piecewise_effects","title":"piecewise_effects  <code>property</code>","text":"Python<pre><code>piecewise_effects: PiecewiseEffects | None\n</code></pre> <p>Deprecated property. Use piecewise_effects_of_investment instead.</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters","title":"OnOffParameters","text":"Python<pre><code>OnOffParameters(effects_per_switch_on: TemporalEffectsUser | None = None, effects_per_running_hour: TemporalEffectsUser | None = None, on_hours_total_min: int | None = None, on_hours_total_max: int | None = None, consecutive_on_hours_min: TemporalDataUser | None = None, consecutive_on_hours_max: TemporalDataUser | None = None, consecutive_off_hours_min: TemporalDataUser | None = None, consecutive_off_hours_max: TemporalDataUser | None = None, switch_on_total_max: int | None = None, force_switch_on: bool = False)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define operational constraints and effects for binary on/off equipment behavior.</p> <p>This class models equipment that operates in discrete states (on/off) rather than continuous operation, capturing realistic operational constraints and associated costs. It handles complex equipment behavior including startup costs, minimum run times, cycling limitations, and maintenance scheduling requirements.</p> Key Modeling Capabilities <p>Switching Costs: One-time costs for starting equipment (fuel, wear, labor) Runtime Constraints: Minimum and maximum continuous operation periods Cycling Limits: Maximum number of starts to prevent excessive wear Operating Hours: Total runtime limits and requirements over time horizon</p> Typical Equipment Applications <ul> <li>Power Plants: Combined cycle units, steam turbines with startup costs</li> <li>Industrial Processes: Batch reactors, furnaces with thermal cycling</li> <li>HVAC Systems: Chillers, boilers with minimum run times</li> <li>Backup Equipment: Emergency generators, standby systems</li> <li>Process Equipment: Compressors, pumps with operational constraints</li> </ul> Mathematical Formulation <p>See the complete mathematical model in the documentation: OnOffParameters</p> <p>Parameters:</p> Name Type Description Default <code>effects_per_switch_on</code> <code>TemporalEffectsUser | None</code> <p>Costs or impacts incurred for each transition from off state (var_on=0) to on state (var_on=1). Represents startup costs, wear and tear, or other switching impacts. Dictionary mapping effect names to values (e.g., {'cost': 500, 'maintenance_hours': 2}).</p> <code>None</code> <code>effects_per_running_hour</code> <code>TemporalEffectsUser | None</code> <p>Ongoing costs or impacts while equipment operates in the on state. Includes fuel costs, labor, consumables, or emissions. Dictionary mapping effect names to hourly values (e.g., {'fuel_cost': 45}).</p> <code>None</code> <code>on_hours_total_min</code> <code>int | None</code> <p>Minimum total operating hours across the entire time horizon. Ensures equipment meets minimum utilization requirements or contractual obligations (e.g., power purchase agreements, maintenance schedules).</p> <code>None</code> <code>on_hours_total_max</code> <code>int | None</code> <p>Maximum total operating hours across the entire time horizon. Limits equipment usage due to maintenance schedules, fuel availability, environmental permits, or equipment lifetime constraints.</p> <code>None</code> <code>consecutive_on_hours_min</code> <code>TemporalDataUser | None</code> <p>Minimum continuous operating duration once started. Models minimum run times due to thermal constraints, process stability, or efficiency considerations. Can be time-varying to reflect different constraints across the planning horizon.</p> <code>None</code> <code>consecutive_on_hours_max</code> <code>TemporalDataUser | None</code> <p>Maximum continuous operating duration in one campaign. Models mandatory maintenance intervals, process batch sizes, or equipment thermal limits requiring periodic shutdowns.</p> <code>None</code> <code>consecutive_off_hours_min</code> <code>TemporalDataUser | None</code> <p>Minimum continuous shutdown duration between operations. Models cooling periods, maintenance requirements, or process constraints that prevent immediate restart after shutdown.</p> <code>None</code> <code>consecutive_off_hours_max</code> <code>TemporalDataUser | None</code> <p>Maximum continuous shutdown duration before mandatory restart. Models equipment preservation, process stability, or contractual requirements for minimum activity levels.</p> <code>None</code> <code>switch_on_total_max</code> <code>int | None</code> <p>Maximum number of startup operations across the time horizon. Limits equipment cycling to reduce wear, maintenance costs, or comply with operational constraints (e.g., grid stability requirements).</p> <code>None</code> <code>force_switch_on</code> <code>bool</code> <p>When True, creates switch-on variables even without explicit switch_on_total_max constraint. Useful for tracking or reporting startup events without enforcing limits.</p> <code>False</code> Note <p>Time Series Boundary Handling: The final time period constraints for consecutive_on_hours_min/max and consecutive_off_hours_min/max are not enforced, allowing the optimization to end with ongoing campaigns that may be shorter than the specified minimums or longer than maximums.</p> <p>Examples:</p> <p>Combined cycle power plant with startup costs and minimum run time:</p> Python<pre><code>power_plant_operation = OnOffParameters(\n    effects_per_switch_on={\n        'startup_cost': 25000,  # \u20ac25,000 per startup\n        'startup_fuel': 150,  # GJ natural gas for startup\n        'startup_time': 4,  # Hours to reach full output\n        'maintenance_impact': 0.1,  # Fractional life consumption\n    },\n    effects_per_running_hour={\n        'fixed_om': 125,  # Fixed O&amp;M costs while running\n        'auxiliary_power': 2.5,  # MW parasitic loads\n    },\n    consecutive_on_hours_min=8,  # Minimum 8-hour run once started\n    consecutive_off_hours_min=4,  # Minimum 4-hour cooling period\n    on_hours_total_max=6000,  # Annual operating limit\n)\n</code></pre> <p>Industrial batch process with cycling limits:</p> Python<pre><code>batch_reactor = OnOffParameters(\n    effects_per_switch_on={\n        'setup_cost': 1500,  # Labor and materials for startup\n        'catalyst_consumption': 5,  # kg catalyst per batch\n        'cleaning_chemicals': 200,  # L cleaning solution\n    },\n    effects_per_running_hour={\n        'steam': 2.5,  # t/h process steam\n        'electricity': 150,  # kWh electrical load\n        'cooling_water': 50,  # m\u00b3/h cooling water\n    },\n    consecutive_on_hours_min=12,  # Minimum batch size (12 hours)\n    consecutive_on_hours_max=24,  # Maximum batch size (24 hours)\n    consecutive_off_hours_min=6,  # Cleaning and setup time\n    switch_on_total_max=200,  # Maximum 200 batches per period\n    on_hours_total_max=4000,  # Maximum production time\n)\n</code></pre> <p>HVAC system with thermostat control and maintenance:</p> Python<pre><code>hvac_operation = OnOffParameters(\n    effects_per_switch_on={\n        'compressor_wear': 0.5,  # Hours of compressor life per start\n        'inrush_current': 15,  # kW peak demand on startup\n    },\n    effects_per_running_hour={\n        'electricity': 25,  # kW electrical consumption\n        'maintenance': 0.12,  # \u20ac/hour maintenance reserve\n    },\n    consecutive_on_hours_min=1,  # Minimum 1-hour run to avoid cycling\n    consecutive_off_hours_min=0.5,  # 30-minute minimum off time\n    switch_on_total_max=2000,  # Limit cycling for compressor life\n    on_hours_total_min=2000,  # Minimum operation for humidity control\n    on_hours_total_max=5000,  # Maximum operation for energy budget\n)\n</code></pre> <p>Backup generator with testing and maintenance requirements:</p> Python<pre><code>backup_generator = OnOffParameters(\n    effects_per_switch_on={\n        'fuel_priming': 50,  # L diesel for system priming\n        'wear_factor': 1.0,  # Start cycles impact on maintenance\n        'testing_labor': 2,  # Hours technician time per test\n    },\n    effects_per_running_hour={\n        'fuel_consumption': 180,  # L/h diesel consumption\n        'emissions_permit': 15,  # \u20ac emissions allowance cost\n        'noise_penalty': 25,  # \u20ac noise compliance cost\n    },\n    consecutive_on_hours_min=0.5,  # Minimum test duration (30 min)\n    consecutive_off_hours_max=720,  # Maximum 30 days between tests\n    switch_on_total_max=52,  # Weekly testing limit\n    on_hours_total_min=26,  # Minimum annual testing (0.5h \u00d7 52)\n    on_hours_total_max=200,  # Maximum runtime (emergencies + tests)\n)\n</code></pre> <p>Peak shaving battery with cycling degradation:</p> Python<pre><code>battery_cycling = OnOffParameters(\n    effects_per_switch_on={\n        'cycle_degradation': 0.01,  # % capacity loss per cycle\n        'inverter_startup': 0.5,  # kWh losses during startup\n    },\n    effects_per_running_hour={\n        'standby_losses': 2,  # kW standby consumption\n        'cooling': 5,  # kW thermal management\n        'inverter_losses': 8,  # kW conversion losses\n    },\n    consecutive_on_hours_min=1,  # Minimum discharge duration\n    consecutive_on_hours_max=4,  # Maximum continuous discharge\n    consecutive_off_hours_min=1,  # Minimum rest between cycles\n    switch_on_total_max=365,  # Daily cycling limit\n    force_switch_on=True,  # Track all cycling events\n)\n</code></pre> Common Use Cases <ul> <li>Power generation: Thermal plant cycling, renewable curtailment, grid services</li> <li>Industrial processes: Batch production, maintenance scheduling, equipment rotation</li> <li>Buildings: HVAC control, lighting systems, elevator operations</li> <li>Transportation: Fleet management, charging infrastructure, maintenance windows</li> <li>Storage systems: Battery cycling, pumped hydro, compressed air systems</li> <li>Emergency equipment: Backup generators, safety systems, emergency lighting</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.use_off","title":"use_off  <code>property</code>","text":"Python<pre><code>use_off: bool\n</code></pre> <p>Proxy: whether OFF variable is required</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.use_consecutive_on_hours","title":"use_consecutive_on_hours  <code>property</code>","text":"Python<pre><code>use_consecutive_on_hours: bool\n</code></pre> <p>Determines whether a Variable for consecutive on hours is needed or not</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.use_consecutive_off_hours","title":"use_consecutive_off_hours  <code>property</code>","text":"Python<pre><code>use_consecutive_off_hours: bool\n</code></pre> <p>Determines whether a Variable for consecutive off hours is needed or not</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.use_switch_on","title":"use_switch_on  <code>property</code>","text":"Python<pre><code>use_switch_on: bool\n</code></pre> <p>Determines whether a variable for switch_on is needed or not</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/interface/#flixopt.interface-functions","title":"Functions","text":""},{"location":"api-reference/io/","title":"Io","text":""},{"location":"api-reference/io/#flixopt.io","title":"flixopt.io","text":""},{"location":"api-reference/io/#flixopt.io-classes","title":"Classes","text":""},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths","title":"CalculationResultsPaths  <code>dataclass</code>","text":"Python<pre><code>CalculationResultsPaths(folder: Path, name: str)\n</code></pre> <p>Container for all paths related to saving CalculationResults.</p>"},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths-functions","title":"Functions","text":""},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths.all_paths","title":"all_paths","text":"Python<pre><code>all_paths() -&gt; dict[str, pathlib.Path]\n</code></pre> <p>Return a dictionary of all paths.</p>"},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths.create_folders","title":"create_folders","text":"Python<pre><code>create_folders(parents: bool = False) -&gt; None\n</code></pre> <p>Ensure the folder exists. Args:     parents: Whether to create the parent folders if they do not exist.</p>"},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths.update","title":"update","text":"Python<pre><code>update(new_name: str | None = None, new_folder: Path | None = None) -&gt; None\n</code></pre> <p>Update name and/or folder and refresh all paths.</p>"},{"location":"api-reference/io/#flixopt.io-functions","title":"Functions","text":""},{"location":"api-reference/io/#flixopt.io.remove_none_and_empty","title":"remove_none_and_empty","text":"Python<pre><code>remove_none_and_empty(obj)\n</code></pre> <p>Recursively removes None and empty dicts and lists values from a dictionary or list.</p>"},{"location":"api-reference/io/#flixopt.io.round_nested_floats","title":"round_nested_floats","text":"Python<pre><code>round_nested_floats(obj: dict | list | float | int | Any, decimals: int = 2) -&gt; dict | list | float | int | Any\n</code></pre> <p>Recursively round floating point numbers in nested data structures and convert it to python native types.</p> <p>This function traverses nested data structures (dictionaries, lists) and rounds any floating point numbers to the specified number of decimal places. It handles various data types including NumPy arrays and xarray DataArrays by converting them to lists with rounded values.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>dict | list | float | int | Any</code> <p>The object to process. Can be a dict, list, float, int, numpy.ndarray, xarray.DataArray, or any other type.</p> required <code>decimals</code> <code>int</code> <p>Number of decimal places to round to. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Type Description <code>dict | list | float | int | Any</code> <p>The processed object with the same structure as the input, but with all floating point numbers rounded to the specified precision. NumPy arrays and xarray DataArrays are converted to lists.</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; data = {'a': 3.14159, 'b': [1.234, 2.678]}\n&gt;&gt;&gt; round_nested_floats(data, decimals=2)\n{'a': 3.14, 'b': [1.23, 2.68]}\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; arr = np.array([1.234, 5.678])\n&gt;&gt;&gt; round_nested_floats(arr, decimals=1)\n[1.2, 5.7]\n</code></pre>"},{"location":"api-reference/io/#flixopt.io.load_json","title":"load_json","text":"Python<pre><code>load_json(path: str | Path) -&gt; dict | list\n</code></pre> <p>Load data from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the JSON file.</p> required <p>Returns:</p> Type Description <code>dict | list</code> <p>Loaded data (typically dict or list).</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>JSONDecodeError</code> <p>If the file is not valid JSON.</p>"},{"location":"api-reference/io/#flixopt.io.save_json","title":"save_json","text":"Python<pre><code>save_json(data: dict | list, path: str | Path, indent: int = 4, ensure_ascii: bool = False, **kwargs) -&gt; None\n</code></pre> <p>Save data to a JSON file with consistent formatting.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | list</code> <p>Data to save (dict or list).</p> required <code>path</code> <code>str | Path</code> <p>Path to save the JSON file.</p> required <code>indent</code> <code>int</code> <p>Number of spaces for indentation (default: 4).</p> <code>4</code> <code>ensure_ascii</code> <code>bool</code> <p>If False, allow Unicode characters (default: False).</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments to pass to json.dump().</p> <code>{}</code>"},{"location":"api-reference/io/#flixopt.io.load_yaml","title":"load_yaml","text":"Python<pre><code>load_yaml(path: str | Path) -&gt; dict | list\n</code></pre> <p>Load data from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the YAML file.</p> required <p>Returns:</p> Type Description <code>dict | list</code> <p>Loaded data (typically dict or list), or empty dict if file is empty.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>YAMLError</code> <p>If the file is not valid YAML.</p> <code>Note</code> <p>Returns {} for empty YAML files instead of None.</p>"},{"location":"api-reference/io/#flixopt.io.save_yaml","title":"save_yaml","text":"Python<pre><code>save_yaml(data: dict | list, path: str | Path, indent: int = 4, width: int = 1000, allow_unicode: bool = True, sort_keys: bool = False, **kwargs) -&gt; None\n</code></pre> <p>Save data to a YAML file with consistent formatting.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | list</code> <p>Data to save (dict or list).</p> required <code>path</code> <code>str | Path</code> <p>Path to save the YAML file.</p> required <code>indent</code> <code>int</code> <p>Number of spaces for indentation (default: 4).</p> <code>4</code> <code>width</code> <code>int</code> <p>Maximum line width (default: 1000).</p> <code>1000</code> <code>allow_unicode</code> <code>bool</code> <p>If True, allow Unicode characters (default: True).</p> <code>True</code> <code>sort_keys</code> <code>bool</code> <p>If True, sort dictionary keys (default: False).</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments to pass to yaml.safe_dump().</p> <code>{}</code>"},{"location":"api-reference/io/#flixopt.io.load_config_file","title":"load_config_file","text":"Python<pre><code>load_config_file(path: str | Path) -&gt; dict\n</code></pre> <p>Load a configuration file, automatically detecting JSON or YAML format.</p> <p>This function intelligently tries to load the file based on its extension, with fallback support if the primary format fails.</p> <p>Supported extensions: - .json: Tries JSON first, falls back to YAML - .yaml, .yml: Tries YAML first, falls back to JSON - Others: Tries YAML, then JSON</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the configuration file.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Loaded configuration as a dictionary.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>ValueError</code> <p>If neither JSON nor YAML parsing succeeds.</p>"},{"location":"api-reference/io/#flixopt.io.document_linopy_model","title":"document_linopy_model","text":"Python<pre><code>document_linopy_model(model: Model, path: Path | None = None) -&gt; dict[str, str]\n</code></pre> <p>Convert all model variables and constraints to a structured string representation. This can take multiple seconds for large models. The output can be saved to a yaml file with readable formating applied.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to save the document. Defaults to None.</p> <code>None</code>"},{"location":"api-reference/io/#flixopt.io.save_dataset_to_netcdf","title":"save_dataset_to_netcdf","text":"Python<pre><code>save_dataset_to_netcdf(ds: Dataset, path: str | Path, compression: int = 0) -&gt; None\n</code></pre> <p>Save a dataset to a netcdf file. Store all attrs as JSON strings in 'attrs' attributes.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset to save.</p> required <code>path</code> <code>str | Path</code> <p>Path to save the dataset to.</p> required <code>compression</code> <code>int</code> <p>Compression level for the dataset (0-9). 0 means no compression. 5 is a good default.</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path has an invalid file extension.</p>"},{"location":"api-reference/io/#flixopt.io.load_dataset_from_netcdf","title":"load_dataset_from_netcdf","text":"Python<pre><code>load_dataset_from_netcdf(path: str | Path) -&gt; xr.Dataset\n</code></pre> <p>Load a dataset from a netcdf file. Load all attrs from 'attrs' attributes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to load the dataset from.</p> required <p>Returns:</p> Name Type Description <code>Dataset</code> <code>Dataset</code> <p>Loaded dataset with restored attrs.</p>"},{"location":"api-reference/linear_converters/","title":"Linear converters","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters","title":"flixopt.linear_converters","text":"<p>This Module contains high-level classes to easily model a FlowSystem.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters-attributes","title":"Attributes","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters-classes","title":"Classes","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler","title":"Boiler","text":"Python<pre><code>Boiler(label: str, eta: TemporalDataUser, Q_fu: Flow, Q_th: Flow, on_off_parameters: OnOffParameters | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing a fuel-fired boiler for thermal energy generation.</p> <p>Boilers convert fuel input into thermal energy with a specified efficiency factor. This is a simplified wrapper around LinearConverter with predefined conversion relationships for thermal generation applications.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>eta</code> <code>TemporalDataUser</code> <p>Thermal efficiency factor (0-1 range). Defines the ratio of thermal output to fuel input energy content.</p> required <code>Q_fu</code> <code>Flow</code> <p>Fuel input-flow representing fuel consumption.</p> required <code>Q_th</code> <code>Flow</code> <p>Thermal output-flow representing heat generation.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Natural gas boiler:</p> Python<pre><code>gas_boiler = Boiler(\n    label='natural_gas_boiler',\n    eta=0.85,  # 85% thermal efficiency\n    Q_fu=natural_gas_flow,\n    Q_th=hot_water_flow,\n)\n</code></pre> <p>Biomass boiler with seasonal efficiency variation:</p> Python<pre><code>biomass_boiler = Boiler(\n    label='wood_chip_boiler',\n    eta=seasonal_efficiency_profile,  # Time-varying efficiency\n    Q_fu=biomass_flow,\n    Q_th=district_heat_flow,\n    on_off_parameters=OnOffParameters(\n        consecutive_on_hours_min=4,  # Minimum 4-hour operation\n        effects_per_switch_on={'startup_fuel': 50},  # Startup fuel penalty\n    ),\n)\n</code></pre> Note <p>The conversion relationship is: Q_th = Q_fu \u00d7 eta</p> <p>Efficiency should be between 0 and 1, where 1 represents perfect conversion (100% of fuel energy converted to useful thermal output).</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat","title":"Power2Heat","text":"Python<pre><code>Power2Heat(label: str, eta: TemporalDataUser, P_el: Flow, Q_th: Flow, on_off_parameters: OnOffParameters | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing electric resistance heating or power-to-heat conversion.</p> <p>Power2Heat components convert electrical energy directly into thermal energy through resistance heating elements, electrode boilers, or other direct electric heating technologies. This is a simplified wrapper around LinearConverter with predefined conversion relationships for electric heating applications.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>eta</code> <code>TemporalDataUser</code> <p>Thermal efficiency factor (0-1 range). For resistance heating this is typically close to 1.0 (nearly 100% efficiency), but may be lower for electrode boilers or systems with distribution losses.</p> required <code>P_el</code> <code>Flow</code> <p>Electrical input-flow representing electricity consumption.</p> required <code>Q_th</code> <code>Flow</code> <p>Thermal output-flow representing heat generation.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Electric resistance heater:</p> Python<pre><code>electric_heater = Power2Heat(\n    label='resistance_heater',\n    eta=0.98,  # 98% efficiency (small losses)\n    P_el=electricity_flow,\n    Q_th=space_heating_flow,\n)\n</code></pre> <p>Electrode boiler for industrial steam:</p> Python<pre><code>electrode_boiler = Power2Heat(\n    label='electrode_steam_boiler',\n    eta=0.95,  # 95% efficiency including boiler losses\n    P_el=industrial_electricity,\n    Q_th=process_steam_flow,\n    on_off_parameters=OnOffParameters(\n        consecutive_on_hours_min=1,  # Minimum 1-hour operation\n        effects_per_switch_on={'startup_cost': 100},\n    ),\n)\n</code></pre> Note <p>The conversion relationship is: Q_th = P_el \u00d7 eta</p> <p>Unlike heat pumps, Power2Heat systems cannot exceed 100% efficiency (eta \u2264 1.0) as they only convert electrical energy without extracting additional energy from the environment. However, they provide fast response times and precise temperature control.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump","title":"HeatPump","text":"Python<pre><code>HeatPump(label: str, COP: TemporalDataUser, P_el: Flow, Q_th: Flow, on_off_parameters: OnOffParameters | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing an electric heat pump for thermal energy generation.</p> <p>Heat pumps convert electrical energy into thermal energy with a Coefficient of Performance (COP) greater than 1, making them more efficient than direct electric heating. This is a simplified wrapper around LinearConverter with predefined conversion relationships for heat pump applications.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>COP</code> <code>TemporalDataUser</code> <p>Coefficient of Performance (typically 1-20 range). Defines the ratio of thermal output to electrical input. COP &gt; 1 indicates the heat pump extracts additional energy from the environment.</p> required <code>P_el</code> <code>Flow</code> <p>Electrical input-flow representing electricity consumption.</p> required <code>Q_th</code> <code>Flow</code> <p>Thermal output-flow representing heat generation.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Air-source heat pump with constant COP:</p> Python<pre><code>air_hp = HeatPump(\n    label='air_source_heat_pump',\n    COP=3.5,  # COP of 3.5 (350% efficiency)\n    P_el=electricity_flow,\n    Q_th=heating_flow,\n)\n</code></pre> <p>Ground-source heat pump with temperature-dependent COP:</p> Python<pre><code>ground_hp = HeatPump(\n    label='geothermal_heat_pump',\n    COP=temperature_dependent_cop,  # Time-varying COP based on ground temp\n    P_el=electricity_flow,\n    Q_th=radiant_heating_flow,\n    on_off_parameters=OnOffParameters(\n        consecutive_on_hours_min=2,  # Avoid frequent cycling\n        effects_per_running_hour={'maintenance': 0.5},\n    ),\n)\n</code></pre> Note <p>The conversion relationship is: Q_th = P_el \u00d7 COP</p> <p>COP should be greater than 1 for realistic heat pump operation, with typical values ranging from 2-6 depending on technology and operating conditions. Higher COP values indicate more efficient heat extraction from the environment.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower","title":"CoolingTower","text":"Python<pre><code>CoolingTower(label: str, specific_electricity_demand: TemporalDataUser, P_el: Flow, Q_th: Flow, on_off_parameters: OnOffParameters | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing a cooling tower for waste heat rejection.</p> <p>Cooling towers consume electrical energy (for fans, pumps) to reject thermal energy to the environment through evaporation and heat transfer. The electricity demand is typically a small fraction of the thermal load being rejected. This component has no thermal outputs as the heat is rejected to the environment.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>specific_electricity_demand</code> <code>TemporalDataUser</code> <p>Auxiliary electricity demand per unit of cooling power (dimensionless, typically 0.01-0.05 range). Represents the fraction of thermal power that must be supplied as electricity for fans and pumps.</p> required <code>P_el</code> <code>Flow</code> <p>Electrical input-flow representing electricity consumption for fans/pumps.</p> required <code>Q_th</code> <code>Flow</code> <p>Thermal input-flow representing waste heat to be rejected to environment.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Industrial cooling tower:</p> Python<pre><code>cooling_tower = CoolingTower(\n    label='process_cooling_tower',\n    specific_electricity_demand=0.025,  # 2.5% auxiliary power\n    P_el=cooling_electricity,\n    Q_th=waste_heat_flow,\n)\n</code></pre> <p>Power plant condenser cooling:</p> Python<pre><code>condenser_cooling = CoolingTower(\n    label='power_plant_cooling',\n    specific_electricity_demand=0.015,  # 1.5% auxiliary power\n    P_el=auxiliary_electricity,\n    Q_th=condenser_waste_heat,\n    on_off_parameters=OnOffParameters(\n        consecutive_on_hours_min=4,  # Minimum operation time\n        effects_per_running_hour={'water_consumption': 2.5},  # m\u00b3/h\n    ),\n)\n</code></pre> Note <p>The conversion relationship is: P_el = Q_th \u00d7 specific_electricity_demand</p> <p>The cooling tower consumes electrical power proportional to the thermal load. No thermal energy is produced - all thermal input is rejected to the environment.</p> <p>Typical specific electricity demands range from 1-5% of the thermal cooling load, depending on tower design, climate conditions, and operational requirements.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP","title":"CHP","text":"Python<pre><code>CHP(label: str, eta_th: TemporalDataUser, eta_el: TemporalDataUser, Q_fu: Flow, P_el: Flow, Q_th: Flow, on_off_parameters: OnOffParameters | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing a Combined Heat and Power (CHP) unit.</p> <p>CHP units simultaneously generate both electrical and thermal energy from a single fuel input, providing higher overall efficiency than separate generation. This is a wrapper around LinearConverter with predefined conversion relationships for cogeneration applications.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>eta_th</code> <code>TemporalDataUser</code> <p>Thermal efficiency factor (0-1 range). Defines the fraction of fuel energy converted to useful thermal output.</p> required <code>eta_el</code> <code>TemporalDataUser</code> <p>Electrical efficiency factor (0-1 range). Defines the fraction of fuel energy converted to electrical output.</p> required <code>Q_fu</code> <code>Flow</code> <p>Fuel input-flow representing fuel consumption.</p> required <code>P_el</code> <code>Flow</code> <p>Electrical output-flow representing electricity generation.</p> required <code>Q_th</code> <code>Flow</code> <p>Thermal output-flow representing heat generation.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Natural gas CHP unit:</p> Python<pre><code>gas_chp = CHP(\n    label='natural_gas_chp',\n    eta_th=0.45,  # 45% thermal efficiency\n    eta_el=0.35,  # 35% electrical efficiency (80% total)\n    Q_fu=natural_gas_flow,\n    P_el=electricity_flow,\n    Q_th=district_heat_flow,\n)\n</code></pre> <p>Industrial CHP with operational constraints:</p> Python<pre><code>industrial_chp = CHP(\n    label='industrial_chp',\n    eta_th=0.40,\n    eta_el=0.38,\n    Q_fu=fuel_gas_flow,\n    P_el=plant_electricity,\n    Q_th=process_steam,\n    on_off_parameters=OnOffParameters(\n        consecutive_on_hours_min=8,  # Minimum 8-hour operation\n        effects_per_switch_on={'startup_cost': 5000},\n        on_hours_total_max=6000,  # Annual operating limit\n    ),\n)\n</code></pre> Note <p>The conversion relationships are: - Q_th = Q_fu \u00d7 eta_th (thermal output) - P_el = Q_fu \u00d7 eta_el (electrical output)</p> <p>Total efficiency (eta_th + eta_el) should be \u2264 1.0, with typical combined efficiencies of 80-90% for modern CHP units. This provides significant efficiency gains compared to separate heat and power generation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource","title":"HeatPumpWithSource","text":"Python<pre><code>HeatPumpWithSource(label: str, COP: TemporalDataUser, P_el: Flow, Q_ab: Flow, Q_th: Flow, on_off_parameters: OnOffParameters | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing a heat pump with explicit heat source modeling.</p> <p>This component models a heat pump that extracts thermal energy from a heat source (ground, air, water) and upgrades it using electrical energy to provide higher-grade thermal output. Unlike the simple HeatPump class, this explicitly models both the heat source extraction and electrical consumption with their interdependent relationships.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>COP</code> <code>TemporalDataUser</code> <p>Coefficient of Performance (typically 1-20 range). Defines the ratio of thermal output to electrical input. The heat source extraction is automatically calculated as Q_ab = Q_th \u00d7 (COP-1)/COP.</p> required <code>P_el</code> <code>Flow</code> <p>Electrical input-flow representing electricity consumption for compressor.</p> required <code>Q_ab</code> <code>Flow</code> <p>Heat source input-flow representing thermal energy extracted from environment (ground, air, water source).</p> required <code>Q_th</code> <code>Flow</code> <p>Thermal output-flow representing useful heat delivered to the application.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Ground-source heat pump with explicit ground coupling:</p> Python<pre><code>ground_source_hp = HeatPumpWithSource(\n    label='geothermal_heat_pump',\n    COP=4.5,  # High COP due to stable ground temperature\n    P_el=electricity_flow,\n    Q_ab=ground_heat_extraction,  # Heat extracted from ground loop\n    Q_th=building_heating_flow,\n)\n</code></pre> <p>Air-source heat pump with temperature-dependent performance:</p> Python<pre><code>waste_heat_pump = HeatPumpWithSource(\n    label='waste_heat_pump',\n    COP=temperature_dependent_cop,  # Varies with temperature of heat source\n    P_el=electricity_consumption,\n    Q_ab=industrial_heat_extraction,  # Heat extracted from a industrial process or waste water\n    Q_th=heat_supply,\n    on_off_parameters=OnOffParameters(\n        consecutive_on_hours_min=0.5,  # 30-minute minimum runtime\n        effects_per_switch_on={'costs': 1000},\n    ),\n)\n</code></pre> Note <p>The conversion relationships are: - Q_th = P_el \u00d7 COP (thermal output from electrical input) - Q_ab = Q_th \u00d7 (COP-1)/COP (heat source extraction) - Energy balance: Q_th = P_el + Q_ab</p> <p>This formulation explicitly tracks the heat source, which is important for systems where the source capacity or temperature is limited, or where the impact of heat extraction must be considered.</p> <p>COP should be &gt; 1 for thermodynamically valid operation, with typical values of 2-6 depending on source and sink temperatures.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.check_bounds","title":"check_bounds","text":"Python<pre><code>check_bounds(value: TemporalDataUser, parameter_label: str, element_label: str, lower_bound: TemporalDataUser, upper_bound: TemporalDataUser) -&gt; None\n</code></pre> <p>Check if the value is within the bounds. The bounds are exclusive. If not, log a warning. Args:     value: The value to check.     parameter_label: The label of the value.     element_label: The label of the element.     lower_bound: The lower bound.     upper_bound: The upper bound.</p>"},{"location":"api-reference/modeling/","title":"Modeling","text":""},{"location":"api-reference/modeling/#flixopt.modeling","title":"flixopt.modeling","text":""},{"location":"api-reference/modeling/#flixopt.modeling-attributes","title":"Attributes","text":""},{"location":"api-reference/modeling/#flixopt.modeling-classes","title":"Classes","text":""},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilitiesAbstract","title":"ModelingUtilitiesAbstract","text":"<p>Utility functions for modeling calculations - leveraging xarray for temporal data</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilitiesAbstract-functions","title":"Functions","text":""},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilitiesAbstract.to_binary","title":"to_binary  <code>staticmethod</code>","text":"Python<pre><code>to_binary(values: DataArray, epsilon: float | None = None, dims: str | list[str] | None = None) -&gt; xr.DataArray\n</code></pre> <p>Converts a DataArray to binary {0, 1} values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>DataArray</code> <p>Input DataArray to convert to binary</p> required <code>epsilon</code> <code>float | None</code> <p>Tolerance for zero detection (uses CONFIG.Modeling.epsilon if None)</p> <code>None</code> <code>dims</code> <code>str | list[str] | None</code> <p>Dims to keep. Other dimensions are collapsed using .any() -&gt; If any value is 1, all are 1.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>Binary DataArray with same shape (or collapsed if collapse_non_time=True)</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilitiesAbstract.count_consecutive_states","title":"count_consecutive_states  <code>staticmethod</code>","text":"Python<pre><code>count_consecutive_states(binary_values: DataArray | ndarray | list[int, float], dim: str = 'time', epsilon: float | None = None) -&gt; float\n</code></pre> <p>Count consecutive steps in the final active state of a binary time series.</p> <p>This function counts how many consecutive time steps the series remains \"on\" (non-zero) at the end of the time series. If the final state is \"off\", returns 0.</p> <p>Parameters:</p> Name Type Description Default <code>binary_values</code> <code>DataArray | ndarray | list[int, float]</code> <p>Binary DataArray with values close to 0 (off) or 1 (on).</p> required <code>dim</code> <code>str</code> <p>Dimension along which to count consecutive states.</p> <code>'time'</code> <code>epsilon</code> <code>float | None</code> <p>Tolerance for zero detection. Uses CONFIG.Modeling.epsilon if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Sum of values in the final consecutive \"on\" period. Returns 0.0 if the</p> <code>float</code> <p>final state is \"off\".</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; arr = xr.DataArray([0, 0, 1, 1, 1, 0, 1, 1], dims=['time'])\n&gt;&gt;&gt; ModelingUtilitiesAbstract.count_consecutive_states(arr)\n2.0\n</code></pre> Python Console Session<pre><code>&gt;&gt;&gt; arr = [0, 0, 1, 0, 1, 1, 1, 1]\n&gt;&gt;&gt; ModelingUtilitiesAbstract.count_consecutive_states(arr)\n4.0\n</code></pre>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilities","title":"ModelingUtilities","text":""},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilities-functions","title":"Functions","text":""},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilities.compute_consecutive_hours_in_state","title":"compute_consecutive_hours_in_state  <code>staticmethod</code>","text":"Python<pre><code>compute_consecutive_hours_in_state(binary_values: TemporalData, hours_per_timestep: int | float, epsilon: float = None) -&gt; float\n</code></pre> <p>Computes the final consecutive duration in state 'on' (=1) in hours.</p> <p>Parameters:</p> Name Type Description Default <code>binary_values</code> <code>TemporalData</code> <p>Binary DataArray with 'time' dim, or scalar/array</p> required <code>hours_per_timestep</code> <code>int | float</code> <p>Duration of each timestep in hours</p> required <code>epsilon</code> <code>float</code> <p>Tolerance for zero detection (uses CONFIG.Modeling.epsilon if None)</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>The duration of the final consecutive 'on' period in hours</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilities.compute_previous_off_duration","title":"compute_previous_off_duration  <code>staticmethod</code>","text":"Python<pre><code>compute_previous_off_duration(previous_values: DataArray, hours_per_step: DataArray | float | int) -&gt; float\n</code></pre> <p>Compute previous consecutive 'off' duration.</p> <p>Parameters:</p> Name Type Description Default <code>previous_values</code> <code>DataArray</code> <p>DataArray with 'time' dimension</p> required <code>hours_per_step</code> <code>DataArray | float | int</code> <p>Duration of each timestep in hours</p> required <p>Returns:</p> Type Description <code>float</code> <p>Previous consecutive off duration in hours</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilities.get_most_recent_state","title":"get_most_recent_state  <code>staticmethod</code>","text":"Python<pre><code>get_most_recent_state(previous_values: DataArray | None) -&gt; int\n</code></pre> <p>Get the most recent binary state from previous values.</p> <p>Parameters:</p> Name Type Description Default <code>previous_values</code> <code>DataArray | None</code> <p>DataArray with 'time' dimension</p> required <p>Returns:</p> Type Description <code>int</code> <p>Most recent binary state (0 or 1)</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingPrimitives","title":"ModelingPrimitives","text":"<p>Mathematical modeling primitives returning (variables, constraints) tuples</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingPrimitives-functions","title":"Functions","text":""},{"location":"api-reference/modeling/#flixopt.modeling.ModelingPrimitives.expression_tracking_variable","title":"expression_tracking_variable  <code>staticmethod</code>","text":"Python<pre><code>expression_tracking_variable(model: Submodel, tracked_expression, name: str = None, short_name: str = None, bounds: tuple[TemporalData, TemporalData] = None, coords: str | list[str] | None = None) -&gt; tuple[linopy.Variable, linopy.Constraint]\n</code></pre> <p>Creates variable that equals a given expression.</p> Mathematical formulation <p>tracker = expression lower \u2264 tracker \u2264 upper (if bounds provided)</p> <p>Returns:</p> Name Type Description <code>variables</code> <code>Variable</code> <p>{'tracker': tracker_var}</p> <code>constraints</code> <code>Constraint</code> <p>{'tracking': constraint}</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingPrimitives.consecutive_duration_tracking","title":"consecutive_duration_tracking  <code>staticmethod</code>","text":"Python<pre><code>consecutive_duration_tracking(model: Submodel, state_variable: Variable, name: str = None, short_name: str = None, minimum_duration: TemporalData | None = None, maximum_duration: TemporalData | None = None, duration_dim: str = 'time', duration_per_step: int | float | TemporalData = None, previous_duration: TemporalData = 0) -&gt; tuple[linopy.Variable, tuple[linopy.Constraint, linopy.Constraint, linopy.Constraint]]\n</code></pre> <p>Creates consecutive duration tracking for a binary state variable.</p> Mathematical formulation <p>duration[t] \u2264 state[t] * M  \u2200t duration[t+1] \u2264 duration[t] + duration_per_step[t]  \u2200t duration[t+1] \u2265 duration[t] + duration_per_step[t] + (state[t+1] - 1) * M  \u2200t duration[0] = (duration_per_step[0] + previous_duration) * state[0]</p> <p>If minimum_duration provided:     duration[t] \u2265 (state[t-1] - state[t]) * minimum_duration[t-1]  \u2200t &gt; 0</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the duration variable</p> <code>None</code> <code>state_variable</code> <code>Variable</code> <p>Binary state variable to track duration for</p> required <code>minimum_duration</code> <code>TemporalData | None</code> <p>Optional minimum consecutive duration</p> <code>None</code> <code>maximum_duration</code> <code>TemporalData | None</code> <p>Optional maximum consecutive duration</p> <code>None</code> <code>previous_duration</code> <code>TemporalData</code> <p>Duration from before first timestep</p> <code>0</code> <p>Returns:</p> Name Type Description <code>variables</code> <code>Variable</code> <p>{'duration': duration_var}</p> <code>constraints</code> <code>tuple[Constraint, Constraint, Constraint]</code> <p>{'ub': constraint, 'forward': constraint, 'backward': constraint, ...}</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingPrimitives.mutual_exclusivity_constraint","title":"mutual_exclusivity_constraint  <code>staticmethod</code>","text":"Python<pre><code>mutual_exclusivity_constraint(model: Submodel, binary_variables: list[Variable], tolerance: float = 1, short_name: str = 'mutual_exclusivity') -&gt; linopy.Constraint\n</code></pre> <p>Creates mutual exclusivity constraint for binary variables.</p> Mathematical formulation <p>\u03a3(binary_vars[i]) \u2264 tolerance  \u2200t</p> <p>Ensures at most one binary variable can be 1 at any time. Tolerance &gt; 1.0 accounts for binary variable numerical precision.</p> <p>Parameters:</p> Name Type Description Default <code>binary_variables</code> <code>list[Variable]</code> <p>List of binary variables that should be mutually exclusive</p> required <code>tolerance</code> <code>float</code> <p>Upper bound</p> <code>1</code> <code>short_name</code> <code>str</code> <p>Short name of the constraint</p> <code>'mutual_exclusivity'</code> <p>Returns:</p> Name Type Description <code>variables</code> <code>Constraint</code> <p>{} (no new variables created)</p> <code>constraints</code> <code>Constraint</code> <p>{'mutual_exclusivity': constraint}</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If fewer than 2 variables provided or variables aren't binary</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns","title":"BoundingPatterns","text":"<p>High-level patterns that compose primitives and return (variables, constraints) tuples</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns-functions","title":"Functions","text":""},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns.basic_bounds","title":"basic_bounds  <code>staticmethod</code>","text":"Python<pre><code>basic_bounds(model: Submodel, variable: Variable, bounds: tuple[TemporalData, TemporalData], name: str = None) -&gt; list[linopy.constraints.Constraint]\n</code></pre> <p>Create simple bounds. variable \u2208 [lower_bound, upper_bound]</p> Mathematical Formulation <p>lower_bound \u2264 variable \u2264 upper_bound</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The optimization model instance</p> required <code>variable</code> <code>Variable</code> <p>Variable to be bounded</p> required <code>bounds</code> <code>tuple[TemporalData, TemporalData]</code> <p>Tuple of (lower_bound, upper_bound) absolute bounds</p> required <p>Returns:</p> Type Description <code>list[Constraint]</code> <p>List containing lower_bound and upper_bound constraints</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns.bounds_with_state","title":"bounds_with_state  <code>staticmethod</code>","text":"Python<pre><code>bounds_with_state(model: Submodel, variable: Variable, bounds: tuple[TemporalData, TemporalData], variable_state: Variable, name: str = None) -&gt; list[linopy.Constraint]\n</code></pre> <p>Constraint a variable to bounds, that can be escaped from to 0 by a binary variable. variable \u2208 {0, [max(\u03b5, lower_bound), upper_bound]}</p> Mathematical Formulation <ul> <li>variable_state * max(\u03b5, lower_bound) \u2264 variable \u2264 variable_state * upper_bound</li> </ul> Use Cases <ul> <li>Investment decisions</li> <li>Unit commitment (on/off states)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The optimization model instance</p> required <code>variable</code> <code>Variable</code> <p>Variable to be bounded</p> required <code>bounds</code> <code>tuple[TemporalData, TemporalData]</code> <p>Tuple of (lower_bound, upper_bound) absolute bounds</p> required <code>variable_state</code> <code>Variable</code> <p>Binary variable controlling the bounds</p> required <p>Returns:</p> Type Description <code>list[Constraint]</code> <p>Tuple containing: - variables (Dict): Empty dict - constraints (Dict[str, linopy.Constraint]): 'ub', 'lb'</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns.scaled_bounds","title":"scaled_bounds  <code>staticmethod</code>","text":"Python<pre><code>scaled_bounds(model: Submodel, variable: Variable, scaling_variable: Variable, relative_bounds: tuple[TemporalData, TemporalData], name: str = None) -&gt; list[linopy.Constraint]\n</code></pre> <p>Constraint a variable by scaling bounds, dependent on another variable. variable \u2208 [lower_bound * scaling_variable, upper_bound * scaling_variable]</p> Mathematical Formulation <p>scaling_variable * lower_factor \u2264 variable \u2264 scaling_variable * upper_factor</p> Use Cases <ul> <li>Flow rates bounded by equipment capacity</li> <li>Production levels scaled by plant size</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The optimization model instance</p> required <code>variable</code> <code>Variable</code> <p>Variable to be bounded</p> required <code>scaling_variable</code> <code>Variable</code> <p>Variable that scales the bound factors</p> required <code>relative_bounds</code> <code>tuple[TemporalData, TemporalData]</code> <p>Tuple of (lower_factor, upper_factor) relative to scaling variable</p> required <p>Returns:</p> Type Description <code>list[Constraint]</code> <p>Tuple containing: - variables (Dict): Empty dict - constraints (Dict[str, linopy.Constraint]): 'ub', 'lb'</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns.scaled_bounds_with_state","title":"scaled_bounds_with_state  <code>staticmethod</code>","text":"Python<pre><code>scaled_bounds_with_state(model: Submodel, variable: Variable, scaling_variable: Variable, relative_bounds: tuple[TemporalData, TemporalData], scaling_bounds: tuple[TemporalData, TemporalData], variable_state: Variable, name: str = None) -&gt; list[linopy.Constraint]\n</code></pre> <p>Constraint a variable by scaling bounds with binary state control.</p> <p>variable \u2208 {0, [max(\u03b5, lower_relative_bound) * scaling_variable, upper_relative_bound * scaling_variable]}</p> <p>Mathematical Formulation (Big-M):     (variable_state - 1) * M_misc + scaling_variable * rel_lower \u2264 variable \u2264 scaling_variable * rel_upper     variable_state * big_m_lower \u2264 variable \u2264 variable_state * big_m_upper</p> Where <p>M_misc = scaling_max * rel_lower big_m_upper = scaling_max * rel_upper big_m_lower = max(\u03b5, scaling_min * rel_lower)</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The optimization model instance</p> required <code>variable</code> <code>Variable</code> <p>Variable to be bounded</p> required <code>scaling_variable</code> <code>Variable</code> <p>Variable that scales the bound factors</p> required <code>relative_bounds</code> <code>tuple[TemporalData, TemporalData]</code> <p>Tuple of (lower_factor, upper_factor) relative to scaling variable</p> required <code>scaling_bounds</code> <code>tuple[TemporalData, TemporalData]</code> <p>Tuple of (scaling_min, scaling_max) bounds of the scaling variable</p> required <code>variable_state</code> <code>Variable</code> <p>Binary variable for on/off control</p> required <code>name</code> <code>str</code> <p>Optional name prefix for constraints</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Constraint]</code> <p>List[linopy.Constraint]: List of constraint objects</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns.state_transition_bounds","title":"state_transition_bounds  <code>staticmethod</code>","text":"Python<pre><code>state_transition_bounds(model: Submodel, state_variable: Variable, switch_on: Variable, switch_off: Variable, name: str, previous_state=0, coord: str = 'time') -&gt; tuple[linopy.Constraint, linopy.Constraint, linopy.Constraint]\n</code></pre> <p>Creates switch-on/off variables with state transition logic.</p> Mathematical formulation <p>switch_on[t] - switch_off[t] = state[t] - state[t-1]  \u2200t &gt; 0 switch_on[0] - switch_off[0] = state[0] - previous_state switch_on[t] + switch_off[t] \u2264 1  \u2200t switch_on[t], switch_off[t] \u2208 {0, 1}</p> <p>Returns:</p> Name Type Description <code>variables</code> <code>Constraint</code> <p>{'switch_on': binary_var, 'switch_off': binary_var}</p> <code>constraints</code> <code>Constraint</code> <p>{'transition': constraint, 'initial': constraint, 'mutex': constraint}</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns.continuous_transition_bounds","title":"continuous_transition_bounds  <code>staticmethod</code>","text":"Python<pre><code>continuous_transition_bounds(model: Submodel, continuous_variable: Variable, switch_on: Variable, switch_off: Variable, name: str, max_change: float | DataArray, previous_value: float | DataArray = 0.0, coord: str = 'time') -&gt; tuple[linopy.Constraint, linopy.Constraint, linopy.Constraint, linopy.Constraint]\n</code></pre> <p>Constrains a continuous variable to only change when switch variables are active.</p> Mathematical formulation <p>-max_change * (switch_on[t] + switch_off[t]) &lt;= continuous[t] - continuous[t-1] &lt;= max_change * (switch_on[t] + switch_off[t])  \u2200t &gt; 0 -max_change * (switch_on[0] + switch_off[0]) &lt;= continuous[0] - previous_value &lt;= max_change * (switch_on[0] + switch_off[0]) switch_on[t], switch_off[t] \u2208 {0, 1}</p> <p>This ensures the continuous variable can only change when switch_on or switch_off is 1. When both switches are 0, the variable must stay exactly constant.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The submodel to add constraints to</p> required <code>continuous_variable</code> <code>Variable</code> <p>The continuous variable to constrain</p> required <code>switch_on</code> <code>Variable</code> <p>Binary variable indicating when changes are allowed (typically transitions to active state)</p> required <code>switch_off</code> <code>Variable</code> <p>Binary variable indicating when changes are allowed (typically transitions to inactive state)</p> required <code>name</code> <code>str</code> <p>Base name for the constraints</p> required <code>max_change</code> <code>float | DataArray</code> <p>Maximum possible change in the continuous variable (Big-M value)</p> required <code>previous_value</code> <code>float | DataArray</code> <p>Initial value of the continuous variable before first period</p> <code>0.0</code> <code>coord</code> <code>str</code> <p>Coordinate name for time dimension</p> <code>'time'</code> <p>Returns:</p> Type Description <code>tuple[Constraint, Constraint, Constraint, Constraint]</code> <p>Tuple of constraints: (transition_upper, transition_lower, initial_upper, initial_lower)</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns.link_changes_to_level_with_binaries","title":"link_changes_to_level_with_binaries  <code>staticmethod</code>","text":"Python<pre><code>link_changes_to_level_with_binaries(model: Submodel, level_variable: Variable, increase_variable: Variable, decrease_variable: Variable, increase_binary: Variable, decrease_binary: Variable, name: str, max_change: float | DataArray, initial_level: float | DataArray = 0.0, coord: str = 'period') -&gt; tuple[linopy.Constraint, linopy.Constraint, linopy.Constraint, linopy.Constraint, linopy.Constraint]\n</code></pre> <p>Link changes to level evolution with binary control and mutual exclusivity.</p> <p>Creates the complete constraint system for ALL time periods: 1. level[0] = initial_level + increase[0] - decrease[0] 2. level[t] = level[t-1] + increase[t] - decrease[t]  \u2200t &gt; 0 3. increase[t] &lt;= max_change * increase_binary[t]  \u2200t 4. decrease[t] &lt;= max_change * decrease_binary[t]  \u2200t 5. increase_binary[t] + decrease_binary[t] &lt;= 1  \u2200t</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The submodel to add constraints to</p> required <code>increase_variable</code> <code>Variable</code> <p>Incremental additions for ALL periods (&gt;= 0)</p> required <code>decrease_variable</code> <code>Variable</code> <p>Incremental reductions for ALL periods (&gt;= 0)</p> required <code>increase_binary</code> <code>Variable</code> <p>Binary indicators for increases for ALL periods</p> required <code>decrease_binary</code> <code>Variable</code> <p>Binary indicators for decreases for ALL periods</p> required <code>level_variable</code> <code>Variable</code> <p>Level variable for ALL periods</p> required <code>name</code> <code>str</code> <p>Base name for constraints</p> required <code>max_change</code> <code>float | DataArray</code> <p>Maximum change per period</p> required <code>initial_level</code> <code>float | DataArray</code> <p>Starting level before first period</p> <code>0.0</code> <code>coord</code> <code>str</code> <p>Time coordinate name</p> <code>'period'</code> <p>Returns:</p> Type Description <code>tuple[Constraint, Constraint, Constraint, Constraint, Constraint]</code> <p>Tuple of (initial_constraint, transition_constraints, increase_bounds, decrease_bounds, mutual_exclusion)</p>"},{"location":"api-reference/network_app/","title":"Network app","text":""},{"location":"api-reference/network_app/#flixopt.network_app","title":"flixopt.network_app","text":""},{"location":"api-reference/network_app/#flixopt.network_app-classes","title":"Classes","text":""},{"location":"api-reference/network_app/#flixopt.network_app.VisualizationConfig","title":"VisualizationConfig","text":"<p>Configuration constants for the visualization</p>"},{"location":"api-reference/network_app/#flixopt.network_app-functions","title":"Functions","text":""},{"location":"api-reference/network_app/#flixopt.network_app.flow_graph","title":"flow_graph","text":"Python<pre><code>flow_graph(flow_system: FlowSystem) -&gt; nx.DiGraph\n</code></pre> <p>Convert FlowSystem to NetworkX graph - simplified and more robust</p>"},{"location":"api-reference/network_app/#flixopt.network_app.make_cytoscape_elements","title":"make_cytoscape_elements","text":"Python<pre><code>make_cytoscape_elements(graph: DiGraph) -&gt; list[dict[str, Any]]\n</code></pre> <p>Convert NetworkX graph to Cytoscape elements</p>"},{"location":"api-reference/network_app/#flixopt.network_app.create_color_picker_input","title":"create_color_picker_input","text":"Python<pre><code>create_color_picker_input(label: str, input_id: str, default_color: str)\n</code></pre> <p>Create a compact color picker with DAQ ColorPicker</p>"},{"location":"api-reference/network_app/#flixopt.network_app.create_style_section","title":"create_style_section","text":"Python<pre><code>create_style_section(title: str, children: list)\n</code></pre> <p>Create a collapsible section for organizing controls</p>"},{"location":"api-reference/network_app/#flixopt.network_app.create_sidebar","title":"create_sidebar","text":"Python<pre><code>create_sidebar()\n</code></pre> <p>Create the main sidebar with improved organization</p>"},{"location":"api-reference/network_app/#flixopt.network_app.shownetwork","title":"shownetwork","text":"Python<pre><code>shownetwork(graph: DiGraph)\n</code></pre> <p>Main function to create and run the network visualization</p>"},{"location":"api-reference/plotting/","title":"Plotting","text":""},{"location":"api-reference/plotting/#flixopt.plotting","title":"flixopt.plotting","text":"<p>Comprehensive visualization toolkit for flixopt optimization results and data analysis.</p> <p>This module provides a unified plotting interface supporting both Plotly (interactive) and Matplotlib (static) backends for visualizing energy system optimization results. It offers specialized plotting functions for time series, heatmaps, network diagrams, and statistical analyses commonly needed in energy system modeling.</p> Key Features <p>Dual Backend Support: Seamless switching between Plotly and Matplotlib Energy System Focus: Specialized plots for power flows, storage states, emissions Color Management: Intelligent color processing and palette management Export Capabilities: High-quality export for reports and publications Integration Ready: Designed for use with CalculationResults and standalone analysis</p> Main Plot Types <ul> <li>Time Series: Flow rates, power profiles, storage states over time</li> <li>Heatmaps: High-resolution temporal data visualization with customizable aggregation</li> <li>Network Diagrams: System topology with flow visualization</li> <li>Statistical Plots: Distribution analysis, correlation studies, performance metrics</li> <li>Comparative Analysis: Multi-scenario and sensitivity study visualizations</li> </ul> <p>The module integrates seamlessly with flixopt's result classes while remaining accessible for standalone data visualization tasks.</p>"},{"location":"api-reference/plotting/#flixopt.plotting-attributes","title":"Attributes","text":""},{"location":"api-reference/plotting/#flixopt.plotting.ColorType","title":"ColorType  <code>module-attribute</code>","text":"Python<pre><code>ColorType = str | list[str] | dict[str, str]\n</code></pre> <p>Flexible color specification type supporting multiple input formats for visualization.</p> <p>Color specifications can take several forms to accommodate different use cases:</p> <p>Named colorscales (str):     - Standard colorscales: 'turbo', 'plasma', 'cividis', 'tab10', 'Set1'     - Energy-focused: 'portland' (custom flixopt colorscale for energy systems)     - Backend-specific maps available in Plotly and Matplotlib</p> <p>Color Lists (list[str]):     - Explicit color sequences: ['red', 'blue', 'green', 'orange']     - HEX codes: ['#FF0000', '#0000FF', '#00FF00', '#FFA500']     - Mixed formats: ['red', '#0000FF', 'green', 'orange']</p> <p>Label-to-Color Mapping (dict[str, str]):     - Explicit associations: {'Wind': 'skyblue', 'Solar': 'gold', 'Gas': 'brown'}     - Ensures consistent colors across different plots and datasets     - Ideal for energy system components with semantic meaning</p> <p>Examples:</p> Python<pre><code># Named colorscale\ncolors = 'turbo'  # Automatic color generation\n\n# Explicit color list\ncolors = ['red', 'blue', 'green', '#FFD700']\n\n# Component-specific mapping\ncolors = {\n    'Wind_Turbine': 'skyblue',\n    'Solar_Panel': 'gold',\n    'Natural_Gas': 'brown',\n    'Battery': 'green',\n    'Electric_Load': 'darkred'\n}\n</code></pre> Color Format Support <ul> <li>Named Colors: 'red', 'blue', 'forestgreen', 'darkorange'</li> <li>HEX Codes: '#FF0000', '#0000FF', '#228B22', '#FF8C00'</li> <li>RGB Tuples: (255, 0, 0), (0, 0, 255) [Matplotlib only]</li> <li>RGBA: 'rgba(255,0,0,0.8)' [Plotly only]</li> </ul> References <ul> <li>HTML Color Names: https://htmlcolorcodes.com/color-names/</li> <li>Matplotlib colorscales: https://matplotlib.org/stable/tutorials/colors/colorscales.html</li> <li>Plotly Built-in Colorscales: https://plotly.com/python/builtin-colorscales/</li> </ul>"},{"location":"api-reference/plotting/#flixopt.plotting.PlottingEngine","title":"PlottingEngine  <code>module-attribute</code>","text":"Python<pre><code>PlottingEngine = Literal['plotly', 'matplotlib']\n</code></pre> <p>Identifier for the plotting engine to use.</p>"},{"location":"api-reference/plotting/#flixopt.plotting-classes","title":"Classes","text":""},{"location":"api-reference/plotting/#flixopt.plotting-functions","title":"Functions","text":""},{"location":"api-reference/plotting/#flixopt.plotting.with_plotly","title":"with_plotly","text":"Python<pre><code>with_plotly(data: Dataset | DataFrame | Series, mode: Literal['stacked_bar', 'line', 'area', 'grouped_bar'] = 'stacked_bar', colors: ColorType | None = None, title: str = '', ylabel: str = '', xlabel: str = '', facet_by: str | list[str] | None = None, animate_by: str | None = None, facet_cols: int | None = None, shared_yaxes: bool = True, shared_xaxes: bool = True, **px_kwargs: Any) -&gt; go.Figure\n</code></pre> <p>Plot data with Plotly using facets (subplots) and/or animation for multidimensional data.</p> <p>Uses Plotly Express for convenient faceting and animation with automatic styling.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dataset | DataFrame | Series</code> <p>An xarray Dataset, pandas DataFrame, or pandas Series to plot.</p> required <code>mode</code> <code>Literal['stacked_bar', 'line', 'area', 'grouped_bar']</code> <p>The plotting mode. Use 'stacked_bar' for stacked bar charts, 'line' for lines,   'area' for stacked area charts, or 'grouped_bar' for grouped bar charts.</p> <code>'stacked_bar'</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale, list, or dict mapping labels to colors).</p> <code>None</code> <code>title</code> <code>str</code> <p>The main title of the plot.</p> <code>''</code> <code>ylabel</code> <code>str</code> <p>The label for the y-axis.</p> <code>''</code> <code>xlabel</code> <code>str</code> <p>The label for the x-axis.</p> <code>''</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) to create facets for. Creates a subplot grid.   Can be a single dimension name or list of dimensions (max 2 for facet_row and facet_col).   If the dimension doesn't exist in the data, it will be silently ignored.</p> <code>None</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over. Creates animation frames.   If the dimension doesn't exist in the data, it will be silently ignored.</p> <code>None</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid (used when facet_by is single dimension).</p> <code>None</code> <code>shared_yaxes</code> <code>bool</code> <p>Whether subplots share y-axes.</p> <code>True</code> <code>shared_xaxes</code> <code>bool</code> <p>Whether subplots share x-axes.</p> <code>True</code> <code>**px_kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the underlying Plotly Express function         (px.bar, px.line, px.area). These override default arguments if provided.         Examples: range_x=[0, 100], range_y=[0, 50], category_orders={...}, line_shape='linear'</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A Plotly figure object containing the faceted/animated plot. You can further customize</p> <code>Figure</code> <p>the returned figure using Plotly's methods (e.g., fig.update_traces(), fig.update_layout()).</p> <p>Examples:</p> <p>Simple plot:</p> Python<pre><code>fig = with_plotly(dataset, mode='area', title='Energy Mix')\n</code></pre> <p>Facet by scenario:</p> Python<pre><code>fig = with_plotly(dataset, facet_by='scenario', facet_cols=2)\n</code></pre> <p>Animate by period:</p> Python<pre><code>fig = with_plotly(dataset, animate_by='period')\n</code></pre> <p>Facet and animate:</p> Python<pre><code>fig = with_plotly(dataset, facet_by='scenario', animate_by='period')\n</code></pre> <p>Customize with Plotly Express kwargs:</p> Python<pre><code>fig = with_plotly(dataset, range_y=[0, 100], line_shape='linear')\n</code></pre> <p>Further customize the returned figure:</p> Python<pre><code>fig = with_plotly(dataset, mode='line')\nfig.update_traces(line={'width': 5, 'dash': 'dot'})\nfig.update_layout(template='plotly_dark', width=1200, height=600)\n</code></pre>"},{"location":"api-reference/plotting/#flixopt.plotting.with_matplotlib","title":"with_matplotlib","text":"Python<pre><code>with_matplotlib(data: Dataset | DataFrame | Series, mode: Literal['stacked_bar', 'line'] = 'stacked_bar', colors: ColorType | None = None, title: str = '', ylabel: str = '', xlabel: str = 'Time in h', figsize: tuple[int, int] = (12, 6), plot_kwargs: dict[str, Any] | None = None) -&gt; tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plot data with Matplotlib using stacked bars or stepped lines.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dataset | DataFrame | Series</code> <p>An xarray Dataset, pandas DataFrame, or pandas Series to plot. After conversion to DataFrame,   the index represents time and each column represents a separate data series (variables).</p> required <code>mode</code> <code>Literal['stacked_bar', 'line']</code> <p>Plotting mode. Use 'stacked_bar' for stacked bar charts or 'line' for stepped lines.</p> <code>'stacked_bar'</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification. Can be: - A colorscale name (e.g., 'turbo', 'plasma') - A list of color strings (e.g., ['#ff0000', '#00ff00']) - A dict mapping column names to colors (e.g., {'Column1': '#ff0000'})</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the plot.</p> <code>''</code> <code>ylabel</code> <code>str</code> <p>The ylabel of the plot.</p> <code>''</code> <code>xlabel</code> <code>str</code> <p>The xlabel of the plot.</p> <code>'Time in h'</code> <code>figsize</code> <code>tuple[int, int]</code> <p>Specify the size of the figure (width, height) in inches.</p> <code>(12, 6)</code> <code>plot_kwargs</code> <code>dict[str, Any] | None</code> <p>Optional dict of parameters to pass to ax.bar() or ax.step() plotting calls.         Use this to customize plot properties (e.g., linewidth, alpha, edgecolor).</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Figure, Axes]</code> <p>A tuple containing the Matplotlib figure and axes objects used for the plot.</p> Notes <ul> <li>If <code>mode</code> is 'stacked_bar', bars are stacked for both positive and negative values.   Negative values are stacked separately without extra labels in the legend.</li> <li>If <code>mode</code> is 'line', stepped lines are drawn for each data series.</li> </ul>"},{"location":"api-reference/plotting/#flixopt.plotting.reshape_data_for_heatmap","title":"reshape_data_for_heatmap","text":"Python<pre><code>reshape_data_for_heatmap(data: DataArray, reshape_time: tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None = 'auto', facet_by: str | list[str] | None = None, animate_by: str | None = None, fill: Literal['ffill', 'bfill'] | None = 'ffill') -&gt; xr.DataArray\n</code></pre> <p>Reshape data for heatmap visualization, handling time dimension intelligently.</p> <p>This function decides whether to reshape the 'time' dimension based on the reshape_time parameter: - 'auto': Automatically reshapes if only 'time' dimension would remain for heatmap - Tuple: Explicitly reshapes time with specified parameters - None: No reshaping (returns data as-is)</p> <p>All non-time dimensions are preserved during reshaping.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataArray</code> <p>DataArray to reshape for heatmap visualization.</p> required <code>reshape_time</code> <code>tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None</code> <p>Reshaping configuration:          - 'auto' (default): Auto-reshape if needed based on facet_by/animate_by          - Tuple (timeframes, timesteps_per_frame): Explicit time reshaping          - None: No reshaping</p> <code>'auto'</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) used for faceting (used in 'auto' decision).</p> <code>None</code> <code>animate_by</code> <code>str | None</code> <p>Dimension used for animation (used in 'auto' decision).</p> <code>None</code> <code>fill</code> <code>Literal['ffill', 'bfill'] | None</code> <p>Method to fill missing values: 'ffill' or 'bfill'. Default is 'ffill'.</p> <code>'ffill'</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>Reshaped DataArray. If time reshaping is applied, 'time' dimension is replaced</p> <code>DataArray</code> <p>by 'timestep' and 'timeframe'. All other dimensions are preserved.</p> <p>Examples:</p> <p>Auto-reshaping:</p> Python<pre><code># Will auto-reshape because only 'time' remains after faceting/animation\ndata = reshape_data_for_heatmap(data, reshape_time='auto', facet_by='scenario', animate_by='period')\n</code></pre> <p>Explicit reshaping:</p> Python<pre><code># Explicitly reshape to daily pattern\ndata = reshape_data_for_heatmap(data, reshape_time=('D', 'h'))\n</code></pre> <p>No reshaping:</p> Python<pre><code># Keep data as-is\ndata = reshape_data_for_heatmap(data, reshape_time=None)\n</code></pre>"},{"location":"api-reference/plotting/#flixopt.plotting.plot_network","title":"plot_network","text":"Python<pre><code>plot_network(node_infos: dict, edge_infos: dict, path: str | Path | None = None, controls: bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']] = True, show: bool = False) -&gt; pyvis.network.Network | None\n</code></pre> <p>Visualizes the network structure of a FlowSystem using PyVis, using info-dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path | None</code> <p>Path to save the HTML visualization. <code>False</code>: Visualization is created but not saved. <code>str</code> or <code>Path</code>: Specifies file path (default: 'results/network.html').</p> <code>None</code> <code>controls</code> <code>bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]</code> <p>UI controls to add to the visualization. <code>True</code>: Enables all available controls. <code>list</code>: Specify controls, e.g., ['nodes', 'layout']. Options: 'nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer'. You can play with these and generate a Dictionary from it that can be applied to the network returned by this function. network.set_options() https://pyvis.readthedocs.io/en/latest/tutorial.html</p> <code>True</code> <code>show</code> <code>bool</code> <p>Whether to open the visualization in the web browser. The calculation must be saved to show it. If no path is given, it defaults to 'network.html'.</p> <code>False</code> <p>Returns:     The <code>Network</code> instance representing the visualization, or <code>None</code> if <code>pyvis</code> is not installed.</p> <p>Notes: - This function requires <code>pyvis</code>. If not installed, the function prints a warning and returns <code>None</code>. - Nodes are styled based on type (e.g., circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.preprocess_data_for_pie","title":"preprocess_data_for_pie","text":"Python<pre><code>preprocess_data_for_pie(data: Dataset | DataFrame | Series, lower_percentage_threshold: float = 5.0) -&gt; pd.Series\n</code></pre> <p>Preprocess data for pie chart display.</p> <p>Groups items that are individually below the threshold percentage into an \"Other\" category. Converts various input types to a pandas Series for uniform handling.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dataset | DataFrame | Series</code> <p>Input data (xarray Dataset, DataFrame, or Series)</p> required <code>lower_percentage_threshold</code> <code>float</code> <p>Percentage threshold - items below this are grouped into \"Other\"</p> <code>5.0</code> <p>Returns:</p> Type Description <code>Series</code> <p>Processed pandas Series with small items grouped into \"Other\"</p>"},{"location":"api-reference/plotting/#flixopt.plotting.dual_pie_with_plotly","title":"dual_pie_with_plotly","text":"Python<pre><code>dual_pie_with_plotly(data_left: Dataset | DataFrame | Series, data_right: Dataset | DataFrame | Series, colors: ColorType | None = None, title: str = '', subtitles: tuple[str, str] = ('Left Chart', 'Right Chart'), legend_title: str = '', hole: float = 0.2, lower_percentage_group: float = 5.0, text_info: str = 'percent+label', text_position: str = 'inside', hover_template: str = '%{label}: %{value} (%{percent})') -&gt; go.Figure\n</code></pre> <p>Create two pie charts side by side with Plotly.</p> <p>Parameters:</p> Name Type Description Default <code>data_left</code> <code>Dataset | DataFrame | Series</code> <p>Data for the left pie chart. Variables are summed across all dimensions.</p> required <code>data_right</code> <code>Dataset | DataFrame | Series</code> <p>Data for the right pie chart. Variables are summed across all dimensions.</p> required <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, list of colors, or dict mapping)</p> <code>None</code> <code>title</code> <code>str</code> <p>The main title of the plot.</p> <code>''</code> <code>subtitles</code> <code>tuple[str, str]</code> <p>Tuple containing the subtitles for (left, right) charts.</p> <code>('Left Chart', 'Right Chart')</code> <code>legend_title</code> <code>str</code> <p>The title for the legend.</p> <code>''</code> <code>hole</code> <code>float</code> <p>Size of the hole in the center for creating donut charts (0.0 to 1.0).</p> <code>0.2</code> <code>lower_percentage_group</code> <code>float</code> <p>Group segments whose cumulative share is below this percentage (0\u2013100) into \"Other\".</p> <code>5.0</code> <code>hover_template</code> <code>str</code> <p>Template for hover text. Use %{label}, %{value}, %{percent}.</p> <code>'%{label}: %{value} (%{percent})'</code> <code>text_info</code> <code>str</code> <p>What to show on pie segments: 'label', 'percent', 'value', 'label+percent',       'label+value', 'percent+value', 'label+percent+value', or 'none'.</p> <code>'percent+label'</code> <code>text_position</code> <code>str</code> <p>Position of text: 'inside', 'outside', 'auto', or 'none'.</p> <code>'inside'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly Figure object</p>"},{"location":"api-reference/plotting/#flixopt.plotting.dual_pie_with_matplotlib","title":"dual_pie_with_matplotlib","text":"Python<pre><code>dual_pie_with_matplotlib(data_left: Dataset | DataFrame | Series, data_right: Dataset | DataFrame | Series, colors: ColorType | None = None, title: str = '', subtitles: tuple[str, str] = ('Left Chart', 'Right Chart'), legend_title: str = '', hole: float = 0.2, lower_percentage_group: float = 5.0, figsize: tuple[int, int] = (14, 7)) -&gt; tuple[plt.Figure, list[plt.Axes]]\n</code></pre> <p>Create two pie charts side by side with Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>data_left</code> <code>Dataset | DataFrame | Series</code> <p>Data for the left pie chart.</p> required <code>data_right</code> <code>Dataset | DataFrame | Series</code> <p>Data for the right pie chart.</p> required <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, list of colors, or dict mapping)</p> <code>None</code> <code>title</code> <code>str</code> <p>The main title of the plot.</p> <code>''</code> <code>subtitles</code> <code>tuple[str, str]</code> <p>Tuple containing the subtitles for (left, right) charts.</p> <code>('Left Chart', 'Right Chart')</code> <code>legend_title</code> <code>str</code> <p>The title for the legend.</p> <code>''</code> <code>hole</code> <code>float</code> <p>Size of the hole in the center for creating donut charts (0.0 to 1.0).</p> <code>0.2</code> <code>lower_percentage_group</code> <code>float</code> <p>Whether to group small segments (below percentage) into an \"Other\" category.</p> <code>5.0</code> <code>figsize</code> <code>tuple[int, int]</code> <p>The size of the figure (width, height) in inches.</p> <code>(14, 7)</code> <p>Returns:</p> Type Description <code>tuple[Figure, list[Axes]]</code> <p>Tuple of (Figure, list of Axes)</p>"},{"location":"api-reference/plotting/#flixopt.plotting.heatmap_with_plotly","title":"heatmap_with_plotly","text":"Python<pre><code>heatmap_with_plotly(data: DataArray, colors: ColorType | None = None, title: str = '', facet_by: str | list[str] | None = None, animate_by: str | None = None, facet_cols: int | None = None, reshape_time: tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None = 'auto', fill: Literal['ffill', 'bfill'] | None = 'ffill', **imshow_kwargs: Any) -&gt; go.Figure\n</code></pre> <p>Plot a heatmap visualization using Plotly's imshow with faceting and animation support.</p> <p>This function creates heatmap visualizations from xarray DataArrays, supporting multi-dimensional data through faceting (subplots) and animation. It automatically handles dimension reduction and data reshaping for optimal heatmap display.</p> Automatic Time Reshaping <p>If only the 'time' dimension remains after faceting/animation (making the data 1D), the function automatically reshapes time into a 2D format using default values (timeframes='D', timesteps_per_frame='h'). This creates a daily pattern heatmap showing hours vs days.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataArray</code> <p>An xarray DataArray containing the data to visualize. Should have at least   2 dimensions, or a 'time' dimension that can be reshaped into 2D.</p> required <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, list, or dict). Common options:     'turbo', 'plasma', 'RdBu', 'portland'.</p> <code>None</code> <code>title</code> <code>str</code> <p>The main title of the heatmap.</p> <code>''</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension to create facets for. Creates a subplot grid.       Can be a single dimension name or list (only first dimension used).       Note: px.imshow only supports single-dimension faceting.       If the dimension doesn't exist in the data, it will be silently ignored.</p> <code>None</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over. Creates animation frames.         If the dimension doesn't exist in the data, it will be silently ignored.</p> <code>None</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid (used with facet_by).</p> <code>None</code> <code>reshape_time</code> <code>tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None</code> <p>Time reshaping configuration:          - 'auto' (default): Automatically applies ('D', 'h') if only 'time' dimension remains          - Tuple like ('D', 'h'): Explicit time reshaping (days vs hours)          - None: Disable time reshaping (will error if only 1D time data)</p> <code>'auto'</code> <code>fill</code> <code>Literal['ffill', 'bfill'] | None</code> <p>Method to fill missing values when reshaping time: 'ffill' or 'bfill'. Default is 'ffill'.</p> <code>'ffill'</code> <code>**imshow_kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to plotly.express.imshow.             Common options include:             - aspect: 'auto', 'equal', or a number for aspect ratio             - zmin, zmax: Minimum and maximum values for color scale             - labels: Dict to customize axis labels</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A Plotly figure object containing the heatmap visualization.</p> <p>Examples:</p> <p>Simple heatmap:</p> Python<pre><code>fig = heatmap_with_plotly(data_array, colors='RdBu', title='Temperature Map')\n</code></pre> <p>Facet by scenario:</p> Python<pre><code>fig = heatmap_with_plotly(data_array, facet_by='scenario', facet_cols=2)\n</code></pre> <p>Animate by period:</p> Python<pre><code>fig = heatmap_with_plotly(data_array, animate_by='period')\n</code></pre> <p>Automatic time reshaping (when only time dimension remains):</p> Python<pre><code># Data with dims ['time', 'scenario', 'period']\n# After faceting and animation, only 'time' remains -&gt; auto-reshapes to (timestep, timeframe)\nfig = heatmap_with_plotly(data_array, facet_by='scenario', animate_by='period')\n</code></pre> <p>Explicit time reshaping:</p> Python<pre><code>fig = heatmap_with_plotly(data_array, facet_by='scenario', animate_by='period', reshape_time=('W', 'D'))\n</code></pre>"},{"location":"api-reference/plotting/#flixopt.plotting.heatmap_with_matplotlib","title":"heatmap_with_matplotlib","text":"Python<pre><code>heatmap_with_matplotlib(data: DataArray, colors: ColorType | None = None, title: str = '', figsize: tuple[float, float] = (12, 6), reshape_time: tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None = 'auto', fill: Literal['ffill', 'bfill'] | None = 'ffill', vmin: float | None = None, vmax: float | None = None, imshow_kwargs: dict[str, Any] | None = None, cbar_kwargs: dict[str, Any] | None = None, **kwargs: Any) -&gt; tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plot a heatmap visualization using Matplotlib's imshow.</p> <p>This function creates a basic 2D heatmap from an xarray DataArray using matplotlib's imshow function. For multi-dimensional data, only the first two dimensions are used.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataArray</code> <p>An xarray DataArray containing the data to visualize. Should have at least   2 dimensions. If more than 2 dimensions exist, additional dimensions will   be reduced by taking the first slice.</p> required <code>colors</code> <code>ColorType | None</code> <p>Color specification. Should be a colorscale name (e.g., 'turbo', 'RdBu').</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the heatmap.</p> <code>''</code> <code>figsize</code> <code>tuple[float, float]</code> <p>The size of the figure (width, height) in inches.</p> <code>(12, 6)</code> <code>reshape_time</code> <code>tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None</code> <p>Time reshaping configuration:          - 'auto' (default): Automatically applies ('D', 'h') if only 'time' dimension          - Tuple like ('D', 'h'): Explicit time reshaping (days vs hours)          - None: Disable time reshaping</p> <code>'auto'</code> <code>fill</code> <code>Literal['ffill', 'bfill'] | None</code> <p>Method to fill missing values when reshaping time: 'ffill' or 'bfill'. Default is 'ffill'.</p> <code>'ffill'</code> <code>vmin</code> <code>float | None</code> <p>Minimum value for color scale. If None, uses data minimum.</p> <code>None</code> <code>vmax</code> <code>float | None</code> <p>Maximum value for color scale. If None, uses data maximum.</p> <code>None</code> <code>imshow_kwargs</code> <code>dict[str, Any] | None</code> <p>Optional dict of parameters to pass to ax.imshow().           Use this to customize image properties (e.g., interpolation, aspect).</p> <code>None</code> <code>cbar_kwargs</code> <code>dict[str, Any] | None</code> <p>Optional dict of parameters to pass to plt.colorbar().         Use this to customize colorbar properties (e.g., orientation, label).</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to ax.imshow().      Common options include:      - interpolation: 'nearest', 'bilinear', 'bicubic', etc.      - alpha: Transparency level (0-1)      - extent: [left, right, bottom, top] for axis limits</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[Figure, Axes]</code> <p>A tuple containing the Matplotlib figure and axes objects used for the plot.</p> Notes <ul> <li>Matplotlib backend doesn't support faceting or animation. Use plotly engine for those features.</li> <li>The y-axis is automatically inverted to display data with origin at top-left.</li> <li>A colorbar is added to show the value scale.</li> </ul> <p>Examples:</p> Python<pre><code>fig, ax = heatmap_with_matplotlib(data_array, colors='RdBu', title='Temperature')\nplt.savefig('heatmap.png')\n</code></pre> <p>Time reshaping:</p> Python<pre><code>fig, ax = heatmap_with_matplotlib(data_array, reshape_time=('D', 'h'))\n</code></pre>"},{"location":"api-reference/plotting/#flixopt.plotting.export_figure","title":"export_figure","text":"Python<pre><code>export_figure(figure_like: Figure | tuple[Figure, Axes], default_path: Path, default_filetype: str | None = None, user_path: Path | None = None, show: bool | None = None, save: bool = False, dpi: int | None = None) -&gt; go.Figure | tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Export a figure to a file and or show it.</p> <p>Parameters:</p> Name Type Description Default <code>figure_like</code> <code>Figure | tuple[Figure, Axes]</code> <p>The figure to export. Can be a Plotly figure or a tuple of Matplotlib figure and axes.</p> required <code>default_path</code> <code>Path</code> <p>The default file path if no user filename is provided.</p> required <code>default_filetype</code> <code>str | None</code> <p>The default filetype if the path doesnt end with a filetype.</p> <code>None</code> <code>user_path</code> <code>Path | None</code> <p>An optional user-specified file path.</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure. If None, uses CONFIG.Plotting.default_show (default: None).</p> <code>None</code> <code>save</code> <code>bool</code> <p>Whether to save the figure (default: False).</p> <code>False</code> <code>dpi</code> <code>int | None</code> <p>DPI (dots per inch) for saving Matplotlib figures. If None, uses CONFIG.Plotting.default_dpi.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no default filetype is provided and the path doesn't specify a filetype.</p> <code>TypeError</code> <p>If the figure type is not supported.</p>"},{"location":"api-reference/results/","title":"Results","text":""},{"location":"api-reference/results/#flixopt.results","title":"flixopt.results","text":""},{"location":"api-reference/results/#flixopt.results-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results-classes","title":"Classes","text":""},{"location":"api-reference/results/#flixopt.results.CalculationResults","title":"CalculationResults","text":"Python<pre><code>CalculationResults(solution: Dataset, flow_system_data: Dataset, name: str, summary: dict, folder: Path | None = None, model: Model | None = None, **kwargs)\n</code></pre> <p>Comprehensive container for optimization calculation results and analysis tools.</p> <p>This class provides unified access to all optimization results including flow rates, component states, bus balances, and system effects. It offers powerful analysis capabilities through filtering, plotting, and export functionality, making it the primary interface for post-processing optimization results.</p> Key Features <p>Unified Access: Single interface to all solution variables and constraints Element Results: Direct access to component, bus, and effect-specific results Visualization: Built-in plotting methods for heatmaps, time series, and networks Persistence: Save/load functionality with compression for large datasets Analysis Tools: Filtering, aggregation, and statistical analysis methods</p> Result Organization <ul> <li>Components: Equipment-specific results (flows, states, constraints)</li> <li>Buses: Network node balances and energy flows</li> <li>Effects: System-wide impacts (costs, emissions, resource consumption)</li> <li>Solution: Raw optimization variables and their values</li> <li>Metadata: Calculation parameters, timing, and system configuration</li> </ul> <p>Attributes:</p> Name Type Description <code>solution</code> <p>Dataset containing all optimization variable solutions</p> <code>flow_system_data</code> <p>Dataset with complete system configuration and parameters. Restore the used FlowSystem for further analysis.</p> <code>summary</code> <p>Calculation metadata including solver status, timing, and statistics</p> <code>name</code> <p>Unique identifier for this calculation</p> <code>model</code> <p>Original linopy optimization model (if available)</p> <code>folder</code> <p>Directory path for result storage and loading</p> <code>components</code> <p>Dictionary mapping component labels to ComponentResults objects</p> <code>buses</code> <p>Dictionary mapping bus labels to BusResults objects</p> <code>effects</code> <p>Dictionary mapping effect names to EffectResults objects</p> <code>timesteps_extra</code> <p>Extended time index including boundary conditions</p> <code>hours_per_timestep</code> <p>Duration of each timestep for proper energy calculations</p> <p>Examples:</p> <p>Load and analyze saved results:</p> Python<pre><code># Load results from file\nresults = CalculationResults.from_file('results', 'annual_optimization')\n\n# Access specific component results\nboiler_results = results['Boiler_01']\nheat_pump_results = results['HeatPump_02']\n\n# Plot component flow rates\nresults.plot_heatmap('Boiler_01(Natural_Gas)|flow_rate')\nresults['Boiler_01'].plot_node_balance()\n\n# Access raw solution dataarrays\nelectricity_flows = results.solution[['Generator_01(Grid)|flow_rate', 'HeatPump_02(Grid)|flow_rate']]\n\n# Filter and analyze results\npeak_demand_hours = results.filter_solution(variable_dims='time')\ncosts_solution = results.effects['cost'].solution\n</code></pre> <p>Advanced filtering and aggregation:</p> Python<pre><code># Filter by variable type\nscalar_results = results.filter_solution(variable_dims='scalar')\ntime_series = results.filter_solution(variable_dims='time')\n\n# Custom data analysis leveraging xarray\npeak_power = results.solution['Generator_01(Grid)|flow_rate'].max()\navg_efficiency = (\n    results.solution['HeatPump(Heat)|flow_rate'] / results.solution['HeatPump(Electricity)|flow_rate']\n).mean()\n</code></pre> <p>Configure automatic color management for plots:</p> Python<pre><code># Dict-based configuration:\nresults.setup_colors({'Solar*': 'Oranges', 'Wind*': 'Blues', 'Battery': 'green'})\n\n# All plots automatically use configured colors (colors=None is the default)\nresults['ElectricityBus'].plot_node_balance()\nresults['Battery'].plot_charge_state()\n\n# Override when needed\nresults['ElectricityBus'].plot_node_balance(colors='turbo')  # Ignores setup\n</code></pre> Design Patterns <p>Factory Methods: Use <code>from_file()</code> and <code>from_calculation()</code> for creation or access directly from <code>Calculation.results</code> Dictionary Access: Use <code>results[element_label]</code> for element-specific results Lazy Loading: Results objects created on-demand for memory efficiency Unified Interface: Consistent API across different result types</p> <p>Initialize CalculationResults with optimization data. Usually, this class is instantiated by the Calculation class, or by loading from file.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>Dataset</code> <p>Optimization solution dataset.</p> required <code>flow_system_data</code> <code>Dataset</code> <p>Flow system configuration dataset.</p> required <code>name</code> <code>str</code> <p>Calculation name.</p> required <code>summary</code> <code>dict</code> <p>Calculation metadata.</p> required <code>folder</code> <code>Path | None</code> <p>Results storage folder.</p> <code>None</code> <code>model</code> <code>Model | None</code> <p>Linopy optimization model.</p> <code>None</code> <p>Deprecated:     flow_system: Use flow_system_data instead.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.CalculationResults.storages","title":"storages  <code>property</code>","text":"Python<pre><code>storages: list[ComponentResults]\n</code></pre> <p>Get all storage components in the results.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.objective","title":"objective  <code>property</code>","text":"Python<pre><code>objective: float\n</code></pre> <p>Get optimization objective value.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>Get optimization variables (requires linopy model).</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>Get optimization constraints (requires linopy model).</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.flow_system","title":"flow_system  <code>property</code>","text":"Python<pre><code>flow_system: FlowSystem\n</code></pre> <p>The restored flow_system that was used to create the calculation. Contains all input parameters.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.effects_per_component","title":"effects_per_component  <code>property</code>","text":"Python<pre><code>effects_per_component: Dataset\n</code></pre> <p>Returns a dataset containing effect results for each mode, aggregated by Component</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>An xarray Dataset with an additional component dimension and effects as variables.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.CalculationResults.from_file","title":"from_file  <code>classmethod</code>","text":"Python<pre><code>from_file(folder: str | Path, name: str) -&gt; CalculationResults\n</code></pre> <p>Load CalculationResults from saved files.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path</code> <p>Directory containing saved files.</p> required <code>name</code> <code>str</code> <p>Base name of saved files (without extensions).</p> required <p>Returns:</p> Name Type Description <code>CalculationResults</code> <code>CalculationResults</code> <p>Loaded instance.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.from_calculation","title":"from_calculation  <code>classmethod</code>","text":"Python<pre><code>from_calculation(calculation: Calculation) -&gt; CalculationResults\n</code></pre> <p>Create CalculationResults from a Calculation object.</p> <p>Parameters:</p> Name Type Description Default <code>calculation</code> <code>Calculation</code> <p>Calculation object with solved model.</p> required <p>Returns:</p> Name Type Description <code>CalculationResults</code> <code>CalculationResults</code> <p>New instance with extracted results.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.setup_colors","title":"setup_colors","text":"Python<pre><code>setup_colors(config: dict[str, str | list[str]] | str | Path | None = None, default_colorscale: str | None = None) -&gt; dict[str, str]\n</code></pre> <p>Setup colors for all variables across all elements. Overwrites existing ones.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, str | list[str]] | str | Path | None</code> <p>Configuration for color assignment. Can be: - dict: Maps components to colors/colorscales:     * 'component1': 'red'  # Single component to single color     * 'component1': '#FF0000'  # Single component to hex color     - OR maps colorscales to multiple components:     * 'colorscale_name': ['component1', 'component2']  # Colorscale across components - str: Path to a JSON/YAML config file or a colorscale name to apply to all - Path: Path to a JSON/YAML config file - None: Use default_colorscale for all components</p> <code>None</code> <code>default_colorscale</code> <code>str | None</code> <p>Default colorscale for unconfigured components (default: 'turbo')</p> <code>None</code> <p>Examples:</p> <p>setup_colors({     # Direct component-to-color mappings     'Boiler1': '#FF0000',     'CHP': 'darkred',     # Colorscale for multiple components     'Oranges': ['Solar1', 'Solar2'],     'Blues': ['Wind1', 'Wind2'],     'Greens': ['Battery1', 'Battery2', 'Battery3'], })</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Complete variable-to-color mapping dictionary</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.filter_solution","title":"filter_solution","text":"Python<pre><code>filter_solution(variable_dims: Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None = None, element: str | None = None, timesteps: DatetimeIndex | None = None, scenarios: Index | None = None, contains: str | list[str] | None = None, startswith: str | list[str] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter solution by variable dimension and/or element.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None</code> <p>The dimension of which to get variables from. - 'scalar': Get scalar variables (without dimensions) - 'time': Get time-dependent variables (with a time dimension) - 'scenario': Get scenario-dependent variables (with ONLY a scenario dimension) - 'timeonly': Get time-dependent variables (with ONLY a time dimension) - 'scenarioonly': Get scenario-dependent variables (with ONLY a scenario dimension)</p> <code>None</code> <code>element</code> <code>str | None</code> <p>The element to filter for.</p> <code>None</code> <code>timesteps</code> <code>DatetimeIndex | None</code> <p>Optional time indexes to select. Can be: - pd.DatetimeIndex: Multiple timesteps - str/pd.Timestamp: Single timestep Defaults to all available timesteps.</p> <code>None</code> <code>scenarios</code> <code>Index | None</code> <p>Optional scenario indexes to select. Can be: - pd.Index: Multiple scenarios - str/int: Single scenario (int is treated as a label, not an index position) Defaults to all available scenarios.</p> <code>None</code> <code>contains</code> <code>str | list[str] | None</code> <p>Filter variables that contain this string or strings. If a list is provided, variables must contain ALL strings in the list.</p> <code>None</code> <code>startswith</code> <code>str | list[str] | None</code> <p>Filter variables that start with this string or strings. If a list is provided, variables must start with ANY of the strings in the list.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.flow_rates","title":"flow_rates","text":"Python<pre><code>flow_rates(start: str | list[str] | None = None, end: str | list[str] | None = None, component: str | list[str] | None = None) -&gt; xr.DataArray\n</code></pre> <p>Returns a DataArray containing the flow rates of each Flow.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | list[str] | None</code> <p>Optional source node(s) to filter by. Can be a single node name or a list of names.</p> <code>None</code> <code>end</code> <code>str | list[str] | None</code> <p>Optional destination node(s) to filter by. Can be a single node name or a list of names.</p> <code>None</code> <code>component</code> <code>str | list[str] | None</code> <p>Optional component(s) to filter by. Can be a single component name or a list of names.</p> <code>None</code> Further usage <p>Convert the dataarray to a dataframe:</p> <p>results.flow_rates().to_pandas() Get the max or min over time: results.flow_rates().max('time') Sum up the flow rates of flows with the same start and end: results.flow_rates(end='Fernw\u00e4rme').groupby('start').sum(dim='flow') To recombine filtered dataarrays, use <code>xr.concat</code> with dim 'flow': xr.concat([results.flow_rates(start='Fernw\u00e4rme'), results.flow_rates(end='Fernw\u00e4rme')], dim='flow')</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.flow_hours","title":"flow_hours","text":"Python<pre><code>flow_hours(start: str | list[str] | None = None, end: str | list[str] | None = None, component: str | list[str] | None = None) -&gt; xr.DataArray\n</code></pre> <p>Returns a DataArray containing the flow hours of each Flow.</p> <p>Flow hours represent the total energy/material transferred over time, calculated by multiplying flow rates by the duration of each timestep.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | list[str] | None</code> <p>Optional source node(s) to filter by. Can be a single node name or a list of names.</p> <code>None</code> <code>end</code> <code>str | list[str] | None</code> <p>Optional destination node(s) to filter by. Can be a single node name or a list of names.</p> <code>None</code> <code>component</code> <code>str | list[str] | None</code> <p>Optional component(s) to filter by. Can be a single component name or a list of names.</p> <code>None</code> Further usage <p>Convert the dataarray to a dataframe:</p> <p>results.flow_hours().to_pandas() Sum up the flow hours over time: results.flow_hours().sum('time') Sum up the flow hours of flows with the same start and end: results.flow_hours(end='Fernw\u00e4rme').groupby('start').sum(dim='flow') To recombine filtered dataarrays, use <code>xr.concat</code> with dim 'flow': xr.concat([results.flow_hours(start='Fernw\u00e4rme'), results.flow_hours(end='Fernw\u00e4rme')], dim='flow')</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.sizes","title":"sizes","text":"Python<pre><code>sizes(start: str | list[str] | None = None, end: str | list[str] | None = None, component: str | list[str] | None = None) -&gt; xr.DataArray\n</code></pre> <p>Returns a dataset with the sizes of the Flows. Args:     start: Optional source node(s) to filter by. Can be a single node name or a list of names.     end: Optional destination node(s) to filter by. Can be a single node name or a list of names.     component: Optional component(s) to filter by. Can be a single component name or a list of names.</p> Further usage <p>Convert the dataarray to a dataframe:</p> <p>results.sizes().to_pandas() To recombine filtered dataarrays, use <code>xr.concat</code> with dim 'flow': xr.concat([results.sizes(start='Fernw\u00e4rme'), results.sizes(end='Fernw\u00e4rme')], dim='flow')</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.get_effect_shares","title":"get_effect_shares","text":"Python<pre><code>get_effect_shares(element: str, effect: str, mode: Literal['temporal', 'periodic'] | None = None, include_flows: bool = False) -&gt; xr.Dataset\n</code></pre> <p>Retrieves individual effect shares for a specific element and effect. Either for temporal, investment, or both modes combined. Only includes the direct shares.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>The element identifier for which to retrieve effect shares.</p> required <code>effect</code> <code>str</code> <p>The effect identifier for which to retrieve shares.</p> required <code>mode</code> <code>Literal['temporal', 'periodic'] | None</code> <p>Optional. The mode to retrieve shares for. Can be 'temporal', 'periodic', or None to retrieve both. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>An xarray Dataset containing the requested effect shares. If mode is None,</p> <code>Dataset</code> <p>returns a merged Dataset containing both temporal and investment shares.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified effect is not available or if mode is invalid.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.plot_heatmap","title":"plot_heatmap","text":"Python<pre><code>plot_heatmap(variable_name: str | list[str], save: bool | Path = False, show: bool | None = None, colors: ColorType | None = None, engine: PlottingEngine = 'plotly', select: dict[FlowSystemDimensions, Any] | None = None, facet_by: str | list[str] | None = 'scenario', animate_by: str | None = 'period', facet_cols: int | None = None, reshape_time: tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None = 'auto', fill: Literal['ffill', 'bfill'] | None = 'ffill', indexer: dict[FlowSystemDimensions, Any] | None = None, heatmap_timeframes: Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'] | None = None, heatmap_timesteps_per_frame: Literal['W', 'D', 'h', '15min', 'min'] | None = None, color_map: str | None = None, **plot_kwargs: Any) -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plots a heatmap visualization of a variable using imshow or time-based reshaping.</p> <p>Supports multiple visualization features that can be combined: - Multi-variable: Plot multiple variables on a single heatmap (creates 'variable' dimension) - Time reshaping: Converts 'time' dimension into 2D (e.g., hours vs days) - Faceting: Creates subplots for different dimension values - Animation: Animates through dimension values (Plotly only)</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str | list[str]</code> <p>The name of the variable to plot, or a list of variable names. When a list is provided, variables are combined into a single DataArray with a new 'variable' dimension.</p> required <code>save</code> <code>bool | Path</code> <p>Whether to save the plot or not. If a path is provided, the plot will be saved at that location.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to show the plot or not.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color scheme for the heatmap. See <code>flixopt.plotting.ColorType</code> for options.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>The engine to use for plotting. Can be either 'plotly' or 'matplotlib'.</p> <code>'plotly'</code> <code>select</code> <code>dict[FlowSystemDimensions, Any] | None</code> <p>Optional data selection dict. Supports single values, lists, slices, and index arrays. Applied BEFORE faceting/animation/reshaping.</p> <code>None</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) to create facets (subplots) for. Can be a single dimension name (str) or list of dimensions. Each unique value combination creates a subplot. Ignored if not found.</p> <code>'scenario'</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over (Plotly only). Creates animation frames that cycle through dimension values. Only one dimension can be animated. Ignored if not found.</p> <code>'period'</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid layout (default: 3).</p> <code>None</code> <code>reshape_time</code> <code>tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None</code> <p>Time reshaping configuration (default: 'auto'): - 'auto': Automatically applies ('D', 'h') when only 'time' dimension remains - Tuple: Explicit reshaping, e.g. ('D', 'h') for days vs hours,          ('MS', 'D') for months vs days, ('W', 'h') for weeks vs hours - None: Disable auto-reshaping (will error if only 1D time data) Supported timeframes: 'YS', 'MS', 'W', 'D', 'h', '15min', 'min'</p> <code>'auto'</code> <code>fill</code> <code>Literal['ffill', 'bfill'] | None</code> <p>Method to fill missing values after reshape: 'ffill' (forward fill) or 'bfill' (backward fill). Default is 'ffill'.</p> <code>'ffill'</code> <code>**plot_kwargs</code> <code>Any</code> <p>Additional plotting customization options. Common options:</p> <ul> <li>dpi (int): Export resolution for saved plots. Default: 300.</li> </ul> <p>For heatmaps specifically:</p> <ul> <li>vmin (float): Minimum value for color scale (both engines).</li> <li>vmax (float): Maximum value for color scale (both engines).</li> </ul> <p>For Matplotlib heatmaps:</p> <ul> <li>imshow_kwargs (dict): Additional kwargs for matplotlib's imshow (e.g., interpolation, aspect).</li> <li>cbar_kwargs (dict): Additional kwargs for colorbar customization.</li> </ul> <code>{}</code> <p>Examples:</p> <p>Direct imshow mode (default):</p> Python Console Session<pre><code>&gt;&gt;&gt; results.plot_heatmap('Battery|charge_state', select={'scenario': 'base'})\n</code></pre> <p>Facet by scenario:</p> Python Console Session<pre><code>&gt;&gt;&gt; results.plot_heatmap('Boiler(Qth)|flow_rate', facet_by='scenario', facet_cols=2)\n</code></pre> <p>Animate by period:</p> Python Console Session<pre><code>&gt;&gt;&gt; results.plot_heatmap('Boiler(Qth)|flow_rate', select={'scenario': 'base'}, animate_by='period')\n</code></pre> <p>Time reshape mode - daily patterns:</p> Python Console Session<pre><code>&gt;&gt;&gt; results.plot_heatmap('Boiler(Qth)|flow_rate', select={'scenario': 'base'}, reshape_time=('D', 'h'))\n</code></pre> <p>Combined: time reshaping with faceting and animation:</p> Python Console Session<pre><code>&gt;&gt;&gt; results.plot_heatmap(\n...     'Boiler(Qth)|flow_rate', facet_by='scenario', animate_by='period', reshape_time=('D', 'h')\n... )\n</code></pre> <p>Multi-variable heatmap (variables as one axis):</p> Python Console Session<pre><code>&gt;&gt;&gt; results.plot_heatmap(\n...     ['Boiler(Q_th)|flow_rate', 'CHP(Q_th)|flow_rate', 'HeatStorage|charge_state'],\n...     select={'scenario': 'base', 'period': 1},\n...     reshape_time=None,\n... )\n</code></pre> <p>Multi-variable with time reshaping:</p> Python Console Session<pre><code>&gt;&gt;&gt; results.plot_heatmap(\n...     ['Boiler(Q_th)|flow_rate', 'CHP(Q_th)|flow_rate'],\n...     facet_by='scenario',\n...     animate_by='period',\n...     reshape_time=('D', 'h'),\n... )\n</code></pre> <p>High-resolution export with custom color range:</p> Python Console Session<pre><code>&gt;&gt;&gt; results.plot_heatmap('Battery|charge_state', save=True, dpi=600, vmin=0, vmax=100)\n</code></pre> <p>Matplotlib heatmap with custom imshow settings:</p> Python Console Session<pre><code>&gt;&gt;&gt; results.plot_heatmap(\n...     'Boiler(Q_th)|flow_rate',\n...     engine='matplotlib',\n...     imshow_kwargs={'interpolation': 'bilinear', 'aspect': 'auto'},\n... )\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.plot_network","title":"plot_network","text":"Python<pre><code>plot_network(controls: bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']] = True, path: Path | None = None, show: bool = False) -&gt; pyvis.network.Network | None\n</code></pre> <p>Plot interactive network visualization of the system.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]</code> <p>Enable/disable interactive controls.</p> <code>True</code> <code>path</code> <code>Path | None</code> <p>Save path for network HTML.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Whether to display the plot.</p> <code>False</code>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.to_file","title":"to_file","text":"Python<pre><code>to_file(folder: str | Path | None = None, name: str | None = None, compression: int = 5, document_model: bool = True, save_linopy_model: bool = False)\n</code></pre> <p>Save results to files.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path | None</code> <p>Save folder (defaults to calculation folder).</p> <code>None</code> <code>name</code> <code>str | None</code> <p>File name (defaults to calculation name).</p> <code>None</code> <code>compression</code> <code>int</code> <p>Compression level 0-9.</p> <code>5</code> <code>document_model</code> <code>bool</code> <p>Whether to document model formulations as yaml.</p> <code>True</code> <code>save_linopy_model</code> <code>bool</code> <p>Whether to save linopy model file.</p> <code>False</code>"},{"location":"api-reference/results/#flixopt.results.BusResults","title":"BusResults","text":"Python<pre><code>BusResults(calculation_results: CalculationResults, label: str, variables: list[str], constraints: list[str], inputs: list[str], outputs: list[str], flows: list[str])\n</code></pre> <p>               Bases: <code>_NodeResults</code></p> <p>Results container for energy/material balance nodes in the system.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.BusResults.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>Get element variables (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>Get element constraints (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.BusResults.filter_solution","title":"filter_solution","text":"Python<pre><code>filter_solution(variable_dims: Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None = None, timesteps: DatetimeIndex | None = None, scenarios: Index | None = None, contains: str | list[str] | None = None, startswith: str | list[str] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter the solution to a specific variable dimension and element. If no element is specified, all elements are included.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None</code> <p>The dimension of which to get variables from. - 'scalar': Get scalar variables (without dimensions) - 'time': Get time-dependent variables (with a time dimension) - 'scenario': Get scenario-dependent variables (with ONLY a scenario dimension) - 'timeonly': Get time-dependent variables (with ONLY a time dimension) - 'scenarioonly': Get scenario-dependent variables (with ONLY a scenario dimension)</p> <code>None</code> <code>timesteps</code> <code>DatetimeIndex | None</code> <p>Optional time indexes to select. Can be: - pd.DatetimeIndex: Multiple timesteps - str/pd.Timestamp: Single timestep Defaults to all available timesteps.</p> <code>None</code> <code>scenarios</code> <code>Index | None</code> <p>Optional scenario indexes to select. Can be: - pd.Index: Multiple scenarios - str/int: Single scenario (int is treated as a label, not an index position) Defaults to all available scenarios.</p> <code>None</code> <code>contains</code> <code>str | list[str] | None</code> <p>Filter variables that contain this string or strings. If a list is provided, variables must contain ALL strings in the list.</p> <code>None</code> <code>startswith</code> <code>str | list[str] | None</code> <p>Filter variables that start with this string or strings. If a list is provided, variables must start with ANY of the strings in the list.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.BusResults.plot_node_balance","title":"plot_node_balance","text":"Python<pre><code>plot_node_balance(save: bool | Path = False, show: bool | None = None, colors: ColorType | None = None, engine: PlottingEngine = 'plotly', select: dict[FlowSystemDimensions, Any] | None = None, unit_type: Literal['flow_rate', 'flow_hours'] = 'flow_rate', mode: Literal['area', 'stacked_bar', 'line'] = 'stacked_bar', drop_suffix: bool = True, facet_by: str | list[str] | None = 'scenario', animate_by: str | None = 'period', facet_cols: int | None = None, indexer: dict[FlowSystemDimensions, Any] | None = None, **plot_kwargs: Any) -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plots the node balance of the Component or Bus with optional faceting and animation.</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool | Path</code> <p>Whether to save the plot or not. If a path is provided, the plot will be saved at that location.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to show the plot or not.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>The colors to use for the plot. See <code>flixopt.plotting.ColorType</code> for options.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>The engine to use for plotting. Can be either 'plotly' or 'matplotlib'.</p> <code>'plotly'</code> <code>select</code> <code>dict[FlowSystemDimensions, Any] | None</code> <p>Optional data selection dict. Supports: - Single values: {'scenario': 'base', 'period': 2024} - Multiple values: {'scenario': ['base', 'high', 'renewable']} - Slices: {'time': slice('2024-01', '2024-06')} - Index arrays: {'time': time_array} Note: Applied BEFORE faceting/animation.</p> <code>None</code> <code>unit_type</code> <code>Literal['flow_rate', 'flow_hours']</code> <p>The unit type to use for the dataset. Can be 'flow_rate' or 'flow_hours'. - 'flow_rate': Returns the flow_rates of the Node. - 'flow_hours': Returns the flow_hours of the Node. [flow_hours(t) = flow_rate(t) * dt(t)]. Renames suffixes to |flow_hours.</p> <code>'flow_rate'</code> <code>mode</code> <code>Literal['area', 'stacked_bar', 'line']</code> <p>The plotting mode. Use 'stacked_bar' for stacked bar charts, 'line' for stepped lines, or 'area' for stacked area charts.</p> <code>'stacked_bar'</code> <code>drop_suffix</code> <code>bool</code> <p>Whether to drop the suffix from the variable names.</p> <code>True</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) to create facets (subplots) for. Can be a single dimension name (str) or list of dimensions. Each unique value combination creates a subplot. Ignored if not found. Example: 'scenario' creates one subplot per scenario. Example: ['scenario', 'period'] creates a grid of subplots for each scenario-period combination.</p> <code>'scenario'</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over (Plotly only). Creates animation frames that cycle through dimension values. Only one dimension can be animated. Ignored if not found.</p> <code>'period'</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid layout (default: 3).</p> <code>None</code> <code>**plot_kwargs</code> <code>Any</code> <p>Additional plotting customization options passed to underlying plotting functions.</p> <p>Common options:</p> <ul> <li>dpi (int): Export resolution in dots per inch. Default: 300.</li> </ul> <p>For Plotly engine (<code>engine='plotly'</code>):</p> <ul> <li>Any Plotly Express parameter for px.bar()/px.line()/px.area()   Example: <code>range_y=[0, 100]</code>, <code>line_shape='linear'</code></li> </ul> <p>For Matplotlib engine (<code>engine='matplotlib'</code>):</p> <ul> <li>plot_kwargs (dict): Customize plot via <code>ax.bar()</code> or <code>ax.step()</code>.   Example: <code>plot_kwargs={'linewidth': 3, 'alpha': 0.7, 'edgecolor': 'black'}</code></li> </ul> <p>See :func:<code>flixopt.plotting.with_plotly</code> and :func:<code>flixopt.plotting.with_matplotlib</code> for complete parameter reference.</p> <p>Note: For Plotly, you can further customize the returned figure using <code>fig.update_traces()</code> and <code>fig.update_layout()</code> after calling this method.</p> <code>{}</code> <p>Examples:</p> <p>Basic plot (current behavior):</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance()\n</code></pre> <p>Facet by scenario:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(facet_by='scenario', facet_cols=2)\n</code></pre> <p>Animate by period:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(animate_by='period')\n</code></pre> <p>Facet by scenario AND animate by period:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(facet_by='scenario', animate_by='period')\n</code></pre> <p>Select single scenario, then facet by period:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(select={'scenario': 'base'}, facet_by='period')\n</code></pre> <p>Select multiple scenarios and facet by them:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(\n...     select={'scenario': ['base', 'high', 'renewable']}, facet_by='scenario'\n... )\n</code></pre> <p>Time range selection (summer months only):</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(select={'time': slice('2024-06', '2024-08')}, facet_by='scenario')\n</code></pre> <p>High-resolution export for publication:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(engine='matplotlib', save='figure.png', dpi=600)\n</code></pre> <p>Plotly Express customization (e.g., set y-axis range):</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(range_y=[0, 100])\n</code></pre> <p>Custom matplotlib appearance:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(engine='matplotlib', plot_kwargs={'linewidth': 3, 'alpha': 0.7})\n</code></pre> <p>Further customize Plotly figure after creation:</p> Python Console Session<pre><code>&gt;&gt;&gt; fig = results['Boiler'].plot_node_balance(mode='line', show=False)\n&gt;&gt;&gt; fig.update_traces(line={'width': 5, 'dash': 'dot'})\n&gt;&gt;&gt; fig.update_layout(template='plotly_dark', width=1200, height=600)\n&gt;&gt;&gt; fig.show()\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.BusResults.plot_node_balance_pie","title":"plot_node_balance_pie","text":"Python<pre><code>plot_node_balance_pie(lower_percentage_group: float = 5, colors: ColorType | None = None, text_info: str = 'percent+label+value', save: bool | Path = False, show: bool | None = None, engine: PlottingEngine = 'plotly', select: dict[FlowSystemDimensions, Any] | None = None, indexer: dict[FlowSystemDimensions, Any] | None = None, **plot_kwargs: Any) -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, list[plt.Axes]]\n</code></pre> <p>Plot pie chart of flow hours distribution.</p> Note <p>Pie charts require scalar data (no extra dimensions beyond time). If your data has dimensions like 'scenario' or 'period', either:</p> <ul> <li>Use <code>select</code> to choose specific values: <code>select={'scenario': 'base', 'period': 2024}</code></li> <li>Let auto-selection choose the first value (a warning will be logged)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>lower_percentage_group</code> <code>float</code> <p>Percentage threshold for \"Others\" grouping.</p> <code>5</code> <code>colors</code> <code>ColorType | None</code> <p>Color scheme. Also see plotly.</p> <code>None</code> <code>text_info</code> <code>str</code> <p>Information to display on pie slices.</p> <code>'percent+label+value'</code> <code>save</code> <code>bool | Path</code> <p>Whether to save plot.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to display plot.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine ('plotly' or 'matplotlib').</p> <code>'plotly'</code> <code>select</code> <code>dict[FlowSystemDimensions, Any] | None</code> <p>Optional data selection dict. Supports single values, lists, slices, and index arrays. Use this to select specific scenario/period before creating the pie chart.</p> <code>None</code> <code>**plot_kwargs</code> <code>Any</code> <p>Additional plotting customization options.</p> <p>Common options:</p> <ul> <li>dpi (int): Export resolution in dots per inch. Default: 300.</li> <li>hover_template (str): Hover text template (Plotly only).   Example: <code>hover_template='%{label}: %{value} (%{percent})'</code></li> <li>text_position (str): Text position ('inside', 'outside', 'auto').</li> <li>hole (float): Size of donut hole (0.0 to 1.0).</li> </ul> <p>See :func:<code>flixopt.plotting.dual_pie_with_plotly</code> for complete reference.</p> <code>{}</code> <p>Examples:</p> <p>Basic usage (auto-selects first scenario/period if present):</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie()\n</code></pre> <p>Explicitly select a scenario and period:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie(select={'scenario': 'high_demand', 'period': 2030})\n</code></pre> <p>Create a donut chart with custom hover text:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie(hole=0.4, hover_template='%{label}: %{value:.2f} (%{percent})')\n</code></pre> <p>High-resolution export:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie(save='figure.png', dpi=600)\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.BusResults.node_balance","title":"node_balance","text":"Python<pre><code>node_balance(negate_inputs: bool = True, negate_outputs: bool = False, threshold: float | None = 1e-05, with_last_timestep: bool = False, unit_type: Literal['flow_rate', 'flow_hours'] = 'flow_rate', drop_suffix: bool = False, select: dict[FlowSystemDimensions, Any] | None = None, indexer: dict[FlowSystemDimensions, Any] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Returns a dataset with the node balance of the Component or Bus. Args:     negate_inputs: Whether to negate the input flow_rates of the Node.     negate_outputs: Whether to negate the output flow_rates of the Node.     threshold: The threshold for small values. Variables with all values below the threshold are dropped.     with_last_timestep: Whether to include the last timestep in the dataset.     unit_type: The unit type to use for the dataset. Can be 'flow_rate' or 'flow_hours'.         - 'flow_rate': Returns the flow_rates of the Node.         - 'flow_hours': Returns the flow_hours of the Node. [flow_hours(t) = flow_rate(t) * dt(t)]. Renames suffixes to |flow_hours.     drop_suffix: Whether to drop the suffix from the variable names.     select: Optional data selection dict. Supports single values, lists, slices, and index arrays.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults","title":"ComponentResults","text":"Python<pre><code>ComponentResults(calculation_results: CalculationResults, label: str, variables: list[str], constraints: list[str], inputs: list[str], outputs: list[str], flows: list[str])\n</code></pre> <p>               Bases: <code>_NodeResults</code></p> <p>Results container for individual system components with specialized analysis tools.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.ComponentResults.charge_state","title":"charge_state  <code>property</code>","text":"Python<pre><code>charge_state: DataArray\n</code></pre> <p>Get storage charge state solution.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>Get element variables (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>Get element constraints (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.ComponentResults.plot_charge_state","title":"plot_charge_state","text":"Python<pre><code>plot_charge_state(save: bool | Path = False, show: bool | None = None, colors: ColorType | None = None, engine: PlottingEngine = 'plotly', mode: Literal['area', 'stacked_bar', 'line'] = 'area', select: dict[FlowSystemDimensions, Any] | None = None, facet_by: str | list[str] | None = 'scenario', animate_by: str | None = 'period', facet_cols: int | None = None, indexer: dict[FlowSystemDimensions, Any] | None = None, **plot_kwargs: Any) -&gt; plotly.graph_objs.Figure\n</code></pre> <p>Plot storage charge state over time, combined with the node balance with optional faceting and animation.</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool | Path</code> <p>Whether to save the plot or not. If a path is provided, the plot will be saved at that location.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to show the plot or not.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color scheme. Also see plotly.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine to use. Only 'plotly' is implemented atm.</p> <code>'plotly'</code> <code>mode</code> <code>Literal['area', 'stacked_bar', 'line']</code> <p>The plotting mode. Use 'stacked_bar' for stacked bar charts, 'line' for stepped lines, or 'area' for stacked area charts.</p> <code>'area'</code> <code>select</code> <code>dict[FlowSystemDimensions, Any] | None</code> <p>Optional data selection dict. Supports single values, lists, slices, and index arrays. Applied BEFORE faceting/animation.</p> <code>None</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) to create facets (subplots) for. Can be a single dimension name (str) or list of dimensions. Each unique value combination creates a subplot. Ignored if not found.</p> <code>'scenario'</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over (Plotly only). Creates animation frames that cycle through dimension values. Only one dimension can be animated. Ignored if not found.</p> <code>'period'</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid layout (default: 3).</p> <code>None</code> <code>**plot_kwargs</code> <code>Any</code> <p>Additional plotting customization options passed to underlying plotting functions.</p> <p>Common options:</p> <ul> <li>dpi (int): Export resolution in dots per inch. Default: 300.</li> </ul> <p>For Plotly engine:</p> <ul> <li>Any Plotly Express parameter for px.bar()/px.line()/px.area()   Example: <code>range_y=[0, 100]</code>, <code>line_shape='linear'</code></li> </ul> <p>For Matplotlib engine:</p> <ul> <li>plot_kwargs (dict): Customize plot via <code>ax.bar()</code> or <code>ax.step()</code>.</li> </ul> <p>See :func:<code>flixopt.plotting.with_plotly</code> and :func:<code>flixopt.plotting.with_matplotlib</code> for complete parameter reference.</p> <p>Note: For Plotly, you can further customize the returned figure using <code>fig.update_traces()</code> and <code>fig.update_layout()</code> after calling this method.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If component is not a storage.</p> <p>Examples:</p> <p>Basic plot:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Storage'].plot_charge_state()\n</code></pre> <p>Facet by scenario:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Storage'].plot_charge_state(facet_by='scenario', facet_cols=2)\n</code></pre> <p>Animate by period:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Storage'].plot_charge_state(animate_by='period')\n</code></pre> <p>Facet by scenario AND animate by period:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Storage'].plot_charge_state(facet_by='scenario', animate_by='period')\n</code></pre> <p>Custom layout after creation:</p> Python Console Session<pre><code>&gt;&gt;&gt; fig = results['Storage'].plot_charge_state(show=False)\n&gt;&gt;&gt; fig.update_layout(template='plotly_dark', height=800)\n&gt;&gt;&gt; fig.show()\n</code></pre> <p>High-resolution export:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Storage'].plot_charge_state(save='storage.png', dpi=600)\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.node_balance_with_charge_state","title":"node_balance_with_charge_state","text":"Python<pre><code>node_balance_with_charge_state(negate_inputs: bool = True, negate_outputs: bool = False, threshold: float | None = 1e-05) -&gt; xr.Dataset\n</code></pre> <p>Get storage node balance including charge state.</p> <p>Parameters:</p> Name Type Description Default <code>negate_inputs</code> <code>bool</code> <p>Whether to negate input flows.</p> <code>True</code> <code>negate_outputs</code> <code>bool</code> <p>Whether to negate output flows.</p> <code>False</code> <code>threshold</code> <code>float | None</code> <p>Threshold for small values.</p> <code>1e-05</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Node balance with charge state.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If component is not a storage.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.filter_solution","title":"filter_solution","text":"Python<pre><code>filter_solution(variable_dims: Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None = None, timesteps: DatetimeIndex | None = None, scenarios: Index | None = None, contains: str | list[str] | None = None, startswith: str | list[str] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter the solution to a specific variable dimension and element. If no element is specified, all elements are included.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None</code> <p>The dimension of which to get variables from. - 'scalar': Get scalar variables (without dimensions) - 'time': Get time-dependent variables (with a time dimension) - 'scenario': Get scenario-dependent variables (with ONLY a scenario dimension) - 'timeonly': Get time-dependent variables (with ONLY a time dimension) - 'scenarioonly': Get scenario-dependent variables (with ONLY a scenario dimension)</p> <code>None</code> <code>timesteps</code> <code>DatetimeIndex | None</code> <p>Optional time indexes to select. Can be: - pd.DatetimeIndex: Multiple timesteps - str/pd.Timestamp: Single timestep Defaults to all available timesteps.</p> <code>None</code> <code>scenarios</code> <code>Index | None</code> <p>Optional scenario indexes to select. Can be: - pd.Index: Multiple scenarios - str/int: Single scenario (int is treated as a label, not an index position) Defaults to all available scenarios.</p> <code>None</code> <code>contains</code> <code>str | list[str] | None</code> <p>Filter variables that contain this string or strings. If a list is provided, variables must contain ALL strings in the list.</p> <code>None</code> <code>startswith</code> <code>str | list[str] | None</code> <p>Filter variables that start with this string or strings. If a list is provided, variables must start with ANY of the strings in the list.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.plot_node_balance","title":"plot_node_balance","text":"Python<pre><code>plot_node_balance(save: bool | Path = False, show: bool | None = None, colors: ColorType | None = None, engine: PlottingEngine = 'plotly', select: dict[FlowSystemDimensions, Any] | None = None, unit_type: Literal['flow_rate', 'flow_hours'] = 'flow_rate', mode: Literal['area', 'stacked_bar', 'line'] = 'stacked_bar', drop_suffix: bool = True, facet_by: str | list[str] | None = 'scenario', animate_by: str | None = 'period', facet_cols: int | None = None, indexer: dict[FlowSystemDimensions, Any] | None = None, **plot_kwargs: Any) -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plots the node balance of the Component or Bus with optional faceting and animation.</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool | Path</code> <p>Whether to save the plot or not. If a path is provided, the plot will be saved at that location.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to show the plot or not.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>The colors to use for the plot. See <code>flixopt.plotting.ColorType</code> for options.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>The engine to use for plotting. Can be either 'plotly' or 'matplotlib'.</p> <code>'plotly'</code> <code>select</code> <code>dict[FlowSystemDimensions, Any] | None</code> <p>Optional data selection dict. Supports: - Single values: {'scenario': 'base', 'period': 2024} - Multiple values: {'scenario': ['base', 'high', 'renewable']} - Slices: {'time': slice('2024-01', '2024-06')} - Index arrays: {'time': time_array} Note: Applied BEFORE faceting/animation.</p> <code>None</code> <code>unit_type</code> <code>Literal['flow_rate', 'flow_hours']</code> <p>The unit type to use for the dataset. Can be 'flow_rate' or 'flow_hours'. - 'flow_rate': Returns the flow_rates of the Node. - 'flow_hours': Returns the flow_hours of the Node. [flow_hours(t) = flow_rate(t) * dt(t)]. Renames suffixes to |flow_hours.</p> <code>'flow_rate'</code> <code>mode</code> <code>Literal['area', 'stacked_bar', 'line']</code> <p>The plotting mode. Use 'stacked_bar' for stacked bar charts, 'line' for stepped lines, or 'area' for stacked area charts.</p> <code>'stacked_bar'</code> <code>drop_suffix</code> <code>bool</code> <p>Whether to drop the suffix from the variable names.</p> <code>True</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) to create facets (subplots) for. Can be a single dimension name (str) or list of dimensions. Each unique value combination creates a subplot. Ignored if not found. Example: 'scenario' creates one subplot per scenario. Example: ['scenario', 'period'] creates a grid of subplots for each scenario-period combination.</p> <code>'scenario'</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over (Plotly only). Creates animation frames that cycle through dimension values. Only one dimension can be animated. Ignored if not found.</p> <code>'period'</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid layout (default: 3).</p> <code>None</code> <code>**plot_kwargs</code> <code>Any</code> <p>Additional plotting customization options passed to underlying plotting functions.</p> <p>Common options:</p> <ul> <li>dpi (int): Export resolution in dots per inch. Default: 300.</li> </ul> <p>For Plotly engine (<code>engine='plotly'</code>):</p> <ul> <li>Any Plotly Express parameter for px.bar()/px.line()/px.area()   Example: <code>range_y=[0, 100]</code>, <code>line_shape='linear'</code></li> </ul> <p>For Matplotlib engine (<code>engine='matplotlib'</code>):</p> <ul> <li>plot_kwargs (dict): Customize plot via <code>ax.bar()</code> or <code>ax.step()</code>.   Example: <code>plot_kwargs={'linewidth': 3, 'alpha': 0.7, 'edgecolor': 'black'}</code></li> </ul> <p>See :func:<code>flixopt.plotting.with_plotly</code> and :func:<code>flixopt.plotting.with_matplotlib</code> for complete parameter reference.</p> <p>Note: For Plotly, you can further customize the returned figure using <code>fig.update_traces()</code> and <code>fig.update_layout()</code> after calling this method.</p> <code>{}</code> <p>Examples:</p> <p>Basic plot (current behavior):</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance()\n</code></pre> <p>Facet by scenario:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(facet_by='scenario', facet_cols=2)\n</code></pre> <p>Animate by period:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(animate_by='period')\n</code></pre> <p>Facet by scenario AND animate by period:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(facet_by='scenario', animate_by='period')\n</code></pre> <p>Select single scenario, then facet by period:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(select={'scenario': 'base'}, facet_by='period')\n</code></pre> <p>Select multiple scenarios and facet by them:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(\n...     select={'scenario': ['base', 'high', 'renewable']}, facet_by='scenario'\n... )\n</code></pre> <p>Time range selection (summer months only):</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(select={'time': slice('2024-06', '2024-08')}, facet_by='scenario')\n</code></pre> <p>High-resolution export for publication:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(engine='matplotlib', save='figure.png', dpi=600)\n</code></pre> <p>Plotly Express customization (e.g., set y-axis range):</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(range_y=[0, 100])\n</code></pre> <p>Custom matplotlib appearance:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(engine='matplotlib', plot_kwargs={'linewidth': 3, 'alpha': 0.7})\n</code></pre> <p>Further customize Plotly figure after creation:</p> Python Console Session<pre><code>&gt;&gt;&gt; fig = results['Boiler'].plot_node_balance(mode='line', show=False)\n&gt;&gt;&gt; fig.update_traces(line={'width': 5, 'dash': 'dot'})\n&gt;&gt;&gt; fig.update_layout(template='plotly_dark', width=1200, height=600)\n&gt;&gt;&gt; fig.show()\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.plot_node_balance_pie","title":"plot_node_balance_pie","text":"Python<pre><code>plot_node_balance_pie(lower_percentage_group: float = 5, colors: ColorType | None = None, text_info: str = 'percent+label+value', save: bool | Path = False, show: bool | None = None, engine: PlottingEngine = 'plotly', select: dict[FlowSystemDimensions, Any] | None = None, indexer: dict[FlowSystemDimensions, Any] | None = None, **plot_kwargs: Any) -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, list[plt.Axes]]\n</code></pre> <p>Plot pie chart of flow hours distribution.</p> Note <p>Pie charts require scalar data (no extra dimensions beyond time). If your data has dimensions like 'scenario' or 'period', either:</p> <ul> <li>Use <code>select</code> to choose specific values: <code>select={'scenario': 'base', 'period': 2024}</code></li> <li>Let auto-selection choose the first value (a warning will be logged)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>lower_percentage_group</code> <code>float</code> <p>Percentage threshold for \"Others\" grouping.</p> <code>5</code> <code>colors</code> <code>ColorType | None</code> <p>Color scheme. Also see plotly.</p> <code>None</code> <code>text_info</code> <code>str</code> <p>Information to display on pie slices.</p> <code>'percent+label+value'</code> <code>save</code> <code>bool | Path</code> <p>Whether to save plot.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to display plot.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine ('plotly' or 'matplotlib').</p> <code>'plotly'</code> <code>select</code> <code>dict[FlowSystemDimensions, Any] | None</code> <p>Optional data selection dict. Supports single values, lists, slices, and index arrays. Use this to select specific scenario/period before creating the pie chart.</p> <code>None</code> <code>**plot_kwargs</code> <code>Any</code> <p>Additional plotting customization options.</p> <p>Common options:</p> <ul> <li>dpi (int): Export resolution in dots per inch. Default: 300.</li> <li>hover_template (str): Hover text template (Plotly only).   Example: <code>hover_template='%{label}: %{value} (%{percent})'</code></li> <li>text_position (str): Text position ('inside', 'outside', 'auto').</li> <li>hole (float): Size of donut hole (0.0 to 1.0).</li> </ul> <p>See :func:<code>flixopt.plotting.dual_pie_with_plotly</code> for complete reference.</p> <code>{}</code> <p>Examples:</p> <p>Basic usage (auto-selects first scenario/period if present):</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie()\n</code></pre> <p>Explicitly select a scenario and period:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie(select={'scenario': 'high_demand', 'period': 2030})\n</code></pre> <p>Create a donut chart with custom hover text:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie(hole=0.4, hover_template='%{label}: %{value:.2f} (%{percent})')\n</code></pre> <p>High-resolution export:</p> Python Console Session<pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie(save='figure.png', dpi=600)\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.node_balance","title":"node_balance","text":"Python<pre><code>node_balance(negate_inputs: bool = True, negate_outputs: bool = False, threshold: float | None = 1e-05, with_last_timestep: bool = False, unit_type: Literal['flow_rate', 'flow_hours'] = 'flow_rate', drop_suffix: bool = False, select: dict[FlowSystemDimensions, Any] | None = None, indexer: dict[FlowSystemDimensions, Any] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Returns a dataset with the node balance of the Component or Bus. Args:     negate_inputs: Whether to negate the input flow_rates of the Node.     negate_outputs: Whether to negate the output flow_rates of the Node.     threshold: The threshold for small values. Variables with all values below the threshold are dropped.     with_last_timestep: Whether to include the last timestep in the dataset.     unit_type: The unit type to use for the dataset. Can be 'flow_rate' or 'flow_hours'.         - 'flow_rate': Returns the flow_rates of the Node.         - 'flow_hours': Returns the flow_hours of the Node. [flow_hours(t) = flow_rate(t) * dt(t)]. Renames suffixes to |flow_hours.     drop_suffix: Whether to drop the suffix from the variable names.     select: Optional data selection dict. Supports single values, lists, slices, and index arrays.</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults","title":"EffectResults","text":"Python<pre><code>EffectResults(calculation_results: CalculationResults, label: str, variables: list[str], constraints: list[str])\n</code></pre> <p>               Bases: <code>_ElementResults</code></p> <p>Results for an Effect</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.EffectResults.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>Get element variables (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>Get element constraints (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.EffectResults.get_shares_from","title":"get_shares_from","text":"Python<pre><code>get_shares_from(element: str) -&gt; xr.Dataset\n</code></pre> <p>Get effect shares from specific element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>Element label to get shares from.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Element shares to this effect.</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults.filter_solution","title":"filter_solution","text":"Python<pre><code>filter_solution(variable_dims: Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None = None, timesteps: DatetimeIndex | None = None, scenarios: Index | None = None, contains: str | list[str] | None = None, startswith: str | list[str] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter the solution to a specific variable dimension and element. If no element is specified, all elements are included.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None</code> <p>The dimension of which to get variables from. - 'scalar': Get scalar variables (without dimensions) - 'time': Get time-dependent variables (with a time dimension) - 'scenario': Get scenario-dependent variables (with ONLY a scenario dimension) - 'timeonly': Get time-dependent variables (with ONLY a time dimension) - 'scenarioonly': Get scenario-dependent variables (with ONLY a scenario dimension)</p> <code>None</code> <code>timesteps</code> <code>DatetimeIndex | None</code> <p>Optional time indexes to select. Can be: - pd.DatetimeIndex: Multiple timesteps - str/pd.Timestamp: Single timestep Defaults to all available timesteps.</p> <code>None</code> <code>scenarios</code> <code>Index | None</code> <p>Optional scenario indexes to select. Can be: - pd.Index: Multiple scenarios - str/int: Single scenario (int is treated as a label, not an index position) Defaults to all available scenarios.</p> <code>None</code> <code>contains</code> <code>str | list[str] | None</code> <p>Filter variables that contain this string or strings. If a list is provided, variables must contain ALL strings in the list.</p> <code>None</code> <code>startswith</code> <code>str | list[str] | None</code> <p>Filter variables that start with this string or strings. If a list is provided, variables must start with ANY of the strings in the list.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults","title":"SegmentedCalculationResults","text":"Python<pre><code>SegmentedCalculationResults(segment_results: list[CalculationResults], all_timesteps: DatetimeIndex, timesteps_per_segment: int, overlap_timesteps: int, name: str, folder: Path | None = None)\n</code></pre> <p>Results container for segmented optimization calculations with temporal decomposition.</p> <p>This class manages results from SegmentedCalculation runs where large optimization problems are solved by dividing the time horizon into smaller, overlapping segments. It provides unified access to results across all segments while maintaining the ability to analyze individual segment behavior.</p> Key Features <p>Unified Time Series: Automatically assembles results from all segments into continuous time series, removing overlaps and boundary effects Segment Analysis: Access individual segment results for debugging and validation Consistency Checks: Verify solution continuity at segment boundaries Memory Efficiency: Handles large datasets that exceed single-segment memory limits</p> Temporal Handling <p>The class manages the complex task of combining overlapping segment solutions into coherent time series, ensuring proper treatment of: - Storage state continuity between segments - Flow rate transitions at segment boundaries - Aggregated results over the full time horizon</p> <p>Examples:</p> <p>Load and analyze segmented results:</p> Python<pre><code># Load segmented calculation results\nresults = SegmentedCalculationResults.from_file('results', 'annual_segmented')\n\n# Access unified results across all segments\nfull_timeline = results.all_timesteps\ntotal_segments = len(results.segment_results)\n\n# Analyze individual segments\nfor i, segment in enumerate(results.segment_results):\n    print(f'Segment {i + 1}: {len(segment.solution.time)} timesteps')\n    segment_costs = segment.effects['cost'].total_value\n\n# Check solution continuity at boundaries\nsegment_boundaries = results.get_boundary_analysis()\nmax_discontinuity = segment_boundaries['max_storage_jump']\n</code></pre> <p>Create from segmented calculation:</p> Python<pre><code># After running segmented calculation\nsegmented_calc = SegmentedCalculation(\n    name='annual_system',\n    flow_system=system,\n    timesteps_per_segment=730,  # Monthly segments\n    overlap_timesteps=48,  # 2-day overlap\n)\nsegmented_calc.do_modeling_and_solve(solver='gurobi')\n\n# Extract unified results\nresults = SegmentedCalculationResults.from_calculation(segmented_calc)\n\n# Save combined results\nresults.to_file(compression=5)\n</code></pre> <p>Performance analysis across segments:</p> Python<pre><code># Compare segment solve times\nsolve_times = [seg.summary['durations']['solving'] for seg in results.segment_results]\navg_solve_time = sum(solve_times) / len(solve_times)\n\n# Verify solution quality consistency\nsegment_objectives = [seg.summary['objective_value'] for seg in results.segment_results]\n\n# Storage continuity analysis\nif 'Battery' in results.segment_results[0].components:\n    storage_continuity = results.check_storage_continuity('Battery')\n</code></pre> Design Considerations <p>Boundary Effects: Monitor solution quality at segment interfaces where foresight is limited compared to full-horizon optimization.</p> <p>Memory Management: Individual segment results are maintained for detailed analysis while providing unified access for system-wide metrics.</p> <p>Validation Tools: Built-in methods to verify temporal consistency and identify potential issues from segmentation approach.</p> Common Use Cases <ul> <li>Large-Scale Analysis: Annual or multi-period optimization results</li> <li>Memory-Constrained Systems: Results from systems exceeding hardware limits</li> <li>Segment Validation: Verifying segmentation approach effectiveness</li> <li>Performance Monitoring: Comparing segmented vs. full-horizon solutions</li> <li>Debugging: Identifying issues specific to temporal decomposition</li> </ul>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults.from_file","title":"from_file  <code>classmethod</code>","text":"Python<pre><code>from_file(folder: str | Path, name: str) -&gt; SegmentedCalculationResults\n</code></pre> <p>Load SegmentedCalculationResults from saved files.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path</code> <p>Directory containing saved files.</p> required <code>name</code> <code>str</code> <p>Base name of saved files.</p> required <p>Returns:</p> Name Type Description <code>SegmentedCalculationResults</code> <code>SegmentedCalculationResults</code> <p>Loaded instance.</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults.setup_colors","title":"setup_colors","text":"Python<pre><code>setup_colors(config: dict[str, str | list[str]] | str | Path | None = None, default_colorscale: str | None = None) -&gt; dict[str, str]\n</code></pre> <p>Setup colors for all variables across all segment results.</p> <p>This method applies the same color configuration to all segments, ensuring consistent visualization across the entire segmented calculation. The color mapping is propagated to each segment's CalculationResults instance.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, str | list[str]] | str | Path | None</code> <p>Configuration for color assignment. Can be: - dict: Maps components to colors/colorscales:     * 'component1': 'red'  # Single component to single color     * 'component1': '#FF0000'  # Single component to hex color     - OR maps colorscales to multiple components:     * 'colorscale_name': ['component1', 'component2']  # Colorscale across components - str: Path to a JSON/YAML config file or a colorscale name to apply to all - Path: Path to a JSON/YAML config file - None: Use default_colorscale for all components</p> <code>None</code> <code>default_colorscale</code> <code>str | None</code> <p>Default colorscale for unconfigured components (default: 'turbo')</p> <code>None</code> <p>Examples:</p> Python<pre><code># Apply colors to all segments\nsegmented_results.setup_colors(\n    {\n        'CHP': 'red',\n        'Blues': ['Storage1', 'Storage2'],\n        'Oranges': ['Solar1', 'Solar2'],\n    }\n)\n\n# Use a single colorscale for all components in all segments\nsegmented_results.setup_colors('portland')\n</code></pre> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Complete variable-to-color mapping dictionary from the first segment</p> <code>dict[str, str]</code> <p>(all segments will have the same mapping)</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults.solution_without_overlap","title":"solution_without_overlap","text":"Python<pre><code>solution_without_overlap(variable_name: str) -&gt; xr.DataArray\n</code></pre> <p>Get variable solution removing segment overlaps.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>Name of variable to extract.</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xr.DataArray: Continuous solution without overlaps.</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults.plot_heatmap","title":"plot_heatmap","text":"Python<pre><code>plot_heatmap(variable_name: str, reshape_time: tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None = 'auto', colors: ColorType | None = None, save: bool | Path = False, show: bool | None = None, engine: PlottingEngine = 'plotly', facet_by: str | list[str] | None = None, animate_by: str | None = None, facet_cols: int | None = None, fill: Literal['ffill', 'bfill'] | None = 'ffill', heatmap_timeframes: Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'] | None = None, heatmap_timesteps_per_frame: Literal['W', 'D', 'h', '15min', 'min'] | None = None, color_map: str | None = None, **plot_kwargs: Any) -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plot heatmap of variable solution across segments.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>Variable to plot.</p> required <code>reshape_time</code> <code>tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None</code> <p>Time reshaping configuration (default: 'auto'): - 'auto': Automatically applies ('D', 'h') when only 'time' dimension remains - Tuple like ('D', 'h'): Explicit reshaping (days vs hours) - None: Disable time reshaping</p> <code>'auto'</code> <code>colors</code> <code>ColorType | None</code> <p>Color scheme. See plotting.ColorType for options.</p> <code>None</code> <code>save</code> <code>bool | Path</code> <p>Whether to save plot.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to display plot.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine.</p> <code>'plotly'</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) to create facets (subplots) for.</p> <code>None</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over (Plotly only).</p> <code>None</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid layout.</p> <code>None</code> <code>fill</code> <code>Literal['ffill', 'bfill'] | None</code> <p>Method to fill missing values: 'ffill' or 'bfill'.</p> <code>'ffill'</code> <code>heatmap_timeframes</code> <code>Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'] | None</code> <p>(Deprecated) Use reshape_time instead.</p> <code>None</code> <code>heatmap_timesteps_per_frame</code> <code>Literal['W', 'D', 'h', '15min', 'min'] | None</code> <p>(Deprecated) Use reshape_time instead.</p> <code>None</code> <code>color_map</code> <code>str | None</code> <p>(Deprecated) Use colors instead.</p> <code>None</code> <code>**plot_kwargs</code> <code>Any</code> <p>Additional plotting customization options. Common options:</p> <ul> <li>dpi (int): Export resolution for saved plots. Default: 300.</li> <li>vmin (float): Minimum value for color scale.</li> <li>vmax (float): Maximum value for color scale.</li> </ul> <p>For Matplotlib heatmaps:</p> <ul> <li>imshow_kwargs (dict): Additional kwargs for matplotlib's imshow.</li> <li>cbar_kwargs (dict): Additional kwargs for colorbar customization.</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>Figure | tuple[Figure, Axes]</code> <p>Figure object.</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults.to_file","title":"to_file","text":"Python<pre><code>to_file(folder: str | Path | None = None, name: str | None = None, compression: int = 5)\n</code></pre> <p>Save segmented results to files.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path | None</code> <p>Save folder (defaults to instance folder).</p> <code>None</code> <code>name</code> <code>str | None</code> <p>File name (defaults to instance name).</p> <code>None</code> <code>compression</code> <code>int</code> <p>Compression level 0-9.</p> <code>5</code>"},{"location":"api-reference/results/#flixopt.results-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.load_mapping_from_file","title":"load_mapping_from_file","text":"Python<pre><code>load_mapping_from_file(path: Path) -&gt; dict[str, str | list[str]]\n</code></pre> <p>Load color mapping from JSON or YAML file.</p> <p>Tries loader based on file suffix first, with fallback to the other format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to config file (.json or .yaml/.yml)</p> required <p>Returns:</p> Type Description <code>dict[str, str | list[str]]</code> <p>Dictionary mapping components to colors or colorscales to component lists</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If file cannot be loaded as JSON or YAML</p>"},{"location":"api-reference/results/#flixopt.results.plot_heatmap","title":"plot_heatmap","text":"Python<pre><code>plot_heatmap(data: DataArray | Dataset, name: str | None = None, folder: Path | None = None, colors: ColorType | None = None, save: bool | Path = False, show: bool | None = None, engine: PlottingEngine = 'plotly', select: dict[str, Any] | None = None, facet_by: str | list[str] | None = None, animate_by: str | None = None, facet_cols: int | None = None, reshape_time: tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None = 'auto', fill: Literal['ffill', 'bfill'] | None = 'ffill', indexer: dict[str, Any] | None = None, heatmap_timeframes: Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'] | None = None, heatmap_timesteps_per_frame: Literal['W', 'D', 'h', '15min', 'min'] | None = None, color_map: str | None = None, **plot_kwargs: Any)\n</code></pre> <p>Plot heatmap visualization with support for multi-variable, faceting, and animation.</p> <p>This function provides a standalone interface to the heatmap plotting capabilities, supporting the same modern features as CalculationResults.plot_heatmap().</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataArray | Dataset</code> <p>Data to plot. Can be a single DataArray or an xarray Dataset. When a Dataset is provided, all data variables are combined along a new 'variable' dimension.</p> required <code>name</code> <code>str | None</code> <p>Optional name for the title. If not provided, uses the DataArray name or generates a default title for Datasets.</p> <code>None</code> <code>folder</code> <code>Path | None</code> <p>Save folder for the plot. Defaults to current directory if not provided.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color scheme for the heatmap. See <code>flixopt.plotting.ColorType</code> for options.</p> <code>None</code> <code>save</code> <code>bool | Path</code> <p>Whether to save the plot or not. If a path is provided, the plot will be saved at that location.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to show the plot or not.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>The engine to use for plotting. Can be either 'plotly' or 'matplotlib'.</p> <code>'plotly'</code> <code>select</code> <code>dict[str, Any] | None</code> <p>Optional data selection dict. Supports single values, lists, slices, and index arrays.</p> <code>None</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) to create facets (subplots) for. Can be a single dimension name (str) or list of dimensions. Each unique value combination creates a subplot.</p> <code>None</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over (Plotly only). Creates animation frames.</p> <code>None</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid layout (default: 3).</p> <code>None</code> <code>reshape_time</code> <code>tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None</code> <p>Time reshaping configuration (default: 'auto'): - 'auto': Automatically applies ('D', 'h') when only 'time' dimension remains - Tuple: Explicit reshaping, e.g. ('D', 'h') for days vs hours - None: Disable auto-reshaping</p> <code>'auto'</code> <code>fill</code> <code>Literal['ffill', 'bfill'] | None</code> <p>Method to fill missing values after reshape: 'ffill' (forward fill) or 'bfill' (backward fill). Default is 'ffill'.</p> <code>'ffill'</code> <p>Examples:</p> <p>Single DataArray with time reshaping:</p> Python Console Session<pre><code>&gt;&gt;&gt; plot_heatmap(data, name='Temperature', folder=Path('.'), reshape_time=('D', 'h'))\n</code></pre> <p>Dataset with multiple variables (facet by variable):</p> Python Console Session<pre><code>&gt;&gt;&gt; dataset = xr.Dataset({'Boiler': data1, 'CHP': data2, 'Storage': data3})\n&gt;&gt;&gt; plot_heatmap(\n...     dataset,\n...     folder=Path('.'),\n...     facet_by='variable',\n...     reshape_time=('D', 'h'),\n... )\n</code></pre> <p>Dataset with animation by variable:</p> Python Console Session<pre><code>&gt;&gt;&gt; plot_heatmap(dataset, animate_by='variable', reshape_time=('D', 'h'))\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.sanitize_dataset","title":"sanitize_dataset","text":"Python<pre><code>sanitize_dataset(ds: Dataset, timesteps: DatetimeIndex | None = None, threshold: float | None = 1e-05, negate: list[str] | None = None, drop_small_vars: bool = True, zero_small_values: bool = False, drop_suffix: str | None = None) -&gt; xr.Dataset\n</code></pre> <p>Clean dataset by handling small values and reindexing time.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset to sanitize.</p> required <code>timesteps</code> <code>DatetimeIndex | None</code> <p>Time index for reindexing (optional).</p> <code>None</code> <code>threshold</code> <code>float | None</code> <p>Threshold for small values processing.</p> <code>1e-05</code> <code>negate</code> <code>list[str] | None</code> <p>Variables to negate.</p> <code>None</code> <code>drop_small_vars</code> <code>bool</code> <p>Whether to drop variables below threshold.</p> <code>True</code> <code>zero_small_values</code> <code>bool</code> <p>Whether to zero values below threshold.</p> <code>False</code> <code>drop_suffix</code> <code>str | None</code> <p>Drop suffix of data var names. Split by the provided str.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.filter_dataset","title":"filter_dataset","text":"Python<pre><code>filter_dataset(ds: Dataset, variable_dims: Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None = None, timesteps: DatetimeIndex | str | Timestamp | None = None, scenarios: Index | str | int | None = None, contains: str | list[str] | None = None, startswith: str | list[str] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter dataset by variable dimensions, indexes, and with string filters for variable names.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>The dataset to filter.</p> required <code>variable_dims</code> <code>Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None</code> <p>The dimension of which to get variables from. - 'scalar': Get scalar variables (without dimensions) - 'time': Get time-dependent variables (with a time dimension) - 'scenario': Get scenario-dependent variables (with ONLY a scenario dimension) - 'timeonly': Get time-dependent variables (with ONLY a time dimension) - 'scenarioonly': Get scenario-dependent variables (with ONLY a scenario dimension)</p> <code>None</code> <code>timesteps</code> <code>DatetimeIndex | str | Timestamp | None</code> <p>Optional time indexes to select. Can be: - pd.DatetimeIndex: Multiple timesteps - str/pd.Timestamp: Single timestep Defaults to all available timesteps.</p> <code>None</code> <code>scenarios</code> <code>Index | str | int | None</code> <p>Optional scenario indexes to select. Can be: - pd.Index: Multiple scenarios - str/int: Single scenario (int is treated as a label, not an index position) Defaults to all available scenarios.</p> <code>None</code> <code>contains</code> <code>str | list[str] | None</code> <p>Filter variables that contain this string or strings. If a list is provided, variables must contain ALL strings in the list.</p> <code>None</code> <code>startswith</code> <code>str | list[str] | None</code> <p>Filter variables that start with this string or strings. If a list is provided, variables must start with ANY of the strings in the list.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.filter_dataarray_by_coord","title":"filter_dataarray_by_coord","text":"Python<pre><code>filter_dataarray_by_coord(da: DataArray, **kwargs: str | list[str] | None) -&gt; xr.DataArray\n</code></pre> <p>Filter flows by node and component attributes.</p> <p>Filters are applied in the order they are specified. All filters must match for an edge to be included.</p> <p>To recombine filtered dataarrays, use <code>xr.concat</code>.</p> <p>xr.concat([res.sizes(start='Fernw\u00e4rme'), res.sizes(end='Fernw\u00e4rme')], dim='flow')</p> <p>Parameters:</p> Name Type Description Default <code>da</code> <code>DataArray</code> <p>Flow DataArray with network metadata coordinates.</p> required <code>**kwargs</code> <code>str | list[str] | None</code> <p>Coord filters as name=value pairs.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>Filtered DataArray with matching edges.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If required coordinates are missing.</p> <code>ValueError</code> <p>If specified nodes don't exist or no matches found.</p>"},{"location":"api-reference/solvers/","title":"Solvers","text":""},{"location":"api-reference/solvers/#flixopt.solvers","title":"flixopt.solvers","text":"<p>This module contains the solvers of the flixopt framework, making them available to the end user in a compact way.</p>"},{"location":"api-reference/solvers/#flixopt.solvers-classes","title":"Classes","text":""},{"location":"api-reference/solvers/#flixopt.solvers.GurobiSolver","title":"GurobiSolver  <code>dataclass</code>","text":"Python<pre><code>GurobiSolver(mip_gap: float, time_limit_seconds: int, extra_options: dict[str, Any] = dict())\n</code></pre> <p>               Bases: <code>_Solver</code></p> <p>Gurobi solver configuration.</p> <p>Parameters:</p> Name Type Description Default <code>mip_gap</code> <code>float</code> <p>Acceptable relative optimality gap in [0.0, 1.0]; mapped to Gurobi <code>MIPGap</code>.</p> required <code>time_limit_seconds</code> <code>int</code> <p>Time limit in seconds; mapped to Gurobi <code>TimeLimit</code>.</p> required <code>extra_options</code> <code>dict[str, Any]</code> <p>Additional solver options merged into <code>options</code>.</p> <code>dict()</code>"},{"location":"api-reference/solvers/#flixopt.solvers.GurobiSolver-attributes","title":"Attributes","text":""},{"location":"api-reference/solvers/#flixopt.solvers.GurobiSolver.options","title":"options  <code>property</code>","text":"Python<pre><code>options: dict[str, Any]\n</code></pre> <p>Return a dictionary of solver options.</p>"},{"location":"api-reference/solvers/#flixopt.solvers.HighsSolver","title":"HighsSolver  <code>dataclass</code>","text":"Python<pre><code>HighsSolver(mip_gap: float, time_limit_seconds: int, extra_options: dict[str, Any] = dict())\n</code></pre> <p>               Bases: <code>_Solver</code></p> <p>HiGHS solver configuration.</p> <p>Attributes:</p> Name Type Description <code>mip_gap</code> <code>float</code> <p>Acceptable relative optimality gap in [0.0, 1.0]; mapped to HiGHS <code>mip_rel_gap</code>.</p> <code>time_limit_seconds</code> <code>int</code> <p>Time limit in seconds; mapped to HiGHS <code>time_limit</code>.</p> <code>extra_options</code> <code>dict[str, Any]</code> <p>Additional solver options merged into <code>options</code>.</p> <code>threads</code> <code>int | None</code> <p>Number of threads to use. If None, HiGHS chooses.</p>"},{"location":"api-reference/solvers/#flixopt.solvers.HighsSolver-attributes","title":"Attributes","text":""},{"location":"api-reference/solvers/#flixopt.solvers.HighsSolver.options","title":"options  <code>property</code>","text":"Python<pre><code>options: dict[str, Any]\n</code></pre> <p>Return a dictionary of solver options.</p>"},{"location":"api-reference/structure/","title":"Structure","text":""},{"location":"api-reference/structure/#flixopt.structure","title":"flixopt.structure","text":"<p>This module contains the core structure of the flixopt framework. These classes are not directly used by the end user, but are used by other modules.</p>"},{"location":"api-reference/structure/#flixopt.structure-classes","title":"Classes","text":""},{"location":"api-reference/structure/#flixopt.structure.SubmodelsMixin","title":"SubmodelsMixin","text":"<p>Mixin that provides submodel functionality for both FlowSystemModel and Submodel.</p>"},{"location":"api-reference/structure/#flixopt.structure.SubmodelsMixin-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.SubmodelsMixin.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/structure/#flixopt.structure.SubmodelsMixin-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.SubmodelsMixin.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel","title":"FlowSystemModel","text":"Python<pre><code>FlowSystemModel(flow_system: FlowSystem, normalize_weights: bool)\n</code></pre> <p>               Bases: <code>Model</code>, <code>SubmodelsMixin</code></p> <p>The FlowSystemModel is the linopy Model that is used to create the mathematical model of the flow_system. It is used to create and store the variables and constraints for the flow_system.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The flow_system that is used to create the model.</p> required <code>normalize_weights</code> <code>bool</code> <p>Whether to automatically normalize the weights to sum up to 1 when solving.</p> required"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.weights","title":"weights  <code>property</code>","text":"Python<pre><code>weights: int | DataArray\n</code></pre> <p>Returns the weights of the FlowSystem. Normalizes to 1 if normalize_weights is True</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.get_coords","title":"get_coords","text":"Python<pre><code>get_coords(dims: Collection[str] | None = None, extra_timestep: bool = False) -&gt; xr.Coordinates | None\n</code></pre> <p>Returns the coordinates of the model</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>Collection[str] | None</code> <p>The dimensions to include in the coordinates. If None, includes all dimensions</p> <code>None</code> <code>extra_timestep</code> <code>bool</code> <p>If True, uses extra timesteps instead of regular timesteps</p> <code>False</code> <p>Returns:</p> Type Description <code>Coordinates | None</code> <p>The coordinates of the model, or None if no coordinates are available</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If extra_timestep=True but 'time' is not in dims</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface","title":"Interface","text":"<p>Base class for all Elements and Models in flixopt that provides serialization capabilities.</p> <p>This class enables automatic serialization/deserialization of objects containing xarray DataArrays and nested Interface objects to/from xarray Datasets and NetCDF files. It uses introspection of constructor parameters to automatically handle most serialization scenarios.</p> Key Features <ul> <li>Automatic extraction and restoration of xarray DataArrays</li> <li>Support for nested Interface objects</li> <li>NetCDF and JSON export/import</li> <li>Recursive handling of complex nested structures</li> </ul> Subclasses must implement <p>transform_data(flow_system): Transform data to match FlowSystem dimensions</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Interface.transform_data","title":"transform_data","text":"Python<pre><code>transform_data(flow_system: FlowSystem, name_prefix: str = '') -&gt; None\n</code></pre> <p>Transform the data of the interface to match the FlowSystem's dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem containing timing and dimensional information</p> required <code>name_prefix</code> <code>str</code> <p>The prefix to use for the names of the variables. Defaults to '', which results in no prefix.</p> <code>''</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/structure/#flixopt.structure.Element","title":"Element","text":"Python<pre><code>Element(label: str, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>This class is the basic Element of flixopt. Every Element has a label</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the element</p> required <code>meta_data</code> <code>dict | None</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure.Element-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Element.transform_data","title":"transform_data","text":"Python<pre><code>transform_data(flow_system: FlowSystem, name_prefix: str = '') -&gt; None\n</code></pre> <p>Transform the data of the interface to match the FlowSystem's dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem containing timing and dimensional information</p> required <code>name_prefix</code> <code>str</code> <p>The prefix to use for the names of the variables. Defaults to '', which results in no prefix.</p> <code>''</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.to_dataset","title":"to_dataset","text":"Python<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.to_netcdf","title":"to_netcdf","text":"Python<pre><code>to_netcdf(path: str | Path, compression: int = 0)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"Python<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"Python<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.get_structure","title":"get_structure","text":"Python<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.to_json","title":"to_json","text":"Python<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.copy","title":"copy","text":"Python<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel","title":"Submodel","text":"Python<pre><code>Submodel(model: FlowSystemModel, label_of_element: str, label_of_model: str | None = None)\n</code></pre> <p>               Bases: <code>SubmodelsMixin</code></p> <p>Stores Variables and Constraints. Its a subset of a FlowSystemModel. Variables and constraints are stored in the main FlowSystemModel, and are referenced here. Can have other Submodels assigned, and can be a Submodel of another Submodel.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FlowSystemModel</code> <p>The FlowSystemModel that is used to create the model.</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>label_of_model</code> <code>str | None</code> <p>The label of the model. Used as a prefix in all variables and constraints.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure.Submodel-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.Submodel.variables_direct","title":"variables_direct  <code>property</code>","text":"Python<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"Python<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Submodel.add_variables","title":"add_variables","text":"Python<pre><code>add_variables(short_name: str = None, **kwargs) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.add_constraints","title":"add_constraints","text":"Python<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.register_variable","title":"register_variable","text":"Python<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.register_constraint","title":"register_constraint","text":"Python<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.get","title":"get","text":"Python<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodels","title":"Submodels  <code>dataclass</code>","text":"Python<pre><code>Submodels(data: dict[str, Submodel])\n</code></pre> <p>A simple collection for storing submodels with easy access and representation.</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodels-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Submodels.add","title":"add","text":"Python<pre><code>add(submodel: Submodel, name: str) -&gt; None\n</code></pre> <p>Add a submodel to the collection.</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodels.get","title":"get","text":"Python<pre><code>get(name: str, default=None)\n</code></pre> <p>Get submodel by name, returning default if not found.</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel","title":"ElementModel","text":"Python<pre><code>ElementModel(model: FlowSystemModel, element: Element)\n</code></pre> <p>               Bases: <code>Submodel</code></p> <p>Stores the mathematical Variables and Constraints for Elements. ElementModels are directly registered in the main FlowSystemModel</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FlowSystemModel</code> <p>The FlowSystemModel that is used to create the model.</p> required <code>element</code> <code>Element</code> <p>The element this model is created for.</p> required"},{"location":"api-reference/structure/#flixopt.structure.ElementModel-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.ElementModel.all_submodels","title":"all_submodels  <code>property</code>","text":"Python<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.variables_direct","title":"variables_direct  <code>property</code>","text":"Python<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"Python<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.constraints","title":"constraints  <code>property</code>","text":"Python<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.variables","title":"variables  <code>property</code>","text":"Python<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.ElementModel.add_submodels","title":"add_submodels","text":"Python<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.add_variables","title":"add_variables","text":"Python<pre><code>add_variables(short_name: str = None, **kwargs) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.add_constraints","title":"add_constraints","text":"Python<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.register_variable","title":"register_variable","text":"Python<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.register_constraint","title":"register_constraint","text":"Python<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.get","title":"get","text":"Python<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/structure/#flixopt.structure-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.register_class_for_io","title":"register_class_for_io","text":"Python<pre><code>register_class_for_io(cls)\n</code></pre> <p>Register a class for serialization/deserialization.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This project adheres to Semantic Versioning. Formatting is based on Keep a Changelog &amp; Gitmoji. For more details regarding the individual PRs and contributors, please refer to our GitHub releases.</p> <p>Tip</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p> <p>Use the navigation menu to browse through individual release notes.</p>"},{"location":"changelog/99978-v3.2.0/","title":"3.2.0 - 2025-10-26","text":"<p>\u2190 Previous: 3.1.1 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: Enhanced plotting capabilities with consistent color management, custom plotting kwargs support, and centralized I/O handling.</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/99978-v3.2.0/#added","title":"\u2728 Added","text":"<p>Color management: - <code>setup_colors()</code> method for <code>CalculationResults</code> and <code>SegmentedCalculationResults</code> to configure consistent colors across all plots   - Group components by colorscales: <code>results.setup_colors({'CHP': 'reds', 'Storage': 'blues', 'Greys': ['Grid', 'Demand']})</code>   - Automatically propagates to all segments in segmented calculations   - Colors persist across all plot calls unless explicitly overridden - Flexible color inputs: Supports colorscale names (e.g., 'turbo', 'plasma'), color lists, or label-to-color dictionaries - Cross-backend compatibility: Seamless color handling for both Plotly and Matplotlib</p> <p>Plotting customization: - Plotting kwargs support: Pass additional arguments to plotting backends via <code>px_kwargs</code>, <code>plot_kwargs</code>, and <code>backend_kwargs</code> parameters - New <code>CONFIG.Plotting</code> configuration section:   - <code>default_show</code>: Control default plot visibility   - <code>default_engine</code>: Choose 'plotly' or 'matplotlib'   - <code>default_dpi</code>: Set resolution for saved plots   - <code>default_facet_cols</code>: Configure default faceting columns   - <code>default_sequential_colorscale</code>: Default for heatmaps (now 'turbo')   - <code>default_qualitative_colorscale</code>: Default for categorical plots (now 'plotly')</p> <p>I/O improvements: - Centralized JSON/YAML I/O with auto-format detection - Enhanced NetCDF handling with consistent engine usage - Better numeric formatting in YAML exports</p>"},{"location":"changelog/99978-v3.2.0/#changed","title":"\u267b\ufe0f Changed","text":"<ul> <li>Default colorscale: Changed from 'viridis' to 'turbo' for better perceptual uniformity</li> <li>Color terminology: Standardized from \"colormap\" to \"colorscale\" throughout for Plotly consistency</li> <li>Plotting internals: Now use <code>xr.Dataset</code> as primary data type (DataFrames automatically converted)</li> <li>NetCDF engine: Switched back to netcdf4 engine following xarray updates and performance benchmarks</li> </ul>"},{"location":"changelog/99978-v3.2.0/#removed","title":"\ud83d\udd25 Removed","text":"<ul> <li>Removed unused <code>plotting.pie_with_plotly()</code> method</li> </ul>"},{"location":"changelog/99978-v3.2.0/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Improved error messages when using <code>engine='matplotlib'</code> with multidimensional data</li> <li>Better dimension validation in <code>results.plot_heatmap()</code></li> </ul>"},{"location":"changelog/99978-v3.2.0/#docs","title":"\ud83d\udcdd Docs","text":"<ul> <li>Enhanced examples demonstrating <code>setup_colors()</code> usage</li> <li>Updated terminology from \"colormap\" to \"colorscale\" in docstrings</li> </ul>"},{"location":"changelog/99978-v3.2.0/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>Fixed concurrency issue in CI</li> <li>Centralized color processing logic into dedicated module</li> <li>Refactored to function-based color handling for simpler API</li> </ul> <p>\u2190 Previous: 3.1.1 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99979-v3.1.1/","title":"3.1.1 - 2025-10-20","text":"<p>\u2190 Previous: 3.1.0 | Next: 3.2.0 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: Fixed a bug when acessing the <code>effects_per_component</code> dataset in results without periodic effects.</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/99979-v3.1.1/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed ValueError in effects_per_component when all periodic effects are scalars/NaN by explicitly creating mode-specific templates (via _create_template_for_mode) with correct dimensions</li> </ul>"},{"location":"changelog/99979-v3.1.1/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>Converted all remaining numpy style docstrings to google style</li> </ul> <p>\u2190 Previous: 3.1.0 | Next: 3.2.0 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99980-v3.1.0/","title":"3.1.0 - 2025-10-19","text":"<p>\u2190 Previous: 3.0.3 | Next: 3.1.1 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: This release adds faceting and animation support for multidimensional plots and redesigns the documentation website. Plotting results across scenarios or periods is now significantly simpler (Plotly only).</p> <p>If upgrading from v2.x, see the Migration Guide and v3.0.0 release notes.</p>"},{"location":"changelog/99980-v3.1.0/#added","title":"\u2728 Added","text":"<ul> <li>Faceting and animation for multidimensional plots: All plotting methods now support <code>facet_by</code> and <code>animate_by</code> parameters to create subplot grids and animations from multidimensional data (scenarios, periods, etc.). Plotly only.</li> <li>Flexible data selection with <code>select</code> parameter: Select data using single values, lists, slices, or index arrays for precise control over what gets plotted</li> <li>Heatmap fill control: New <code>fill</code> parameter in heatmap methods controls how missing values are filled after reshaping (<code>'ffill'</code> or <code>'bfill'</code>)</li> <li>Smart line styling for mixed variables: Area plots now automatically style variables containing both positive and negative values with dashed lines, while stacking purely positive or negative variables</li> </ul>"},{"location":"changelog/99980-v3.1.0/#changed","title":"\u267b\ufe0f Changed","text":"<ul> <li>Breaking: Selection behavior: Plotting methods no longer automatically select the first value for non-time dimensions. Use the <code>select</code> parameter for explicit selection of scenarios, periods, or other dimensions</li> <li>Better error messages: Enhanced error messages when using Matplotlib with multidimensional data, with clearer guidance on dimension requirements and suggestions to use Plotly</li> <li>Improved examples: Enhanced <code>scenario_example.py</code> with better demonstration of new features</li> <li>Robust validation: Improved dimension validation in <code>plot_heatmap()</code> with clearer error messages</li> </ul>"},{"location":"changelog/99980-v3.1.0/#deprecated","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<ul> <li><code>indexer</code> parameter: Use the new <code>select</code> parameter instead. The <code>indexer</code> parameter will be removed in v4.0.0</li> <li><code>heatmap_timeframes</code> and <code>heatmap_timesteps_per_frame</code> parameters: Use the new <code>reshape_time=(timeframes, timesteps_per_frame)</code> parameter instead in heatmap plotting methods</li> <li><code>color_map</code> parameter: Use the new <code>colors</code> parameter instead in heatmap plotting methods</li> </ul>"},{"location":"changelog/99980-v3.1.0/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed cryptic errors when working with empty buses by adding proper validation</li> <li>Added early validation for non-existent periods when using linked periods with tuples</li> </ul>"},{"location":"changelog/99980-v3.1.0/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Redesigned documentation website with custom css</li> </ul>"},{"location":"changelog/99980-v3.1.0/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>Renamed internal <code>_apply_indexer_to_data()</code> to <code>_apply_selection_to_data()</code> for consistency with new API naming</li> </ul> <p>\u2190 Previous: 3.0.3 | Next: 3.1.1 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99981-v3.0.3/","title":"3.0.3 - 2025-10-16","text":"<p>\u2190 Previous: 3.0.2 | Next: 3.1.0 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: Hotfixing new plotting parameter <code>style</code>. Continue to use <code>mode</code>.</p> <p>Note: If upgrading from v2.x, see the Migration Guide and v3.0.0 release notes.</p>"},{"location":"changelog/99981-v3.0.3/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Reverted breaking change from v3.0.0: continue to use <code>mode parameter in plotting instead of new</code>style`</li> <li>Renamed new <code>mode</code> parameter in plotting methods to <code>unit_type</code></li> </ul>"},{"location":"changelog/99981-v3.0.3/#docs","title":"\ud83d\udcdd Docs","text":"<ul> <li>Updated Migration Guide and added missing entries.</li> <li>Improved Changelog of v3.0.0</li> </ul> <p>\u2190 Previous: 3.0.2 | Next: 3.1.0 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99982-v3.0.2/","title":"3.0.2 - 2025-10-15","text":"<p>\u2190 Previous: 3.0.1 | Next: 3.0.3 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: This is a follow-up release to v3.0.0, improving the documentation.</p> <p>Note: If upgrading from v2.x, see the Migration Guide and v3.0.0 release notes.</p>"},{"location":"changelog/99982-v3.0.2/#docs","title":"\ud83d\udcdd Docs","text":"<ul> <li>Update the Readme</li> <li>Add a project roadmap to the docs</li> <li>Change Development status to \"Production/Stable\"</li> <li>Regroup parts in docs</li> </ul> <p>\u2190 Previous: 3.0.1 | Next: 3.0.3 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99983-v3.0.1/","title":"3.0.1 - 2025-10-14","text":"<p>\u2190 Previous: 3.0.0 | Next: 3.0.2 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: This is a follow-up release to v3.0.0, adding a Migration Guide and bugfixing the docs.</p> <p>Note: If upgrading from v2.x, see the Migration Guide and v3.0.0 release notes.</p>"},{"location":"changelog/99983-v3.0.1/#docs","title":"\ud83d\udcdd Docs","text":"<ul> <li>Fixed deployed docs</li> <li>Added Migration Guide for flixopt 3</li> </ul>"},{"location":"changelog/99983-v3.0.1/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>Added missing type hints</li> </ul> <p>\u2190 Previous: 3.0.0 | Next: 3.0.2 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99984-v3.0.0/","title":"3.0.0 - 2025-10-13","text":"<p>\u2190 Previous: 2.2.0 | Next: 3.0.1 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: This release introduces new model dimensions (periods and scenarios) for multi-period investments and stochastic modeling, along with a redesigned effect sharing system and enhanced I/O capabilities.</p> <p>Note: If upgrading from v2.x, see the Migration Guide and v3.0.0 release notes.</p>"},{"location":"changelog/99984-v3.0.0/#added","title":"\u2728 Added","text":"<p>New model dimensions:</p> <ul> <li>Period dimension: Enables multi-period investment modeling with distinct decisions in each period for transformation pathway optimization</li> <li>Scenario dimension: Supports stochastic modeling with weighted scenarios for robust decision-making under uncertainty (demand, prices, weather)<ul> <li>Control variable independence across scenarios via <code>scenario_independent_sizes</code> and <code>scenario_independent_flow_rates</code> parameters</li> <li>By default, investment sizes are shared across scenarios while flow rates vary per scenario</li> </ul> </li> </ul> <p>Redesigned effect sharing system:</p> <p>Effects now use intuitive <code>share_from_*</code> syntax that clearly shows contribution sources:</p> Python<pre><code>costs = fx.Effect('costs', '\u20ac', 'Total costs',\n    share_from_temporal={'CO2': 0.2},      # From temporal effects\n    share_from_periodic={'land': 100})     # From periodic effects\n</code></pre> <p>This replaces <code>specific_share_to_other_effects_*</code> parameters and inverts the direction for clearer relationships.</p> <p>Enhanced I/O and data handling:</p> <ul> <li>NetCDF/JSON serialization for all Interface objects and FlowSystem with round-trip support</li> <li>FlowSystem manipulation: <code>sel()</code>, <code>isel()</code>, <code>resample()</code>, <code>copy()</code>, <code>__eq__()</code> methods</li> <li>Direct access to FlowSystem from results without manual restoring (lazily loaded)</li> <li>New <code>FlowResults</code> class and precomputed DataArrays for sizes/flow_rates/flow_hours</li> <li><code>effects_per_component</code> dataset for component impact evaluation, including all indirect effects through effect shares</li> </ul> <p>Other additions:</p> <ul> <li>Balanced storage - charging and discharging sizes can be forced equal via <code>balanced</code> parameter</li> <li>New Storage parameters: <code>relative_minimum_final_charge_state</code> and <code>relative_maximum_final_charge_state</code> for final state control</li> <li>Improved filter methods in results</li> <li>Example for 2-stage investment decisions leveraging FlowSystem resampling</li> </ul>"},{"location":"changelog/99984-v3.0.0/#breaking-changes","title":"\ud83d\udca5 Breaking Changes","text":"<p>API and Behavior Changes:</p> <ul> <li>Effect system redesigned (no deprecation):</li> <li>Terminology changes: Effect domains renamed for clarity: <code>operation</code> \u2192 <code>temporal</code>, <code>invest</code>/<code>investment</code> \u2192 <code>periodic</code></li> <li>Sharing system: The old <code>specific_share_to_other_effects_*</code> parameters were completely replaced with the new <code>share_from_temporal</code> and <code>share_from_periodic</code> syntax (see \ud83d\udd25 Removed section)</li> <li>FlowSystem independence: FlowSystems cannot be shared across multiple Calculations anymore. A copy of the FlowSystem is created instead, making every Calculation independent. Each Subcalculation in <code>SegmentedCalculation</code> now has its own distinct <code>FlowSystem</code> object</li> <li>Bus and Effect object assignment: Direct assignment of Bus/Effect objects is no longer supported. Use labels (strings) instead:</li> <li><code>Flow.bus</code> must receive a string label, not a Bus object</li> <li>Effect shares must use effect labels (strings) in dictionaries, not Effect objects</li> <li>Logging defaults (from v2.2.0): Console and file logging are now disabled by default. Enable explicitly with <code>CONFIG.Logging.console = True</code> and <code>CONFIG.apply()</code></li> </ul> <p>Class and Method Renaming:</p> <ul> <li>Renamed class <code>SystemModel</code> to <code>FlowSystemModel</code></li> <li>Renamed class <code>Model</code> to <code>Submodel</code></li> <li>Renamed <code>mode</code> parameter in plotting methods to <code>style</code></li> <li><code>Calculation.do_modeling()</code> now returns the <code>Calculation</code> object instead of its <code>linopy.Model</code>. Callers that previously accessed the linopy model directly should now use <code>calculation.do_modeling().model</code> instead of <code>calculation.do_modeling()</code></li> </ul> <p>Variable Renaming in Results:</p> <ul> <li>Investment binary variable: <code>is_invested</code> \u2192 <code>invested</code> in <code>InvestmentModel</code></li> <li>Switch tracking variables in <code>OnOffModel</code>:</li> <li><code>switch_on</code> \u2192 <code>switch|on</code></li> <li><code>switch_off</code> \u2192 <code>switch|off</code></li> <li><code>switch_on_nr</code> \u2192 <code>switch|count</code></li> <li>Effect submodel variables (following terminology changes):</li> <li><code>Effect(invest)|total</code> \u2192 <code>Effect(periodic)</code></li> <li><code>Effect(operation)|total</code> \u2192 <code>Effect(temporal)</code></li> <li><code>Effect(operation)|total_per_timestep</code> \u2192 <code>Effect(temporal)|per_timestep</code></li> <li><code>Effect|total</code> \u2192 <code>Effect</code></li> </ul> <p>Data Structure Changes:</p> <ul> <li><code>relative_minimum_charge_state</code> and <code>relative_maximum_charge_state</code> don't have an extra timestep anymore. Use the new <code>relative_minimum_final_charge_state</code> and <code>relative_maximum_final_charge_state</code> parameters for final state control</li> </ul>"},{"location":"changelog/99984-v3.0.0/#changed","title":"\u267b\ufe0f Changed","text":"<ul> <li>Type system overhaul - added clear separation between temporal and non-temporal data throughout codebase for better clarity</li> <li>Enhanced FlowSystem interface with improved <code>__repr__()</code> and <code>__str__()</code> methods</li> <li>Improved Model Structure - Views and organisation is now divided into:<ul> <li>Model: The main Model (linopy.Model) that is used to create and store the variables and constraints for the FlowSystem.</li> <li>Submodel: The base class for all submodels. Each is a subset of the Model, for simpler access and clearer code.</li> </ul> </li> <li>Made docstrings in <code>config.py</code> more compact and easier to read</li> <li>Improved format handling in configuration module</li> <li>Enhanced console output to support both <code>stdout</code> and <code>stderr</code> stream selection</li> <li>Added <code>show_logger_name</code> parameter to <code>CONFIG.Logging</code> for displaying logger names in messages</li> </ul>"},{"location":"changelog/99984-v3.0.0/#deprecated","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<ul> <li>The <code>agg_group</code> and <code>agg_weight</code> parameters of <code>TimeSeriesData</code> are deprecated and will be removed in a future version. Use <code>aggregation_group</code> and <code>aggregation_weight</code> instead.</li> <li>The <code>active_timesteps</code> parameter of <code>Calculation</code> is deprecated and will be removed in a future version. Use the new <code>sel(time=...)</code> method on the FlowSystem instead.</li> <li>InvestParameters parameters renamed for improved clarity around investment and retirement effects:<ul> <li><code>fix_effects</code> \u2192 <code>effects_of_investment</code></li> <li><code>specific_effects</code> \u2192 <code>effects_of_investment_per_size</code></li> <li><code>divest_effects</code> \u2192 <code>effects_of_retirement</code></li> <li><code>piecewise_effects</code> \u2192 <code>piecewise_effects_of_investment</code></li> </ul> </li> <li>Effect parameters renamed:<ul> <li><code>minimum_investment</code> \u2192 <code>minimum_periodic</code></li> <li><code>maximum_investment</code> \u2192 <code>maximum_periodic</code></li> <li><code>minimum_operation</code> \u2192 <code>minimum_temporal</code></li> <li><code>maximum_operation</code> \u2192 <code>maximum_temporal</code></li> <li><code>minimum_operation_per_hour</code> \u2192 <code>minimum_per_hour</code></li> <li><code>maximum_operation_per_hour</code> \u2192 <code>maximum_per_hour</code></li> </ul> </li> <li>Component parameters renamed:<ul> <li><code>Source.source</code> \u2192 <code>Source.outputs</code></li> <li><code>Sink.sink</code> \u2192 <code>Sink.inputs</code></li> <li><code>SourceAndSink.source</code> \u2192 <code>SourceAndSink.outputs</code></li> <li><code>SourceAndSink.sink</code> \u2192 <code>SourceAndSink.inputs</code></li> <li><code>SourceAndSink.prevent_simultaneous_sink_and_source</code> \u2192 <code>SourceAndSink.prevent_simultaneous_flow_rates</code></li> </ul> </li> </ul>"},{"location":"changelog/99984-v3.0.0/#removed","title":"\ud83d\udd25 Removed","text":"<ul> <li>Effect share parameters: The old <code>specific_share_to_other_effects_*</code> parameters were replaced WITHOUT DEPRECATION<ul> <li><code>specific_share_to_other_effects_operation</code> \u2192 <code>share_from_temporal</code> (with inverted direction)</li> <li><code>specific_share_to_other_effects_invest</code> \u2192 <code>share_from_periodic</code> (with inverted direction)</li> </ul> </li> </ul>"},{"location":"changelog/99984-v3.0.0/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Enhanced NetCDF I/O with proper attribute preservation for DataArrays</li> <li>Improved error handling and validation in serialization processes</li> <li>Better type consistency across all framework components</li> <li>Added extra validation in <code>config.py</code> to improve error handling</li> </ul>"},{"location":"changelog/99984-v3.0.0/#docs","title":"\ud83d\udcdd Docs","text":"<ul> <li>Reorganized mathematical notation docs: moved to lowercase <code>mathematical-notation/</code> with subdirectories (<code>elements/</code>, <code>features/</code>, <code>modeling-patterns/</code>)</li> <li>Added comprehensive documentation pages: <code>dimensions.md</code> (time/period/scenario), <code>effects-penalty-objective.md</code>, modeling patterns</li> <li>Enhanced all element pages with implementation details, cross-references, and \"See Also\" sections</li> <li>Rewrote README and landing page with clearer vision, roadmap, and universal applicability emphasis</li> <li>Removed deprecated <code>docs/SUMMARY.md</code>, updated <code>mkdocs.yml</code> for new structure</li> <li>Tightened docstrings in core modules with better cross-referencing</li> <li>Added recipes section to docs</li> </ul>"},{"location":"changelog/99984-v3.0.0/#known-issues","title":"\ud83d\udea7 Known Issues","text":"<ul> <li>IO for single Interfaces/Elements to Datasets might not work properly if the Interface/Element is not part of a fully transformed and connected FlowSystem. This arises from Numeric Data not being stored as xr.DataArray by the user. To avoid this, always use the <code>to_dataset()</code> on Elements inside a FlowSystem that's connected and transformed.</li> </ul>"},{"location":"changelog/99984-v3.0.0/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>Centralized deprecation pattern: Added <code>_handle_deprecated_kwarg()</code> helper method to <code>Interface</code> base class that provides reusable deprecation handling with consistent warnings, conflict detection, and optional value transformation. Applied across 5 classes (InvestParameters, Source, Sink, SourceAndSink, Effect) reducing deprecation boilerplate by 72%.</li> <li>FlowSystem data management simplified - removed <code>time_series_collection</code> pattern in favor of direct timestep properties</li> <li>Change modeling hierarchy to allow for more flexibility in future development. This leads to minimal changes in the access and creation of Submodels and their variables.</li> <li>Added new module <code>.modeling</code> that contains modeling primitives and utilities</li> <li>Clearer separation between the main Model and \"Submodels\"</li> <li>Improved access to the Submodels and their variables, constraints and submodels</li> <li>Added <code>__repr__()</code> for Submodels to easily inspect its content</li> <li>Enhanced data handling methods<ul> <li><code>fit_to_model_coords()</code> method for data alignment</li> <li><code>fit_effects_to_model_coords()</code> method for effect data processing</li> <li><code>connect_and_transform()</code> method replacing several operations</li> </ul> </li> <li>Testing improvements: Eliminated warnings during test execution<ul> <li>Updated deprecated code patterns in tests and examples (e.g., <code>sink</code>/<code>source</code> \u2192 <code>inputs</code>/<code>outputs</code>, <code>'H'</code> \u2192 <code>'h'</code> frequency)</li> <li>Refactored plotting logic to handle test environments explicitly with non-interactive backends</li> <li>Added comprehensive warning filters in <code>__init__.py</code> and <code>pyproject.toml</code> to suppress third-party library warnings</li> <li>Improved test fixtures with proper figure cleanup to prevent memory leaks</li> <li>Enhanced backend detection and handling in <code>plotting.py</code> for both Matplotlib and Plotly</li> <li>Always run dependent tests in order</li> </ul> </li> </ul> <p>\u2190 Previous: 2.2.0 | Next: 3.0.1 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99985-v2.2.0/","title":"2.2.0 - 2025-10-11","text":"<p>\u2190 Previous: 2.1.11 | Next: 3.0.0 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: This release is a Configuration and Logging management release.</p>"},{"location":"changelog/99985-v2.2.0/#added","title":"\u2728 Added","text":"<ul> <li>Added <code>CONFIG.reset()</code> method to restore configuration to default values</li> <li>Added configurable log file rotation settings: <code>CONFIG.Logging.max_file_size</code> and <code>CONFIG.Logging.backup_count</code></li> <li>Added configurable log format settings: <code>CONFIG.Logging.date_format</code> and <code>CONFIG.Logging.format</code></li> <li>Added configurable console settings: <code>CONFIG.Logging.console_width</code> and <code>CONFIG.Logging.show_path</code></li> <li>Added <code>CONFIG.Logging.Colors</code> nested class for customizable log level colors using ANSI escape codes (works with both standard and Rich handlers)</li> <li>All examples now enable console logging to demonstrate proper logging usage</li> <li>Console logging now outputs to <code>sys.stdout</code> instead of <code>sys.stderr</code> for better compatibility with output redirection</li> </ul>"},{"location":"changelog/99985-v2.2.0/#breaking-changes","title":"\ud83d\udca5 Breaking Changes","text":"<ul> <li>Console logging is now disabled by default (<code>CONFIG.Logging.console = False</code>). Enable it explicitly in your scripts with <code>CONFIG.Logging.console = True</code> and <code>CONFIG.apply()</code></li> <li>File logging is now disabled by default (<code>CONFIG.Logging.file = None</code>). Set a file path to enable file logging</li> </ul>"},{"location":"changelog/99985-v2.2.0/#changed","title":"\u267b\ufe0f Changed","text":"<ul> <li>Logging and Configuration management changed</li> <li>Improved default logging colors: DEBUG is now gray (<code>\\033[90m</code>) for de-emphasized messages, INFO uses terminal default color (<code>\\033[0m</code>) for clean output</li> </ul>"},{"location":"changelog/99985-v2.2.0/#deprecated","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<ul> <li><code>change_logging_level()</code> function is now deprecated in favor of <code>CONFIG.Logging.level</code> and <code>CONFIG.apply()</code>. Will be removed in version 3.0.0.</li> </ul>"},{"location":"changelog/99985-v2.2.0/#removed","title":"\ud83d\udd25 Removed","text":"<ul> <li>Removed unused <code>config.merge_configs</code> function from configuration module</li> </ul>"},{"location":"changelog/99985-v2.2.0/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>Greatly expanded test coverage for <code>config.py</code> module</li> <li>Added <code>@pytest.mark.xdist_group</code> to <code>TestConfigModule</code> tests to prevent global config interference</li> </ul> <p>\u2190 Previous: 2.1.11 | Next: 3.0.0 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99986-v2.1.11/","title":"2.1.11 - 2025-10-05","text":"<p>\u2190 Previous: 2.1.10 | Next: 2.2.0 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: Important bugfix in <code>Storage</code> leading to wrong results due to incorrect discharge losses.</p>"},{"location":"changelog/99986-v2.1.11/#changed","title":"\u267b\ufe0f Changed","text":"<ul> <li>Using <code>h5netcdf</code> instead of <code>netCDF4</code> for dataset I/O operations. This follows the update in <code>xarray==2025.09.01</code></li> </ul>"},{"location":"changelog/99986-v2.1.11/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fix <code>charge_state</code> Constraint in <code>Storage</code> leading to incorrect losses in discharge and therefore incorrect charge states and discharge values.</li> </ul>"},{"location":"changelog/99986-v2.1.11/#dependencies","title":"\ud83d\udce6 Dependencies","text":"<ul> <li>Updated <code>renovate.config</code> to treat CalVer packages (xarray and dask) with more care</li> <li>Updated packaging configuration</li> </ul> <p>\u2190 Previous: 2.1.10 | Next: 2.2.0 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99987-v2.1.10/","title":"2.1.10 - 2025-09-29","text":"<p>\u2190 Previous: 2.1.9 | Next: 2.1.11 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: This release is a Documentation and Development release.</p>"},{"location":"changelog/99987-v2.1.10/#docs","title":"\ud83d\udcdd Docs","text":"<ul> <li>Improved CHANGELOG.md formatting by adding better categories and formating by Gitmoji.</li> <li>Added a script to extract the release notes from the CHANGELOG.md file for better organized documentation.</li> </ul>"},{"location":"changelog/99987-v2.1.10/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>Improved <code>renovate.config</code></li> <li>Sped up CI by not running examples in every run and using <code>pytest-xdist</code></li> </ul> <p>\u2190 Previous: 2.1.9 | Next: 2.1.11 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99988-v2.1.9/","title":"2.1.9 - 2025-09-23","text":"<p>\u2190 Previous: 2.1.8 | Next: 2.1.10 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: Small bugfix release addressing network visualization error handling.</p>"},{"location":"changelog/99988-v2.1.9/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fix error handling in network visualization if <code>networkx</code> is not installed</li> </ul> <p>\u2190 Previous: 2.1.8 | Next: 2.1.10 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99989-v2.1.8/","title":"2.1.8 - 2025-09-22","text":"<p>\u2190 Previous: 2.1.7 | Next: 2.1.9 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: Code quality improvements, enhanced documentation, and bug fixes for heat pump components and visualization features.</p>"},{"location":"changelog/99989-v2.1.8/#added","title":"\u2728 Added","text":"<ul> <li>Extra Check for HeatPumpWithSource.COP to be strictly &gt; 1 to avoid division by zero</li> <li>Apply deterministic color assignment by using sorted() in <code>plotting.py</code></li> <li>Add missing args in docstrings in <code>plotting.py</code>, <code>solvers.py</code>, and <code>core.py</code>.</li> </ul>"},{"location":"changelog/99989-v2.1.8/#changed","title":"\u267b\ufe0f Changed","text":"<ul> <li>Greatly improved docstrings and documentation of all public classes</li> <li>Make path handling to be gentle about missing .html suffix in <code>plotting.py</code></li> <li>Default for <code>relative_losses</code> in <code>Transmission</code> is now 0 instead of None</li> <li>Setter of COP in <code>HeatPumpWithSource</code> now completely overwrites the conversion factors, which is safer.</li> <li>Fix some docstrings in plotting.py</li> <li>Change assertions to raise Exceptions in <code>plotting.py</code></li> </ul>"},{"location":"changelog/99989-v2.1.8/#fixed","title":"\ud83d\udc1b Fixed","text":"<p>Core Components: - Fix COP getter and setter of <code>HeatPumpWithSource</code> returning and setting wrong conversion factors - Fix custom compression levels in <code>io.save_dataset_to_netcdf</code> - Fix <code>total_max</code> did not work when total min was not used</p> <p>Visualization: - Fix color scheme selection in network_app; color pickers now update when a scheme is selected</p>"},{"location":"changelog/99989-v2.1.8/#docs","title":"\ud83d\udcdd Docs","text":"<ul> <li>Fix broken links in docs</li> <li>Fix some docstrings in plotting.py</li> </ul>"},{"location":"changelog/99989-v2.1.8/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>Pin dev dependencies to specific versions</li> <li>Improve CI workflows to run faster and smarter</li> </ul> <p>\u2190 Previous: 2.1.7 | Next: 2.1.9 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99990-v2.1.7/","title":"2.1.7 - 2025-09-13","text":"<p>\u2190 Previous: 2.1.6 | Next: 2.1.8 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: Maintenance release to improve Code Quality, CI and update the dependencies. There are no changes or new features.</p>"},{"location":"changelog/99990-v2.1.7/#added","title":"\u2728 Added","text":"<ul> <li>Added <code>__version__</code> to flixopt</li> </ul>"},{"location":"changelog/99990-v2.1.7/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>ruff format the whole Codebase</li> <li>Added renovate config</li> <li>Added pre-commit</li> <li>lint and format in CI</li> <li>improved CI</li> <li>Updated Dependencies</li> <li>Updated Issue Templates</li> </ul> <p>\u2190 Previous: 2.1.6 | Next: 2.1.8 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99991-v2.1.6/","title":"2.1.6 - 2025-09-02","text":"<p>\u2190 Previous: 2.1.5 | Next: 2.1.7 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: Enhanced Sink/Source components with multi-flow support and new interactive network visualization.</p>"},{"location":"changelog/99991-v2.1.6/#added","title":"\u2728 Added","text":"<ul> <li>Network Visualization: Added <code>FlowSystem.start_network_app()</code> and <code>FlowSystem.stop_network_app()</code> to easily visualize the network structure of a flow system in an interactive Dash web app</li> <li>Note: This is still experimental and might change in the future</li> </ul>"},{"location":"changelog/99991-v2.1.6/#changed","title":"\u267b\ufe0f Changed","text":"<ul> <li>Multi-Flow Support: <code>Sink</code>, <code>Source</code>, and <code>SourceAndSink</code> now accept multiple <code>flows</code> as <code>inputs</code> and <code>outputs</code> instead of just one. This enables modeling more use cases with these classes</li> <li>Flow Control: Both <code>Sink</code> and <code>Source</code> now have a <code>prevent_simultaneous_flow_rates</code> argument to prevent simultaneous flow rates of more than one of their flows</li> </ul>"},{"location":"changelog/99991-v2.1.6/#deprecated","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<ul> <li>For the classes <code>Sink</code>, <code>Source</code> and <code>SourceAndSink</code>: <code>.sink</code>, <code>.source</code> and <code>.prevent_simultaneous_sink_and_source</code> are deprecated in favor of the new arguments <code>inputs</code>, <code>outputs</code> and <code>prevent_simultaneous_flow_rates</code></li> </ul>"},{"location":"changelog/99991-v2.1.6/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed testing issue with new <code>linopy</code> version 0.5.6</li> </ul>"},{"location":"changelog/99991-v2.1.6/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>Added dependency \"nbformat&gt;=4.2.0\" to dev dependencies to resolve issue with plotly CI</li> </ul> <p>\u2190 Previous: 2.1.5 | Next: 2.1.7 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99992-v2.1.5/","title":"2.1.5 - 2025-07-08","text":"<p>\u2190 Previous: 2.1.4 | Next: 2.1.6 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99992-v2.1.5/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed Docs deployment</li> </ul> <p>\u2190 Previous: 2.1.4 | Next: 2.1.6 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99993-v2.1.4/","title":"2.1.4 - 2025-07-08","text":"<p>\u2190 Previous: 2.1.3 | Next: 2.1.5 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99993-v2.1.4/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixing release notes of 2.1.3, as well as documentation build.</li> </ul> <p>\u2190 Previous: 2.1.3 | Next: 2.1.5 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99994-v2.1.3/","title":"2.1.3 - 2025-07-08","text":"<p>\u2190 Previous: 2.1.2 | Next: 2.1.4 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99994-v2.1.3/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Using <code>Effect.maximum_operation_per_hour</code> raised an error, needing an extra timestep. This has been fixed thanks to @PRse4.</li> </ul> <p>\u2190 Previous: 2.1.2 | Next: 2.1.4 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99995-v2.1.2/","title":"2.1.2 - 2025-06-14","text":"<p>\u2190 Previous: 2.1.1 | Next: 2.1.3 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99995-v2.1.2/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Storage losses per hour were not calculated correctly, as mentioned by @brokenwings01. This might have led to issues when modeling large losses and long timesteps.</li> <li>Old implementation:     \\(c(\\text{t}_{i}) \\cdot (1-\\dot{\\text{c}}_\\text{rel,loss}(\\text{t}_i)) \\cdot \\Delta \\text{t}_{i}\\)</li> <li>Correct implementation: \\(c(\\text{t}_{i}) \\cdot (1-\\dot{\\text{c}}_\\text{rel,loss}(\\text{t}_i)) ^{\\Delta \\text{t}_{i}}\\)</li> </ul>"},{"location":"changelog/99995-v2.1.2/#known-issues","title":"\ud83d\udea7 Known Issues","text":"<ul> <li>Just to mention: Plotly &gt;= 6 may raise errors if \"nbformat\" is not installed. We pinned plotly to &lt;6, but this may be fixed in the future.</li> </ul> <p>\u2190 Previous: 2.1.1 | Next: 2.1.3 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99996-v2.1.1/","title":"2.1.1 - 2025-05-08","text":"<p>\u2190 Previous: 2.1.0 | Next: 2.1.2 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99996-v2.1.1/#changed","title":"\u267b\ufe0f Changed","text":"<ul> <li>Improved docstring and tests</li> </ul>"},{"location":"changelog/99996-v2.1.1/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed bug in the <code>_ElementResults.constraints</code> not returning the constraints but rather the variables</li> </ul> <p>\u2190 Previous: 2.1.0 | Next: 2.1.2 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99997-v2.1.0/","title":"2.1.0 - 2025-04-11","text":"<p>\u2190 Previous: 2.0.1 | Next: 2.1.1 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99997-v2.1.0/#added","title":"\u2728 Added","text":"<ul> <li>Python 3.13 support added</li> <li>Logger warning if relative_minimum is used without on_off_parameters in Flow</li> <li>Greatly improved internal testing infrastructure by leveraging linopy's testing framework</li> </ul>"},{"location":"changelog/99997-v2.1.0/#breaking-changes","title":"\ud83d\udca5 Breaking Changes","text":"<ul> <li>Restructured the modeling of the On/Off state of Flows or Components</li> <li>Variable renaming: <code>...|consecutive_on_hours</code> \u2192 <code>...|ConsecutiveOn|hours</code></li> <li>Variable renaming: <code>...|consecutive_off_hours</code> \u2192 <code>...|ConsecutiveOff|hours</code></li> <li>Constraint renaming: <code>...|consecutive_on_hours_con1</code> \u2192 <code>...|ConsecutiveOn|con1</code></li> <li>Similar pattern for all consecutive on/off constraints</li> </ul>"},{"location":"changelog/99997-v2.1.0/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed the lower bound of <code>flow_rate</code> when using optional investments without OnOffParameters</li> <li>Fixed bug that prevented divest effects from working</li> <li>Added lower bounds of 0 to two unbounded vars (numerical improvement)</li> </ul> <p>\u2190 Previous: 2.0.1 | Next: 2.1.1 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99998-v2.0.1/","title":"2.0.1 - 2025-04-10","text":"<p>\u2190 Previous: 2.0.0 | Next: 2.1.0 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99998-v2.0.1/#added","title":"\u2728 Added","text":"<ul> <li>Logger warning if relative_minimum is used without on_off_parameters in Flow</li> </ul>"},{"location":"changelog/99998-v2.0.1/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Replace \"|\" with \"__\" in filenames when saving figures (Windows compatibility)</li> <li>Fixed bug that prevented the load factor from working without InvestmentParameters</li> </ul> <p>\u2190 Previous: 2.0.0 | Next: 2.1.0 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99999-v2.0.0/","title":"2.0.0 - 2025-03-29","text":"<p>Next: 2.0.1 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: \ud83d\udca5 MAJOR RELEASE - Complete framework migration from Pyomo to Linopy with redesigned architecture.</p>"},{"location":"changelog/99999-v2.0.0/#added","title":"\u2728 Added","text":"<p>Model Capabilities: - Full model serialization support - save and restore unsolved Models - Enhanced model documentation with YAML export containing human-readable mathematical formulations - Extend flixopt models with native linopy language support - Full Model Export/Import capabilities via linopy.Model</p> <p>Results &amp; Data: - Unified solution exploration through <code>Calculation.results</code> attribute - Compression support for result files - <code>to_netcdf/from_netcdf</code> methods for FlowSystem and core components - xarray integration for TimeSeries with improved datatypes support</p>"},{"location":"changelog/99999-v2.0.0/#breaking-changes","title":"\ud83d\udca5 Breaking Changes","text":"<p>Framework Migration: - Optimization Engine: Complete migration from Pyomo to Linopy optimization framework - Package Import: Framework renamed from flixOpt to flixopt (<code>import flixopt as fx</code>) - Data Architecture: Redesigned data handling to rely on xarray.Dataset throughout the package - Results System: Results handling completely redesigned with new <code>CalculationResults</code> class</p> <p>Variable Structure: - Restructured the modeling of the On/Off state of Flows or Components   - Variable renaming: <code>...|consecutive_on_hours</code> \u2192 <code>...|ConsecutiveOn|hours</code>   - Variable renaming: <code>...|consecutive_off_hours</code> \u2192 <code>...|ConsecutiveOff|hours</code>   - Constraint renaming: <code>...|consecutive_on_hours_con1</code> \u2192 <code>...|ConsecutiveOn|con1</code>   - Similar pattern for all consecutive on/off constraints</p>"},{"location":"changelog/99999-v2.0.0/#removed","title":"\ud83d\udd25 Removed","text":"<ul> <li>Pyomo dependency (replaced by linopy)</li> <li>Period concepts in time management (simplified to timesteps)</li> </ul>"},{"location":"changelog/99999-v2.0.0/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Improved infeasible model detection and reporting</li> <li>Enhanced time series management and serialization</li> <li>Reduced file size through improved compression</li> </ul>"},{"location":"changelog/99999-v2.0.0/#docs","title":"\ud83d\udcdd Docs","text":"<ul> <li>Google Style Docstrings throughout the codebase</li> </ul> <p>Next: 2.0.1 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"examples/","title":"Examples","text":"<p>Here you can find a collection of examples that demonstrate how to use FlixOpt.</p> <p>We work on improving this gallery. If you have something to share, please contact us!</p>"},{"location":"examples/00-Minimal%20Example/","title":"Minimal Example","text":"Python<pre><code>\"\"\"\nThis script shows how to use the flixopt framework to model a super minimalistic energy system.\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\nfrom rich.pretty import pprint\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # Enable console logging\n    fx.CONFIG.Logging.console = True\n    fx.CONFIG.apply()\n    # --- Define the Flow System, that will hold all elements, and the time steps you want to model ---\n    timesteps = pd.date_range('2020-01-01', periods=3, freq='h')\n    flow_system = fx.FlowSystem(timesteps)\n\n    # --- Define Thermal Load Profile ---\n    # Load profile (e.g., kW) for heating demand over time\n    thermal_load_profile = np.array([30, 0, 20])\n\n    # --- Define Energy Buses ---\n    # These are balancing nodes (inputs=outputs) and balance the different energy carriers your system\n    flow_system.add_elements(fx.Bus('District Heating'), fx.Bus('Natural Gas'))\n\n    # --- Define Objective Effect (Cost) ---\n    # Cost effect representing the optimization objective (minimizing costs)\n    cost_effect = fx.Effect('costs', '\u20ac', 'Cost', is_standard=True, is_objective=True)\n\n    # --- Define Flow System Components ---\n    # Boiler component with thermal output (heat) and fuel input (gas)\n    boiler = fx.linear_converters.Boiler(\n        'Boiler',\n        eta=0.5,\n        Q_th=fx.Flow(label='Thermal Output', bus='District Heating', size=50),\n        Q_fu=fx.Flow(label='Fuel Input', bus='Natural Gas'),\n    )\n\n    # Heat load component with a fixed thermal demand profile\n    heat_load = fx.Sink(\n        'Heat Demand',\n        inputs=[\n            fx.Flow(label='Thermal Load', bus='District Heating', size=1, fixed_relative_profile=thermal_load_profile)\n        ],\n    )\n\n    # Gas source component with cost-effect per flow hour\n    gas_source = fx.Source(\n        'Natural Gas Tariff',\n        outputs=[fx.Flow(label='Gas Flow', bus='Natural Gas', size=1000, effects_per_flow_hour=0.04)],  # 0.04 \u20ac/kWh\n    )\n\n    # --- Build the Flow System ---\n    # Add all components and effects to the system\n    flow_system.add_elements(cost_effect, boiler, heat_load, gas_source)\n\n    # --- Define, model and solve a Calculation ---\n    calculation = fx.FullCalculation('Simulation1', flow_system)\n    calculation.do_modeling()\n    calculation.solve(fx.solvers.HighsSolver(0.01, 60))\n\n    # --- Analyze Results ---\n    # Access the results of an element\n    df1 = calculation.results['costs'].filter_solution('time').to_dataframe()\n\n    # Plot the results of a specific element\n    calculation.results['District Heating'].plot_node_balance_pie()\n    calculation.results['District Heating'].plot_node_balance()\n\n    # Save results to a file\n    df2 = calculation.results['District Heating'].node_balance().to_dataframe()\n    # df2.to_csv('results/District Heating.csv')  # Save results to csv\n\n    # Print infos to the console.\n    pprint(calculation.summary)\n</code></pre>"},{"location":"examples/01-Basic%20Example/","title":"Simple example","text":"Python<pre><code>\"\"\"\nThis script shows how to use the flixopt framework to model a simple energy system.\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # Enable console logging\n    fx.CONFIG.Logging.console = True\n    fx.CONFIG.apply()\n    # --- Create Time Series Data ---\n    # Heat demand profile (e.g., kW) over time and corresponding power prices\n    heat_demand_per_h = np.array([30, 0, 90, 110, 110, 20, 20, 20, 20])\n    power_prices = 1 / 1000 * np.array([80, 80, 80, 80, 80, 80, 80, 80, 80])\n\n    # Create datetime array starting from '2020-01-01' for the given time period\n    timesteps = pd.date_range('2020-01-01', periods=len(heat_demand_per_h), freq='h')\n    flow_system = fx.FlowSystem(timesteps=timesteps)\n\n    # --- Define Energy Buses ---\n    # These represent nodes, where the used medias are balanced (electricity, heat, and gas)\n    flow_system.add_elements(fx.Bus(label='Strom'), fx.Bus(label='Fernw\u00e4rme'), fx.Bus(label='Gas'))\n\n    # --- Define Effects (Objective and CO2 Emissions) ---\n    # Cost effect: used as the optimization objective --&gt; minimizing costs\n    costs = fx.Effect(\n        label='costs',\n        unit='\u20ac',\n        description='Kosten',\n        is_standard=True,  # standard effect: no explicit value needed for costs\n        is_objective=True,  # Minimizing costs as the optimization objective\n        share_from_temporal={'CO2': 0.2},\n    )\n\n    # CO2 emissions effect with an associated cost impact\n    CO2 = fx.Effect(\n        label='CO2',\n        unit='kg',\n        description='CO2_e-Emissionen',\n        maximum_per_hour=1000,  # Max CO2 emissions per hour\n    )\n\n    # --- Define Flow System Components ---\n    # Boiler: Converts fuel (gas) into thermal energy (heat)\n    boiler = fx.linear_converters.Boiler(\n        label='Boiler',\n        eta=0.5,\n        Q_th=fx.Flow(label='Q_th', bus='Fernw\u00e4rme', size=50, relative_minimum=0.1, relative_maximum=1),\n        Q_fu=fx.Flow(label='Q_fu', bus='Gas'),\n    )\n\n    # Combined Heat and Power (CHP): Generates both electricity and heat from fuel\n    chp = fx.linear_converters.CHP(\n        label='CHP',\n        eta_th=0.5,\n        eta_el=0.4,\n        P_el=fx.Flow('P_el', bus='Strom', size=60, relative_minimum=5 / 60),\n        Q_th=fx.Flow('Q_th', bus='Fernw\u00e4rme'),\n        Q_fu=fx.Flow('Q_fu', bus='Gas'),\n    )\n\n    # Storage: Energy storage system with charging and discharging capabilities\n    storage = fx.Storage(\n        label='Storage',\n        charging=fx.Flow('Q_th_load', bus='Fernw\u00e4rme', size=1000),\n        discharging=fx.Flow('Q_th_unload', bus='Fernw\u00e4rme', size=1000),\n        capacity_in_flow_hours=fx.InvestParameters(effects_of_investment=20, fixed_size=30, mandatory=True),\n        initial_charge_state=0,  # Initial storage state: empty\n        relative_maximum_charge_state=1 / 100 * np.array([80, 70, 80, 80, 80, 80, 80, 80, 80]),\n        relative_maximum_final_charge_state=0.8,\n        eta_charge=0.9,\n        eta_discharge=1,  # Efficiency factors for charging/discharging\n        relative_loss_per_hour=0.08,  # 8% loss per hour. Absolute loss depends on current charge state\n        prevent_simultaneous_charge_and_discharge=True,  # Prevent charging and discharging at the same time\n    )\n\n    # Heat Demand Sink: Represents a fixed heat demand profile\n    heat_sink = fx.Sink(\n        label='Heat Demand',\n        inputs=[fx.Flow(label='Q_th_Last', bus='Fernw\u00e4rme', size=1, fixed_relative_profile=heat_demand_per_h)],\n    )\n\n    # Gas Source: Gas tariff source with associated costs and CO2 emissions\n    gas_source = fx.Source(\n        label='Gastarif',\n        outputs=[\n            fx.Flow(label='Q_Gas', bus='Gas', size=1000, effects_per_flow_hour={costs.label: 0.04, CO2.label: 0.3})\n        ],\n    )\n\n    # Power Sink: Represents the export of electricity to the grid\n    power_sink = fx.Sink(\n        label='Einspeisung', inputs=[fx.Flow(label='P_el', bus='Strom', effects_per_flow_hour=-1 * power_prices)]\n    )\n\n    # --- Build the Flow System ---\n    # Add all defined components and effects to the flow system\n    flow_system.add_elements(costs, CO2, boiler, storage, chp, heat_sink, gas_source, power_sink)\n\n    # Visualize the flow system for validation purposes\n    flow_system.plot_network(show=True)\n\n    # --- Define and Run Calculation ---\n    # Create a calculation object to model the Flow System\n    calculation = fx.FullCalculation(name='Sim1', flow_system=flow_system)\n    calculation.do_modeling()  # Translate the model to a solvable form, creating equations and Variables\n\n    # --- Solve the Calculation and Save Results ---\n    calculation.solve(fx.solvers.HighsSolver(mip_gap=0, time_limit_seconds=30))\n\n    # --- Analyze Results ---\n    # Colors are automatically assigned using default colormap\n    # Optional: Configure custom colors with\n    calculation.results.setup_colors()\n    calculation.results['Fernw\u00e4rme'].plot_node_balance_pie()\n    calculation.results['Fernw\u00e4rme'].plot_node_balance()\n    calculation.results['Storage'].plot_charge_state()\n    calculation.results.plot_heatmap('CHP(Q_th)|flow_rate')\n\n    # Convert the results for the storage component to a dataframe and display\n    df = calculation.results['Storage'].node_balance_with_charge_state()\n    print(df)\n\n    # Save results to file for later usage\n    calculation.results.to_file()\n</code></pre>"},{"location":"examples/02-Complex%20Example/","title":"Complex example","text":"<p>This saves the results of a calculation to file and reloads them to analyze the results</p>"},{"location":"examples/02-Complex%20Example/#build-the-model","title":"Build the Model","text":"Python<pre><code>\"\"\"\nThis script shows how to use the flixopt framework to model a more complex energy system.\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\nfrom rich.pretty import pprint  # Used for pretty printing\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # Enable console logging\n    fx.CONFIG.Logging.console = True\n    fx.CONFIG.apply()\n    # --- Experiment Options ---\n    # Configure options for testing various parameters and behaviors\n    check_penalty = False\n    excess_penalty = 1e5\n    use_chp_with_piecewise_conversion = True\n    time_indices = None  # Define specific time steps for custom calculations, or use the entire series\n\n    # --- Define Demand and Price Profiles ---\n    # Input data for electricity and heat demands, as well as electricity price\n    electricity_demand = np.array([70, 80, 90, 90, 90, 90, 90, 90, 90])\n    heat_demand = (\n        np.array([30, 0, 90, 110, 2000, 20, 20, 20, 20])\n        if check_penalty\n        else np.array([30, 0, 90, 110, 110, 20, 20, 20, 20])\n    )\n    electricity_price = np.array([40, 40, 40, 40, 40, 40, 40, 40, 40])\n\n    # --- Define the Flow System, that will hold all elements, and the time steps you want to model ---\n    timesteps = pd.date_range('2020-01-01', periods=len(heat_demand), freq='h')\n    flow_system = fx.FlowSystem(timesteps)  # Create FlowSystem\n\n    # --- Define Energy Buses ---\n    # Represent node balances (inputs=outputs) for the different energy carriers (electricity, heat, gas) in the system\n    flow_system.add_elements(\n        fx.Bus('Strom', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Fernw\u00e4rme', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Gas', excess_penalty_per_flow_hour=excess_penalty),\n    )\n\n    # --- Define Effects ---\n    # Specify effects related to costs, CO2 emissions, and primary energy consumption\n    Costs = fx.Effect('costs', '\u20ac', 'Kosten', is_standard=True, is_objective=True, share_from_temporal={'CO2': 0.2})\n    CO2 = fx.Effect('CO2', 'kg', 'CO2_e-Emissionen')\n    PE = fx.Effect('PE', 'kWh_PE', 'Prim\u00e4renergie', maximum_total=3.5e3)\n\n    # --- Define Components ---\n    # 1. Define Boiler Component\n    # A gas boiler that converts fuel into thermal output, with investment and on-off parameters\n    Gaskessel = fx.linear_converters.Boiler(\n        'Kessel',\n        eta=0.5,  # Efficiency ratio\n        on_off_parameters=fx.OnOffParameters(\n            effects_per_running_hour={Costs.label: 0, CO2.label: 1000}\n        ),  # CO2 emissions per hour\n        Q_th=fx.Flow(\n            label='Q_th',  # Thermal output\n            bus='Fernw\u00e4rme',  # Linked bus\n            size=fx.InvestParameters(\n                effects_of_investment=1000,  # Fixed investment costs\n                fixed_size=50,  # Fixed size\n                mandatory=True,  # Forced investment\n                effects_of_investment_per_size={Costs.label: 10, PE.label: 2},  # Specific costs\n            ),\n            load_factor_max=1.0,  # Maximum load factor (50 kW)\n            load_factor_min=0.1,  # Minimum load factor (5 kW)\n            relative_minimum=5 / 50,  # Minimum part load\n            relative_maximum=1,  # Maximum part load\n            previous_flow_rate=50,  # Previous flow rate\n            flow_hours_total_max=1e6,  # Total energy flow limit\n            on_off_parameters=fx.OnOffParameters(\n                on_hours_total_min=0,  # Minimum operating hours\n                on_hours_total_max=1000,  # Maximum operating hours\n                consecutive_on_hours_max=10,  # Max consecutive operating hours\n                consecutive_on_hours_min=np.array([1, 1, 1, 1, 1, 2, 2, 2, 2]),  # min consecutive operation hours\n                consecutive_off_hours_max=10,  # Max consecutive off hours\n                effects_per_switch_on=0.01,  # Cost per switch-on\n                switch_on_total_max=1000,  # Max number of starts\n            ),\n        ),\n        Q_fu=fx.Flow(label='Q_fu', bus='Gas', size=200),\n    )\n\n    # 2. Define CHP Unit\n    # Combined Heat and Power unit that generates both electricity and heat from fuel\n    bhkw = fx.linear_converters.CHP(\n        'BHKW2',\n        eta_th=0.5,\n        eta_el=0.4,\n        on_off_parameters=fx.OnOffParameters(effects_per_switch_on=0.01),\n        P_el=fx.Flow('P_el', bus='Strom', size=60, relative_minimum=5 / 60),\n        Q_th=fx.Flow('Q_th', bus='Fernw\u00e4rme', size=1e3),\n        Q_fu=fx.Flow('Q_fu', bus='Gas', size=1e3, previous_flow_rate=20),  # The CHP was ON previously\n    )\n\n    # 3. Define CHP with Piecewise Conversion\n    # This CHP unit uses piecewise conversion for more dynamic behavior over time\n    P_el = fx.Flow('P_el', bus='Strom', size=60, previous_flow_rate=20)\n    Q_th = fx.Flow('Q_th', bus='Fernw\u00e4rme')\n    Q_fu = fx.Flow('Q_fu', bus='Gas')\n    piecewise_conversion = fx.PiecewiseConversion(\n        {\n            P_el.label: fx.Piecewise([fx.Piece(5, 30), fx.Piece(40, 60)]),\n            Q_th.label: fx.Piecewise([fx.Piece(6, 35), fx.Piece(45, 100)]),\n            Q_fu.label: fx.Piecewise([fx.Piece(12, 70), fx.Piece(90, 200)]),\n        }\n    )\n\n    bhkw_2 = fx.LinearConverter(\n        'BHKW2',\n        inputs=[Q_fu],\n        outputs=[P_el, Q_th],\n        piecewise_conversion=piecewise_conversion,\n        on_off_parameters=fx.OnOffParameters(effects_per_switch_on=0.01),\n    )\n\n    # 4. Define Storage Component\n    # Storage with variable size and piecewise investment effects\n    segmented_investment_effects = fx.PiecewiseEffects(\n        piecewise_origin=fx.Piecewise([fx.Piece(5, 25), fx.Piece(25, 100)]),\n        piecewise_shares={\n            Costs.label: fx.Piecewise([fx.Piece(50, 250), fx.Piece(250, 800)]),\n            PE.label: fx.Piecewise([fx.Piece(5, 25), fx.Piece(25, 100)]),\n        },\n    )\n\n    speicher = fx.Storage(\n        'Speicher',\n        charging=fx.Flow('Q_th_load', bus='Fernw\u00e4rme', size=1e4),\n        discharging=fx.Flow('Q_th_unload', bus='Fernw\u00e4rme', size=1e4),\n        capacity_in_flow_hours=fx.InvestParameters(\n            piecewise_effects_of_investment=segmented_investment_effects,  # Investment effects\n            mandatory=True,  # Forced investment\n            minimum_size=0,\n            maximum_size=1000,  # Optimizing between 0 and 1000 kWh\n        ),\n        initial_charge_state=0,  # Initial charge state\n        maximal_final_charge_state=10,  # Maximum final charge state\n        eta_charge=0.9,\n        eta_discharge=1,  # Charge/discharge efficiency\n        relative_loss_per_hour=0.08,  # Energy loss per hour, relative to current charge state\n        prevent_simultaneous_charge_and_discharge=True,  # Prevent simultaneous charge/discharge\n    )\n\n    # 5. Define Sinks and Sources\n    # 5.a) Heat demand profile\n    Waermelast = fx.Sink(\n        'W\u00e4rmelast',\n        inputs=[\n            fx.Flow(\n                'Q_th_Last',  # Heat sink\n                bus='Fernw\u00e4rme',  # Linked bus\n                size=1,\n                fixed_relative_profile=heat_demand,  # Fixed demand profile\n            )\n        ],\n    )\n\n    # 5.b) Gas tariff\n    Gasbezug = fx.Source(\n        'Gastarif',\n        outputs=[\n            fx.Flow(\n                'Q_Gas',\n                bus='Gas',  # Gas source\n                size=1000,  # Nominal size\n                effects_per_flow_hour={Costs.label: 0.04, CO2.label: 0.3},\n            )\n        ],\n    )\n\n    # 5.c) Feed-in of electricity\n    Stromverkauf = fx.Sink(\n        'Einspeisung',\n        inputs=[\n            fx.Flow(\n                'P_el',\n                bus='Strom',  # Feed-in tariff for electricity\n                effects_per_flow_hour=-1 * electricity_price,  # Negative price for feed-in\n            )\n        ],\n    )\n\n    # --- Build FlowSystem ---\n    # Select components to be included in the flow system\n    flow_system.add_elements(Costs, CO2, PE, Gaskessel, Waermelast, Gasbezug, Stromverkauf, speicher)\n    flow_system.add_elements(bhkw_2) if use_chp_with_piecewise_conversion else flow_system.add_elements(bhkw)\n\n    pprint(flow_system)  # Get a string representation of the FlowSystem\n    try:\n        flow_system.start_network_app()  # Start the network app\n    except ImportError as e:\n        print(f'Network app requires extra dependencies: {e}')\n\n    # --- Solve FlowSystem ---\n    calculation = fx.FullCalculation('complex example', flow_system, time_indices)\n    calculation.do_modeling()\n\n    calculation.solve(fx.solvers.HighsSolver(0.01, 60))\n\n    # --- Results ---\n    # You can analyze results directly or save them to file and reload them later.\n    calculation.results.to_file()\n\n    # But let's plot some results anyway\n    calculation.results.plot_heatmap('BHKW2(Q_th)|flow_rate')\n    calculation.results['BHKW2'].plot_node_balance()\n    calculation.results['Speicher'].plot_charge_state()\n    calculation.results['Fernw\u00e4rme'].plot_node_balance_pie()\n</code></pre>"},{"location":"examples/02-Complex%20Example/#load-the-results-from-file","title":"Load the Results from file","text":"Python<pre><code>\"\"\"\nThis script shows how load results of a prior calcualtion and how to analyze them.\n\"\"\"\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # Enable console logging\n    fx.CONFIG.Logging.console = True\n    fx.CONFIG.apply()\n    # --- Load Results ---\n    try:\n        results = fx.results.CalculationResults.from_file('results', 'complex example')\n    except FileNotFoundError as e:\n        raise FileNotFoundError(\n            f\"Results file not found in the specified directory ('results'). \"\n            f\"Please ensure that the file is generated by running 'complex_example.py'. \"\n            f'Original error: {e}'\n        ) from e\n\n    # --- Basic overview ---\n    results.plot_network(show=True)\n    results['Fernw\u00e4rme'].plot_node_balance()\n\n    # --- Detailed Plots ---\n    # In depth plot for individual flow rates ('__' is used as the delimiter between Component and Flow\n    results.plot_heatmap('W\u00e4rmelast(Q_th_Last)|flow_rate')\n    for bus in results.buses.values():\n        bus.plot_node_balance_pie(show=False, save=f'results/{bus.label}--pie.html')\n        bus.plot_node_balance(show=False, save=f'results/{bus.label}--balance.html')\n\n    # --- Plotting internal variables manually ---\n    results.plot_heatmap('BHKW2(Q_th)|on')\n    results.plot_heatmap('Kessel(Q_th)|on')\n\n    # Dataframes from results:\n    fw_bus = results['Fernw\u00e4rme'].node_balance().to_dataframe()\n    all = results.solution.to_dataframe()\n</code></pre>"},{"location":"examples/03-Calculation%20Modes/","title":"Calculation Mode comparison","text":"<p>Note: This example relies on time series data. You can find it in the <code>examples</code> folder of the FlixOpt repository. Python<pre><code>\"\"\"\nThis script demonstrates how to use the different calculation types in the flixopt framework\nto model the same energy system. The results will be compared to each other.\n\"\"\"\n\nimport pathlib\n\nimport pandas as pd\nimport xarray as xr\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # Enable console logging\n    fx.CONFIG.Logging.console = True\n    fx.CONFIG.apply()\n    # Calculation Types\n    full, segmented, aggregated = True, True, True\n\n    # Segmented Properties\n    segment_length, overlap_length = 96, 1\n\n    # Aggregated Properties\n    aggregation_parameters = fx.AggregationParameters(\n        hours_per_period=6,\n        nr_of_periods=4,\n        fix_storage_flows=False,\n        aggregate_data_and_fix_non_binary_vars=True,\n        percentage_of_period_freedom=0,\n        penalty_of_period_freedom=0,\n    )\n    keep_extreme_periods = True\n    excess_penalty = 1e5  # or set to None if not needed\n\n    # Data Import\n    data_import = pd.read_csv(\n        pathlib.Path(__file__).parent.parent / 'resources' / 'Zeitreihen2020.csv', index_col=0\n    ).sort_index()\n    filtered_data = data_import['2020-01-01':'2020-01-07 23:45:00']\n    # filtered_data = data_import[0:500]  # Alternatively filter by index\n\n    filtered_data.index = pd.to_datetime(filtered_data.index)\n    timesteps = filtered_data.index\n\n    # Access specific columns and convert to 1D-numpy array\n    electricity_demand = filtered_data['P_Netz/MW'].to_numpy()\n    heat_demand = filtered_data['Q_Netz/MW'].to_numpy()\n    electricity_price = filtered_data['Strompr.\u20ac/MWh'].to_numpy()\n    gas_price = filtered_data['Gaspr.\u20ac/MWh'].to_numpy()\n\n    # TimeSeriesData objects\n    TS_heat_demand = fx.TimeSeriesData(heat_demand)\n    TS_electricity_demand = fx.TimeSeriesData(electricity_demand, aggregation_weight=0.7)\n    TS_electricity_price_sell = fx.TimeSeriesData(-(electricity_price - 0.5), aggregation_group='p_el')\n    TS_electricity_price_buy = fx.TimeSeriesData(electricity_price + 0.5, aggregation_group='p_el')\n\n    flow_system = fx.FlowSystem(timesteps)\n    flow_system.add_elements(\n        fx.Bus('Strom', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Fernw\u00e4rme', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Gas', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Kohle', excess_penalty_per_flow_hour=excess_penalty),\n    )\n\n    # Effects\n    costs = fx.Effect('costs', '\u20ac', 'Kosten', is_standard=True, is_objective=True)\n    CO2 = fx.Effect('CO2', 'kg', 'CO2_e-Emissionen')\n    PE = fx.Effect('PE', 'kWh_PE', 'Prim\u00e4renergie')\n\n    # Component Definitions\n\n    # 1. Boiler\n    a_gaskessel = fx.linear_converters.Boiler(\n        'Kessel',\n        eta=0.85,\n        Q_th=fx.Flow(label='Q_th', bus='Fernw\u00e4rme'),\n        Q_fu=fx.Flow(\n            label='Q_fu',\n            bus='Gas',\n            size=95,\n            relative_minimum=12 / 95,\n            previous_flow_rate=20,\n            on_off_parameters=fx.OnOffParameters(effects_per_switch_on=1000),\n        ),\n    )\n\n    # 2. CHP\n    a_kwk = fx.linear_converters.CHP(\n        'BHKW2',\n        eta_th=0.58,\n        eta_el=0.22,\n        on_off_parameters=fx.OnOffParameters(effects_per_switch_on=24000),\n        P_el=fx.Flow('P_el', bus='Strom', size=200),\n        Q_th=fx.Flow('Q_th', bus='Fernw\u00e4rme', size=200),\n        Q_fu=fx.Flow('Q_fu', bus='Kohle', size=288, relative_minimum=87 / 288, previous_flow_rate=100),\n    )\n\n    # 3. Storage\n    a_speicher = fx.Storage(\n        'Speicher',\n        capacity_in_flow_hours=684,\n        initial_charge_state=137,\n        minimal_final_charge_state=137,\n        maximal_final_charge_state=158,\n        eta_charge=1,\n        eta_discharge=1,\n        relative_loss_per_hour=0.001,\n        prevent_simultaneous_charge_and_discharge=True,\n        charging=fx.Flow('Q_th_load', size=137, bus='Fernw\u00e4rme'),\n        discharging=fx.Flow('Q_th_unload', size=158, bus='Fernw\u00e4rme'),\n    )\n\n    # 4. Sinks and Sources\n    # Heat Load Profile\n    a_waermelast = fx.Sink(\n        'W\u00e4rmelast', inputs=[fx.Flow('Q_th_Last', bus='Fernw\u00e4rme', size=1, fixed_relative_profile=TS_heat_demand)]\n    )\n\n    # Electricity Feed-in\n    a_strom_last = fx.Sink(\n        'Stromlast', inputs=[fx.Flow('P_el_Last', bus='Strom', size=1, fixed_relative_profile=TS_electricity_demand)]\n    )\n\n    # Gas Tariff\n    a_gas_tarif = fx.Source(\n        'Gastarif',\n        outputs=[\n            fx.Flow('Q_Gas', bus='Gas', size=1000, effects_per_flow_hour={costs.label: gas_price, CO2.label: 0.3})\n        ],\n    )\n\n    # Coal Tariff\n    a_kohle_tarif = fx.Source(\n        'Kohletarif',\n        outputs=[fx.Flow('Q_Kohle', bus='Kohle', size=1000, effects_per_flow_hour={costs.label: 4.6, CO2.label: 0.3})],\n    )\n\n    # Electricity Tariff and Feed-in\n    a_strom_einspeisung = fx.Sink(\n        'Einspeisung', inputs=[fx.Flow('P_el', bus='Strom', size=1000, effects_per_flow_hour=TS_electricity_price_sell)]\n    )\n\n    a_strom_tarif = fx.Source(\n        'Stromtarif',\n        outputs=[\n            fx.Flow(\n                'P_el',\n                bus='Strom',\n                size=1000,\n                effects_per_flow_hour={costs.label: TS_electricity_price_buy, CO2.label: 0.3},\n            )\n        ],\n    )\n\n    # Flow System Setup\n    flow_system.add_elements(costs, CO2, PE)\n    flow_system.add_elements(\n        a_gaskessel,\n        a_waermelast,\n        a_strom_last,\n        a_gas_tarif,\n        a_kohle_tarif,\n        a_strom_einspeisung,\n        a_strom_tarif,\n        a_kwk,\n        a_speicher,\n    )\n    flow_system.plot_network(controls=False, show=True)\n\n    # Calculations\n    calculations: list[fx.FullCalculation | fx.AggregatedCalculation | fx.SegmentedCalculation] = []\n\n    if full:\n        calculation = fx.FullCalculation('Full', flow_system)\n        calculation.do_modeling()\n        calculation.solve(fx.solvers.HighsSolver(0.01 / 100, 60))\n        calculations.append(calculation)\n\n    if segmented:\n        calculation = fx.SegmentedCalculation('Segmented', flow_system, segment_length, overlap_length)\n        calculation.do_modeling_and_solve(fx.solvers.HighsSolver(0.01 / 100, 60))\n        calculations.append(calculation)\n\n    if aggregated:\n        if keep_extreme_periods:\n            aggregation_parameters.time_series_for_high_peaks = [TS_heat_demand]\n            aggregation_parameters.time_series_for_low_peaks = [TS_electricity_demand, TS_heat_demand]\n        calculation = fx.AggregatedCalculation('Aggregated', flow_system, aggregation_parameters)\n        calculation.do_modeling()\n        calculation.solve(fx.solvers.HighsSolver(0.01 / 100, 60))\n        calculations.append(calculation)\n\n    # Get solutions for plotting for different calculations\n    def get_solutions(calcs: list, variable: str) -&gt; xr.Dataset:\n        dataarrays = []\n        for calc in calcs:\n            if calc.name == 'Segmented':\n                dataarrays.append(calc.results.solution_without_overlap(variable).rename(calc.name))\n            else:\n                dataarrays.append(calc.results.model.variables[variable].solution.rename(calc.name))\n        return xr.merge(dataarrays)\n\n    # --- Plotting for comparison ---\n    fx.plotting.with_plotly(\n        get_solutions(calculations, 'Speicher|charge_state'),\n        mode='line',\n        title='Charge State Comparison',\n        ylabel='Charge state',\n        xlabel='Time in h',\n    ).write_html('results/Charge State.html')\n\n    fx.plotting.with_plotly(\n        get_solutions(calculations, 'BHKW2(Q_th)|flow_rate'),\n        mode='line',\n        title='BHKW2(Q_th) Flow Rate Comparison',\n        ylabel='Flow rate',\n        xlabel='Time in h',\n    ).write_html('results/BHKW2 Thermal Power.html')\n\n    fx.plotting.with_plotly(\n        get_solutions(calculations, 'costs(temporal)|per_timestep'),\n        mode='line',\n        title='Operation Cost Comparison',\n        ylabel='Costs [\u20ac]',\n        xlabel='Time in h',\n    ).write_html('results/Operation Costs.html')\n\n    fx.plotting.with_plotly(\n        get_solutions(calculations, 'costs(temporal)|per_timestep').sum('time'),\n        mode='stacked_bar',\n        title='Total Cost Comparison',\n        ylabel='Costs [\u20ac]',\n    ).update_layout(barmode='group').write_html('results/Total Costs.html')\n\n    fx.plotting.with_plotly(\n        pd.DataFrame([calc.durations for calc in calculations], index=[calc.name for calc in calculations]).to_xarray(),\n        mode='stacked_bar',\n    ).update_layout(title='Duration Comparison', xaxis_title='Calculation type', yaxis_title='Time (s)').write_html(\n        'results/Speed Comparison.html'\n    )\n</code></pre></p>"},{"location":"user-guide/","title":"FlixOpt Concepts","text":"<p>FlixOpt is built around a set of core concepts that work together to represent and optimize any system involving flows and conversions - whether that's energy systems, material flows, supply chains, water networks, or production processes.</p> <p>This page provides a high-level overview of these concepts and how they interact.</p>"},{"location":"user-guide/#core-concepts","title":"Core Concepts","text":""},{"location":"user-guide/#flowsystem","title":"FlowSystem","text":"<p>The <code>FlowSystem</code> is the central organizing unit in FlixOpt. Every FlixOpt model starts with creating a FlowSystem. It:</p> <ul> <li>Defines the timesteps for the optimization</li> <li>Contains and connects components, buses, and flows</li> <li>Manages the effects (objectives and constraints)</li> </ul>"},{"location":"user-guide/#flows","title":"Flows","text":"<p><code>Flow</code> objects represent the movement of energy or material between a Bus and a Component in a predefined direction.</p> <ul> <li>Have a <code>size</code> which, generally speaking, defines how fast energy or material can be moved. Usually measured in MW, kW, m\u00b3/h, etc.</li> <li>Have a <code>flow_rate</code>, which is defines how fast energy or material is transported. Usually measured in MW, kW, m\u00b3/h, etc.</li> <li>Have constraints to limit the flow-rate (min/max, total flow hours, on/off etc.)</li> <li>Can have fixed profiles (for demands or renewable generation)</li> <li>Can have Effects associated by their use (operation, investment, on/off, ...)</li> </ul>"},{"location":"user-guide/#flow-hours","title":"Flow Hours","text":"<p>While the Flow Rate defines the rate in which energy or material is transported, the Flow Hours define the amount of energy or material that is transported. Its defined by the flow_rate times the duration of the timestep in hours.</p> <p>Examples:</p> Flow Rate Timestep Flow Hours 10 (MW) 1 hour 10 (MWh) 10 (MW) 6 minutes 0.1 (MWh) 10 (kg/h) 1 hour 10 (kg)"},{"location":"user-guide/#buses","title":"Buses","text":"<p><code>Bus</code> objects represent nodes or connection points in a FlowSystem. They:</p> <ul> <li>Balance incoming and outgoing flows</li> <li>Can represent physical networks like heat, electricity, or gas</li> <li>Handle infeasible balances gently by allowing the balance to be closed in return for a big Penalty (optional)</li> </ul>"},{"location":"user-guide/#components","title":"Components","text":"<p><code>Component</code> objects usually represent physical entities in your system that interact with <code>Flows</code>. The generic component types work across all domains:</p> <ul> <li><code>LinearConverters</code> - Converts input flows to output flows with (piecewise) linear relationships</li> <li>Energy: boilers, heat pumps, turbines</li> <li>Manufacturing: assembly lines, processing equipment</li> <li>Chemistry: reactors, separators</li> <li><code>Storages</code> - Stores energy or material over time</li> <li>Energy: batteries, thermal storage, gas storage</li> <li>Logistics: warehouses, buffer inventory</li> <li>Water: reservoirs, tanks</li> <li><code>Sources</code> / <code>Sinks</code> / <code>SourceAndSinks</code> - Produce or consume flows</li> <li>Energy: demands, renewable generation</li> <li>Manufacturing: raw material supply, product demand</li> <li>Supply chain: suppliers, customers</li> <li><code>Transmissions</code> - Moves flows between locations with possible losses</li> <li>Energy: pipelines, power lines</li> <li>Logistics: transport routes</li> <li>Water: distribution networks</li> </ul> <p>Pre-built specialized components for energy systems include <code>Boilers</code>, <code>HeatPumps</code>, <code>CHPs</code>, etc. These can serve as blueprints for custom domain-specific components.</p>"},{"location":"user-guide/#effects","title":"Effects","text":"<p><code>Effect</code> objects represent impacts or metrics related to your system. While commonly used to allocate costs, they're completely flexible:</p> <p>Energy systems: - Costs (investment, operation) - Emissions (CO\u2082, NOx, etc.) - Primary energy consumption</p> <p>Other domains: - Production time, labor hours (manufacturing) - Water consumption, wastewater (process industries) - Transport distance, vehicle utilization (logistics) - Space consumption - Any custom metric relevant to your domain</p> <p>These can be freely defined and crosslink to each other (<code>CO\u2082</code> \u2500\u2500[specific CO\u2082-costs]\u2500\u2192 <code>Costs</code>). One effect is designated as the optimization objective (typically Costs), while others can be constrained. This approach allows for multi-criteria optimization using both:</p> <ul> <li>Weighted Sum Method: Optimize a theoretical Effect which other Effects crosslink to</li> <li>\u03b5-constraint method: Constrain effects to specific limits</li> </ul>"},{"location":"user-guide/#calculation","title":"Calculation","text":"<p>A <code>FlowSystem</code> can be converted to a Model and optimized by creating a <code>Calculation</code> from it.</p> <p>FlixOpt offers different calculation modes:</p> <ul> <li><code>FullCalculation</code> - Solves the entire problem at once</li> <li><code>SegmentedCalculation</code> - Solves the problem in segments (with optioinal overlap), improving performance for large problems</li> <li><code>AggregatedCalculation</code> - Uses typical periods to reduce computational requirements</li> </ul>"},{"location":"user-guide/#results","title":"Results","text":"<p>The results of a calculation are stored in a <code>CalculationResults</code> object. This object contains the solutions of the optimization as well as all information about the <code>Calculation</code> and the <code>FlowSystem</code> it was created from. The solutions is stored as an <code>xarray.Dataset</code>, but can be accessed through their assotiated Component, Bus or Effect.</p> <p>This <code>CalculationResults</code> object can be saved to file and reloaded from file, allowing you to analyze the results anytime after the solve.</p>"},{"location":"user-guide/#how-these-concepts-work-together","title":"How These Concepts Work Together","text":"<p>The process of working with FlixOpt can be divided into 3 steps:</p> <ol> <li>Create a <code>FlowSystem</code>, containing all the elements and data of your system<ul> <li>Define the time series of your system</li> <li>Add <code>Components</code> like <code>Boilers</code>, <code>HeatPumps</code>, <code>CHPs</code>, etc.</li> <li>Add <code>Buses</code> as connection points in your system</li> <li>Add <code>Effects</code> to represent costs, emissions, etc.</li> <li>This <code>FlowSystem</code> can also be loaded from a netCDF file</li> </ul> </li> <li>Translate the model to a mathematical optimization problem<ul> <li>Create a <code>Calculation</code> from your FlowSystem and choose a Solver</li> <li>...The Calculation is translated internaly to a mathematical optimization problem...</li> <li>...and solved by the chosen solver.</li> </ul> </li> <li>Analyze the results<ul> <li>The results are stored in a <code>CalculationResults</code> object</li> <li>This object can be saved to file and reloaded from file, retaining all information about the calculation</li> <li>As it contains the used <code>FlowSystem</code>, it can be used to start a new calculation</li> </ul> </li> </ol> <p> </p> Conceptual Usage and IO operations of FlixOpt"},{"location":"user-guide/#advanced-usage","title":"Advanced Usage","text":"<p>As flixopt is build on linopy, any model created with FlixOpt can be extended or modified using the great linopy API. This allows to adjust your model to very specific requirements without loosing the convenience of FlixOpt.</p>"},{"location":"user-guide/migration-guide-v3/","title":"Migration Guide: v2.x \u2192 v3.0.0","text":"<p>Quick Start</p> <p>Bash<pre><code>pip install --upgrade flixopt\n</code></pre> Review breaking changes, update deprecated parameters, test thoroughly.</p>"},{"location":"user-guide/migration-guide-v3/#breaking-changes","title":"\ud83d\udca5 Breaking Changes","text":""},{"location":"user-guide/migration-guide-v3/#effect-system-redesign","title":"Effect System Redesign","text":"<p>Terminology changed and sharing system inverted: effects now \"pull\" shares.</p> Concept Old (v2.x) New (v3.0.0) Time-varying effects <code>operation</code> <code>temporal</code> Investment effects <code>invest</code> / <code>investment</code> <code>periodic</code> Share to other effects (operation) <code>specific_share_to_other_effects_operation</code> <code>share_from_temporal</code> Share to other effects (invest) <code>specific_share_to_other_effects_invest</code> <code>share_from_periodic</code> v2.xv3.0.0 Python<pre><code>CO2 = fx.Effect('CO2', 'kg', 'CO2',\n    specific_share_to_other_effects_operation={'costs': 0.2})\ncosts = fx.Effect('costs', '\u20ac', 'Total')\n</code></pre> Python<pre><code>CO2 = fx.Effect('CO2', 'kg', 'CO2')\ncosts = fx.Effect('costs', '\u20ac', 'Total',\n    share_from_temporal={'CO2': 0.2})  # Pull from CO2\n</code></pre> <p>No deprecation warning</p> <p>Move shares to receiving effect and update parameter names throughout your code.</p>"},{"location":"user-guide/migration-guide-v3/#variable-names","title":"Variable Names","text":"Category Old (v2.x) New (v3.0.0) Investment <code>is_invested</code> <code>invested</code> Switching <code>switch_on</code> <code>switch|on</code> Switching <code>switch_off</code> <code>switch|off</code> Switching <code>switch_on_nr</code> <code>switch|count</code> Effects <code>Effect(invest)|total</code> <code>Effect(periodic)</code> Effects <code>Effect(operation)|total</code> <code>Effect(temporal)</code> Effects <code>Effect(operation)|total_per_timestep</code> <code>Effect(temporal)|per_timestep</code> Effects <code>Effect|total</code> <code>Effect</code>"},{"location":"user-guide/migration-guide-v3/#string-labels","title":"String Labels","text":"What Old (v2.x) New (v3.0.0) Bus assignment <code>bus=my_bus</code> (object) <code>bus='electricity'</code> (string) Effect shares <code>{CO2: 0.2}</code> (object key) <code>{'CO2': 0.2}</code> (string key) v2.xv3.0.0 Python<pre><code>flow = fx.Flow('P_el', bus=my_bus)  # \u274c Object\ncosts = fx.Effect('costs', '\u20ac', share_from_temporal={CO2: 0.2})  # \u274c\n</code></pre> Python<pre><code>flow = fx.Flow('P_el', bus='electricity')  # \u2705 String\ncosts = fx.Effect('costs', '\u20ac', share_from_temporal={'CO2': 0.2})  # \u2705\n</code></pre>"},{"location":"user-guide/migration-guide-v3/#flowsystem-calculation","title":"FlowSystem &amp; Calculation","text":"Change Description FlowSystem copying Each <code>Calculation</code> gets its own copy (independent) do_modeling() return Returns <code>Calculation</code> object (access model via <code>.model</code> property) Storage arrays Arrays match timestep count (no extra element) Final charge state Use <code>relative_minimum_final_charge_state</code> / <code>relative_maximum_final_charge_state</code>"},{"location":"user-guide/migration-guide-v3/#other-changes","title":"Other Changes","text":"Category Old (v2.x) New (v3.0.0) System model class <code>SystemModel</code> <code>FlowSystemModel</code> Element submodel <code>Model</code> <code>Submodel</code> Logging default Enabled Disabled Enable logging (default) <code>fx.CONFIG.Logging.console = True; fx.CONFIG.apply()</code>"},{"location":"user-guide/migration-guide-v3/#deprecated-parameters","title":"\ud83d\uddd1\ufe0f Deprecated Parameters","text":"InvestParameters Old (v2.x) New (v3.0.0) <code>fix_effects</code> <code>effects_of_investment</code> <code>specific_effects</code> <code>effects_of_investment_per_size</code> <code>divest_effects</code> <code>effects_of_retirement</code> <code>piecewise_effects</code> <code>piecewise_effects_of_investment</code> Effect Old (v2.x) New (v3.0.0) <code>minimum_investment</code> <code>minimum_periodic</code> <code>maximum_investment</code> <code>maximum_periodic</code> <code>minimum_operation</code> <code>minimum_temporal</code> <code>maximum_operation</code> <code>maximum_temporal</code> <code>minimum_operation_per_hour</code> <code>minimum_per_hour</code> <code>maximum_operation_per_hour</code> <code>maximum_per_hour</code> Components Old (v2.x) New (v3.0.0) <code>source</code> (parameter) <code>outputs</code> <code>sink</code> (parameter) <code>inputs</code> <code>prevent_simultaneous_sink_and_source</code> <code>prevent_simultaneous_flow_rates</code> TimeSeriesData Old (v2.x) New (v3.0.0) <code>agg_group</code> <code>aggregation_group</code> <code>agg_weight</code> <code>aggregation_weight</code> Calculation Old (v2.x) New (v3.0.0) <code>active_timesteps=[0, 1, 2]</code> Use <code>flow_system.sel()</code> or <code>flow_system.isel()</code>"},{"location":"user-guide/migration-guide-v3/#new-features","title":"\u2728 New Features","text":"Multi-Period Investments Python<pre><code>periods = pd.Index(['2020', '2030'])\nflow_system = fx.FlowSystem(time=timesteps, periods=periods)\n</code></pre> Scenario-Based Optimization Parameter Description Example <code>scenarios</code> Scenario index <code>pd.Index(['low', 'base', 'high'], name='scenario')</code> <code>scenario_weights</code> Probabilities <code>[0.2, 0.6, 0.2]</code> <code>scenario_independent_sizes</code> Separate capacities per scenario <code>True</code> / <code>False</code> (default) Python<pre><code>flow_system = fx.FlowSystem(\n    time=timesteps,\n    scenarios=scenarios,\n    scenario_weights=[0.2, 0.6, 0.2],\n    scenario_independent_sizes=True\n)\n</code></pre> Enhanced I/O Method Description <code>flow_system.to_netcdf('file.nc')</code> Save FlowSystem <code>fx.FlowSystem.from_netcdf('file.nc')</code> Load FlowSystem <code>flow_system.sel(time=slice(...))</code> Select by label <code>flow_system.isel(time=slice(...))</code> Select by index <code>flow_system.resample(time='D')</code> Resample timeseries <code>flow_system.copy()</code> Deep copy <code>results.flow_system</code> Access from results Effects Per Component Python<pre><code>effects_ds = results.effects_per_component\n\n# Access effect contributions by component\nprint(effects_ds['total'].sel(effect='costs'))      # Total effects\nprint(effects_ds['temporal'].sel(effect='CO2'))     # Temporal effects\nprint(effects_ds['periodic'].sel(effect='costs'))   # Periodic effects\n</code></pre> Storage Features Feature Parameter Description Balanced storage <code>balanced=True</code> Ensures charge_size == discharge_size Final state min <code>relative_minimum_final_charge_state=0.5</code> End at least 50% charged Final state max <code>relative_maximum_final_charge_state=0.8</code> End at most 80% charged"},{"location":"user-guide/migration-guide-v3/#common-issues","title":"\ud83d\udd27 Common Issues","text":"Issue Solution Effect shares not working See Effect System Redesign Storage dimensions wrong See FlowSystem &amp; Calculation Bus assignment error See String Labels KeyError in results See Variable Names <code>AttributeError: model</code> Rename <code>.model</code> \u2192 <code>.submodel</code> No logging See Other Changes"},{"location":"user-guide/migration-guide-v3/#checklist","title":"\u2705 Checklist","text":"Category Tasks Install \u2022 <code>pip install --upgrade flixopt</code> Breaking changes \u2022 Update effect sharing\u2022 Update variable names\u2022 Update string labels\u2022 Fix storage arrays\u2022 Update Calculation API\u2022 Update class names Configuration \u2022 Enable logging if needed Deprecated \u2022 Update deprecated parameters (recommended) Testing \u2022 Test thoroughly\u2022 Validate results match v2.x <p> Docs \u2022  Issues \u2022  Changelog</p> <p>Welcome to flixopt v3.0.0! \ud83c\udf89</p>"},{"location":"user-guide/mathematical-notation/","title":"Mathematical Notation","text":"<p>This section provides the mathematical formulations underlying FlixOpt's optimization models. It is intended as reference documentation for users who want to understand the mathematical details behind the high-level FlixOpt API described in the FlixOpt Concepts guide.</p> <p>For typical usage, refer to the FlixOpt Concepts guide, Examples, and API Reference - you don't need to understand these mathematical formulations to use FlixOpt effectively.</p>"},{"location":"user-guide/mathematical-notation/#naming-conventions","title":"Naming Conventions","text":"<p>FlixOpt uses the following naming conventions:</p> <ul> <li>All optimization variables are denoted by italic letters (e.g., \\(x\\), \\(y\\), \\(z\\))</li> <li>All parameters and constants are denoted by non italic small letters (e.g., \\(\\text{a}\\), \\(\\text{b}\\), \\(\\text{c}\\))</li> <li>All Sets are denoted by greek capital letters (e.g., \\(\\mathcal{F}\\), \\(\\mathcal{E}\\))</li> <li>All units of a set are denoted by greek small letters (e.g., \\(\\mathcal{f}\\), \\(\\mathcal{e}\\))</li> <li>The letter \\(i\\) is used to denote an index (e.g., \\(i=1,\\dots,\\text n\\))</li> <li>All time steps are denoted by the letter \\(\\text{t}\\) (e.g., \\(\\text{t}_0\\), \\(\\text{t}_1\\), \\(\\text{t}_i\\))</li> </ul>"},{"location":"user-guide/mathematical-notation/#dimensions-and-time-steps","title":"Dimensions and Time Steps","text":"<p>FlixOpt supports multi-dimensional optimization with up to three dimensions: time (mandatory), period (optional), and scenario (optional).</p> <p>All mathematical formulations in this documentation are independent of whether periods or scenarios are present. The equations shown are written with time index \\(\\text{t}_i\\) only, but automatically expand to additional dimensions when periods/scenarios are added.</p> <p>For complete details on dimensions, their relationships, and influence on formulations, see Dimensions.</p>"},{"location":"user-guide/mathematical-notation/#time-steps","title":"Time Steps","text":"<p>Time steps are defined as a sequence of discrete time steps \\(\\text{t}_i \\in \\mathcal{T} \\quad \\text{for} \\quad i \\in \\{1, 2, \\dots, \\text{n}\\}\\) (left-aligned in its timespan). From this sequence, the corresponding time intervals \\(\\Delta \\text{t}_i \\in \\Delta \\mathcal{T}\\) are derived as</p> \\[\\Delta \\text{t}_i = \\text{t}_{i+1} - \\text{t}_i \\quad \\text{for} \\quad i \\in \\{1, 2, \\dots, \\text{n}-1\\}\\] <p>The final time interval \\(\\Delta \\text{t}_\\text n\\) defaults to \\(\\Delta \\text{t}_\\text n = \\Delta \\text{t}_{\\text n-1}\\), but is of course customizable. Non-equidistant time steps are also supported.</p>"},{"location":"user-guide/mathematical-notation/#documentation-structure","title":"Documentation Structure","text":"<p>This reference is organized to match the FlixOpt API structure:</p>"},{"location":"user-guide/mathematical-notation/#elements","title":"Elements","text":"<p>Mathematical formulations for core FlixOpt elements (corresponding to <code>flixopt.elements</code>):</p> <ul> <li>Flow - Flow rate constraints and bounds</li> <li>Bus - Nodal balance equations</li> <li>Storage - Storage balance and charge state evolution</li> <li>LinearConverter - Linear conversion relationships</li> </ul> <p>User API: When you create a <code>Flow</code>, <code>Bus</code>, <code>Storage</code>, or <code>LinearConverter</code> in your FlixOpt model, these mathematical formulations are automatically applied.</p>"},{"location":"user-guide/mathematical-notation/#features","title":"Features","text":"<p>Mathematical formulations for optional features (corresponding to parameters in FlixOpt classes):</p> <ul> <li>InvestParameters - Investment decision modeling</li> <li>OnOffParameters - Binary on/off operation</li> <li>Piecewise - Piecewise linear approximations</li> </ul> <p>User API: When you pass <code>invest_parameters</code> or <code>on_off_parameters</code> to a <code>Flow</code> or component, these formulations are applied.</p>"},{"location":"user-guide/mathematical-notation/#system-level","title":"System-Level","text":"<ul> <li>Effects, Penalty &amp; Objective - Cost allocation and objective function</li> </ul> <p>User API: When you create <code>Effect</code> objects and set <code>effects_per_flow_hour</code>, these formulations govern how costs are calculated.</p>"},{"location":"user-guide/mathematical-notation/#modeling-patterns-advanced","title":"Modeling Patterns (Advanced)","text":"<p>Internal implementation details - These low-level patterns are used internally by Elements and Features. They are documented here for:</p> <ul> <li>Developers extending FlixOpt</li> <li>Advanced users debugging models or understanding solver behavior</li> <li>Researchers comparing mathematical formulations</li> </ul> <p>Normal users do not need to read this section - the patterns are automatically applied when you use Elements and Features:</p> <ul> <li>Bounds and States - Variable bounding patterns</li> <li>Duration Tracking - Consecutive time period tracking</li> <li>State Transitions - State change modeling</li> </ul>"},{"location":"user-guide/mathematical-notation/#quick-reference","title":"Quick Reference","text":""},{"location":"user-guide/mathematical-notation/#components-cross-reference","title":"Components Cross-Reference","text":"Concept Documentation Python Class Flow rate bounds Flow <code>Flow</code> Bus balance Bus <code>Bus</code> Storage balance Storage <code>Storage</code> Linear conversion LinearConverter <code>LinearConverter</code>"},{"location":"user-guide/mathematical-notation/#features-cross-reference","title":"Features Cross-Reference","text":"Concept Documentation Python Class Binary investment InvestParameters <code>InvestParameters</code> On/off operation OnOffParameters <code>OnOffParameters</code> Piecewise segments Piecewise <code>Piecewise</code>"},{"location":"user-guide/mathematical-notation/#modeling-patterns-cross-reference","title":"Modeling Patterns Cross-Reference","text":"Pattern Documentation Implementation Basic bounds bounds-and-states <code>BoundingPatterns.basic_bounds()</code> Bounds with state bounds-and-states <code>BoundingPatterns.bounds_with_state()</code> Scaled bounds bounds-and-states <code>BoundingPatterns.scaled_bounds()</code> Duration tracking duration-tracking <code>ModelingPrimitives.consecutive_duration_tracking()</code> State transitions state-transitions <code>BoundingPatterns.state_transition_bounds()</code>"},{"location":"user-guide/mathematical-notation/#python-class-lookup","title":"Python Class Lookup","text":"Class Documentation API Reference <code>Flow</code> Flow <code>Flow</code> <code>Bus</code> Bus <code>Bus</code> <code>Storage</code> Storage <code>Storage</code> <code>LinearConverter</code> LinearConverter <code>LinearConverter</code> <code>InvestParameters</code> InvestParameters <code>InvestParameters</code> <code>OnOffParameters</code> OnOffParameters <code>OnOffParameters</code> <code>Piecewise</code> Piecewise <code>Piecewise</code>"},{"location":"user-guide/mathematical-notation/dimensions/","title":"Dimensions","text":"<p>FlixOpt's <code>FlowSystem</code> supports multiple dimensions for modeling optimization problems. Understanding these dimensions is crucial for interpreting the mathematical formulations presented in this documentation.</p>"},{"location":"user-guide/mathematical-notation/dimensions/#the-three-dimensions","title":"The Three Dimensions","text":"<p>FlixOpt models can have up to three dimensions:</p> <ol> <li>Time (<code>time</code>) - MANDATORY<ul> <li>Represents the temporal evolution of the system</li> <li>Defined via <code>pd.DatetimeIndex</code></li> <li>Must contain at least 2 timesteps</li> <li>All optimization variables and constraints evolve over time</li> </ul> </li> <li>Period (<code>period</code>) - OPTIONAL<ul> <li>Represents independent planning periods (e.g., years 2020, 2021, 2022)</li> <li>Defined via <code>pd.Index</code> with integer values</li> <li>Used for multi-period optimization such as investment planning across years</li> <li>Each period is independent with its own time series</li> </ul> </li> <li>Scenario (<code>scenario</code>) - OPTIONAL<ul> <li>Represents alternative futures or uncertainty realizations (e.g., \"Base Case\", \"High Demand\")</li> <li>Defined via <code>pd.Index</code> with any labels</li> <li>Scenarios within the same period share the same time dimension</li> <li>Used for stochastic optimization or scenario comparison</li> </ul> </li> </ol>"},{"location":"user-guide/mathematical-notation/dimensions/#dimensional-structure","title":"Dimensional Structure","text":"<p>Coordinate System:</p> Python<pre><code>FlowSystemDimensions = Literal['time', 'period', 'scenario']\n\ncoords = {\n    'time': pd.DatetimeIndex,      # Always present\n    'period': pd.Index | None,      # Optional\n    'scenario': pd.Index | None     # Optional\n}\n</code></pre> <p>Example: Python<pre><code>import pandas as pd\nimport numpy as np\nimport flixopt as fx\n\ntimesteps = pd.date_range('2020-01-01', periods=24, freq='h')\nscenarios = pd.Index(['Base Case', 'High Demand'])\nperiods = pd.Index([2020, 2021, 2022])\n\nflow_system = fx.FlowSystem(\n    timesteps=timesteps,\n    periods=periods,\n    scenarios=scenarios,\n    weights=np.array([0.5, 0.5])  # Scenario weights\n)\n</code></pre></p> <p>This creates a system with: - 24 time steps per scenario per period - 2 scenarios with equal weights (0.5 each) - 3 periods (years) - Total decision space: 24 \u00d7 2 \u00d7 3 = 144 time-scenario-period combinations</p>"},{"location":"user-guide/mathematical-notation/dimensions/#independence-of-formulations","title":"Independence of Formulations","text":"<p>All mathematical formulations in this documentation are independent of whether periods or scenarios are present.</p> <p>The equations shown throughout this documentation (for Flow, Storage, Bus, etc.) are written with only the time index \\(\\text{t}_i\\). When periods and/or scenarios are added, the same equations apply - they are simply expanded to additional dimensions.</p>"},{"location":"user-guide/mathematical-notation/dimensions/#how-dimensions-expand-formulations","title":"How Dimensions Expand Formulations","text":"<p>Flow rate bounds (from Flow):</p> \\[ \\text{P} \\cdot \\text{p}^{\\text{L}}_{\\text{rel}}(\\text{t}_{i}) \\leq p(\\text{t}_{i}) \\leq \\text{P} \\cdot \\text{p}^{\\text{U}}_{\\text{rel}}(\\text{t}_{i}) \\] <p>This equation remains valid regardless of dimensions:</p> Dimensions Present Variable Indexing Interpretation Time only \\(p(\\text{t}_i)\\) Flow rate at time \\(\\text{t}_i\\) Time + Scenario \\(p(\\text{t}_i, s)\\) Flow rate at time \\(\\text{t}_i\\) in scenario \\(s\\) Time + Period \\(p(\\text{t}_i, y)\\) Flow rate at time \\(\\text{t}_i\\) in period \\(y\\) Time + Period + Scenario \\(p(\\text{t}_i, y, s)\\) Flow rate at time \\(\\text{t}_i\\) in period \\(y\\), scenario \\(s\\) <p>The mathematical relationship remains identical - only the indexing expands.</p>"},{"location":"user-guide/mathematical-notation/dimensions/#independence-between-scenarios-and-periods","title":"Independence Between Scenarios and Periods","text":"<p>There is no interconnection between scenarios and periods, except for shared investment decisions within a period.</p>"},{"location":"user-guide/mathematical-notation/dimensions/#scenario-independence","title":"Scenario Independence","text":"<p>Scenarios within a period are operationally independent:</p> <ul> <li>Each scenario has its own operational variables: \\(p(\\text{t}_i, s_1)\\) and \\(p(\\text{t}_i, s_2)\\) are independent</li> <li>Scenarios cannot exchange energy, information, or resources</li> <li>Storage states are separate: \\(c(\\text{t}_i, s_1) \\neq c(\\text{t}_i, s_2)\\)</li> <li>Binary states (on/off) are independent: \\(s(\\text{t}_i, s_1)\\) vs \\(s(\\text{t}_i, s_2)\\)</li> </ul> <p>Scenarios are connected only through the objective function via weights:</p> \\[ \\min \\quad \\sum_{s \\in \\mathcal{S}} w_s \\cdot \\text{Objective}_s \\] <p>Where: - \\(\\mathcal{S}\\) is the set of scenarios - \\(w_s\\) is the weight for scenario \\(s\\) - The optimizer balances performance across scenarios according to their weights</p>"},{"location":"user-guide/mathematical-notation/dimensions/#period-independence","title":"Period Independence","text":"<p>Periods are completely independent optimization problems:</p> <ul> <li>Each period has separate operational variables</li> <li>Each period has separate investment decisions</li> <li>No temporal coupling between periods (e.g., storage state at end of period \\(y\\) does not affect period \\(y+1\\))</li> <li>Periods cannot exchange resources or information</li> </ul> <p>Periods are connected only through weighted aggregation in the objective:</p> \\[ \\min \\quad \\sum_{y \\in \\mathcal{Y}} w_y \\cdot \\text{Objective}_y \\]"},{"location":"user-guide/mathematical-notation/dimensions/#shared-periodic-decisions-the-exception","title":"Shared Periodic Decisions: The Exception","text":"<p>Investment decisions (sizes) can be shared across all scenarios:</p> <p>By default, sizes (e.g., Storage capacity, Thermal power, ...) are scenario-independent but flow_rates are scenario-specific.</p> <p>Example - Flow with investment:</p> \\[ v_\\text{invest}(y) = s_\\text{invest}(y) \\cdot \\text{size}_\\text{fixed} \\quad \\text{(one decision per period)} \\] \\[ p(\\text{t}_i, y, s) \\leq v_\\text{invest}(y) \\cdot \\text{rel}_\\text{upper} \\quad \\forall s \\in \\mathcal{S} \\quad \\text{(same capacity for all scenarios)} \\] <p>Interpretation: - \"We decide once in period \\(y\\) how much capacity to build\" (periodic decision) - \"This capacity is then operated differently in each scenario \\(s\\) within period \\(y\\)\" (temporal decisions) - \"Periodic effects (investment) are incurred once per period, temporal effects (operational) are weighted across scenarios\"</p> <p>This reflects real-world investment under uncertainty: you build capacity once (periodic/investment decision), but it operates under different conditions (temporal/operational decisions per scenario).</p> <p>Mathematical Flexibility:</p> <p>Variables can be either scenario-independent or scenario-specific:</p> Variable Type Scenario-Independent Scenario-Specific Sizes (e.g., \\(\\text{P}\\)) \\(\\text{P}(y)\\) - Single value per period \\(\\text{P}(y, s)\\) - Different per scenario Flow rates (e.g., \\(p(\\text{t}_i)\\)) \\(p(\\text{t}_i, y)\\) - Same across scenarios \\(p(\\text{t}_i, y, s)\\) - Different per scenario <p>Use Cases:</p> <p>Investment problems (with InvestParameters): - Sizes shared (default): Investment under uncertainty - build capacity that performs well across all scenarios - Sizes vary: Scenario-specific capacity planning where different investments can be made for each future - Selected sizes shared: Mix of shared critical infrastructure and scenario-specific optional/flexible capacity</p> <p>Dispatch problems (fixed sizes, no investments): - Flow rates shared: Robust dispatch - find a single operational strategy that works across all forecast scenarios (e.g., day-ahead unit commitment under demand/weather uncertainty) - Flow rates vary (default): Scenario-adaptive dispatch - optimize operations for each scenario's specific conditions (demand, weather, prices)</p> <p>For implementation details on controlling scenario independence, see the <code>FlowSystem</code> API reference.</p>"},{"location":"user-guide/mathematical-notation/dimensions/#dimensional-impact-on-objective-function","title":"Dimensional Impact on Objective Function","text":"<p>The objective function aggregates effects across all dimensions with weights:</p>"},{"location":"user-guide/mathematical-notation/dimensions/#time-only","title":"Time Only","text":"\\[ \\min \\quad \\sum_{\\text{t}_i \\in \\mathcal{T}} \\sum_{e \\in \\mathcal{E}} s_{e}(\\text{t}_i) \\]"},{"location":"user-guide/mathematical-notation/dimensions/#time-scenario","title":"Time + Scenario","text":"\\[ \\min \\quad \\sum_{s \\in \\mathcal{S}} w_s \\cdot \\left( \\sum_{\\text{t}_i \\in \\mathcal{T}} \\sum_{e \\in \\mathcal{E}} s_{e}(\\text{t}_i, s) \\right) \\]"},{"location":"user-guide/mathematical-notation/dimensions/#time-period","title":"Time + Period","text":"\\[ \\min \\quad \\sum_{y \\in \\mathcal{Y}} w_y \\cdot \\left( \\sum_{\\text{t}_i \\in \\mathcal{T}} \\sum_{e \\in \\mathcal{E}} s_{e}(\\text{t}_i, y) \\right) \\]"},{"location":"user-guide/mathematical-notation/dimensions/#time-period-scenario-full-multi-dimensional","title":"Time + Period + Scenario (Full Multi-Dimensional)","text":"\\[ \\min \\quad \\sum_{y \\in \\mathcal{Y}} \\sum_{s \\in \\mathcal{S}} w_{y,s} \\cdot \\left( \\sum_{\\text{t}_i \\in \\mathcal{T}} \\sum_{e \\in \\mathcal{E}} s_{e}(\\text{t}_i, y, s) \\right) \\] <p>Where: - \\(\\mathcal{T}\\) is the set of time steps - \\(\\mathcal{E}\\) is the set of effects - \\(\\mathcal{S}\\) is the set of scenarios - \\(\\mathcal{Y}\\) is the set of periods - \\(s_{e}(\\cdots)\\) are the effect contributions (costs, emissions, etc.) - \\(w_s, w_y, w_{y,s}\\) are the dimension weights</p> <p>See Effects, Penalty &amp; Objective for complete formulations including: - How temporal and periodic effects expand with dimensions - Detailed objective function for each dimensional case - Periodic (investment) vs temporal (operational) effect handling</p>"},{"location":"user-guide/mathematical-notation/dimensions/#weights","title":"Weights","text":"<p>Weights determine the relative importance of scenarios and periods in the objective function.</p> <p>Specification:</p> Python<pre><code>flow_system = fx.FlowSystem(\n    timesteps=timesteps,\n    periods=periods,\n    scenarios=scenarios,\n    weights=weights  # Shape depends on dimensions\n)\n</code></pre> <p>Weight Dimensions:</p> Dimensions Present Weight Shape Example Meaning Time + Scenario 1D array of length <code>n_scenarios</code> <code>[0.3, 0.7]</code> Scenario probabilities Time + Period 1D array of length <code>n_periods</code> <code>[0.5, 0.3, 0.2]</code> Period importance Time + Period + Scenario 2D array <code>(n_periods, n_scenarios)</code> <code>[[0.25, 0.25], [0.25, 0.25]]</code> Combined weights <p>Default: If not specified, all scenarios/periods have equal weight (normalized to sum to 1).</p> <p>Normalization: Set <code>normalize_weights=True</code> in <code>Calculation</code> to automatically normalize weights to sum to 1.</p>"},{"location":"user-guide/mathematical-notation/dimensions/#summary-table","title":"Summary Table","text":"Dimension Required? Independence Typical Use Case time \u2705 Yes Variables evolve over time via constraints (e.g., storage balance) All optimization problems scenario \u274c No Fully independent operations; shared investments within period Uncertainty modeling, risk assessment period \u274c No Fully independent; no coupling between periods Multi-year planning, long-term investment <p>Key Principle: All constraints and formulations operate within each (period, scenario) combination independently. Only the objective function couples them via weighted aggregation.</p>"},{"location":"user-guide/mathematical-notation/dimensions/#see-also","title":"See Also","text":"<ul> <li>Effects, Penalty &amp; Objective - How dimensions affect the objective function</li> <li>InvestParameters - Investment decisions across scenarios</li> <li>FlowSystem API - Creating multi-dimensional systems</li> </ul>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/","title":"Effects, Penalty &amp; Objective","text":""},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#effects","title":"Effects","text":"<p><code>Effects</code> are used to quantify system-wide impacts like costs, emissions, or resource consumption. These arise from shares contributed by Elements such as Flows, Storage, and other components.</p> <p>Example:</p> <p><code>Flows</code> have an attribute <code>effects_per_flow_hour</code> that defines the effect contribution per flow-hour: - Costs (\u20ac/kWh) - Emissions (kg CO\u2082/kWh) - Primary energy consumption (kWh_primary/kWh)</p> <p>Effects are categorized into two domains:</p> <ol> <li>Temporal effects - Time-dependent contributions (e.g., operational costs, hourly emissions)</li> <li>Periodic effects - Time-independent contributions (e.g., investment costs, fixed annual fees)</li> </ol>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#multi-dimensional-effects","title":"Multi-Dimensional Effects","text":"<p>The formulations below are written with time index \\(\\text{t}_i\\) only, but automatically expand when periods and/or scenarios are present.</p> <p>When the FlowSystem has additional dimensions (see Dimensions):</p> <ul> <li>Temporal effects are indexed by all present dimensions: \\(E_{e,\\text{temp}}(\\text{t}_i, y, s)\\)</li> <li>Periodic effects are indexed by period only (scenario-independent within a period): \\(E_{e,\\text{per}}(y)\\)</li> <li>Effects are aggregated with dimension weights in the objective function</li> </ul> <p>For complete details on how dimensions affect effects and the objective, see Dimensions.</p>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#effect-formulation","title":"Effect Formulation","text":""},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#shares-from-elements","title":"Shares from Elements","text":"<p>Each element \\(l\\) contributes shares to effect \\(e\\) in both temporal and periodic domains:</p> <p>Periodic shares (time-independent): $$ \\label{eq:Share_periodic} s_{l \\rightarrow e, \\text{per}} = \\sum_{v \\in \\mathcal{V}{l, \\text{per}}} v \\cdot \\text{a} $$</p> <p>Temporal shares (time-dependent): $$ \\label{eq:Share_temporal} s_{l \\rightarrow e, \\text{temp}}(\\text{t}i) = \\sum{l,\\text{temp}}} v(\\text{t}_i) \\cdot \\text{a}_i) $$}(\\text{t</p> <p>Where:</p> <ul> <li>\\(\\text{t}_i\\) is the time step</li> <li>\\(\\mathcal{V}_l\\) is the set of all optimization variables of element \\(l\\)</li> <li>\\(\\mathcal{V}_{l, \\text{per}}\\) is the subset of periodic (investment-related) variables</li> <li>\\(\\mathcal{V}_{l, \\text{temp}}\\) is the subset of temporal (operational) variables</li> <li>\\(v\\) is an optimization variable</li> <li>\\(v(\\text{t}_i)\\) is the variable value at timestep \\(\\text{t}_i\\)</li> <li>\\(\\text{a}_{v \\rightarrow e}\\) is the effect factor (e.g., \u20ac/kW for investment, \u20ac/kWh for operation)</li> <li>\\(s_{l \\rightarrow e, \\text{per}}\\) is the periodic share of element \\(l\\) to effect \\(e\\)</li> <li>\\(s_{l \\rightarrow e, \\text{temp}}(\\text{t}_i)\\) is the temporal share of element \\(l\\) to effect \\(e\\)</li> </ul> <p>Examples: - Periodic share: Investment cost = \\(\\text{size} \\cdot \\text{specific\\_cost}\\) (\u20ac/kW) - Temporal share: Operational cost = \\(\\text{flow\\_rate}(\\text{t}_i) \\cdot \\text{price}(\\text{t}_i)\\) (\u20ac/kWh)</p>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#cross-effect-contributions","title":"Cross-Effect Contributions","text":"<p>Effects can contribute shares to other effects, enabling relationships like carbon pricing or resource accounting.</p> <p>An effect \\(x\\) can contribute to another effect \\(e \\in \\mathcal{E}\\backslash x\\) via conversion factors:</p> <p>Example: CO\u2082 emissions (kg) \u2192 Monetary costs (\u20ac) - Effect \\(x\\): \"CO\u2082 emissions\" (unit: kg) - Effect \\(e\\): \"costs\" (unit: \u20ac) - Factor \\(\\text{r}_{x \\rightarrow e}\\): CO\u2082 price (\u20ac/kg)</p> <p>Note: Circular references must be avoided.</p>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#total-effect-calculation","title":"Total Effect Calculation","text":"<p>Periodic effects aggregate element shares and cross-effect contributions:</p> \\[ \\label{eq:Effect_periodic} E_{e, \\text{per}} = \\sum_{l \\in \\mathcal{L}} s_{l \\rightarrow e,\\text{per}} + \\sum_{x \\in \\mathcal{E}\\backslash e} E_{x, \\text{per}}  \\cdot \\text{r}_{x \\rightarrow  e,\\text{per}} \\] <p>Temporal effects at each timestep:</p> \\[ \\label{eq:Effect_temporal} E_{e, \\text{temp}}(\\text{t}_{i}) = \\sum_{l \\in \\mathcal{L}} s_{l \\rightarrow e, \\text{temp}}(\\text{t}_i) + \\sum_{x \\in \\mathcal{E}\\backslash e} E_{x, \\text{temp}}(\\text{t}_i) \\cdot \\text{r}_{x \\rightarrow {e},\\text{temp}}(\\text{t}_i) \\] <p>Total temporal effects (sum over all timesteps):</p> \\[\\label{eq:Effect_temporal_total} E_{e,\\text{temp},\\text{tot}} = \\sum_{i=1}^n  E_{e,\\text{temp}}(\\text{t}_{i}) \\] <p>Total effect (combining both domains):</p> \\[ \\label{eq:Effect_Total} E_{e} = E_{e,\\text{per}} + E_{e,\\text{temp},\\text{tot}} \\] <p>Where:</p> <ul> <li>\\(\\mathcal{L}\\) is the set of all elements in the FlowSystem</li> <li>\\(\\mathcal{E}\\) is the set of all effects</li> <li>\\(\\text{r}_{x \\rightarrow e, \\text{per}}\\) is the periodic conversion factor from effect \\(x\\) to effect \\(e\\)</li> <li>\\(\\text{r}_{x \\rightarrow e, \\text{temp}}(\\text{t}_i)\\) is the temporal conversion factor</li> </ul>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#constraining-effects","title":"Constraining Effects","text":"<p>Effects can be bounded to enforce limits on costs, emissions, or other impacts:</p> <p>Total bounds (apply to \\(E_{e,\\text{per}}\\), \\(E_{e,\\text{temp},\\text{tot}}\\), or \\(E_e\\)):</p> \\[ \\label{eq:Bounds_Total} E^\\text{L} \\leq E \\leq E^\\text{U} \\] <p>Temporal bounds per timestep:</p> \\[ \\label{eq:Bounds_Timestep} E_{e,\\text{temp}}^\\text{L}(\\text{t}_i) \\leq E_{e,\\text{temp}}(\\text{t}_i) \\leq E_{e,\\text{temp}}^\\text{U}(\\text{t}_i) \\] <p>Implementation: See <code>Effect</code> parameters: - <code>minimum_temporal</code>, <code>maximum_temporal</code> - Total temporal bounds - <code>minimum_per_hour</code>, <code>maximum_per_hour</code> - Hourly temporal bounds - <code>minimum_periodic</code>, <code>maximum_periodic</code> - Periodic bounds - <code>minimum_total</code>, <code>maximum_total</code> - Combined total bounds</p>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#penalty","title":"Penalty","text":"<p>In addition to user-defined Effects, every FlixOpt model includes a Penalty term \\(\\Phi\\) to: - Prevent infeasible problems - Simplify troubleshooting by allowing constraint violations with high cost</p> <p>Penalty shares originate from elements, similar to effect shares:</p> \\[ \\label{eq:Penalty} \\Phi = \\sum_{l \\in \\mathcal{L}} \\left( s_{l \\rightarrow \\Phi}  +\\sum_{\\text{t}_i \\in \\mathcal{T}} s_{l \\rightarrow \\Phi}(\\text{t}_{i}) \\right) \\] <p>Where:</p> <ul> <li>\\(\\mathcal{L}\\) is the set of all elements</li> <li>\\(\\mathcal{T}\\) is the set of all timesteps</li> <li>\\(s_{l \\rightarrow \\Phi}\\) is the penalty share from element \\(l\\)</li> </ul> <p>Current usage: Penalties primarily occur in Buses via the <code>excess_penalty_per_flow_hour</code> parameter, which allows nodal imbalances at a high cost.</p>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#objective-function","title":"Objective Function","text":"<p>The optimization objective minimizes the chosen effect plus any penalties:</p> \\[ \\label{eq:Objective} \\min \\left( E_{\\Omega} + \\Phi \\right) \\] <p>Where:</p> <ul> <li>\\(E_{\\Omega}\\) is the chosen objective effect (see \\(\\eqref{eq:Effect_Total}\\))</li> <li>\\(\\Phi\\) is the penalty term</li> </ul> <p>One effect must be designated as the objective via <code>is_objective=True</code>.</p>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#multi-criteria-optimization","title":"Multi-Criteria Optimization","text":"<p>This formulation supports multiple optimization approaches:</p> <p>1. Weighted Sum Method - The objective effect can incorporate other effects via cross-effect factors - Example: Minimize costs while including carbon pricing: \\(\\text{CO}_2 \\rightarrow \\text{costs}\\)</p> <p>2. \u03b5-Constraint Method - Optimize one effect while constraining others - Example: Minimize costs subject to \\(\\text{CO}_2 \\leq 1000\\) kg</p>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#objective-with-multiple-dimensions","title":"Objective with Multiple Dimensions","text":"<p>When the FlowSystem includes periods and/or scenarios (see Dimensions), the objective aggregates effects across all dimensions using weights.</p>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#time-only-base-case","title":"Time Only (Base Case)","text":"\\[ \\min \\quad E_{\\Omega} + \\Phi = \\sum_{\\text{t}_i \\in \\mathcal{T}} E_{\\Omega,\\text{temp}}(\\text{t}_i) + E_{\\Omega,\\text{per}} + \\Phi \\] <p>Where: - Temporal effects sum over time: \\(\\sum_{\\text{t}_i} E_{\\Omega,\\text{temp}}(\\text{t}_i)\\) - Periodic effects are constant: \\(E_{\\Omega,\\text{per}}\\) - Penalty sums over time: \\(\\Phi = \\sum_{\\text{t}_i} \\Phi(\\text{t}_i)\\)</p>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#time-scenario","title":"Time + Scenario","text":"\\[ \\min \\quad \\sum_{s \\in \\mathcal{S}} w_s \\cdot \\left( E_{\\Omega}(s) + \\Phi(s) \\right) \\] <p>Where: - \\(\\mathcal{S}\\) is the set of scenarios - \\(w_s\\) is the weight for scenario \\(s\\) (typically scenario probability) - Periodic effects are shared across scenarios: \\(E_{\\Omega,\\text{per}}\\) (same for all \\(s\\)) - Temporal effects are scenario-specific: \\(E_{\\Omega,\\text{temp}}(s) = \\sum_{\\text{t}_i} E_{\\Omega,\\text{temp}}(\\text{t}_i, s)\\) - Penalties are scenario-specific: \\(\\Phi(s) = \\sum_{\\text{t}_i} \\Phi(\\text{t}_i, s)\\)</p> <p>Interpretation: - Investment decisions (periodic) made once, used across all scenarios - Operations (temporal) differ by scenario - Objective balances expected value across scenarios</p>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#time-period","title":"Time + Period","text":"\\[ \\min \\quad \\sum_{y \\in \\mathcal{Y}} w_y \\cdot \\left( E_{\\Omega}(y) + \\Phi(y) \\right) \\] <p>Where: - \\(\\mathcal{Y}\\) is the set of periods (e.g., years) - \\(w_y\\) is the weight for period \\(y\\) (typically annual discount factor) - Each period \\(y\\) has independent periodic and temporal effects - Each period \\(y\\) has independent investment and operational decisions</p>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#time-period-scenario-full-multi-dimensional","title":"Time + Period + Scenario (Full Multi-Dimensional)","text":"\\[ \\min \\quad \\sum_{y \\in \\mathcal{Y}} \\left[ w_y \\cdot E_{\\Omega,\\text{per}}(y) + \\sum_{s \\in \\mathcal{S}} w_{y,s} \\cdot \\left( E_{\\Omega,\\text{temp}}(y,s) + \\Phi(y,s) \\right) \\right] \\] <p>Where: - \\(\\mathcal{S}\\) is the set of scenarios - \\(\\mathcal{Y}\\) is the set of periods - \\(w_y\\) is the period weight (for periodic effects) - \\(w_{y,s}\\) is the combined period-scenario weight (for temporal effects) - Periodic effects \\(E_{\\Omega,\\text{per}}(y)\\) are period-specific but scenario-independent - Temporal effects \\(E_{\\Omega,\\text{temp}}(y,s) = \\sum_{\\text{t}_i} E_{\\Omega,\\text{temp}}(\\text{t}_i, y, s)\\) are fully indexed - Penalties \\(\\Phi(y,s)\\) are fully indexed</p> <p>Key Principle: - Scenarios and periods are operationally independent (no energy/resource exchange) - Coupled only through the weighted objective function - Periodic effects within a period are shared across all scenarios (investment made once per period) - Temporal effects are independent per scenario (different operations under different conditions)</p>"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#summary","title":"Summary","text":"Concept Formulation Time Dependency Dimension Indexing Temporal share \\(s_{l \\rightarrow e, \\text{temp}}(\\text{t}_i)\\) Time-dependent \\((t, y, s)\\) when present Periodic share \\(s_{l \\rightarrow e, \\text{per}}\\) Time-independent \\((y)\\) when periods present Total temporal effect \\(E_{e,\\text{temp},\\text{tot}} = \\sum_{\\text{t}_i} E_{e,\\text{temp}}(\\text{t}_i)\\) Sum over time Depends on dimensions Total periodic effect \\(E_{e,\\text{per}}\\) Constant \\((y)\\) when periods present Total effect \\(E_e = E_{e,\\text{per}} + E_{e,\\text{temp},\\text{tot}}\\) Combined Depends on dimensions Objective \\(\\min(E_{\\Omega} + \\Phi)\\) With weights when multi-dimensional See formulations above"},{"location":"user-guide/mathematical-notation/effects-penalty-objective/#see-also","title":"See Also","text":"<ul> <li>Dimensions - Complete explanation of multi-dimensional modeling</li> <li>Flow - Temporal effect contributions via <code>effects_per_flow_hour</code></li> <li>InvestParameters - Periodic effect contributions via investment</li> <li>Effect API - Implementation details and parameters</li> </ul>"},{"location":"user-guide/mathematical-notation/others/","title":"Work in Progress","text":"<p>This is a work in progress.</p>"},{"location":"user-guide/mathematical-notation/elements/Bus/","title":"Bus","text":"<p>A Bus is a simple nodal balance between its incoming and outgoing flow rates.</p> \\[ \\label{eq:bus_balance}   \\sum_{f_\\text{in} \\in \\mathcal{F}_\\text{in}} p_{f_\\text{in}}(\\text{t}_i) =   \\sum_{f_\\text{out} \\in \\mathcal{F}_\\text{out}} p_{f_\\text{out}}(\\text{t}_i) \\] <p>Optionally, a Bus can have a <code>excess_penalty_per_flow_hour</code> parameter, which allows to penaltize the balance for missing or excess flow-rates. This is usefull as it handles a possible ifeasiblity gently.</p> <p>This changes the balance to</p> \\[ \\label{eq:bus_balance-excess}   \\sum_{f_\\text{in} \\in \\mathcal{F}_\\text{in}} p_{f_ \\text{in}}(\\text{t}_i) + \\phi_\\text{in}(\\text{t}_i) =   \\sum_{f_\\text{out} \\in \\mathcal{F}_\\text{out}} p_{f_\\text{out}}(\\text{t}_i) + \\phi_\\text{out}(\\text{t}_i) \\] <p>The penalty term is defined as</p> \\[ \\label{eq:bus_penalty}   s_{b \\rightarrow \\Phi}(\\text{t}_i) =       \\text a_{b \\rightarrow \\Phi}(\\text{t}_i) \\cdot \\Delta \\text{t}_i       \\cdot [ \\phi_\\text{in}(\\text{t}_i) + \\phi_\\text{out}(\\text{t}_i) ] \\] <p>With:</p> <ul> <li>\\(\\mathcal{F}_\\text{in}\\) and \\(\\mathcal{F}_\\text{out}\\) being the set of all incoming and outgoing flows</li> <li>\\(p_{f_\\text{in}}(\\text{t}_i)\\) and \\(p_{f_\\text{out}}(\\text{t}_i)\\) being the flow-rate at time \\(\\text{t}_i\\) for flow \\(f_\\text{in}\\) and \\(f_\\text{out}\\), respectively</li> <li>\\(\\phi_\\text{in}(\\text{t}_i)\\) and \\(\\phi_\\text{out}(\\text{t}_i)\\) being the missing or excess flow-rate at time \\(\\text{t}_i\\), respectively</li> <li>\\(\\text{t}_i\\) being the time step</li> <li>\\(s_{b \\rightarrow \\Phi}(\\text{t}_i)\\) being the penalty term</li> <li>\\(\\text a_{b \\rightarrow \\Phi}(\\text{t}_i)\\) being the penalty coefficient (<code>excess_penalty_per_flow_hour</code>)</li> </ul>"},{"location":"user-guide/mathematical-notation/elements/Bus/#implementation","title":"Implementation","text":"<p>Python Class: <code>Bus</code></p> <p>See the API documentation for implementation details and usage examples.</p>"},{"location":"user-guide/mathematical-notation/elements/Bus/#see-also","title":"See Also","text":"<ul> <li>Flow - Definition of flow rates in the balance</li> <li>Effects, Penalty &amp; Objective - How penalties are included in the objective function</li> <li>Modeling Patterns - Mathematical building blocks</li> </ul>"},{"location":"user-guide/mathematical-notation/elements/Flow/","title":"Flow","text":"<p>The flow_rate is the main optimization variable of the Flow. It's limited by the size of the Flow and relative bounds \\eqref{eq:flow_rate}.</p> \\[ \\label{eq:flow_rate}     \\text P \\cdot \\text p^{\\text{L}}_{\\text{rel}}(\\text{t}_{i})     \\leq p(\\text{t}_{i}) \\leq     \\text P \\cdot \\text p^{\\text{U}}_{\\text{rel}}(\\text{t}_{i}) \\] <p>With:</p> <ul> <li>\\(\\text P\\) being the size of the Flow</li> <li>\\(p(\\text{t}_{i})\\) being the flow-rate at time \\(\\text{t}_{i}\\)</li> <li>\\(\\text p^{\\text{L}}_{\\text{rel}}(\\text{t}_{i})\\) being the relative lower bound (typically 0)</li> <li>\\(\\text p^{\\text{U}}_{\\text{rel}}(\\text{t}_{i})\\) being the relative upper bound (typically 1)</li> </ul> <p>With \\(\\text p^{\\text{L}}_{\\text{rel}}(\\text{t}_{i}) = 0\\) and \\(\\text p^{\\text{U}}_{\\text{rel}}(\\text{t}_{i}) = 1\\), equation \\eqref{eq:flow_rate} simplifies to</p> \\[     0 \\leq p(\\text{t}_{i}) \\leq \\text P \\] <p>This mathematical formulation can be extended by using OnOffParameters to define the on/off state of the Flow, or by using InvestParameters to change the size of the Flow from a constant to an optimization variable.</p>"},{"location":"user-guide/mathematical-notation/elements/Flow/#mathematical-patterns-used","title":"Mathematical Patterns Used","text":"<p>Flow formulation uses the following modeling patterns:</p> <ul> <li>Scaled Bounds - Basic flow rate bounds (equation \\(\\eqref{eq:flow_rate}\\))</li> <li>Scaled Bounds with State - When combined with OnOffParameters</li> <li>Bounds with State - Investment decisions with InvestParameters</li> </ul>"},{"location":"user-guide/mathematical-notation/elements/Flow/#implementation","title":"Implementation","text":"<p>Python Class: <code>Flow</code></p> <p>Key Parameters: - <code>size</code>: Flow size \\(\\text{P}\\) (can be fixed or variable with InvestParameters) - <code>relative_minimum</code>, <code>relative_maximum</code>: Relative bounds \\(\\text{p}^{\\text{L}}_{\\text{rel}}, \\text{p}^{\\text{U}}_{\\text{rel}}\\) - <code>effects_per_flow_hour</code>: Operational effects (costs, emissions, etc.) - <code>invest_parameters</code>: Optional investment modeling (see InvestParameters) - <code>on_off_parameters</code>: Optional on/off operation (see OnOffParameters)</p> <p>See the <code>Flow</code> API documentation for complete parameter list and usage examples.</p>"},{"location":"user-guide/mathematical-notation/elements/Flow/#see-also","title":"See Also","text":"<ul> <li>OnOffParameters - Binary on/off operation</li> <li>InvestParameters - Variable flow sizing</li> <li>Bus - Flow balance constraints</li> <li>LinearConverter - Flow ratio constraints</li> <li>Storage - Flow integration over time</li> <li>Modeling Patterns - Mathematical building blocks</li> </ul>"},{"location":"user-guide/mathematical-notation/elements/LinearConverter/","title":"LinearConverter","text":"<p><code>LinearConverters</code> define a ratio between incoming and outgoing Flows.</p> \\[ \\label{eq:Linear-Transformer-Ratio}     \\sum_{f_{\\text{in}} \\in \\mathcal F_{in}} \\text a_{f_{\\text{in}}}(\\text{t}_i) \\cdot p_{f_\\text{in}}(\\text{t}_i) = \\sum_{f_{\\text{out}} \\in \\mathcal F_{out}}  \\text b_{f_\\text{out}}(\\text{t}_i) \\cdot p_{f_\\text{out}}(\\text{t}_i) \\] <p>With:</p> <ul> <li>\\(\\mathcal F_{in}\\) and \\(\\mathcal F_{out}\\) being the set of all incoming and outgoing flows</li> <li>\\(p_{f_\\text{in}}(\\text{t}_i)\\) and \\(p_{f_\\text{out}}(\\text{t}_i)\\) being the flow-rate at time \\(\\text{t}_i\\) for flow \\(f_\\text{in}\\) and \\(f_\\text{out}\\), respectively</li> <li>\\(\\text a_{f_\\text{in}}(\\text{t}_i)\\) and \\(\\text b_{f_\\text{out}}(\\text{t}_i)\\) being the ratio of the flow-rate at time \\(\\text{t}_i\\) for flow \\(f_\\text{in}\\) and \\(f_\\text{out}\\), respectively</li> </ul> <p>With one incoming Flow and one outgoing Flow, this can be simplified to:</p> \\[ \\label{eq:Linear-Transformer-Ratio-simple}     \\text a(\\text{t}_i) \\cdot p_{f_\\text{in}}(\\text{t}_i) = p_{f_\\text{out}}(\\text{t}_i) \\] <p>where \\(\\text a\\) can be interpreted as the conversion efficiency of the LinearConverter.</p>"},{"location":"user-guide/mathematical-notation/elements/LinearConverter/#piecewise-conversion-factors","title":"Piecewise Conversion factors","text":"<p>The conversion efficiency can be defined as a piecewise linear approximation. See Piecewise for more details.</p>"},{"location":"user-guide/mathematical-notation/elements/LinearConverter/#implementation","title":"Implementation","text":"<p>Python Class: <code>LinearConverter</code></p> <p>Specialized Linear Converters:</p> <p>FlixOpt provides specialized linear converter classes for common applications:</p> <ul> <li><code>HeatPump</code> - Coefficient of Performance (COP) based conversion</li> <li><code>Power2Heat</code> - Electric heating with efficiency \u2264 1</li> <li><code>CHP</code> - Combined heat and power generation</li> <li><code>Boiler</code> - Fuel to heat conversion</li> </ul> <p>These classes handle the mathematical formulation automatically based on physical relationships.</p> <p>See the API documentation for implementation details and usage examples.</p>"},{"location":"user-guide/mathematical-notation/elements/LinearConverter/#see-also","title":"See Also","text":"<ul> <li>Flow - Definition of flow rates</li> <li>Piecewise - Non-linear conversion efficiency modeling</li> <li>InvestParameters - Variable converter sizing</li> <li>Modeling Patterns - Mathematical building blocks</li> </ul>"},{"location":"user-guide/mathematical-notation/elements/Storage/","title":"Storages","text":"<p>Storages have one incoming and one outgoing Flow with a charging and discharging efficiency. A storage has a state of charge \\(c(\\text{t}_i)\\) which is limited by its <code>size</code> \\(\\text C\\) and relative bounds \\(\\eqref{eq:Storage_Bounds}\\).</p> \\[ \\label{eq:Storage_Bounds}     \\text C \\cdot \\text c^{\\text{L}}_{\\text{rel}}(\\text t_{i})     \\leq c(\\text{t}_i) \\leq     \\text C \\cdot \\text c^{\\text{U}}_{\\text{rel}}(\\text t_{i}) \\] <p>Where:</p> <ul> <li>\\(\\text C\\) is the size of the storage</li> <li>\\(c(\\text{t}_i)\\) is the state of charge at time \\(\\text{t}_i\\)</li> <li>\\(\\text c^{\\text{L}}_{\\text{rel}}(\\text t_{i})\\) is the relative lower bound (typically 0)</li> <li>\\(\\text c^{\\text{U}}_{\\text{rel}}(\\text t_{i})\\) is the relative upper bound (typically 1)</li> </ul> <p>With \\(\\text c^{\\text{L}}_{\\text{rel}}(\\text t_{i}) = 0\\) and \\(\\text c^{\\text{U}}_{\\text{rel}}(\\text t_{i}) = 1\\), Equation \\(\\eqref{eq:Storage_Bounds}\\) simplifies to</p> \\[ 0 \\leq c(\\text t_{i}) \\leq \\text C \\] <p>The state of charge \\(c(\\text{t}_i)\\) decreases by a fraction of the prior state of charge. The belonging parameter $ \\dot{ \\text c}_\\text{rel, loss}(\\text{t}_i)$ expresses the \"loss fraction per hour\". The storage balance from  \\(\\text{t}_i\\) to \\(\\text t_{i+1}\\) is</p> \\[ \\begin{align*}     c(\\text{t}_{i+1}) &amp;= c(\\text{t}_{i}) \\cdot (1-\\dot{\\text{c}}_\\text{rel,loss}(\\text{t}_i))^{\\Delta \\text{t}_{i}} \\\\     &amp;\\quad + p_{f_\\text{in}}(\\text{t}_i) \\cdot \\Delta \\text{t}_i \\cdot \\eta_\\text{in}(\\text{t}_i) \\\\     &amp;\\quad - p_{f_\\text{out}}(\\text{t}_i) \\cdot \\Delta \\text{t}_i \\cdot \\eta_\\text{out}(\\text{t}_i)     \\tag{3} \\end{align*} \\] <p>Where:</p> <ul> <li>\\(c(\\text{t}_{i+1})\\) is the state of charge at time \\(\\text{t}_{i+1}\\)</li> <li>\\(c(\\text{t}_{i})\\) is the state of charge at time \\(\\text{t}_{i}\\)</li> <li>\\(\\dot{\\text{c}}_\\text{rel,loss}(\\text{t}_i)\\) is the relative loss rate (self-discharge) per hour</li> <li>\\(\\Delta \\text{t}_{i}\\) is the time step duration in hours</li> <li>\\(p_{f_\\text{in}}(\\text{t}_i)\\) is the input flow rate at time \\(\\text{t}_i\\)</li> <li>\\(\\eta_\\text{in}(\\text{t}_i)\\) is the charging efficiency at time \\(\\text{t}_i\\)</li> <li>\\(p_{f_\\text{out}}(\\text{t}_i)\\) is the output flow rate at time \\(\\text{t}_i\\)</li> <li>\\(\\eta_\\text{out}(\\text{t}_i)\\) is the discharging efficiency at time \\(\\text{t}_i\\)</li> </ul>"},{"location":"user-guide/mathematical-notation/elements/Storage/#mathematical-patterns-used","title":"Mathematical Patterns Used","text":"<p>Storage formulation uses the following modeling patterns:</p> <ul> <li>Basic Bounds - For charge state bounds (equation \\(\\eqref{eq:Storage_Bounds}\\))</li> <li>Scaled Bounds - For flow rate bounds relative to storage size</li> </ul> <p>When combined with investment parameters, storage can use: - Bounds with State - Investment decisions (see InvestParameters)</p>"},{"location":"user-guide/mathematical-notation/elements/Storage/#implementation","title":"Implementation","text":"<p>Python Class: <code>Storage</code></p> <p>Key Parameters: - <code>capacity_in_flow_hours</code>: Storage capacity \\(\\text{C}\\) - <code>relative_loss_per_hour</code>: Self-discharge rate \\(\\dot{\\text{c}}_\\text{rel,loss}\\) - <code>initial_charge_state</code>: Initial charge \\(c(\\text{t}_0)\\) - <code>minimal_final_charge_state</code>, <code>maximal_final_charge_state</code>: Final charge bounds \\(c(\\text{t}_\\text{end})\\) (optional) - <code>eta_charge</code>, <code>eta_discharge</code>: Charging/discharging efficiencies \\(\\eta_\\text{in}, \\eta_\\text{out}\\)</p> <p>See the <code>Storage</code> API documentation for complete parameter list and usage examples.</p>"},{"location":"user-guide/mathematical-notation/elements/Storage/#see-also","title":"See Also","text":"<ul> <li>Flow - Input and output flow definitions</li> <li>InvestParameters - Variable storage sizing</li> <li>Modeling Patterns - Mathematical building blocks</li> </ul>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/","title":"InvestParameters","text":"<p><code>InvestParameters</code> model investment decisions in optimization problems, enabling both binary (invest/don't invest) and continuous sizing choices with comprehensive cost modeling.</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#investment-decision-types","title":"Investment Decision Types","text":"<p>FlixOpt supports two main types of investment decisions:</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#binary-investment","title":"Binary Investment","text":"<p>Fixed-size investment creating a yes/no decision (e.g., install a 100 kW generator):</p> \\[\\label{eq:invest_binary} v_\\text{invest} = s_\\text{invest} \\cdot \\text{size}_\\text{fixed} \\] <p>With: - \\(v_\\text{invest}\\) being the resulting investment size - \\(s_\\text{invest} \\in \\{0, 1\\}\\) being the binary investment decision - \\(\\text{size}_\\text{fixed}\\) being the predefined component size</p> <p>Behavior: - \\(s_\\text{invest} = 0\\): no investment (\\(v_\\text{invest} = 0\\)) - \\(s_\\text{invest} = 1\\): invest at fixed size (\\(v_\\text{invest} = \\text{size}_\\text{fixed}\\))</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#continuous-sizing","title":"Continuous Sizing","text":"<p>Variable-size investment with bounds (e.g., battery capacity from 10-1000 kWh):</p> \\[\\label{eq:invest_continuous} s_\\text{invest} \\cdot \\text{size}_\\text{min} \\leq v_\\text{invest} \\leq s_\\text{invest} \\cdot \\text{size}_\\text{max} \\] <p>With: - \\(v_\\text{invest}\\) being the investment size variable (continuous) - \\(s_\\text{invest} \\in \\{0, 1\\}\\) being the binary investment decision - \\(\\text{size}_\\text{min}\\) being the minimum investment size (if investing) - \\(\\text{size}_\\text{max}\\) being the maximum investment size</p> <p>Behavior: - \\(s_\\text{invest} = 0\\): no investment (\\(v_\\text{invest} = 0\\)) - \\(s_\\text{invest} = 1\\): invest with size in \\([\\text{size}_\\text{min}, \\text{size}_\\text{max}]\\)</p> <p>This uses the bounds with state pattern described in Bounds and States.</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#optional-vs-mandatory-investment","title":"Optional vs. Mandatory Investment","text":"<p>The <code>mandatory</code> parameter controls whether investment is required:</p> <p>Optional Investment (<code>mandatory=False</code>, default): $$\\label{eq:invest_optional} s_\\text{invest} \\in {0, 1} $$</p> <p>The optimization can freely choose to invest or not.</p> <p>Mandatory Investment (<code>mandatory=True</code>): $$\\label{eq:invest_mandatory} s_\\text{invest} = 1 $$</p> <p>The investment must occur (useful for mandatory upgrades or replacements).</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#effect-modeling","title":"Effect Modeling","text":"<p>Investment effects (costs, emissions, etc.) are modeled using three components:</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#fixed-effects","title":"Fixed Effects","text":"<p>One-time effects incurred if investment is made, independent of size:</p> \\[\\label{eq:invest_fixed_effects} E_{e,\\text{fix}} = s_\\text{invest} \\cdot \\text{fix}_e \\] <p>With: - \\(E_{e,\\text{fix}}\\) being the fixed contribution to effect \\(e\\) - \\(\\text{fix}_e\\) being the fixed effect value (e.g., fixed installation cost)</p> <p>Examples: - Fixed installation costs (permits, grid connection) - One-time environmental impacts (land preparation) - Fixed labor or administrative costs</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#specific-effects","title":"Specific Effects","text":"<p>Effects proportional to investment size (per-unit costs):</p> \\[\\label{eq:invest_specific_effects} E_{e,\\text{spec}} = v_\\text{invest} \\cdot \\text{spec}_e \\] <p>With: - \\(E_{e,\\text{spec}}\\) being the size-dependent contribution to effect \\(e\\) - \\(\\text{spec}_e\\) being the specific effect value per unit size (e.g., \u20ac/kW)</p> <p>Examples: - Equipment costs (\u20ac/kW) - Material requirements (kg steel/kW) - Recurring costs (\u20ac/kW/year maintenance)</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#piecewise-effects","title":"Piecewise Effects","text":"<p>Non-linear effect relationships using piecewise linear approximations:</p> \\[\\label{eq:invest_piecewise_effects} E_{e,\\text{pw}} = \\sum_{k=1}^{K} \\lambda_k \\cdot r_{e,k} \\] <p>Subject to: $$ v_\\text{invest} = \\sum_{k=1}^{K} \\lambda_k \\cdot v_k $$</p> <p>With: - \\(E_{e,\\text{pw}}\\) being the piecewise contribution to effect \\(e\\) - \\(\\lambda_k\\) being the piecewise lambda variables (see Piecewise) - \\(r_{e,k}\\) being the effect rate at piece \\(k\\) - \\(v_k\\) being the size points defining the pieces</p> <p>Use cases: - Economies of scale (bulk discounts) - Technology learning curves - Threshold effects (capacity tiers with different costs)</p> <p>See Piecewise for detailed mathematical formulation.</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#retirement-effects","title":"Retirement Effects","text":"<p>Effects incurred if investment is NOT made (when retiring/not replacing existing equipment):</p> \\[\\label{eq:invest_retirement_effects} E_{e,\\text{retirement}} = (1 - s_\\text{invest}) \\cdot \\text{retirement}_e \\] <p>With: - \\(E_{e,\\text{retirement}}\\) being the retirement contribution to effect \\(e\\) - \\(\\text{retirement}_e\\) being the retirement effect value</p> <p>Behavior: - \\(s_\\text{invest} = 0\\): retirement effects are incurred - \\(s_\\text{invest} = 1\\): no retirement effects</p> <p>Examples: - Demolition or disposal costs - Decommissioning expenses - Contractual penalties for not investing - Opportunity costs or lost revenues</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#total-investment-effects","title":"Total Investment Effects","text":"<p>The total contribution to effect \\(e\\) from an investment is:</p> \\[\\label{eq:invest_total_effects} E_{e,\\text{invest}} = E_{e,\\text{fix}} + E_{e,\\text{spec}} + E_{e,\\text{pw}} + E_{e,\\text{retirement}} \\] <p>Effects integrate into the overall system effects as described in Effects, Penalty &amp; Objective.</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#integration-with-components","title":"Integration with Components","text":"<p>Investment parameters modify component sizing:</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#without-investment","title":"Without Investment","text":"<p>Component size is a fixed parameter: $$ \\text{size} = \\text{size}_\\text{nominal} $$</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#with-investment","title":"With Investment","text":"<p>Component size becomes a variable: $$ \\text{size} = v_\\text{invest} $$</p> <p>This size variable then appears in component constraints. For example, flow rate bounds become:</p> \\[ v_\\text{invest} \\cdot \\text{rel}_\\text{lower} \\leq p(t) \\leq v_\\text{invest} \\cdot \\text{rel}_\\text{upper} \\] <p>Using the scaled bounds pattern from Bounds and States.</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#cost-annualization","title":"Cost Annualization","text":"<p>Important: All investment cost values must be properly weighted to match the optimization model's time horizon.</p> <p>For long-term investments, costs should be annualized:</p> \\[\\label{eq:annualization} \\text{cost}_\\text{annual} = \\frac{\\text{cost}_\\text{capital} \\cdot r}{1 - (1 + r)^{-n}} \\] <p>With: - \\(\\text{cost}_\\text{capital}\\) being the upfront investment cost - \\(r\\) being the discount rate - \\(n\\) being the equipment lifetime in years</p> <p>Example: \u20ac1,000,000 equipment with 20-year life and 5% discount rate $$ \\text{cost}_\\text{annual} = \\frac{1{,}000{,}000 \\cdot 0.05}{1 - (1.05)^{-20}} \\approx \u20ac80{,}243/\\text{year} $$</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#implementation","title":"Implementation","text":"<p>Python Class: <code>InvestParameters</code></p> <p>Key Parameters: - <code>fixed_size</code>: For binary investments (mutually exclusive with continuous sizing) - <code>minimum_size</code>, <code>maximum_size</code>: For continuous sizing - <code>mandatory</code>: Whether investment is required (default: <code>False</code>) - <code>effects_of_investment</code>: Fixed effects incurred when investing (replaces deprecated <code>fix_effects</code>) - <code>effects_of_investment_per_size</code>: Per-unit effects proportional to size (replaces deprecated <code>specific_effects</code>) - <code>piecewise_effects_of_investment</code>: Non-linear effect modeling (replaces deprecated <code>piecewise_effects</code>) - <code>effects_of_retirement</code>: Effects for not investing (replaces deprecated <code>divest_effects</code>)</p> <p>See the <code>InvestParameters</code> API documentation for complete parameter list and usage examples.</p> <p>Used in: - <code>Flow</code> - Flexible capacity decisions - <code>Storage</code> - Storage sizing optimization - <code>LinearConverter</code> - Converter capacity planning - All components supporting investment decisions</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#examples","title":"Examples","text":""},{"location":"user-guide/mathematical-notation/features/InvestParameters/#binary-investment-solar-panels","title":"Binary Investment (Solar Panels)","text":"Python<pre><code>solar_investment = InvestParameters(\n    fixed_size=100,  # 100 kW system\n    mandatory=False,  # Optional investment (default)\n    effects_of_investment={'cost': 25000},  # Installation costs\n    effects_of_investment_per_size={'cost': 1200},  # \u20ac1200/kW\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#continuous-sizing-battery","title":"Continuous Sizing (Battery)","text":"Python<pre><code>battery_investment = InvestParameters(\n    minimum_size=10,  # kWh\n    maximum_size=1000,\n    mandatory=False,  # Optional investment (default)\n    effects_of_investment={'cost': 5000},  # Grid connection\n    effects_of_investment_per_size={'cost': 600},  # \u20ac600/kWh\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#with-retirement-costs-replacement","title":"With Retirement Costs (Replacement)","text":"Python<pre><code>boiler_replacement = InvestParameters(\n    minimum_size=50,  # kW\n    maximum_size=200,\n    mandatory=False,  # Optional investment (default)\n    effects_of_investment={'cost': 15000},\n    effects_of_investment_per_size={'cost': 400},\n    effects_of_retirement={'cost': 8000},  # Demolition if not replaced\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#economies-of-scale-piecewise","title":"Economies of Scale (Piecewise)","text":"Python<pre><code>battery_investment = InvestParameters(\n    minimum_size=10,\n    maximum_size=1000,\n    piecewise_effects_of_investment=PiecewiseEffects(\n        piecewise_origin=Piecewise([\n            Piece(0, 100),    # Small\n            Piece(100, 500),  # Medium\n            Piece(500, 1000), # Large\n        ]),\n        piecewise_shares={\n            'cost': Piecewise([\n                Piece(800, 750),  # \u20ac800-750/kWh\n                Piece(750, 600),  # \u20ac750-600/kWh\n                Piece(600, 500),  # \u20ac600-500/kWh (bulk discount)\n            ])\n        },\n    ),\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/","title":"OnOffParameters","text":"<p><code>OnOffParameters</code> model equipment that operates in discrete on/off states rather than continuous operation. This captures realistic operational constraints including startup costs, minimum run times, cycling limitations, and maintenance scheduling.</p>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#binary-state-variable","title":"Binary State Variable","text":"<p>Equipment operation is modeled using a binary state variable:</p> \\[\\label{eq:onoff_state} s(t) \\in \\{0, 1\\} \\quad \\forall t \\] <p>With: - \\(s(t) = 1\\): equipment is operating (on state) - \\(s(t) = 0\\): equipment is shutdown (off state)</p> <p>This state variable controls the equipment's operational constraints and modifies flow bounds using the bounds with state pattern from Bounds and States.</p>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#state-transitions-and-switching","title":"State Transitions and Switching","text":"<p>State transitions are tracked using switch variables (see State Transitions):</p> \\[\\label{eq:onoff_transitions} s^\\text{on}(t) - s^\\text{off}(t) = s(t) - s(t-1) \\quad \\forall t &gt; 0 \\] \\[\\label{eq:onoff_switch_exclusivity} s^\\text{on}(t) + s^\\text{off}(t) \\leq 1 \\quad \\forall t \\] <p>With: - \\(s^\\text{on}(t) \\in \\{0, 1\\}\\): equals 1 when switching from off to on (startup) - \\(s^\\text{off}(t) \\in \\{0, 1\\}\\): equals 1 when switching from on to off (shutdown)</p> <p>Behavior: - Off \u2192 On: \\(s^\\text{on}(t) = 1, s^\\text{off}(t) = 0\\) - On \u2192 Off: \\(s^\\text{on}(t) = 0, s^\\text{off}(t) = 1\\) - No change: \\(s^\\text{on}(t) = 0, s^\\text{off}(t) = 0\\)</p>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#effects-and-costs","title":"Effects and Costs","text":""},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#switching-effects","title":"Switching Effects","text":"<p>Effects incurred when equipment starts up:</p> \\[\\label{eq:onoff_switch_effects} E_{e,\\text{switch}} = \\sum_{t} s^\\text{on}(t) \\cdot \\text{effect}_{e,\\text{switch}} \\] <p>With: - \\(\\text{effect}_{e,\\text{switch}}\\) being the effect value per startup event</p> <p>Examples: - Startup fuel consumption - Wear and tear costs - Labor costs for startup procedures - Inrush power demands</p>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#running-effects","title":"Running Effects","text":"<p>Effects incurred while equipment is operating:</p> \\[\\label{eq:onoff_running_effects} E_{e,\\text{run}} = \\sum_{t} s(t) \\cdot \\Delta t \\cdot \\text{effect}_{e,\\text{run}} \\] <p>With: - \\(\\text{effect}_{e,\\text{run}}\\) being the effect rate per operating hour - \\(\\Delta t\\) being the time step duration</p> <p>Examples: - Fixed operating and maintenance costs - Auxiliary power consumption - Consumable materials - Emissions while running</p>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#operating-hour-constraints","title":"Operating Hour Constraints","text":""},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#total-operating-hours","title":"Total Operating Hours","text":"<p>Bounds on total operating time across the planning horizon:</p> \\[\\label{eq:onoff_total_hours} h_\\text{min} \\leq \\sum_{t} s(t) \\cdot \\Delta t \\leq h_\\text{max} \\] <p>With: - \\(h_\\text{min}\\) being the minimum total operating hours - \\(h_\\text{max}\\) being the maximum total operating hours</p> <p>Use cases: - Minimum runtime requirements (contracts, maintenance) - Maximum runtime limits (fuel availability, permits, equipment life)</p>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#consecutive-operating-hours","title":"Consecutive Operating Hours","text":"<p>Minimum Consecutive On-Time:</p> <p>Enforces minimum runtime once started using duration tracking (see Duration Tracking):</p> \\[\\label{eq:onoff_min_on_duration} d^\\text{on}(t) \\geq (s(t-1) - s(t)) \\cdot h^\\text{on}_\\text{min} \\quad \\forall t &gt; 0 \\] <p>With: - \\(d^\\text{on}(t)\\) being the consecutive on-time duration at time \\(t\\) - \\(h^\\text{on}_\\text{min}\\) being the minimum required on-time</p> <p>Behavior: - When shutting down at time \\(t\\): enforces equipment was on for at least \\(h^\\text{on}_\\text{min}\\) prior to the switch - Prevents short cycling and frequent startups</p> <p>Maximum Consecutive On-Time:</p> <p>Limits continuous operation before requiring shutdown:</p> \\[\\label{eq:onoff_max_on_duration} d^\\text{on}(t) \\leq h^\\text{on}_\\text{max} \\quad \\forall t \\] <p>Use cases: - Mandatory maintenance intervals - Process batch time limits - Thermal cycling requirements</p>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#consecutive-shutdown-hours","title":"Consecutive Shutdown Hours","text":"<p>Minimum Consecutive Off-Time:</p> <p>Enforces minimum shutdown duration before restarting:</p> \\[\\label{eq:onoff_min_off_duration} d^\\text{off}(t) \\geq (s(t) - s(t-1)) \\cdot h^\\text{off}_\\text{min} \\quad \\forall t &gt; 0 \\] <p>With: - \\(d^\\text{off}(t)\\) being the consecutive off-time duration at time \\(t\\) - \\(h^\\text{off}_\\text{min}\\) being the minimum required off-time</p> <p>Use cases: - Cooling periods - Maintenance requirements - Process stabilization</p> <p>Maximum Consecutive Off-Time:</p> <p>Limits shutdown duration before mandatory restart:</p> \\[\\label{eq:onoff_max_off_duration} d^\\text{off}(t) \\leq h^\\text{off}_\\text{max} \\quad \\forall t \\] <p>Use cases: - Equipment preservation requirements - Process stability needs - Contractual minimum activity levels</p>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#cycling-limits","title":"Cycling Limits","text":"<p>Maximum number of startups across the planning horizon:</p> \\[\\label{eq:onoff_max_switches} \\sum_{t} s^\\text{on}(t) \\leq n_\\text{max} \\] <p>With: - \\(n_\\text{max}\\) being the maximum allowed number of startups</p> <p>Use cases: - Preventing excessive equipment wear - Grid stability requirements - Operational complexity limits - Maintenance budget constraints</p>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#integration-with-flow-bounds","title":"Integration with Flow Bounds","text":"<p>OnOffParameters modify flow rate bounds by coupling them to the on/off state.</p> <p>Without OnOffParameters (continuous operation): $$ P \\cdot \\text{rel}\\text{lower} \\leq p(t) \\leq P \\cdot \\text{rel}\\text{upper} $$</p> <p>With OnOffParameters (binary operation): $$ s(t) \\cdot P \\cdot \\max(\\varepsilon, \\text{rel}\\text{lower}) \\leq p(t) \\leq s(t) \\cdot P \\cdot \\text{rel}\\text{upper} $$</p> <p>Using the bounds with state pattern from Bounds and States.</p> <p>Behavior: - When \\(s(t) = 0\\): flow is forced to zero - When \\(s(t) = 1\\): flow follows normal bounds</p>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#complete-formulation-summary","title":"Complete Formulation Summary","text":"<p>For equipment with OnOffParameters, the complete constraint system includes:</p> <ol> <li>State variable: \\(s(t) \\in \\{0, 1\\}\\)</li> <li>Switch tracking: \\(s^\\text{on}(t) - s^\\text{off}(t) = s(t) - s(t-1)\\)</li> <li>Switch exclusivity: \\(s^\\text{on}(t) + s^\\text{off}(t) \\leq 1\\)</li> <li>Duration tracking:<ul> <li>On-duration: \\(d^\\text{on}(t)\\) following duration tracking pattern</li> <li>Off-duration: \\(d^\\text{off}(t)\\) following duration tracking pattern</li> </ul> </li> <li>Minimum on-time: \\(d^\\text{on}(t) \\geq (s(t-1) - s(t)) \\cdot h^\\text{on}_\\text{min}\\)</li> <li>Maximum on-time: \\(d^\\text{on}(t) \\leq h^\\text{on}_\\text{max}\\)</li> <li>Minimum off-time: \\(d^\\text{off}(t) \\geq (s(t) - s(t-1)) \\cdot h^\\text{off}_\\text{min}\\)</li> <li>Maximum off-time: \\(d^\\text{off}(t) \\leq h^\\text{off}_\\text{max}\\)</li> <li>Total hours: \\(h_\\text{min} \\leq \\sum_t s(t) \\cdot \\Delta t \\leq h_\\text{max}\\)</li> <li>Cycling limit: \\(\\sum_t s^\\text{on}(t) \\leq n_\\text{max}\\)</li> <li>Flow bounds: \\(s(t) \\cdot P \\cdot \\text{rel}_\\text{lower} \\leq p(t) \\leq s(t) \\cdot P \\cdot \\text{rel}_\\text{upper}\\)</li> </ol>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#implementation","title":"Implementation","text":"<p>Python Class: <code>OnOffParameters</code></p> <p>Key Parameters: - <code>effects_per_switch_on</code>: Costs per startup event - <code>effects_per_running_hour</code>: Costs per hour of operation - <code>on_hours_total_min</code>, <code>on_hours_total_max</code>: Total runtime bounds - <code>consecutive_on_hours_min</code>, <code>consecutive_on_hours_max</code>: Consecutive runtime bounds - <code>consecutive_off_hours_min</code>, <code>consecutive_off_hours_max</code>: Consecutive shutdown bounds - <code>switch_on_total_max</code>: Maximum number of startups - <code>force_switch_on</code>: Create switch variables even without limits (for tracking)</p> <p>See the <code>OnOffParameters</code> API documentation for complete parameter list and usage examples.</p> <p>Mathematical Patterns Used: - State Transitions - Switch tracking - Duration Tracking - Consecutive time constraints - Bounds with State - Flow control</p> <p>Used in: - <code>Flow</code> - On/off operation for flows - All components supporting discrete operational states</p>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#examples","title":"Examples","text":""},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#power-plant-with-startup-costs","title":"Power Plant with Startup Costs","text":"Python<pre><code>power_plant = OnOffParameters(\n    effects_per_switch_on={'startup_cost': 25000},  # \u20ac25k per startup\n    effects_per_running_hour={'fixed_om': 125},  # \u20ac125/hour while running\n    consecutive_on_hours_min=8,  # Minimum 8-hour run\n    consecutive_off_hours_min=4,  # 4-hour cooling period\n    on_hours_total_max=6000,  # Annual limit\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#batch-process-with-cycling-limits","title":"Batch Process with Cycling Limits","text":"Python<pre><code>batch_reactor = OnOffParameters(\n    effects_per_switch_on={'setup_cost': 1500},\n    consecutive_on_hours_min=12,  # 12-hour minimum batch\n    consecutive_on_hours_max=24,  # 24-hour maximum batch\n    consecutive_off_hours_min=6,  # Cleaning time\n    switch_on_total_max=200,  # Max 200 batches\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#hvac-with-cycle-prevention","title":"HVAC with Cycle Prevention","text":"Python<pre><code>hvac = OnOffParameters(\n    effects_per_switch_on={'compressor_wear': 0.5},\n    consecutive_on_hours_min=1,  # Prevent short cycling\n    consecutive_off_hours_min=0.5,  # 30-min minimum off\n    switch_on_total_max=2000,  # Limit compressor starts\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#backup-generator-with-testing-requirements","title":"Backup Generator with Testing Requirements","text":"Python<pre><code>backup_gen = OnOffParameters(\n    effects_per_switch_on={'fuel_priming': 50},  # L diesel\n    consecutive_on_hours_min=0.5,  # 30-min test duration\n    consecutive_off_hours_max=720,  # Test every 30 days\n    on_hours_total_min=26,  # Weekly testing requirement\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/features/OnOffParameters/#notes","title":"Notes","text":"<p>Time Series Boundary: The final time period constraints for consecutive_on_hours_min/max and consecutive_off_hours_min/max are not enforced at the end of the planning horizon. This allows optimization to end with ongoing campaigns that may be shorter/longer than specified, as they extend beyond the modeled period.</p>"},{"location":"user-guide/mathematical-notation/features/Piecewise/","title":"Piecewise","text":"<p>A Piecewise is a collection of <code>Pieces</code>, which each define a valid range for a variable \\(v\\)</p> \\[ \\label{eq:active_piece}     \\beta_\\text{k} = \\lambda_\\text{0, k} + \\lambda_\\text{1, k} \\] \\[ \\label{eq:piece}     v_\\text{k} = \\lambda_\\text{0, k} * \\text{v}_{\\text{start,k}} + \\lambda_\\text{1,k} * \\text{v}_{\\text{end,k}} \\] \\[ \\label{eq:piecewise_in_pieces} \\sum_{k=1}^k \\beta_{k} = 1 \\] <p>With:</p> <ul> <li>\\(v\\): The variable to be defined by the Piecewise</li> <li>\\(\\text{v}_{\\text{start,k}}\\): the start point of the piece for variable \\(v\\)</li> <li>\\(\\text{v}_{\\text{end,k}}\\): the end point of the piece for variable \\(v\\)</li> <li>\\(\\beta_\\text{k} \\in \\{0, 1\\}\\): defining wether the Piece \\(k\\) is active</li> <li>\\(\\lambda_\\text{0,k} \\in [0, 1]\\): A variable defining the fraction of \\(\\text{v}_{\\text{start,k}}\\) that is active</li> <li>\\(\\lambda_\\text{1,k} \\in [0, 1]\\): A variable defining the fraction of \\(\\text{v}_{\\text{end,k}}\\) that is active</li> </ul> <p>Which can also be described as \\(v \\in 0 \\cup [\\text{v}_\\text{start}, \\text{v}_\\text{end}]\\).</p> <p>Instead of \\eqref{eq:piecewise_in_pieces}, the following constraint is used to also allow all variables to be zero:</p> \\[ \\label{eq:piecewise_in_pieces_zero} \\sum_{k=1}^k \\beta_{k} = \\beta_\\text{zero} \\] <p>With:</p> <ul> <li>\\(\\beta_\\text{zero} \\in \\{0, 1\\}\\).</li> </ul> <p>Which can also be described as \\(v \\in \\{0\\} \\cup [\\text{v}_{\\text{start_k}}, \\text{v}_{\\text{end_k}}]\\)</p>"},{"location":"user-guide/mathematical-notation/features/Piecewise/#combining-multiple-piecewises","title":"Combining multiple Piecewises","text":"<p>Piecewise allows representing non-linear relationships. This is a powerful technique in linear optimization to model non-linear behaviors while maintaining the problem's linearity.</p> <p>Therefore, each Piecewise must have the same number of Pieces \\(k\\).</p> <p>The variables described in Piecewise are created for each Piece, but nor for each Piecewise. Rather, \\eqref{eq:piece} is the only constraint that is created for each Piecewise, using the start and endpoints \\(\\text{v}_{\\text{start,k}}\\) and \\(\\text{v}_{\\text{end,k}}\\) of each Piece for the corresponding variable \\(v\\)</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/","title":"Modeling Patterns","text":"<p>This section documents the fundamental mathematical patterns used throughout FlixOpt for constructing optimization models. These patterns are implemented in <code>flixopt.modeling</code> and provide reusable building blocks for creating constraints.</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/#overview","title":"Overview","text":"<p>The modeling patterns are organized into three categories:</p> <ol> <li>Bounds and States - Variable bounding with optional state control</li> <li>Duration Tracking - Tracking consecutive durations of states</li> <li>State Transitions - Modeling state changes and transitions</li> </ol>"},{"location":"user-guide/mathematical-notation/modeling-patterns/#pattern-categories","title":"Pattern Categories","text":""},{"location":"user-guide/mathematical-notation/modeling-patterns/#bounding-patterns","title":"Bounding Patterns","text":"<p>These patterns define how optimization variables are constrained within bounds:</p> <ul> <li>Basic Bounds - Simple upper and lower bounds on variables</li> <li>Bounds with State - Binary-controlled bounds (on/off states)</li> <li>Scaled Bounds - Bounds dependent on another variable (e.g., size)</li> <li>Scaled Bounds with State - Combination of scaling and binary control</li> </ul>"},{"location":"user-guide/mathematical-notation/modeling-patterns/#tracking-patterns","title":"Tracking Patterns","text":"<p>These patterns track properties over time:</p> <ul> <li>Expression Tracking - Creating auxiliary variables that track expressions</li> <li>Consecutive Duration Tracking - Tracking how long a state has been active</li> <li>Mutual Exclusivity - Ensuring only one of multiple options is active</li> </ul>"},{"location":"user-guide/mathematical-notation/modeling-patterns/#transition-patterns","title":"Transition Patterns","text":"<p>These patterns model changes between states:</p> <ul> <li>State Transitions - Tracking switches between binary states (on\u2192off, off\u2192on)</li> <li>Continuous Transitions - Linking continuous variable changes to switches</li> <li>Level Changes with Binaries - Controlled increases/decreases in levels</li> </ul>"},{"location":"user-guide/mathematical-notation/modeling-patterns/#usage-in-components","title":"Usage in Components","text":"<p>These patterns are used throughout FlixOpt components:</p> <ul> <li><code>Flow</code> uses scaled bounds with state for flow rate constraints</li> <li><code>Storage</code> uses basic bounds for charge state</li> <li><code>OnOffParameters</code> uses state transitions for startup/shutdown</li> <li><code>InvestParameters</code> uses bounds with state for investment decisions</li> </ul>"},{"location":"user-guide/mathematical-notation/modeling-patterns/#implementation","title":"Implementation","text":"<p>All patterns are implemented in <code>flixopt.modeling</code> module:</p> <ul> <li><code>ModelingPrimitives</code> - Core constraint patterns</li> <li><code>BoundingPatterns</code> - Specialized bounding patterns</li> </ul>"},{"location":"user-guide/mathematical-notation/modeling-patterns/bounds-and-states/","title":"Bounds and States","text":"<p>This document describes the mathematical formulations for variable bounding patterns used throughout FlixOpt. These patterns define how optimization variables are constrained, both with and without state control.</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/bounds-and-states/#basic-bounds","title":"Basic Bounds","text":"<p>The simplest bounding pattern constrains a variable between lower and upper bounds.</p> \\[\\label{eq:basic_bounds} \\text{lower} \\leq v \\leq \\text{upper} \\] <p>With: - \\(v\\) being the optimization variable - \\(\\text{lower}\\) being the lower bound (constant or time-dependent) - \\(\\text{upper}\\) being the upper bound (constant or time-dependent)</p> <p>Implementation: <code>BoundingPatterns.basic_bounds()</code></p> <p>Used in: - Storage charge state bounds (see Storage) - Flow rate absolute bounds</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/bounds-and-states/#bounds-with-state","title":"Bounds with State","text":"<p>When a variable should only be non-zero if a binary state variable is active (e.g., on/off operation, investment decisions), the bounds are controlled by the state:</p> \\[\\label{eq:bounds_with_state} s \\cdot \\max(\\varepsilon, \\text{lower}) \\leq v \\leq s \\cdot \\text{upper} \\] <p>With: - \\(v\\) being the optimization variable - \\(s \\in \\{0, 1\\}\\) being the binary state variable - \\(\\text{lower}\\) being the lower bound when active - \\(\\text{upper}\\) being the upper bound when active - \\(\\varepsilon\\) being a small positive number to ensure numerical stability</p> <p>Behavior: - When \\(s = 0\\): variable is forced to zero (\\(0 \\leq v \\leq 0\\)) - When \\(s = 1\\): variable can take values in \\([\\text{lower}, \\text{upper}]\\)</p> <p>Implementation: <code>BoundingPatterns.bounds_with_state()</code></p> <p>Used in: - Flow rates with on/off operation (see OnOffParameters) - Investment size decisions (see InvestParameters)</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/bounds-and-states/#scaled-bounds","title":"Scaled Bounds","text":"<p>When a variable's bounds depend on another variable (e.g., flow rate scaled by component size), scaled bounds are used:</p> \\[\\label{eq:scaled_bounds} v_\\text{scale} \\cdot \\text{rel}_\\text{lower} \\leq v \\leq v_\\text{scale} \\cdot \\text{rel}_\\text{upper} \\] <p>With: - \\(v\\) being the optimization variable (e.g., flow rate) - \\(v_\\text{scale}\\) being the scaling variable (e.g., component size) - \\(\\text{rel}_\\text{lower}\\) being the relative lower bound factor (typically 0) - \\(\\text{rel}_\\text{upper}\\) being the relative upper bound factor (typically 1)</p> <p>Example: Flow rate bounds - If \\(v_\\text{scale} = P\\) (flow size) and \\(\\text{rel}_\\text{upper} = 1\\) - Then: \\(0 \\leq p(t_i) \\leq P\\) (see Flow)</p> <p>Implementation: <code>BoundingPatterns.scaled_bounds()</code></p> <p>Used in: - Flow rate constraints (see Flow equation 1) - Storage charge state constraints (see Storage equation 1)</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/bounds-and-states/#scaled-bounds-with-state","title":"Scaled Bounds with State","text":"<p>Combining scaled bounds with binary state control requires a Big-M formulation to handle both the scaling and the on/off behavior:</p> \\[\\label{eq:scaled_bounds_with_state_1} (s - 1) \\cdot M_\\text{misc} + v_\\text{scale} \\cdot \\text{rel}_\\text{lower} \\leq v \\leq v_\\text{scale} \\cdot \\text{rel}_\\text{upper} \\] \\[\\label{eq:scaled_bounds_with_state_2} s \\cdot M_\\text{lower} \\leq v \\leq s \\cdot M_\\text{upper} \\] <p>With: - \\(v\\) being the optimization variable - \\(v_\\text{scale}\\) being the scaling variable - \\(s \\in \\{0, 1\\}\\) being the binary state variable - \\(\\text{rel}_\\text{lower}\\) being the relative lower bound factor - \\(\\text{rel}_\\text{upper}\\) being the relative upper bound factor - \\(M_\\text{misc} = v_\\text{scale,max} \\cdot \\text{rel}_\\text{lower}\\) - \\(M_\\text{upper} = v_\\text{scale,max} \\cdot \\text{rel}_\\text{upper}\\) - \\(M_\\text{lower} = \\max(\\varepsilon, v_\\text{scale,min} \\cdot \\text{rel}_\\text{lower})\\)</p> <p>Where \\(v_\\text{scale,max}\\) and \\(v_\\text{scale,min}\\) are the maximum and minimum possible values of the scaling variable.</p> <p>Behavior: - When \\(s = 0\\): variable is forced to zero - When \\(s = 1\\): variable follows scaled bounds \\(v_\\text{scale} \\cdot \\text{rel}_\\text{lower} \\leq v \\leq v_\\text{scale} \\cdot \\text{rel}_\\text{upper}\\)</p> <p>Implementation: <code>BoundingPatterns.scaled_bounds_with_state()</code></p> <p>Used in: - Flow rates with on/off operation and investment sizing - Components combining OnOffParameters and InvestParameters</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/bounds-and-states/#expression-tracking","title":"Expression Tracking","text":"<p>Sometimes it's necessary to create an auxiliary variable that equals an expression:</p> \\[\\label{eq:expression_tracking} v_\\text{tracker} = \\text{expression} \\] <p>With optional bounds:</p> \\[\\label{eq:expression_tracking_bounds} \\text{lower} \\leq v_\\text{tracker} \\leq \\text{upper} \\] <p>With: - \\(v_\\text{tracker}\\) being the auxiliary tracking variable - \\(\\text{expression}\\) being a linear expression of other variables - \\(\\text{lower}, \\text{upper}\\) being optional bounds on the tracker</p> <p>Use cases: - Creating named variables for complex expressions - Bounding intermediate results - Simplifying constraint formulations</p> <p>Implementation: <code>ModelingPrimitives.expression_tracking_variable()</code></p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/bounds-and-states/#mutual-exclusivity","title":"Mutual Exclusivity","text":"<p>When multiple binary variables should not be active simultaneously (at most one can be 1):</p> \\[\\label{eq:mutual_exclusivity} \\sum_{i} s_i(t) \\leq \\text{tolerance} \\quad \\forall t \\] <p>With: - \\(s_i(t) \\in \\{0, 1\\}\\) being binary state variables - \\(\\text{tolerance}\\) being the maximum number of simultaneously active states (typically 1) - \\(t\\) being the time index</p> <p>Use cases: - Ensuring only one operating mode is active - Mutual exclusion of operation and maintenance states - Enforcing single-choice decisions</p> <p>Implementation: <code>ModelingPrimitives.mutual_exclusivity_constraint()</code></p> <p>Used in: - Operating mode selection - Piecewise linear function segments (see Piecewise)</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/duration-tracking/","title":"Duration Tracking","text":"<p>Duration tracking allows monitoring how long a binary state has been consecutively active. This is essential for modeling minimum run times, ramp-up periods, and similar time-dependent constraints.</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/duration-tracking/#consecutive-duration-tracking","title":"Consecutive Duration Tracking","text":"<p>For a binary state variable \\(s(t) \\in \\{0, 1\\}\\), the consecutive duration \\(d(t)\\) tracks how long the state has been continuously active.</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/duration-tracking/#duration-upper-bound","title":"Duration Upper Bound","text":"<p>The duration cannot exceed zero when the state is inactive:</p> \\[\\label{eq:duration_upper} d(t) \\leq s(t) \\cdot M \\quad \\forall t \\] <p>With: - \\(d(t)\\) being the duration variable (continuous, non-negative) - \\(s(t) \\in \\{0, 1\\}\\) being the binary state variable - \\(M\\) being a sufficiently large constant (big-M)</p> <p>Behavior: - When \\(s(t) = 0\\): forces \\(d(t) \\leq 0\\), thus \\(d(t) = 0\\) - When \\(s(t) = 1\\): allows \\(d(t)\\) to be positive</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/duration-tracking/#duration-accumulation","title":"Duration Accumulation","text":"<p>While the state is active, the duration increases by the time step size:</p> \\[\\label{eq:duration_accumulation_upper} d(t+1) \\leq d(t) + \\Delta d(t) \\quad \\forall t \\] \\[\\label{eq:duration_accumulation_lower} d(t+1) \\geq d(t) + \\Delta d(t) + (s(t+1) - 1) \\cdot M \\quad \\forall t \\] <p>With: - \\(\\Delta d(t)\\) being the duration increment for time step \\(t\\) (typically \\(\\Delta t_i\\) from the time series) - \\(M\\) being a sufficiently large constant</p> <p>Behavior: - When \\(s(t+1) = 1\\): both inequalities enforce \\(d(t+1) = d(t) + \\Delta d(t)\\) - When \\(s(t+1) = 0\\): only the upper bound applies, and \\(d(t+1) = 0\\) (from equation \\(\\eqref{eq:duration_upper}\\))</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/duration-tracking/#initial-duration","title":"Initial Duration","text":"<p>The duration at the first time step depends on both the state and any previous duration:</p> \\[\\label{eq:duration_initial} d(0) = (\\Delta d(0) + d_\\text{prev}) \\cdot s(0) \\] <p>With: - \\(d_\\text{prev}\\) being the duration from before the optimization period - \\(\\Delta d(0)\\) being the duration increment for the first time step</p> <p>Behavior: - When \\(s(0) = 1\\): duration continues from previous period - When \\(s(0) = 0\\): duration resets to zero</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/duration-tracking/#complete-formulation","title":"Complete Formulation","text":"<p>Combining all constraints:</p> \\[ \\begin{align} d(t) &amp;\\leq s(t) \\cdot M &amp;&amp; \\forall t \\label{eq:duration_complete_1} \\\\ d(t+1) &amp;\\leq d(t) + \\Delta d(t) &amp;&amp; \\forall t \\label{eq:duration_complete_2} \\\\ d(t+1) &amp;\\geq d(t) + \\Delta d(t) + (s(t+1) - 1) \\cdot M &amp;&amp; \\forall t \\label{eq:duration_complete_3} \\\\ d(0) &amp;= (\\Delta d(0) + d_\\text{prev}) \\cdot s(0) &amp;&amp; \\label{eq:duration_complete_4} \\end{align} \\]"},{"location":"user-guide/mathematical-notation/modeling-patterns/duration-tracking/#minimum-duration-constraints","title":"Minimum Duration Constraints","text":"<p>To enforce a minimum consecutive duration (e.g., minimum run time), an additional constraint links the duration to state changes:</p> \\[\\label{eq:minimum_duration} d(t) \\geq (s(t-1) - s(t)) \\cdot d_\\text{min}(t-1) \\quad \\forall t &gt; 0 \\] <p>With: - \\(d_\\text{min}(t)\\) being the required minimum duration at time \\(t\\)</p> <p>Behavior: - When shutting down (\\(s(t-1) = 1, s(t) = 0\\)): enforces \\(d(t-1) \\geq d_\\text{min}(t-1)\\) - This ensures the state was active for at least \\(d_\\text{min}\\) before turning off - When state is constant or turning on: constraint is non-binding</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/duration-tracking/#implementation","title":"Implementation","text":"<p>Function: <code>ModelingPrimitives.consecutive_duration_tracking()</code></p> <p>See the API documentation for complete parameter list and usage details.</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/duration-tracking/#use-cases","title":"Use Cases","text":""},{"location":"user-guide/mathematical-notation/modeling-patterns/duration-tracking/#minimum-run-time","title":"Minimum Run Time","text":"<p>Ensuring equipment runs for a minimum duration once started:</p> Python<pre><code># State: 1 when running, 0 when off\n# Require at least 2 hours of operation\nduration = modeling.consecutive_duration_tracking(\n    state_variable=on_state,\n    duration_per_step=time_step_hours,\n    minimum_duration=2.0\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/modeling-patterns/duration-tracking/#ramp-up-tracking","title":"Ramp-Up Tracking","text":"<p>Tracking time since startup for gradual ramp-up constraints:</p> Python<pre><code># Track startup duration\nstartup_duration = modeling.consecutive_duration_tracking(\n    state_variable=on_state,\n    duration_per_step=time_step_hours\n)\n# Constrain output based on startup duration\n# (additional constraints would link output to startup_duration)\n</code></pre>"},{"location":"user-guide/mathematical-notation/modeling-patterns/duration-tracking/#cooldown-requirements","title":"Cooldown Requirements","text":"<p>Tracking time in a state before allowing transitions:</p> Python<pre><code># Track maintenance duration\nmaintenance_duration = modeling.consecutive_duration_tracking(\n    state_variable=maintenance_state,\n    duration_per_step=time_step_hours,\n    minimum_duration=scheduled_maintenance_hours\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/modeling-patterns/duration-tracking/#used-in","title":"Used In","text":"<p>This pattern is used in: - <code>OnOffParameters</code> - Minimum on/off times - Operating mode constraints with minimum durations - Startup/shutdown sequence modeling</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/","title":"State Transitions","text":"<p>State transition patterns model changes between discrete states and link them to continuous variables. These patterns are essential for modeling startup/shutdown events, switching behavior, and controlled changes in system operation.</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#binary-state-transitions","title":"Binary State Transitions","text":"<p>For a binary state variable \\(s(t) \\in \\{0, 1\\}\\), state transitions track when the state switches on or off.</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#switch-variables","title":"Switch Variables","text":"<p>Two binary variables track the transitions: - \\(s^\\text{on}(t) \\in \\{0, 1\\}\\): equals 1 when switching from off to on - \\(s^\\text{off}(t) \\in \\{0, 1\\}\\): equals 1 when switching from on to off</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#transition-tracking","title":"Transition Tracking","text":"<p>The state change equals the difference between switch-on and switch-off:</p> \\[\\label{eq:state_transition} s^\\text{on}(t) - s^\\text{off}(t) = s(t) - s(t-1) \\quad \\forall t &gt; 0 \\] \\[\\label{eq:state_transition_initial} s^\\text{on}(0) - s^\\text{off}(0) = s(0) - s_\\text{prev} \\] <p>With: - \\(s(t)\\) being the binary state variable - \\(s_\\text{prev}\\) being the state before the optimization period - \\(s^\\text{on}(t), s^\\text{off}(t)\\) being the switch variables</p> <p>Behavior: - Off \u2192 On (\\(s(t-1)=0, s(t)=1\\)): \\(s^\\text{on}(t)=1, s^\\text{off}(t)=0\\) - On \u2192 Off (\\(s(t-1)=1, s(t)=0\\)): \\(s^\\text{on}(t)=0, s^\\text{off}(t)=1\\) - No change: \\(s^\\text{on}(t)=0, s^\\text{off}(t)=0\\)</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#mutual-exclusivity-of-switches","title":"Mutual Exclusivity of Switches","text":"<p>A state cannot switch on and off simultaneously:</p> \\[\\label{eq:switch_exclusivity} s^\\text{on}(t) + s^\\text{off}(t) \\leq 1 \\quad \\forall t \\] <p>This ensures: - At most one switch event per time step - No simultaneous on/off switching</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#complete-state-transition-formulation","title":"Complete State Transition Formulation","text":"\\[ \\begin{align} s^\\text{on}(t) - s^\\text{off}(t) &amp;= s(t) - s(t-1) &amp;&amp; \\forall t &gt; 0 \\label{eq:transition_complete_1} \\\\ s^\\text{on}(0) - s^\\text{off}(0) &amp;= s(0) - s_\\text{prev} &amp;&amp; \\label{eq:transition_complete_2} \\\\ s^\\text{on}(t) + s^\\text{off}(t) &amp;\\leq 1 &amp;&amp; \\forall t \\label{eq:transition_complete_3} \\\\ s^\\text{on}(t), s^\\text{off}(t) &amp;\\in \\{0, 1\\} &amp;&amp; \\forall t \\label{eq:transition_complete_4} \\end{align} \\] <p>Implementation: <code>BoundingPatterns.state_transition_bounds()</code></p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#continuous-transitions","title":"Continuous Transitions","text":"<p>When a continuous variable should only change when certain switch events occur, continuous transition bounds link the variable changes to binary switches.</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#change-bounds-with-switches","title":"Change Bounds with Switches","text":"\\[\\label{eq:continuous_transition} -\\Delta v^\\text{max} \\cdot (s^\\text{on}(t) + s^\\text{off}(t)) \\leq v(t) - v(t-1) \\leq \\Delta v^\\text{max} \\cdot (s^\\text{on}(t) + s^\\text{off}(t)) \\quad \\forall t &gt; 0 \\] \\[\\label{eq:continuous_transition_initial} -\\Delta v^\\text{max} \\cdot (s^\\text{on}(0) + s^\\text{off}(0)) \\leq v(0) - v_\\text{prev} \\leq \\Delta v^\\text{max} \\cdot (s^\\text{on}(0) + s^\\text{off}(0)) \\] <p>With: - \\(v(t)\\) being the continuous variable - \\(v_\\text{prev}\\) being the value before the optimization period - \\(\\Delta v^\\text{max}\\) being the maximum allowed change - \\(s^\\text{on}(t), s^\\text{off}(t) \\in \\{0, 1\\}\\) being switch binary variables</p> <p>Behavior: - When \\(s^\\text{on}(t) = 0\\) and \\(s^\\text{off}(t) = 0\\): forces \\(v(t) = v(t-1)\\) (no change) - When \\(s^\\text{on}(t) = 1\\) or \\(s^\\text{off}(t) = 1\\): allows change up to \\(\\pm \\Delta v^\\text{max}\\)</p> <p>Implementation: <code>BoundingPatterns.continuous_transition_bounds()</code></p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#level-changes-with-binaries","title":"Level Changes with Binaries","text":"<p>This pattern models a level variable that can increase or decrease, with changes controlled by binary variables. This is useful for inventory management, capacity adjustments, or gradual state changes.</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#level-evolution","title":"Level Evolution","text":"<p>The level evolves based on increases and decreases:</p> \\[\\label{eq:level_initial} \\ell(0) = \\ell_\\text{init} + \\ell^\\text{inc}(0) - \\ell^\\text{dec}(0) \\] \\[\\label{eq:level_evolution} \\ell(t) = \\ell(t-1) + \\ell^\\text{inc}(t) - \\ell^\\text{dec}(t) \\quad \\forall t &gt; 0 \\] <p>With: - \\(\\ell(t)\\) being the level variable - \\(\\ell_\\text{init}\\) being the initial level - \\(\\ell^\\text{inc}(t)\\) being the increase in level at time \\(t\\) (non-negative) - \\(\\ell^\\text{dec}(t)\\) being the decrease in level at time \\(t\\) (non-negative)</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#change-bounds-with-binary-control","title":"Change Bounds with Binary Control","text":"<p>Changes are bounded and controlled by binary variables:</p> \\[\\label{eq:increase_bound} \\ell^\\text{inc}(t) \\leq \\Delta \\ell^\\text{max} \\cdot b^\\text{inc}(t) \\quad \\forall t \\] \\[\\label{eq:decrease_bound} \\ell^\\text{dec}(t) \\leq \\Delta \\ell^\\text{max} \\cdot b^\\text{dec}(t) \\quad \\forall t \\] <p>With: - \\(\\Delta \\ell^\\text{max}\\) being the maximum change per time step - \\(b^\\text{inc}(t), b^\\text{dec}(t) \\in \\{0, 1\\}\\) being binary control variables</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#mutual-exclusivity-of-changes","title":"Mutual Exclusivity of Changes","text":"<p>Simultaneous increase and decrease are prevented:</p> \\[\\label{eq:change_exclusivity} b^\\text{inc}(t) + b^\\text{dec}(t) \\leq 1 \\quad \\forall t \\] <p>This ensures: - Level can only increase OR decrease (or stay constant) in each time step - No simultaneous contradictory changes</p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#complete-level-change-formulation","title":"Complete Level Change Formulation","text":"\\[ \\begin{align} \\ell(0) &amp;= \\ell_\\text{init} + \\ell^\\text{inc}(0) - \\ell^\\text{dec}(0) &amp;&amp; \\label{eq:level_complete_1} \\\\ \\ell(t) &amp;= \\ell(t-1) + \\ell^\\text{inc}(t) - \\ell^\\text{dec}(t) &amp;&amp; \\forall t &gt; 0 \\label{eq:level_complete_2} \\\\ \\ell^\\text{inc}(t) &amp;\\leq \\Delta \\ell^\\text{max} \\cdot b^\\text{inc}(t) &amp;&amp; \\forall t \\label{eq:level_complete_3} \\\\ \\ell^\\text{dec}(t) &amp;\\leq \\Delta \\ell^\\text{max} \\cdot b^\\text{dec}(t) &amp;&amp; \\forall t \\label{eq:level_complete_4} \\\\ b^\\text{inc}(t) + b^\\text{dec}(t) &amp;\\leq 1 &amp;&amp; \\forall t \\label{eq:level_complete_5} \\\\ b^\\text{inc}(t), b^\\text{dec}(t) &amp;\\in \\{0, 1\\} &amp;&amp; \\forall t \\label{eq:level_complete_6} \\end{align} \\] <p>Implementation: <code>BoundingPatterns.link_changes_to_level_with_binaries()</code></p>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#use-cases","title":"Use Cases","text":""},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#startupshutdown-costs","title":"Startup/Shutdown Costs","text":"<p>Track startup and shutdown events to apply costs:</p> Python<pre><code># Create switch variables\nswitch_on, switch_off = modeling.state_transition_bounds(\n    state_variable=on_state,\n    previous_state=previous_on_state\n)\n\n# Apply costs to switches\nstartup_cost = switch_on * startup_cost_per_event\nshutdown_cost = switch_off * shutdown_cost_per_event\n</code></pre>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#limited-switching","title":"Limited Switching","text":"<p>Restrict the number of state changes:</p> Python<pre><code># Track all switches\nswitch_on, switch_off = modeling.state_transition_bounds(\n    state_variable=on_state\n)\n\n# Limit total switches\nmodel.add_constraint(\n    (switch_on + switch_off).sum() &lt;= max_switches\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#gradual-capacity-changes","title":"Gradual Capacity Changes","text":"<p>Model systems where capacity can be incrementally adjusted:</p> Python<pre><code># Level represents installed capacity\nlevel_var, increase, decrease, inc_binary, dec_binary = \\\n    modeling.link_changes_to_level_with_binaries(\n        initial_level=current_capacity,\n        max_change=max_capacity_change_per_period\n    )\n\n# Constrain total increases\nmodel.add_constraint(increase.sum() &lt;= max_total_expansion)\n</code></pre>"},{"location":"user-guide/mathematical-notation/modeling-patterns/state-transitions/#used-in","title":"Used In","text":"<p>These patterns are used in: - <code>OnOffParameters</code> - Startup/shutdown tracking and costs - Operating mode switching with transition costs - Investment planning with staged capacity additions - Inventory management with controlled stock changes</p>"},{"location":"user-guide/recipes/","title":"Recipes","text":"<p>Coming Soon! \ud83d\udea7</p> <p>This section will contain quick, copy-paste ready code snippets for common FlixOpt patterns.</p>"},{"location":"user-guide/recipes/#what-will-be-here","title":"What Will Be Here?","text":"<p>Short, focused code snippets showing how to do specific things in FlixOpt:</p> <ul> <li>Common modeling patterns</li> <li>Integration with other tools</li> <li>Performance optimizations</li> <li>Domain-specific solutions</li> <li>Data analysis shortcuts</li> </ul> <p>Unlike full examples, recipes will be focused snippets showing a single concept.</p>"},{"location":"user-guide/recipes/#planned-topics","title":"Planned Topics","text":"<ul> <li>Storage Patterns - Batteries, thermal storage, seasonal storage</li> <li>Multi-Criteria Optimization - Balance multiple objectives</li> <li>Data I/O - Loading time series from CSV, databases, APIs</li> <li>Data Manipulation - Common xarray operations for parameterization and analysis</li> <li>Investment Optimization - Size optimization strategies</li> <li>Renewable Integration - Solar, wind capacity optimization</li> <li>On/Off Constraints - Minimum runtime, startup costs</li> <li>Large-Scale Problems - Segmented and aggregated calculations</li> <li>Custom Constraints - Extend models with linopy</li> <li>Domain-Specific Patterns - District heating, microgrids, industrial processes</li> </ul>"},{"location":"user-guide/recipes/#want-to-contribute","title":"Want to Contribute?","text":"<p>We need your help! If you have recurring modeling patterns or clever solutions to share, please contribute via GitHub issues or pull requests.</p> <p>Guidelines: 1. Keep it short (&lt; 100 lines of code) 2. Focus on one specific technique 3. Add brief explanation and when to use it</p> <p>Check the contribution guide for details.</p>"}]}