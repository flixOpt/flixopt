{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FlixOpt","text":"<p>FlixOpt is a Python-based optimization framework designed to tackle energy and material flow problems using mixed-integer linear programming (MILP).</p> <p>It borrows concepts from both FINE and oemof.solph.</p>"},{"location":"#why-flixopt","title":"Why FlixOpt?","text":"<p>FlixOpt is designed as a general-purpose optimization framework to get your model running quickly, without sacrificing flexibility down the road:</p> <ul> <li> <p>Easy to Use API: FlixOpt provides a Pythonic, object-oriented interface that makes mathematical optimization more accessible to Python developers.</p> </li> <li> <p>Approachable Learning Curve: Designed to be accessible from the start, with options for more detailed models down the road.</p> </li> <li> <p>Domain Independence: While frameworks like oemof and FINE excel at energy system modeling with domain-specific components, FlixOpt offers a more general mathematical approach that can be applied across different fields.</p> </li> <li> <p>Extensibility: Easily add custom constraints or variables to any FlixOpt Model using linopy. Tailor any FlixOpt model to your specific needs without loosing the convenience of the framework.</p> </li> <li> <p>Solver Agnostic: Work with different solvers through a consistent interface.</p> </li> <li> <p>Results File I/O: Built to analyze results independent of running the optimization.</p> </li> </ul> <p> </p> Conceptual Usage and IO operations of FlixOpt"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install flixopt\n</code></pre> <p>For more detailed installation options, see the Getting Started guide.</p>"},{"location":"#license","title":"License","text":"<p>FlixOpt is released under the MIT License. See LICENSE for details.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use FlixOpt in your research or project, please cite:</p> <ul> <li>Main Citation: DOI:10.18086/eurosun.2022.04.07</li> <li>Short Overview: DOI:10.13140/RG.2.2.14948.24969</li> </ul> <p>A more sophisticated paper is in progress</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Getting Started</li> <li>User Guide</li> <li>Examples</li> <li>FAQ</li> <li>API-Reference</li> <li>Release Notes</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#212-2025-06-14","title":"[2.1.2] - 2025-06-14","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Storage losses per hour where not calculated correctly, as mentioned by @brokenwings01. This might have lead to issues with modeling large losses and long timesteps. </li> <li>Old implementation:     \\(c(\\text{t}_{i}) \\cdot (1-\\dot{\\text{c}}_\\text{rel,loss}(\\text{t}_i)) \\cdot \\Delta \\text{t}_{i}\\)</li> <li>Correct implementation: \\(c(\\text{t}_{i}) \\cdot (1-\\dot{\\text{c}}_\\text{rel,loss}(\\text{t}_i)) ^{\\Delta \\text{t}_{i}}\\)</li> </ul>"},{"location":"changelog/#known-issues","title":"Known issues","text":"<ul> <li>Just to mention: Plotly &gt;= 6 may raise errors if \"nbformat\" is not installed. We pinned plotly to &lt;6, but this may be fixed in the future.</li> </ul>"},{"location":"changelog/#211-2025-05-08","title":"[2.1.1] - 2025-05-08","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fixed bug in the <code>_ElementResults.constraints</code> not returning the constraints but rather the variables</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Improved docstring and tests</li> </ul>"},{"location":"changelog/#210-2025-04-11","title":"[2.1.0] - 2025-04-11","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Python 3.13 support added</li> <li>Logger warning if relative_minimum is used without on_off_parameters in Flow</li> <li>Greatly improved internal testing infrastructure by leveraging linopy's testing framework</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed the lower bound of <code>flow_rate</code> when using optional investments without OnOffParameters</li> <li>Fixed bug that prevented divest effects from working</li> <li>Added lower bounds of 0 to two unbounded vars (numerical improvement)</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>BREAKING: Restructured the modeling of the On/Off state of Flows or Components</li> <li>Variable renaming: <code>...|consecutive_on_hours</code> \u2192 <code>...|ConsecutiveOn|hours</code></li> <li>Variable renaming: <code>...|consecutive_off_hours</code> \u2192 <code>...|ConsecutiveOff|hours</code></li> <li>Constraint renaming: <code>...|consecutive_on_hours_con1</code> \u2192 <code>...|ConsecutiveOn|con1</code></li> <li>Similar pattern for all consecutive on/off constraints</li> </ul>"},{"location":"changelog/#201-2025-04-10","title":"[2.0.1] - 2025-04-10","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Logger warning if relative_minimum is used without on_off_parameters in Flow</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Replace \"|\" with \"__\" in filenames when saving figures (Windows compatibility)</li> <li>Fixed bug that prevented the load factor from working without InvestmentParameters</li> </ul>"},{"location":"changelog/#200-2025-03-29","title":"[2.0.0] - 2025-03-29","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>BREAKING: Complete migration from Pyomo to Linopy optimization framework</li> <li>BREAKING: Redesigned data handling to rely on xarray.Dataset throughout the package</li> <li>BREAKING: Framework renamed from flixOpt to flixopt (<code>import flixopt as fx</code>)</li> <li>BREAKING: Results handling completely redesigned with new <code>CalculationResults</code> class</li> </ul>"},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Full model serialization support - save and restore unsolved Models</li> <li>Enhanced model documentation with YAML export containing human-readable mathematical formulations</li> <li>Extend flixopt models with native linopy language support</li> <li>Full Model Export/Import capabilities via linopy.Model</li> <li>Unified solution exploration through <code>Calculation.results</code> attribute</li> <li>Compression support for result files</li> <li><code>to_netcdf/from_netcdf</code> methods for FlowSystem and core components</li> <li>xarray integration for TimeSeries with improved datatypes support</li> <li>Google Style Docstrings throughout the codebase</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Improved infeasible model detection and reporting</li> <li>Enhanced time series management and serialization</li> <li>Reduced file size through improved compression</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>BREAKING: Pyomo dependency (replaced by linopy)</li> <li>Period concepts in time management (simplified to timesteps)</li> </ul>"},{"location":"contribute/","title":"Contributing to the Project","text":"<p>We warmly welcome contributions from the community! This guide will help you get started with contributing to our project.</p>"},{"location":"contribute/#development-setup","title":"Development Setup","text":"<ol> <li>Clone the repository <code>git clone https://github.com/flixOpt/flixopt.git</code></li> <li>Install the development dependencies <code>pip install -editable .[dev, docs]</code></li> <li>Run <code>pytest</code> and <code>ruff check .</code> to ensure your code passes all tests</li> </ol>"},{"location":"contribute/#documentation","title":"Documentation","text":"<p>FlixOpt uses mkdocs to generate documentation. To preview the documentation locally, run <code>mkdocs serve</code> in the root directory.</p>"},{"location":"contribute/#helpful-commands","title":"Helpful Commands","text":"<ul> <li><code>mkdocs serve</code> to preview the documentation locally. Navigate to <code>http://127.0.0.1:8000/</code> to view the documentation.</li> <li><code>pytest</code> to run the test suite (You can also run the provided python script <code>run_all_test.py</code>)</li> <li><code>ruff check .</code> to run the linter</li> <li><code>ruff check . --fix</code> to automatically fix linting issues</li> </ul>"},{"location":"contribute/#best-practices","title":"Best practices","text":""},{"location":"contribute/#coding-guidelines","title":"Coding Guidelines","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Write clear, commented code</li> <li>Include type hints</li> <li>Create or update tests for new functionality</li> <li>Ensure 100% test coverage for new code</li> </ul>"},{"location":"contribute/#branches","title":"Branches","text":"<p>As we start to think FlixOpt in Releases, we decided to introduce multiple dev-branches instead of only one: Following the Semantic Versioning guidelines, we introduced: - <code>next/patch</code>: This is where all pull requests for the next patch release (1.0.x) go. - <code>next/minor</code>: This is where all pull requests for the next minor release (1.x.0) go. - <code>next/major</code>: This is where all pull requests for the next major release (x.0.0) go.</p> <p>Everything else remains in <code>feature/...</code>-branches.</p>"},{"location":"contribute/#pull-requests","title":"Pull requests","text":"<p>Every feature or bugfix should be merged into one of the 3 release branches, using Squash and merge or a regular single commit. At some point, <code>next/minor</code> or <code>next/major</code> will get merged into <code>main</code> using a regular Merge  (not squash). This ensures that Features are kept separate, and the <code>next/...</code>branches stay in synch with <code>`main</code>.</p>"},{"location":"contribute/#releases","title":"Releases","text":"<p>As stated, we follow Semantic Versioning. Right after one of the 3 release branches is merged into main, a Tag should be added to the merge commit and pushed to the main branch. The tag has the form <code>v1.2.3</code>. With this tag,  a release with Release Notes must be created. </p> <p>This is our current best practice</p>"},{"location":"getting-started/","title":"Getting Started with FlixOpt","text":"<p>This guide will help you install FlixOpt, understand its basic concepts, and run your first optimization model.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#basic-installation","title":"Basic Installation","text":"<p>Install FlixOpt directly into your environment using pip:</p> <pre><code>pip install flixopt\n</code></pre> <p>This provides the core functionality with the HiGHS solver included.</p>"},{"location":"getting-started/#full-installation","title":"Full Installation","text":"<p>For all features including interactive network visualizations and time series aggregation:</p> <pre><code>pip install \"flixopt[full]\"\"\n</code></pre>"},{"location":"getting-started/#basic-workflow","title":"Basic Workflow","text":"<p>Working with FlixOpt follows a general pattern:</p> <ol> <li>Create a <code>FlowSystem</code> with a time series</li> <li>Define <code>Effects</code> (costs, emissions, etc.)</li> <li>Define <code>Buses</code> as connection points in your system</li> <li>Add <code>Components</code> like converters, storage, sources/sinks with their Flows</li> <li>Run <code>Calculations</code> to optimize your system</li> <li>Analyze <code>Results</code> using built-in or external visualization tools</li> </ol>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you've installed FlixOpt and understand the basic workflow, you can:</p> <ul> <li>Learn about the core concepts of FlixOpt</li> <li>Explore some examples</li> <li>Check the API reference for detailed documentation</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>This section contains the documentation for all modules and classes in flixopt. For more information on how to use the classes and functions, see the Concepts &amp; Math section.</p>"},{"location":"api-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>aggregation</li> <li>calculation</li> <li>commons</li> <li>components</li> <li>config</li> <li>core</li> <li>effects</li> <li>elements</li> <li>features</li> <li>flow_system</li> <li>interface</li> <li>io</li> <li>linear_converters</li> <li>plotting</li> <li>results</li> <li>solvers</li> <li>structure</li> <li>utils</li> </ul>"},{"location":"api-reference/aggregation/","title":"aggregation","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation","title":"flixopt.aggregation","text":"<p>This module contains the Aggregation functionality for the flixopt framework. Through this, aggregating TimeSeriesData is possible.</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation-attributes","title":"Attributes","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation-classes","title":"Classes","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation","title":"Aggregation","text":"<pre><code>Aggregation(\n    original_data: DataFrame,\n    hours_per_time_step: Scalar,\n    hours_per_period: Scalar,\n    nr_of_periods: int = 8,\n    weights: Dict[str, float] = None,\n    time_series_for_high_peaks: List[str] = None,\n    time_series_for_low_peaks: List[str] = None,\n)\n</code></pre> <p>aggregation organizing class</p> <p>Parameters:</p> Name Type Description Default <code>original_data</code> <code>DataFrame</code> <p>The original data to aggregate</p> required <code>hours_per_time_step</code> <code>Scalar</code> <p>The duration of each timestep in hours.</p> required <code>hours_per_period</code> <code>Scalar</code> <p>The duration of each period in hours.</p> required <code>nr_of_periods</code> <code>int</code> <p>The number of typical periods to use in the aggregation.</p> <code>8</code> <code>weights</code> <code>Dict[str, float]</code> <p>The weights for aggregation. If None, all time series are equally weighted.</p> <code>None</code> <code>time_series_for_high_peaks</code> <code>List[str]</code> <p>List of time series to use for explicitly selecting periods with high values.</p> <code>None</code> <code>time_series_for_low_peaks</code> <code>List[str]</code> <p>List of time series to use for explicitly selecting periods with low values.</p> <code>None</code>"},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation-functions","title":"Functions","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation.cluster","title":"cluster","text":"<pre><code>cluster() -&gt; None\n</code></pre> <p>Durchf\u00fchrung der Zeitreihenaggregation</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation.get_cluster_indices","title":"get_cluster_indices","text":"<pre><code>get_cluster_indices() -&gt; Dict[str, List[np.ndarray]]\n</code></pre> <p>Generates a dictionary that maps each cluster to a list of index vectors representing the time steps assigned to that cluster for each period.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, List[ndarray]]</code> <p>{cluster_0: [index_vector_3, index_vector_7, ...],    cluster_1: [index_vector_1],    ...}</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation.get_equation_indices","title":"get_equation_indices","text":"<pre><code>get_equation_indices(\n    skip_first_index_of_period: bool = True,\n) -&gt; Tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Generates pairs of indices for the equations by comparing index vectors of the same cluster. If <code>skip_first_index_of_period</code> is True, the first index of each period is skipped.</p> <p>Parameters:</p> Name Type Description Default <code>skip_first_index_of_period</code> <code>bool</code> <p>Whether to include or skip the first index of each period.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: Two arrays of indices.</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationParameters","title":"AggregationParameters","text":"<pre><code>AggregationParameters(\n    hours_per_period: float,\n    nr_of_periods: int,\n    fix_storage_flows: bool,\n    aggregate_data_and_fix_non_binary_vars: bool,\n    percentage_of_period_freedom: float = 0,\n    penalty_of_period_freedom: float = 0,\n    time_series_for_high_peaks: List[TimeSeriesData] = None,\n    time_series_for_low_peaks: List[TimeSeriesData] = None,\n)\n</code></pre> <p>Initializes aggregation parameters for time series data</p> <p>Parameters:</p> Name Type Description Default <code>hours_per_period</code> <code>float</code> <p>Duration of each period in hours.</p> required <code>nr_of_periods</code> <code>int</code> <p>Number of typical periods to use in the aggregation.</p> required <code>fix_storage_flows</code> <code>bool</code> <p>Whether to aggregate storage flows (load/unload); if other flows are fixed, fixing storage flows is usually not required.</p> required <code>aggregate_data_and_fix_non_binary_vars</code> <code>bool</code> <p>Whether to aggregate all time series data, which allows to fix all time series variables (like flow_rate), or only fix binary variables. If False non time_series data is changed!! If True, the mathematical Problem is simplified even further.</p> required <code>percentage_of_period_freedom</code> <code>float</code> <p>Specifies the maximum percentage (0\u2013100) of binary values within each period that can deviate as \"free variables\", chosen by the solver (default is 0). This allows binary variables to be 'partly equated' between aggregated periods.</p> <code>0</code> <code>penalty_of_period_freedom</code> <code>float</code> <p>The penalty associated with each \"free variable\"; defaults to 0. Added to Penalty</p> <code>0</code> <code>time_series_for_high_peaks</code> <code>List[TimeSeriesData]</code> <p>List of TimeSeriesData to use for explicitly selecting periods with high values.</p> <code>None</code> <code>time_series_for_low_peaks</code> <code>List[TimeSeriesData]</code> <p>List of TimeSeriesData to use for explicitly selecting periods with low values.</p> <code>None</code>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationParameters-functions","title":"Functions","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel","title":"AggregationModel","text":"<pre><code>AggregationModel(\n    model: SystemModel,\n    aggregation_parameters: AggregationParameters,\n    flow_system: FlowSystem,\n    aggregation_data: Aggregation,\n    components_to_clusterize: Optional[List[Component]],\n)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>The AggregationModel holds equations and variables related to the Aggregation of a FLowSystem. It creates Equations that equates indices of variables, and introduces penalties related to binary variables, that escape the equation to their related binaries in other periods</p> <p>Modeling-Element for \"index-equating\"-equations</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel-attributes","title":"Attributes","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel-functions","title":"Functions","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/calculation/","title":"calculation","text":""},{"location":"api-reference/calculation/#flixopt.calculation","title":"flixopt.calculation","text":"<p>This module contains the Calculation functionality for the flixopt framework. It is used to calculate a SystemModel for a given FlowSystem through a solver. There are three different Calculation types:     1. FullCalculation: Calculates the SystemModel for the full FlowSystem     2. AggregatedCalculation: Calculates the SystemModel for the full FlowSystem, but aggregates the TimeSeriesData.         This simplifies the mathematical model and usually speeds up the solving process.     3. SegmentedCalculation: Solves a SystemModel for each individual Segment of the FlowSystem.</p>"},{"location":"api-reference/calculation/#flixopt.calculation-attributes","title":"Attributes","text":""},{"location":"api-reference/calculation/#flixopt.calculation-classes","title":"Classes","text":""},{"location":"api-reference/calculation/#flixopt.calculation.Calculation","title":"Calculation","text":"<pre><code>Calculation(\n    name: str,\n    flow_system: FlowSystem,\n    active_timesteps: Optional[DatetimeIndex] = None,\n    folder: Optional[Path] = None,\n)\n</code></pre> <p>class for defined way of solving a flow_system optimization</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>active_timesteps</code> <code>Optional[DatetimeIndex]</code> <p>list with indices, which should be used for calculation. If None, then all timesteps are used.</p> <code>None</code> <code>folder</code> <code>Optional[Path]</code> <p>folder where results should be saved. If None, then the current working directory is used.</p> <code>None</code>"},{"location":"api-reference/calculation/#flixopt.calculation.Calculation-functions","title":"Functions","text":""},{"location":"api-reference/calculation/#flixopt.calculation.FullCalculation","title":"FullCalculation","text":"<pre><code>FullCalculation(\n    name: str,\n    flow_system: FlowSystem,\n    active_timesteps: Optional[DatetimeIndex] = None,\n    folder: Optional[Path] = None,\n)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>class for defined way of solving a flow_system optimization</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>active_timesteps</code> <code>Optional[DatetimeIndex]</code> <p>list with indices, which should be used for calculation. If None, then all timesteps are used.</p> <code>None</code> <code>folder</code> <code>Optional[Path]</code> <p>folder where results should be saved. If None, then the current working directory is used.</p> <code>None</code>"},{"location":"api-reference/calculation/#flixopt.calculation.FullCalculation-functions","title":"Functions","text":""},{"location":"api-reference/calculation/#flixopt.calculation.AggregatedCalculation","title":"AggregatedCalculation","text":"<pre><code>AggregatedCalculation(\n    name: str,\n    flow_system: FlowSystem,\n    aggregation_parameters: AggregationParameters,\n    components_to_clusterize: Optional[List[Component]] = None,\n    active_timesteps: Optional[DatetimeIndex] = None,\n    folder: Optional[Path] = None,\n)\n</code></pre> <p>               Bases: <code>FullCalculation</code></p> <p>class for defined way of solving a flow_system optimization</p> <p>Class for Optimizing the <code>FlowSystem</code> including:     1. Aggregating TimeSeriesData via typical periods using tsam.     2. Equalizing variables of typical periods. Args:     name: name of calculation     flow_system: flow_system which should be calculated     aggregation_parameters: Parameters for aggregation. See documentation of AggregationParameters class.     components_to_clusterize: List of Components to perform aggregation on. If None, then all components are aggregated.         This means, teh variables in the components are equalized to each other, according to the typical periods         computed in the DataAggregation     active_timesteps: pd.DatetimeIndex or None         list with indices, which should be used for calculation. If None, then all timesteps are used.     folder: folder where results should be saved. If None, then the current working directory is used.</p>"},{"location":"api-reference/calculation/#flixopt.calculation.AggregatedCalculation-functions","title":"Functions","text":""},{"location":"api-reference/calculation/#flixopt.calculation.SegmentedCalculation","title":"SegmentedCalculation","text":"<pre><code>SegmentedCalculation(\n    name: str,\n    flow_system: FlowSystem,\n    timesteps_per_segment: int,\n    overlap_timesteps: int,\n    nr_of_previous_values: int = 1,\n    folder: Optional[Path] = None,\n)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>Dividing and Modeling the problem in (overlapping) segments. The final values of each Segment are recognized by the following segment, effectively coupling charge_states and flow_rates between segments. Because of this intersection, both modeling and solving is done in one step</p> <p>Take care: Parameters like InvestParameters, sum_of_flow_hours and other restrictions over the total time_series don't really work in this Calculation. Lower bounds to such SUMS can lead to weird results. This is NOT yet explicitly checked for...</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>timesteps_per_segment</code> <code>int</code> <p>The number of time_steps per individual segment (without the overlap)</p> required <code>overlap_timesteps</code> <code>int</code> <p>The number of time_steps that are added to each individual model. Used for better results of storages)</p> required <code>folder</code> <code>Optional[Path]</code> <p>folder where results should be saved. If None, then the current working directory is used.</p> <code>None</code>"},{"location":"api-reference/calculation/#flixopt.calculation.SegmentedCalculation-attributes","title":"Attributes","text":""},{"location":"api-reference/calculation/#flixopt.calculation.SegmentedCalculation.start_values_of_segments","title":"start_values_of_segments  <code>property</code>","text":"<pre><code>start_values_of_segments: Dict[int, Dict[str, Any]]\n</code></pre> <p>Gives an overview of the start values of all Segments</p>"},{"location":"api-reference/calculation/#flixopt.calculation.SegmentedCalculation-functions","title":"Functions","text":""},{"location":"api-reference/calculation/#flixopt.calculation-functions","title":"Functions","text":""},{"location":"api-reference/commons/","title":"commons","text":""},{"location":"api-reference/commons/#flixopt.commons","title":"flixopt.commons","text":"<p>This module makes the commonly used classes and functions available in the flixopt framework.</p>"},{"location":"api-reference/commons/#flixopt.commons-classes","title":"Classes","text":""},{"location":"api-reference/commons/#flixopt.commons.AggregationParameters","title":"AggregationParameters","text":"<pre><code>AggregationParameters(\n    hours_per_period: float,\n    nr_of_periods: int,\n    fix_storage_flows: bool,\n    aggregate_data_and_fix_non_binary_vars: bool,\n    percentage_of_period_freedom: float = 0,\n    penalty_of_period_freedom: float = 0,\n    time_series_for_high_peaks: List[TimeSeriesData] = None,\n    time_series_for_low_peaks: List[TimeSeriesData] = None,\n)\n</code></pre> <p>Initializes aggregation parameters for time series data</p> <p>Parameters:</p> Name Type Description Default <code>hours_per_period</code> <code>float</code> <p>Duration of each period in hours.</p> required <code>nr_of_periods</code> <code>int</code> <p>Number of typical periods to use in the aggregation.</p> required <code>fix_storage_flows</code> <code>bool</code> <p>Whether to aggregate storage flows (load/unload); if other flows are fixed, fixing storage flows is usually not required.</p> required <code>aggregate_data_and_fix_non_binary_vars</code> <code>bool</code> <p>Whether to aggregate all time series data, which allows to fix all time series variables (like flow_rate), or only fix binary variables. If False non time_series data is changed!! If True, the mathematical Problem is simplified even further.</p> required <code>percentage_of_period_freedom</code> <code>float</code> <p>Specifies the maximum percentage (0\u2013100) of binary values within each period that can deviate as \"free variables\", chosen by the solver (default is 0). This allows binary variables to be 'partly equated' between aggregated periods.</p> <code>0</code> <code>penalty_of_period_freedom</code> <code>float</code> <p>The penalty associated with each \"free variable\"; defaults to 0. Added to Penalty</p> <code>0</code> <code>time_series_for_high_peaks</code> <code>List[TimeSeriesData]</code> <p>List of TimeSeriesData to use for explicitly selecting periods with high values.</p> <code>None</code> <code>time_series_for_low_peaks</code> <code>List[TimeSeriesData]</code> <p>List of TimeSeriesData to use for explicitly selecting periods with low values.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.AggregationParameters-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.AggregatedCalculation","title":"AggregatedCalculation","text":"<pre><code>AggregatedCalculation(\n    name: str,\n    flow_system: FlowSystem,\n    aggregation_parameters: AggregationParameters,\n    components_to_clusterize: Optional[List[Component]] = None,\n    active_timesteps: Optional[DatetimeIndex] = None,\n    folder: Optional[Path] = None,\n)\n</code></pre> <p>               Bases: <code>FullCalculation</code></p> <p>class for defined way of solving a flow_system optimization</p> <p>Class for Optimizing the <code>FlowSystem</code> including:     1. Aggregating TimeSeriesData via typical periods using tsam.     2. Equalizing variables of typical periods. Args:     name: name of calculation     flow_system: flow_system which should be calculated     aggregation_parameters: Parameters for aggregation. See documentation of AggregationParameters class.     components_to_clusterize: List of Components to perform aggregation on. If None, then all components are aggregated.         This means, teh variables in the components are equalized to each other, according to the typical periods         computed in the DataAggregation     active_timesteps: pd.DatetimeIndex or None         list with indices, which should be used for calculation. If None, then all timesteps are used.     folder: folder where results should be saved. If None, then the current working directory is used.</p>"},{"location":"api-reference/commons/#flixopt.commons.AggregatedCalculation-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.FullCalculation","title":"FullCalculation","text":"<pre><code>FullCalculation(\n    name: str,\n    flow_system: FlowSystem,\n    active_timesteps: Optional[DatetimeIndex] = None,\n    folder: Optional[Path] = None,\n)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>class for defined way of solving a flow_system optimization</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>active_timesteps</code> <code>Optional[DatetimeIndex]</code> <p>list with indices, which should be used for calculation. If None, then all timesteps are used.</p> <code>None</code> <code>folder</code> <code>Optional[Path]</code> <p>folder where results should be saved. If None, then the current working directory is used.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.FullCalculation-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.SegmentedCalculation","title":"SegmentedCalculation","text":"<pre><code>SegmentedCalculation(\n    name: str,\n    flow_system: FlowSystem,\n    timesteps_per_segment: int,\n    overlap_timesteps: int,\n    nr_of_previous_values: int = 1,\n    folder: Optional[Path] = None,\n)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>Dividing and Modeling the problem in (overlapping) segments. The final values of each Segment are recognized by the following segment, effectively coupling charge_states and flow_rates between segments. Because of this intersection, both modeling and solving is done in one step</p> <p>Take care: Parameters like InvestParameters, sum_of_flow_hours and other restrictions over the total time_series don't really work in this Calculation. Lower bounds to such SUMS can lead to weird results. This is NOT yet explicitly checked for...</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>timesteps_per_segment</code> <code>int</code> <p>The number of time_steps per individual segment (without the overlap)</p> required <code>overlap_timesteps</code> <code>int</code> <p>The number of time_steps that are added to each individual model. Used for better results of storages)</p> required <code>folder</code> <code>Optional[Path]</code> <p>folder where results should be saved. If None, then the current working directory is used.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.SegmentedCalculation-attributes","title":"Attributes","text":""},{"location":"api-reference/commons/#flixopt.commons.SegmentedCalculation.start_values_of_segments","title":"start_values_of_segments  <code>property</code>","text":"<pre><code>start_values_of_segments: Dict[int, Dict[str, Any]]\n</code></pre> <p>Gives an overview of the start values of all Segments</p>"},{"location":"api-reference/commons/#flixopt.commons.SegmentedCalculation-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.LinearConverter","title":"LinearConverter","text":"<pre><code>LinearConverter(\n    label: str,\n    inputs: List[Flow],\n    outputs: List[Flow],\n    on_off_parameters: OnOffParameters = None,\n    conversion_factors: List[Dict[str, NumericDataTS]] = None,\n    piecewise_conversion: Optional[PiecewiseConversion] = None,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Converts input-Flows into output-Flows via linear conversion factors</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>inputs</code> <code>List[Flow]</code> <p>The input Flows</p> required <code>outputs</code> <code>List[Flow]</code> <p>The output Flows</p> required <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Information about on and off state of LinearConverter. Component is On/Off, if all connected Flows are On/Off. This induces an On-Variable (binary) in all Flows! If possible, use OnOffParameters in a single Flow instead to keep the number of binary variables low. See class OnOffParameters.</p> <code>None</code> <code>conversion_factors</code> <code>List[Dict[str, NumericDataTS]]</code> <p>linear relation between flows. Either 'conversion_factors' or 'piecewise_conversion' can be used!</p> <code>None</code> <code>piecewise_conversion</code> <code>Optional[PiecewiseConversion]</code> <p>Define a piecewise linear relation between flow rates of different flows. Either 'conversion_factors' or 'piecewise_conversion' can be used!</p> <code>None</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.LinearConverter.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Sink","title":"Sink","text":"<pre><code>Sink(label: str, sink: Flow, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>sink</code> <code>Flow</code> <p>input-flow of sink</p> required"},{"location":"api-reference/commons/#flixopt.commons.Sink-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Sink.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Sink.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Sink.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Source","title":"Source","text":"<pre><code>Source(label: str, source: Flow, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>source</code> <code>Flow</code> <p>output-flow of source</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.Source-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Source.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Source.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Source.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink","title":"SourceAndSink","text":"<pre><code>SourceAndSink(\n    label: str,\n    source: Flow,\n    sink: Flow,\n    prevent_simultaneous_sink_and_source: bool = True,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>class for source (output-flow) and sink (input-flow) in one commponent</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>source</code> <code>Flow</code> <p>output-flow of this component</p> required <code>sink</code> <code>Flow</code> <p>input-flow of this component</p> required <code>prevent_simultaneous_sink_and_source</code> <code>bool</code> <p>If True, inflow and outflow can not be active simultaniously.</p> <code>True</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Storage","title":"Storage","text":"<pre><code>Storage(\n    label: str,\n    charging: Flow,\n    discharging: Flow,\n    capacity_in_flow_hours: Union[Scalar, InvestParameters],\n    relative_minimum_charge_state: NumericData = 0,\n    relative_maximum_charge_state: NumericData = 1,\n    initial_charge_state: Union[Scalar, Literal['lastValueOfSim']] = 0,\n    minimal_final_charge_state: Optional[Scalar] = None,\n    maximal_final_charge_state: Optional[Scalar] = None,\n    eta_charge: NumericData = 1,\n    eta_discharge: NumericData = 1,\n    relative_loss_per_hour: NumericData = 0,\n    prevent_simultaneous_charge_and_discharge: bool = True,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Used to model the storage of energy or material.</p> <p>Storages have one incoming and one outgoing Flow each with an efficiency. Further, storages have a <code>size</code> and a <code>charge_state</code>. Similarly to the flow-rate of a Flow, the <code>size</code> combined with a relative upper and lower bound limits the <code>charge_state</code> of the storage.</p> <p>For mathematical details take a look at our online documentation</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>charging</code> <code>Flow</code> <p>ingoing flow.</p> required <code>discharging</code> <code>Flow</code> <p>outgoing flow.</p> required <code>capacity_in_flow_hours</code> <code>Union[Scalar, InvestParameters]</code> <p>nominal capacity/size of the storage</p> required <code>relative_minimum_charge_state</code> <code>NumericData</code> <p>minimum relative charge state. The default is 0.</p> <code>0</code> <code>relative_maximum_charge_state</code> <code>NumericData</code> <p>maximum relative charge state. The default is 1.</p> <code>1</code> <code>initial_charge_state</code> <code>Union[Scalar, Literal['lastValueOfSim']]</code> <p>storage charge_state at the beginning. The default is 0.</p> <code>0</code> <code>minimal_final_charge_state</code> <code>Optional[Scalar]</code> <p>minimal value of chargeState at the end of timeseries.</p> <code>None</code> <code>maximal_final_charge_state</code> <code>Optional[Scalar]</code> <p>maximal value of chargeState at the end of timeseries.</p> <code>None</code> <code>eta_charge</code> <code>NumericData</code> <p>efficiency factor of charging/loading. The default is 1.</p> <code>1</code> <code>eta_discharge</code> <code>NumericData</code> <p>efficiency factor of uncharging/unloading. The default is 1.</p> <code>1</code> <code>relative_loss_per_hour</code> <code>NumericData</code> <p>loss per chargeState-Unit per hour. The default is 0.</p> <code>0</code> <code>prevent_simultaneous_charge_and_discharge</code> <code>bool</code> <p>If True, loading and unloading at the same time is not possible. Increases the number of binary variables, but is recommended for easier evaluation. The default is True.</p> <code>True</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.Storage-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Storage.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Storage.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Storage.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Transmission","title":"Transmission","text":"<pre><code>Transmission(\n    label: str,\n    in1: Flow,\n    out1: Flow,\n    in2: Optional[Flow] = None,\n    out2: Optional[Flow] = None,\n    relative_losses: Optional[NumericDataTS] = None,\n    absolute_losses: Optional[NumericDataTS] = None,\n    on_off_parameters: OnOffParameters = None,\n    prevent_simultaneous_flows_in_both_directions: bool = True,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Initializes a Transmission component (Pipe, cable, ...) that models the flows between two sides with potential losses.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>in1</code> <code>Flow</code> <p>The inflow at side A. Pass InvestmentParameters here.</p> required <code>out1</code> <code>Flow</code> <p>The outflow at side B.</p> required <code>in2</code> <code>Optional[Flow]</code> <p>The optional inflow at side B. If in1 got InvestParameters, the size of this Flow will be equal to in1 (with no extra effects!)</p> <code>None</code> <code>out2</code> <code>Optional[Flow]</code> <p>The optional outflow at side A.</p> <code>None</code> <code>relative_losses</code> <code>Optional[NumericDataTS]</code> <p>The relative loss between inflow and outflow, e.g., 0.02 for 2% loss.</p> <code>None</code> <code>absolute_losses</code> <code>Optional[NumericDataTS]</code> <p>The absolute loss, occur only when the Flow is on. Induces the creation of the ON-Variable</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Parameters defining the on/off behavior of the component.</p> <code>None</code> <code>prevent_simultaneous_flows_in_both_directions</code> <code>bool</code> <p>If True, inflow and outflow are not allowed to be both non-zero at same timestep.</p> <code>True</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.Transmission-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Transmission.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Transmission.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Transmission.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.CONFIG","title":"CONFIG","text":"<p>A configuration class that stores global configuration values as class attributes.</p>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.CONFIG.load_config","title":"load_config  <code>classmethod</code>","text":"<pre><code>load_config(user_config_file: Optional[str] = None)\n</code></pre> <p>Initialize configuration using defaults or user-specified file.</p>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG.to_dict","title":"to_dict  <code>classmethod</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the configuration class into a dictionary for JSON serialization. Handles dataclasses and simple types like str, int, etc.</p>"},{"location":"api-reference/commons/#flixopt.commons.TimeSeriesData","title":"TimeSeriesData","text":"<pre><code>TimeSeriesData(\n    data: NumericData,\n    agg_group: Optional[str] = None,\n    agg_weight: Optional[float] = None,\n)\n</code></pre> <p>timeseries class for transmit timeseries AND special characteristics of timeseries, i.g. to define weights needed in calculation_type 'aggregated'     EXAMPLE solar:     you have several solar timeseries. These should not be overweighted     compared to the remaining timeseries (i.g. heat load, price)!     fixed_relative_profile_solar1 = TimeSeriesData(sol_array_1, type = 'solar')     fixed_relative_profile_solar2 = TimeSeriesData(sol_array_2, type = 'solar')     fixed_relative_profile_solar3 = TimeSeriesData(sol_array_3, type = 'solar')     --&gt; this 3 series of same type share one weight, i.e. internally assigned each weight = 1/3     (instead of standard weight = 1)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NumericData</code> <p>The timeseries data, which can be a scalar, array, or numpy array.</p> required <code>agg_group</code> <code>Optional[str]</code> <p>The group this TimeSeriesData is a part of. agg_weight is split between members of a group. Default is None.</p> <code>None</code> <code>agg_weight</code> <code>Optional[float]</code> <p>The weight for calculation_type 'aggregated', should be between 0 and 1. Default is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If both agg_group and agg_weight are set, an exception is raised.</p>"},{"location":"api-reference/commons/#flixopt.commons.TimeSeriesData-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Effect","title":"Effect","text":"<pre><code>Effect(\n    label: str,\n    unit: str,\n    description: str,\n    meta_data: Optional[Dict] = None,\n    is_standard: bool = False,\n    is_objective: bool = False,\n    specific_share_to_other_effects_operation: Optional[\n        EffectValuesUser\n    ] = None,\n    specific_share_to_other_effects_invest: Optional[EffectValuesUser] = None,\n    minimum_operation: Optional[Scalar] = None,\n    maximum_operation: Optional[Scalar] = None,\n    minimum_invest: Optional[Scalar] = None,\n    maximum_invest: Optional[Scalar] = None,\n    minimum_operation_per_hour: Optional[NumericDataTS] = None,\n    maximum_operation_per_hour: Optional[NumericDataTS] = None,\n    minimum_total: Optional[Scalar] = None,\n    maximum_total: Optional[Scalar] = None,\n)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Effect, i.g. costs, CO2 emissions, area, ... Components, FLows, and so on can contribute to an Effect. One Effect is chosen as the Objective of the Optimization</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>unit</code> <code>str</code> <p>The unit of effect, i.g. \u20ac, kg_CO2, kWh_primaryEnergy</p> required <code>description</code> <code>str</code> <p>The long name</p> required <code>is_standard</code> <code>bool</code> <p>true, if Standard-Effect (for direct input of value without effect (alternatively to dict)) , else false</p> <code>False</code> <code>is_objective</code> <code>bool</code> <p>true, if optimization target</p> <code>False</code> <code>specific_share_to_other_effects_operation</code> <code>Optional[EffectValuesUser]</code> <p>{effectType: TS, ...}, i.g. 180 \u20ac/t_CO2, input as {costs: 180}, optional share to other effects (only operation)</p> <code>None</code> <code>specific_share_to_other_effects_invest</code> <code>Optional[EffectValuesUser]</code> <p>{effectType: TS, ...}, i.g. 180 \u20ac/t_CO2, input as {costs: 180}, optional share to other effects (only invest).</p> <code>None</code> <code>minimum_operation</code> <code>Optional[Scalar]</code> <p>minimal sum (only operation) of the effect.</p> <code>None</code> <code>maximum_operation</code> <code>Optional[Scalar]</code> <p>maximal sum (nur operation) of the effect.</p> <code>None</code> <code>minimum_operation_per_hour</code> <code>Optional[NumericDataTS]</code> <p>max. value per hour (only operation) of effect (=sum of all effect-shares) for each timestep!</p> <code>None</code> <code>maximum_operation_per_hour</code> <code>Optional[NumericDataTS]</code> <p>min. value per hour (only operation) of effect (=sum of all effect-shares) for each timestep!</p> <code>None</code> <code>minimum_invest</code> <code>Optional[Scalar]</code> <p>minimal sum (only invest) of the effect</p> <code>None</code> <code>maximum_invest</code> <code>Optional[Scalar]</code> <p>maximal sum (only invest) of the effect</p> <code>None</code> <code>minimum_total</code> <code>Optional[Scalar]</code> <p>min sum of effect (invest+operation).</p> <code>None</code> <code>maximum_total</code> <code>Optional[Scalar]</code> <p>max sum of effect (invest+operation).</p> <code>None</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.Effect-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Effect.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Effect.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Bus","title":"Bus","text":"<pre><code>Bus(\n    label: str,\n    excess_penalty_per_flow_hour: Optional[NumericDataTS] = 100000.0,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>A Bus represents a nodal balance between the flow rates of its incoming and outgoing Flows.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>excess_penalty_per_flow_hour</code> <code>Optional[NumericDataTS]</code> <p>excess costs / penalty costs (bus balance compensation) (none/ 0 -&gt; no penalty). The default is 1e5. (Take care: if you use a timeseries (no scalar), timeseries is aggregated if calculation_type = aggregated!)</p> <code>100000.0</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.Bus-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Bus.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.Bus.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Bus.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Bus.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Flow","title":"Flow","text":"<pre><code>Flow(\n    label: str,\n    bus: str,\n    size: Union[Scalar, InvestParameters] = None,\n    fixed_relative_profile: Optional[NumericDataTS] = None,\n    relative_minimum: NumericDataTS = 0,\n    relative_maximum: NumericDataTS = 1,\n    effects_per_flow_hour: Optional[EffectValuesUser] = None,\n    on_off_parameters: Optional[OnOffParameters] = None,\n    flow_hours_total_max: Optional[Scalar] = None,\n    flow_hours_total_min: Optional[Scalar] = None,\n    load_factor_min: Optional[Scalar] = None,\n    load_factor_max: Optional[Scalar] = None,\n    previous_flow_rate: Optional[NumericData] = None,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>A Flow moves energy (or material) between a Bus and a Component in a predefined direction. The flow-rate is the main optimization variable of the Flow.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the FLow. Used to identify it in the FlowSystem. Its <code>full_label</code> consists of the label of the Component and the label of the Flow.</p> required <code>bus</code> <code>str</code> <p>blabel of the bus the flow is connected to.</p> required <code>size</code> <code>Union[Scalar, InvestParameters]</code> <p>size of the flow. If InvestmentParameters is used, size is optimized. If size is None, a default value is used.</p> <code>None</code> <code>relative_minimum</code> <code>NumericDataTS</code> <p>min value is relative_minimum multiplied by size</p> <code>0</code> <code>relative_maximum</code> <code>NumericDataTS</code> <p>max value is relative_maximum multiplied by size. If size = max then relative_maximum=1</p> <code>1</code> <code>load_factor_min</code> <code>Optional[Scalar]</code> <p>minimal load factor  general: avg Flow per nominalVal/investSize (e.g. boiler, kW/kWh=h; solarthermal: kW/m\u00b2;  def: :math:<code>load\\_factor:= sumFlowHours/ (nominal\\_val \\cdot \\Delta t_{tot})</code></p> <code>None</code> <code>load_factor_max</code> <code>Optional[Scalar]</code> <p>maximal load factor (see minimal load factor)</p> <code>None</code> <code>effects_per_flow_hour</code> <code>Optional[EffectValuesUser]</code> <p>operational costs, costs per flow-\"work\"</p> <code>None</code> <code>on_off_parameters</code> <code>Optional[OnOffParameters]</code> <p>If present, flow can be \"off\", i.e. be zero (only relevant if relative_minimum &gt; 0) Therefore a binary var \"on\" is used. Further, several other restrictions and effects can be modeled through this On/Off State (See OnOffParameters)</p> <code>None</code> <code>flow_hours_total_max</code> <code>Optional[Scalar]</code> <p>maximum flow-hours (\"flow-work\") (if size is not const, maybe load_factor_max is the better choice!)</p> <code>None</code> <code>flow_hours_total_min</code> <code>Optional[Scalar]</code> <p>minimum flow-hours (\"flow-work\") (if size is not predefined, maybe load_factor_min is the better choice!)</p> <code>None</code> <code>fixed_relative_profile</code> <code>Optional[NumericDataTS]</code> <p>fixed relative values for flow (if given). flow_rate(t) := fixed_relative_profile(t) * size(t) With this value, the flow_rate is no optimization-variable anymore. (relative_minimum and relative_maximum are ignored) used for fixed load or supply profiles, i.g. heat demand, wind-power, solarthermal If the load-profile is just an upper limit, use relative_maximum instead.</p> <code>None</code> <code>previous_flow_rate</code> <code>Optional[NumericData]</code> <p>previous flow rate of the flow. Used to determine if and how long the flow is already on / off. If None, the flow is considered to be off for one timestep.</p> <code>None</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.Flow-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Flow.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Flow.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem","title":"FlowSystem","text":"<pre><code>FlowSystem(\n    timesteps: DatetimeIndex,\n    hours_of_last_timestep: Optional[float] = None,\n    hours_of_previous_timesteps: Optional[Union[int, float, ndarray]] = None,\n)\n</code></pre> <p>A FlowSystem organizes the high level Elements (Components &amp; Effects).</p> <p>Parameters:</p> Name Type Description Default <code>timesteps</code> <code>DatetimeIndex</code> <p>The timesteps of the model.</p> required <code>hours_of_last_timestep</code> <code>Optional[float]</code> <p>The duration of the last time step. Uses the last time interval if not specified</p> <code>None</code> <code>hours_of_previous_timesteps</code> <code>Optional[Union[int, float, ndarray]]</code> <p>The duration of previous timesteps. If None, the first time increment of time_series is used. This is needed to calculate previous durations (for example consecutive_on_hours). If you use an array, take care that its long enough to cover all previous values!</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; FlowSystem\n</code></pre> <p>Load a FlowSystem from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the FlowSystem data.</p> required"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: Union[str, Path])\n</code></pre> <p>Load a FlowSystem from a netcdf file</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.add_elements","title":"add_elements","text":"<pre><code>add_elements(*elements: Element) -&gt; None\n</code></pre> <p>Add Components(Storages, Boilers, Heatpumps, ...), Buses or Effects to the FlowSystem</p> <p>Parameters:</p> Name Type Description Default <code>*elements</code> <code>Element</code> <p>childs of  Element like Boiler, HeatPump, Bus,... modeling Elements</p> <code>()</code>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the flow system to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the flow_system to others.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.as_dict","title":"as_dict","text":"<pre><code>as_dict(data_mode: Literal['data', 'name', 'stats'] = 'data') -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.as_dataset","title":"as_dataset","text":"<pre><code>as_dataset(constants_in_dataset: bool = False) -&gt; xr.Dataset\n</code></pre> <p>Convert the FlowSystem to a xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>constants_in_dataset</code> <code>bool</code> <p>If True, constants are included as Dataset variables.</p> <code>False</code>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(\n    path: Union[str, Path],\n    compression: int = 0,\n    constants_in_dataset: bool = True,\n)\n</code></pre> <p>Saves the FlowSystem to a netCDF file. Args:     path: The path to the netCDF file.     compression: The compression level to use when saving the file.     constants_in_dataset: If True, constants are included as Dataset variables.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.plot_network","title":"plot_network","text":"<pre><code>plot_network(\n    path: Union[bool, str, Path] = 'flow_system.html',\n    controls: Union[\n        bool,\n        List[\n            Literal[\n                'nodes',\n                'edges',\n                'layout',\n                'interaction',\n                'manipulation',\n                'physics',\n                'selection',\n                'renderer',\n            ]\n        ],\n    ] = True,\n    show: bool = False,\n) -&gt; Optional[pyvis.network.Network]\n</code></pre> <p>Visualizes the network structure of a FlowSystem using PyVis, saving it as an interactive HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[bool, str, Path]</code> <p>Path to save the HTML visualization. - <code>False</code>: Visualization is created but not saved. - <code>str</code> or <code>Path</code>: Specifies file path (default: 'flow_system.html').</p> <code>'flow_system.html'</code> <code>controls</code> <code>Union[bool, List[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]]</code> <p>UI controls to add to the visualization. - <code>True</code>: Enables all available controls. - <code>List</code>: Specify controls, e.g., ['nodes', 'layout']. - Options: 'nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer'.</p> <code>True</code> <code>show</code> <code>bool</code> <p>Whether to open the visualization in the web browser.</p> <code>False</code> <p>Returns: - Optional[pyvis.network.Network]: The <code>Network</code> instance representing the visualization, or <code>None</code> if <code>pyvis</code> is not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.plot_network()\n&gt;&gt;&gt; flow_system.plot_network(show=False)\n&gt;&gt;&gt; flow_system.plot_network(path='output/custom_network.html', controls=['nodes', 'layout'])\n</code></pre> <p>Notes: - This function requires <code>pyvis</code>. If not installed, the function prints a warning and returns <code>None</code>. - Nodes are styled based on type (e.g., circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.create_time_series","title":"create_time_series","text":"<pre><code>create_time_series(\n    name: str,\n    data: Optional[Union[NumericData, TimeSeriesData, TimeSeries]],\n    needs_extra_timestep: bool = False,\n) -&gt; Optional[TimeSeries]\n</code></pre> <p>Tries to create a TimeSeries from NumericData Data and adds it to the time_series_collection If the data already is a TimeSeries, nothing happens and the TimeSeries gets reset and returned If the data is a TimeSeriesData, it is converted to a TimeSeries, and the aggregation weights are applied. If the data is None, nothing happens.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.create_effect_time_series","title":"create_effect_time_series","text":"<pre><code>create_effect_time_series(\n    label_prefix: Optional[str],\n    effect_values: EffectValuesUser,\n    label_suffix: Optional[str] = None,\n) -&gt; Optional[EffectTimeSeries]\n</code></pre> <p>Transform EffectValues to EffectTimeSeries. Creates a TimeSeries for each key in the nested_values dictionary, using the value as the data.</p> <p>The resulting label of the TimeSeries is the label of the parent_element, followed by the label of the Effect in the nested_values and the label_suffix. If the key in the EffectValues is None, the alias 'Standard_Effect' is used</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters","title":"InvestParameters","text":"<pre><code>InvestParameters(\n    fixed_size: Optional[Union[int, float]] = None,\n    minimum_size: Optional[Union[int, float]] = None,\n    maximum_size: Optional[Union[int, float]] = None,\n    optional: bool = True,\n    fix_effects: Optional[EffectValuesUserScalar] = None,\n    specific_effects: Optional[EffectValuesUserScalar] = None,\n    piecewise_effects: Optional[PiecewiseEffects] = None,\n    divest_effects: Optional[EffectValuesUserScalar] = None,\n)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>collects arguments for invest-stuff</p> <p>Parameters:</p> Name Type Description Default <code>fix_effects</code> <code>Optional[EffectValuesUserScalar]</code> <p>Fixed investment costs if invested. (Attention: Annualize costs to chosen period!)</p> <code>None</code> <code>divest_effects</code> <code>Optional[EffectValuesUserScalar]</code> <p>Fixed divestment costs (if not invested, e.g., demolition costs or contractual penalty).</p> <code>None</code> <code>fixed_size</code> <code>Optional[Union[int, float]]</code> <p>Determines if the investment size is fixed.</p> <code>None</code> <code>optional</code> <code>bool</code> <p>If True, investment is not forced.</p> <code>True</code> <code>specific_effects</code> <code>Optional[EffectValuesUserScalar]</code> <p>Specific costs, e.g., in \u20ac/kW_nominal or \u20ac/m\u00b2_nominal. Example: {costs: 3, CO2: 0.3} with costs and CO2 representing an Object of class Effect (Attention: Annualize costs to chosen period!)</p> <code>None</code> <code>piecewise_effects</code> <code>Optional[PiecewiseEffects]</code> <p>Linear piecewise relation [invest_pieces, cost_pieces]. Example 1:     [           [5, 25, 25, 100],       # size in kW      {costs:    [50,250,250,800],       # \u20ac       PE:       [5, 25, 25, 100]        # kWh_PrimaryEnergy       }     ] Example 2 (if only standard-effect):     [   [5, 25, 25, 100],  # kW # size in kW         [50,250,250,800]        # value for standart effect, typically \u20ac      ]  # \u20ac (Attention: Annualize costs to chosen period!) (Args 'specific_effects' and 'fix_effects' can be used in parallel to Investsizepieces)</p> <code>None</code> <code>minimum_size</code> <code>Optional[Union[int, float]]</code> <p>Min nominal value (only if: size_is_fixed = False). Defaults to CONFIG.modeling.EPSILON.</p> <code>None</code> <code>maximum_size</code> <code>Optional[Union[int, float]]</code> <p>Max nominal value (only if: size_is_fixed = False). Defaults to CONFIG.modeling.BIG.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters","title":"OnOffParameters","text":"<pre><code>OnOffParameters(\n    effects_per_switch_on: Optional[EffectValuesUser] = None,\n    effects_per_running_hour: Optional[EffectValuesUser] = None,\n    on_hours_total_min: Optional[int] = None,\n    on_hours_total_max: Optional[int] = None,\n    consecutive_on_hours_min: Optional[NumericData] = None,\n    consecutive_on_hours_max: Optional[NumericData] = None,\n    consecutive_off_hours_min: Optional[NumericData] = None,\n    consecutive_off_hours_max: Optional[NumericData] = None,\n    switch_on_total_max: Optional[int] = None,\n    force_switch_on: bool = False,\n)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Bundles information about the on and off state of an Element. If no parameters are given, the default is to create a binary variable for the on state without further constraints or effects and a variable for the total on hours.</p> <p>Parameters:</p> Name Type Description Default <code>effects_per_switch_on</code> <code>Optional[EffectValuesUser]</code> <p>cost of one switch from off (var_on=0) to on (var_on=1), unit i.g. in Euro</p> <code>None</code> <code>effects_per_running_hour</code> <code>Optional[EffectValuesUser]</code> <p>costs for operating, i.g. in \u20ac per hour</p> <code>None</code> <code>on_hours_total_min</code> <code>Optional[int]</code> <p>min. overall sum of operating hours.</p> <code>None</code> <code>on_hours_total_max</code> <code>Optional[int]</code> <p>max. overall sum of operating hours.</p> <code>None</code> <code>consecutive_on_hours_min</code> <code>Optional[NumericData]</code> <p>min sum of operating hours in one piece (last on-time period of timeseries is not checked and can be shorter)</p> <code>None</code> <code>consecutive_on_hours_max</code> <code>Optional[NumericData]</code> <p>max sum of operating hours in one piece</p> <code>None</code> <code>consecutive_off_hours_min</code> <code>Optional[NumericData]</code> <p>min sum of non-operating hours in one piece (last off-time period of timeseries is not checked and can be shorter)</p> <code>None</code> <code>consecutive_off_hours_max</code> <code>Optional[NumericData]</code> <p>max sum of non-operating hours in one piece</p> <code>None</code> <code>switch_on_total_max</code> <code>Optional[int]</code> <p>max nr of switchOn operations</p> <code>None</code> <code>force_switch_on</code> <code>bool</code> <p>force creation of switch on variable, even if there is no switch_on_total_max</p> <code>False</code>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters-attributes","title":"Attributes","text":""},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.use_off","title":"use_off  <code>property</code>","text":"<pre><code>use_off: bool\n</code></pre> <p>Determines wether the OFF Variable is needed or not</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.use_consecutive_on_hours","title":"use_consecutive_on_hours  <code>property</code>","text":"<pre><code>use_consecutive_on_hours: bool\n</code></pre> <p>Determines wether a Variable for consecutive off hours is needed or not</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.use_consecutive_off_hours","title":"use_consecutive_off_hours  <code>property</code>","text":"<pre><code>use_consecutive_off_hours: bool\n</code></pre> <p>Determines wether a Variable for consecutive off hours is needed or not</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.use_switch_on","title":"use_switch_on  <code>property</code>","text":"<pre><code>use_switch_on: bool\n</code></pre> <p>Determines wether a Variable for SWITCH-ON is needed or not</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Piece","title":"Piece","text":"<pre><code>Piece(start: NumericData, end: NumericData)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a Piece, which is part of a Piecewise object.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>NumericData</code> <p>The x-values of the piece.</p> required <code>end</code> <code>NumericData</code> <p>The end of the piece.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Piece-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Piece.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.Piece.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Piece.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Piece.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Piecewise","title":"Piecewise","text":"<pre><code>Piecewise(pieces: List[Piece])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a Piecewise, consisting of a list of Pieces.</p> <p>Parameters:</p> Name Type Description Default <code>pieces</code> <code>List[Piece]</code> <p>The pieces of the piecewise.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Piecewise-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Piecewise.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.Piecewise.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Piecewise.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Piecewise.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion","title":"PiecewiseConversion","text":"<pre><code>PiecewiseConversion(piecewises: Dict[str, Piecewise])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a piecewise conversion between multiple Flows. --&gt; \"gaps\" can be expressed by a piece not starting at the end of the prior piece: [(1,3), (4,5)] --&gt; \"points\" can expressed as piece with same begin and end: [(3,3), (4,4)]</p> <p>Parameters:</p> Name Type Description Default <code>piecewises</code> <code>Dict[str, Piecewise]</code> <p>Dict of Piecewises defining the conversion factors. flow labels as keys, piecewise as values</p> required"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects","title":"PiecewiseEffects","text":"<pre><code>PiecewiseEffects(\n    piecewise_origin: Piecewise, piecewise_shares: Dict[str, Piecewise]\n)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define piecewise effects related to a variable.</p> <p>Parameters:</p> Name Type Description Default <code>piecewise_origin</code> <code>Piecewise</code> <p>Piecewise of the related variable</p> required <code>piecewise_shares</code> <code>Dict[str, Piecewise]</code> <p>Piecewise defining the shares to different Effects</p> required"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/components/","title":"components","text":""},{"location":"api-reference/components/#flixopt.components","title":"flixopt.components","text":"<p>This module contains the basic components of the flixopt framework.</p>"},{"location":"api-reference/components/#flixopt.components-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components-classes","title":"Classes","text":""},{"location":"api-reference/components/#flixopt.components.LinearConverter","title":"LinearConverter","text":"<pre><code>LinearConverter(\n    label: str,\n    inputs: List[Flow],\n    outputs: List[Flow],\n    on_off_parameters: OnOffParameters = None,\n    conversion_factors: List[Dict[str, NumericDataTS]] = None,\n    piecewise_conversion: Optional[PiecewiseConversion] = None,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Converts input-Flows into output-Flows via linear conversion factors</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>inputs</code> <code>List[Flow]</code> <p>The input Flows</p> required <code>outputs</code> <code>List[Flow]</code> <p>The output Flows</p> required <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Information about on and off state of LinearConverter. Component is On/Off, if all connected Flows are On/Off. This induces an On-Variable (binary) in all Flows! If possible, use OnOffParameters in a single Flow instead to keep the number of binary variables low. See class OnOffParameters.</p> <code>None</code> <code>conversion_factors</code> <code>List[Dict[str, NumericDataTS]]</code> <p>linear relation between flows. Either 'conversion_factors' or 'piecewise_conversion' can be used!</p> <code>None</code> <code>piecewise_conversion</code> <code>Optional[PiecewiseConversion]</code> <p>Define a piecewise linear relation between flow rates of different flows. Either 'conversion_factors' or 'piecewise_conversion' can be used!</p> <code>None</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/components/#flixopt.components.LinearConverter-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.LinearConverter.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/components/#flixopt.components.LinearConverter.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/components/#flixopt.components.Storage","title":"Storage","text":"<pre><code>Storage(\n    label: str,\n    charging: Flow,\n    discharging: Flow,\n    capacity_in_flow_hours: Union[Scalar, InvestParameters],\n    relative_minimum_charge_state: NumericData = 0,\n    relative_maximum_charge_state: NumericData = 1,\n    initial_charge_state: Union[Scalar, Literal['lastValueOfSim']] = 0,\n    minimal_final_charge_state: Optional[Scalar] = None,\n    maximal_final_charge_state: Optional[Scalar] = None,\n    eta_charge: NumericData = 1,\n    eta_discharge: NumericData = 1,\n    relative_loss_per_hour: NumericData = 0,\n    prevent_simultaneous_charge_and_discharge: bool = True,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Used to model the storage of energy or material.</p> <p>Storages have one incoming and one outgoing Flow each with an efficiency. Further, storages have a <code>size</code> and a <code>charge_state</code>. Similarly to the flow-rate of a Flow, the <code>size</code> combined with a relative upper and lower bound limits the <code>charge_state</code> of the storage.</p> <p>For mathematical details take a look at our online documentation</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>charging</code> <code>Flow</code> <p>ingoing flow.</p> required <code>discharging</code> <code>Flow</code> <p>outgoing flow.</p> required <code>capacity_in_flow_hours</code> <code>Union[Scalar, InvestParameters]</code> <p>nominal capacity/size of the storage</p> required <code>relative_minimum_charge_state</code> <code>NumericData</code> <p>minimum relative charge state. The default is 0.</p> <code>0</code> <code>relative_maximum_charge_state</code> <code>NumericData</code> <p>maximum relative charge state. The default is 1.</p> <code>1</code> <code>initial_charge_state</code> <code>Union[Scalar, Literal['lastValueOfSim']]</code> <p>storage charge_state at the beginning. The default is 0.</p> <code>0</code> <code>minimal_final_charge_state</code> <code>Optional[Scalar]</code> <p>minimal value of chargeState at the end of timeseries.</p> <code>None</code> <code>maximal_final_charge_state</code> <code>Optional[Scalar]</code> <p>maximal value of chargeState at the end of timeseries.</p> <code>None</code> <code>eta_charge</code> <code>NumericData</code> <p>efficiency factor of charging/loading. The default is 1.</p> <code>1</code> <code>eta_discharge</code> <code>NumericData</code> <p>efficiency factor of uncharging/unloading. The default is 1.</p> <code>1</code> <code>relative_loss_per_hour</code> <code>NumericData</code> <p>loss per chargeState-Unit per hour. The default is 0.</p> <code>0</code> <code>prevent_simultaneous_charge_and_discharge</code> <code>bool</code> <p>If True, loading and unloading at the same time is not possible. Increases the number of binary variables, but is recommended for easier evaluation. The default is True.</p> <code>True</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/components/#flixopt.components.Storage-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Storage.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/components/#flixopt.components.Storage.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/components/#flixopt.components.Storage.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/components/#flixopt.components.Transmission","title":"Transmission","text":"<pre><code>Transmission(\n    label: str,\n    in1: Flow,\n    out1: Flow,\n    in2: Optional[Flow] = None,\n    out2: Optional[Flow] = None,\n    relative_losses: Optional[NumericDataTS] = None,\n    absolute_losses: Optional[NumericDataTS] = None,\n    on_off_parameters: OnOffParameters = None,\n    prevent_simultaneous_flows_in_both_directions: bool = True,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Initializes a Transmission component (Pipe, cable, ...) that models the flows between two sides with potential losses.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>in1</code> <code>Flow</code> <p>The inflow at side A. Pass InvestmentParameters here.</p> required <code>out1</code> <code>Flow</code> <p>The outflow at side B.</p> required <code>in2</code> <code>Optional[Flow]</code> <p>The optional inflow at side B. If in1 got InvestParameters, the size of this Flow will be equal to in1 (with no extra effects!)</p> <code>None</code> <code>out2</code> <code>Optional[Flow]</code> <p>The optional outflow at side A.</p> <code>None</code> <code>relative_losses</code> <code>Optional[NumericDataTS]</code> <p>The relative loss between inflow and outflow, e.g., 0.02 for 2% loss.</p> <code>None</code> <code>absolute_losses</code> <code>Optional[NumericDataTS]</code> <p>The absolute loss, occur only when the Flow is on. Induces the creation of the ON-Variable</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Parameters defining the on/off behavior of the component.</p> <code>None</code> <code>prevent_simultaneous_flows_in_both_directions</code> <code>bool</code> <p>If True, inflow and outflow are not allowed to be both non-zero at same timestep.</p> <code>True</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/components/#flixopt.components.Transmission-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Transmission.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/components/#flixopt.components.Transmission.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/components/#flixopt.components.TransmissionModel","title":"TransmissionModel","text":"<pre><code>TransmissionModel(model: SystemModel, element: Transmission)\n</code></pre> <p>               Bases: <code>ComponentModel</code></p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.TransmissionModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.TransmissionModel.do_modeling","title":"do_modeling","text":"<pre><code>do_modeling()\n</code></pre> <p>Initiates all FlowModels</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.create_transmission_equation","title":"create_transmission_equation","text":"<pre><code>create_transmission_equation(\n    name: str, in_flow: Flow, out_flow: Flow\n) -&gt; linopy.Constraint\n</code></pre> <p>Creates an Equation for the Transmission efficiency and adds it to the model</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/components/#flixopt.components.StorageModel","title":"StorageModel","text":"<pre><code>StorageModel(model: SystemModel, element: Storage)\n</code></pre> <p>               Bases: <code>ComponentModel</code></p> <p>Model of Storage</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.StorageModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.StorageModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink","title":"SourceAndSink","text":"<pre><code>SourceAndSink(\n    label: str,\n    source: Flow,\n    sink: Flow,\n    prevent_simultaneous_sink_and_source: bool = True,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>class for source (output-flow) and sink (input-flow) in one commponent</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>source</code> <code>Flow</code> <p>output-flow of this component</p> required <code>sink</code> <code>Flow</code> <p>input-flow of this component</p> required <code>prevent_simultaneous_sink_and_source</code> <code>bool</code> <p>If True, inflow and outflow can not be active simultaniously.</p> <code>True</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.SourceAndSink.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/components/#flixopt.components.Source","title":"Source","text":"<pre><code>Source(label: str, source: Flow, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>source</code> <code>Flow</code> <p>output-flow of source</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/components/#flixopt.components.Source-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Source.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/components/#flixopt.components.Source.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/components/#flixopt.components.Source.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/components/#flixopt.components.Sink","title":"Sink","text":"<pre><code>Sink(label: str, sink: Flow, meta_data: Optional[Dict] = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the element. Is not used internally, but saved in the results</p> <code>None</code> <code>sink</code> <code>Flow</code> <p>input-flow of sink</p> required"},{"location":"api-reference/components/#flixopt.components.Sink-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Sink.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/components/#flixopt.components.Sink.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/components/#flixopt.components.Sink.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/components/#flixopt.components-functions","title":"Functions","text":""},{"location":"api-reference/config/","title":"config","text":""},{"location":"api-reference/config/#flixopt.config","title":"flixopt.config","text":""},{"location":"api-reference/config/#flixopt.config-classes","title":"Classes","text":""},{"location":"api-reference/config/#flixopt.config.CONFIG","title":"CONFIG","text":"<p>A configuration class that stores global configuration values as class attributes.</p>"},{"location":"api-reference/config/#flixopt.config.CONFIG-functions","title":"Functions","text":""},{"location":"api-reference/config/#flixopt.config.CONFIG.load_config","title":"load_config  <code>classmethod</code>","text":"<pre><code>load_config(user_config_file: Optional[str] = None)\n</code></pre> <p>Initialize configuration using defaults or user-specified file.</p>"},{"location":"api-reference/config/#flixopt.config.CONFIG.to_dict","title":"to_dict  <code>classmethod</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the configuration class into a dictionary for JSON serialization. Handles dataclasses and simple types like str, int, etc.</p>"},{"location":"api-reference/config/#flixopt.config-functions","title":"Functions","text":""},{"location":"api-reference/config/#flixopt.config.merge_configs","title":"merge_configs","text":"<pre><code>merge_configs(defaults: dict, overrides: dict) -&gt; dict\n</code></pre> <p>Merge the default configuration with user-provided overrides. Args:     defaults: Default configuration dictionary.     overrides: User configuration dictionary. Returns:     Merged configuration dictionary.</p>"},{"location":"api-reference/config/#flixopt.config.dataclass_from_dict_with_validation","title":"dataclass_from_dict_with_validation","text":"<pre><code>dataclass_from_dict_with_validation(cls, data: dict)\n</code></pre> <p>Recursively initialize a dataclass from a dictionary.</p>"},{"location":"api-reference/config/#flixopt.config.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(\n    default_level: Literal[\n        'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'\n    ] = 'INFO',\n    log_file: Optional[str] = 'flixopt.log',\n    use_rich_handler: bool = False,\n)\n</code></pre> <p>Setup logging configuration</p>"},{"location":"api-reference/core/","title":"core","text":""},{"location":"api-reference/core/#flixopt.core","title":"flixopt.core","text":"<p>This module contains the core functionality of the flixopt framework. It provides Datatypes, logging functionality, and some functions to transform data structures.</p>"},{"location":"api-reference/core/#flixopt.core-attributes","title":"Attributes","text":""},{"location":"api-reference/core/#flixopt.core.Scalar","title":"Scalar  <code>module-attribute</code>","text":"<pre><code>Scalar = Union[int, float]\n</code></pre> <p>A type representing a single number, either integer or float.</p>"},{"location":"api-reference/core/#flixopt.core.NumericData","title":"NumericData  <code>module-attribute</code>","text":"<pre><code>NumericData = Union[\n    int, float, integer, floating, ndarray, Series, DataFrame, DataArray\n]\n</code></pre> <p>Represents any form of numeric data, from simple scalars to complex data structures.</p>"},{"location":"api-reference/core/#flixopt.core.NumericDataTS","title":"NumericDataTS  <code>module-attribute</code>","text":"<pre><code>NumericDataTS = Union[NumericData, 'TimeSeriesData']\n</code></pre> <p>Represents either standard numeric data or TimeSeriesData.</p>"},{"location":"api-reference/core/#flixopt.core-classes","title":"Classes","text":""},{"location":"api-reference/core/#flixopt.core.PlausibilityError","title":"PlausibilityError","text":"<p>               Bases: <code>Exception</code></p> <p>Error for a failing Plausibility check.</p>"},{"location":"api-reference/core/#flixopt.core.ConversionError","title":"ConversionError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for data conversion errors.</p>"},{"location":"api-reference/core/#flixopt.core.DataConverter","title":"DataConverter","text":"<p>Converts various data types into xarray.DataArray with a timesteps index.</p> <p>Supports: scalars, arrays, Series, DataFrames, and DataArrays.</p>"},{"location":"api-reference/core/#flixopt.core.DataConverter-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.DataConverter.as_dataarray","title":"as_dataarray  <code>staticmethod</code>","text":"<pre><code>as_dataarray(data: NumericData, timesteps: DatetimeIndex) -&gt; xr.DataArray\n</code></pre> <p>Convert data to xarray.DataArray with specified timesteps index.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesData","title":"TimeSeriesData","text":"<pre><code>TimeSeriesData(\n    data: NumericData,\n    agg_group: Optional[str] = None,\n    agg_weight: Optional[float] = None,\n)\n</code></pre> <p>timeseries class for transmit timeseries AND special characteristics of timeseries, i.g. to define weights needed in calculation_type 'aggregated'     EXAMPLE solar:     you have several solar timeseries. These should not be overweighted     compared to the remaining timeseries (i.g. heat load, price)!     fixed_relative_profile_solar1 = TimeSeriesData(sol_array_1, type = 'solar')     fixed_relative_profile_solar2 = TimeSeriesData(sol_array_2, type = 'solar')     fixed_relative_profile_solar3 = TimeSeriesData(sol_array_3, type = 'solar')     --&gt; this 3 series of same type share one weight, i.e. internally assigned each weight = 1/3     (instead of standard weight = 1)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NumericData</code> <p>The timeseries data, which can be a scalar, array, or numpy array.</p> required <code>agg_group</code> <code>Optional[str]</code> <p>The group this TimeSeriesData is a part of. agg_weight is split between members of a group. Default is None.</p> <code>None</code> <code>agg_weight</code> <code>Optional[float]</code> <p>The weight for calculation_type 'aggregated', should be between 0 and 1. Default is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If both agg_group and agg_weight are set, an exception is raised.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesData-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.TimeSeries","title":"TimeSeries","text":"<pre><code>TimeSeries(\n    data: DataArray,\n    name: str,\n    aggregation_weight: Optional[float] = None,\n    aggregation_group: Optional[str] = None,\n    needs_extra_timestep: bool = False,\n)\n</code></pre> <p>A class representing time series data with active and stored states.</p> <p>TimeSeries provides a way to store time-indexed data and work with temporal subsets. It supports arithmetic operations, aggregation, and JSON serialization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the time series</p> <code>aggregation_weight</code> <code>Optional[float]</code> <p>Weight used for aggregation</p> <code>aggregation_group</code> <code>Optional[str]</code> <p>Group name for shared aggregation weighting</p> <code>needs_extra_timestep</code> <code>bool</code> <p>Whether this series needs an extra timestep</p> <p>Initialize a TimeSeries with a DataArray.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataArray</code> <p>The DataArray containing time series data</p> required <code>name</code> <code>str</code> <p>The name of the TimeSeries</p> required <code>aggregation_weight</code> <code>Optional[float]</code> <p>The weight in aggregation calculations</p> <code>None</code> <code>aggregation_group</code> <code>Optional[str]</code> <p>Group this TimeSeries belongs to for weight sharing</p> <code>None</code> <code>needs_extra_timestep</code> <code>bool</code> <p>Whether this series requires an extra timestep</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data doesn't have a 'time' index or has more than 1 dimension</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries-attributes","title":"Attributes","text":""},{"location":"api-reference/core/#flixopt.core.TimeSeries.stats","title":"stats  <code>property</code>","text":"<pre><code>stats: str\n</code></pre> <p>Return a statistical summary of the active data.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of data statistics</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.all_equal","title":"all_equal  <code>property</code>","text":"<pre><code>all_equal: bool\n</code></pre> <p>Check if all values in the series are equal.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.active_timesteps","title":"active_timesteps  <code>property</code> <code>writable</code>","text":"<pre><code>active_timesteps: DatetimeIndex\n</code></pre> <p>Get the current active timesteps.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.active_data","title":"active_data  <code>property</code>","text":"<pre><code>active_data: DataArray\n</code></pre> <p>Get a view of stored_data based on active_timesteps.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.stored_data","title":"stored_data  <code>property</code> <code>writable</code>","text":"<pre><code>stored_data: DataArray\n</code></pre> <p>Get a copy of the full stored data.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.TimeSeries.from_datasource","title":"from_datasource  <code>classmethod</code>","text":"<pre><code>from_datasource(\n    data: NumericData,\n    name: str,\n    timesteps: DatetimeIndex,\n    aggregation_weight: Optional[float] = None,\n    aggregation_group: Optional[str] = None,\n    needs_extra_timestep: bool = False,\n) -&gt; TimeSeries\n</code></pre> <p>Initialize the TimeSeries from multiple data sources.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NumericData</code> <p>The time series data</p> required <code>name</code> <code>str</code> <p>The name of the TimeSeries</p> required <code>timesteps</code> <code>DatetimeIndex</code> <p>The timesteps of the TimeSeries</p> required <code>aggregation_weight</code> <code>Optional[float]</code> <p>The weight in aggregation calculations</p> <code>None</code> <code>aggregation_group</code> <code>Optional[str]</code> <p>Group this TimeSeries belongs to for aggregation weight sharing</p> <code>None</code> <code>needs_extra_timestep</code> <code>bool</code> <p>Whether this series requires an extra timestep</p> <code>False</code> <p>Returns:</p> Type Description <code>TimeSeries</code> <p>A new TimeSeries instance</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(\n    data: Optional[Dict[str, Any]] = None, path: Optional[str] = None\n) -&gt; TimeSeries\n</code></pre> <p>Load a TimeSeries from a dictionary or json file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Optional[Dict[str, Any]]</code> <p>Dictionary containing TimeSeries data</p> <code>None</code> <code>path</code> <code>Optional[str]</code> <p>Path to a JSON file containing TimeSeries data</p> <code>None</code> <p>Returns:</p> Type Description <code>TimeSeries</code> <p>A new TimeSeries instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both path and data are provided or neither is provided</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset active timesteps to the full set of stored timesteps.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.restore_data","title":"restore_data","text":"<pre><code>restore_data()\n</code></pre> <p>Restore stored_data from the backup and reset active timesteps.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.to_json","title":"to_json","text":"<pre><code>to_json(path: Optional[Path] = None) -&gt; Dict[str, Any]\n</code></pre> <p>Save the TimeSeries to a dictionary or JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Path]</code> <p>Optional path to save JSON file</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary representation of the TimeSeries</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection","title":"TimeSeriesCollection","text":"<pre><code>TimeSeriesCollection(\n    timesteps: DatetimeIndex,\n    hours_of_last_timestep: Optional[float] = None,\n    hours_of_previous_timesteps: Optional[Union[float, ndarray]] = None,\n)\n</code></pre> <p>Collection of TimeSeries objects with shared timestep management.</p> <p>TimeSeriesCollection handles multiple TimeSeries objects with synchronized timesteps, provides operations on collections, and manages extra timesteps.</p> <p>Parameters:</p> Name Type Description Default <code>timesteps</code> <code>DatetimeIndex</code> <p>The timesteps of the Collection.</p> required <code>hours_of_last_timestep</code> <code>Optional[float]</code> <p>The duration of the last time step. Uses the last time interval if not specified</p> <code>None</code> <code>hours_of_previous_timesteps</code> <code>Optional[Union[float, ndarray]]</code> <p>The duration of previous timesteps. If None, the first time increment of time_series is used. This is needed to calculate previous durations (for example consecutive_on_hours). If you use an array, take care that its long enough to cover all previous values!</p> <code>None</code>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection-attributes","title":"Attributes","text":""},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.non_constants","title":"non_constants  <code>property</code>","text":"<pre><code>non_constants: List[TimeSeries]\n</code></pre> <p>Get time series with varying values.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.constants","title":"constants  <code>property</code>","text":"<pre><code>constants: List[TimeSeries]\n</code></pre> <p>Get time series with constant values.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.timesteps","title":"timesteps  <code>property</code>","text":"<pre><code>timesteps: DatetimeIndex\n</code></pre> <p>Get the active timesteps.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.timesteps_extra","title":"timesteps_extra  <code>property</code>","text":"<pre><code>timesteps_extra: DatetimeIndex\n</code></pre> <p>Get the active timesteps with extra step.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.hours_per_timestep","title":"hours_per_timestep  <code>property</code>","text":"<pre><code>hours_per_timestep: DataArray\n</code></pre> <p>Get the duration of each active timestep.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.hours_of_last_timestep","title":"hours_of_last_timestep  <code>property</code>","text":"<pre><code>hours_of_last_timestep: float\n</code></pre> <p>Get the duration of the last timestep.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.with_uniform_timesteps","title":"with_uniform_timesteps  <code>classmethod</code>","text":"<pre><code>with_uniform_timesteps(\n    start_time: Timestamp,\n    periods: int,\n    freq: str,\n    hours_per_step: Optional[float] = None,\n) -&gt; TimeSeriesCollection\n</code></pre> <p>Create a collection with uniform timesteps.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.create_time_series","title":"create_time_series","text":"<pre><code>create_time_series(\n    data: Union[NumericData, TimeSeriesData],\n    name: str,\n    needs_extra_timestep: bool = False,\n) -&gt; TimeSeries\n</code></pre> <p>Creates a TimeSeries from the given data and adds it to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[NumericData, TimeSeriesData]</code> <p>The data to create the TimeSeries from.</p> required <code>name</code> <code>str</code> <p>The name of the TimeSeries.</p> required <code>needs_extra_timestep</code> <code>bool</code> <p>Whether to create an additional timestep at the end of the timesteps.</p> <code>False</code> <p>Returns:</p> Type Description <code>TimeSeries</code> <p>The created TimeSeries.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.calculate_aggregation_weights","title":"calculate_aggregation_weights","text":"<pre><code>calculate_aggregation_weights() -&gt; Dict[str, float]\n</code></pre> <p>Calculate and return aggregation weights for all time series.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.activate_timesteps","title":"activate_timesteps","text":"<pre><code>activate_timesteps(active_timesteps: Optional[DatetimeIndex] = None)\n</code></pre> <p>Update active timesteps for the collection and all time series. If no arguments are provided, the active timesteps are reset.</p> <p>Parameters:</p> Name Type Description Default <code>active_timesteps</code> <code>Optional[DatetimeIndex]</code> <p>The active timesteps of the model. If None, the all timesteps of the TimeSeriesCollection are taken.</p> <code>None</code>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset active timesteps to defaults for all time series.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.restore_data","title":"restore_data","text":"<pre><code>restore_data()\n</code></pre> <p>Restore original data for all time series.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.add_time_series","title":"add_time_series","text":"<pre><code>add_time_series(time_series: TimeSeries)\n</code></pre> <p>Add an existing TimeSeries to the collection.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.insert_new_data","title":"insert_new_data","text":"<pre><code>insert_new_data(data: DataFrame, include_extra_timestep: bool = False)\n</code></pre> <p>Update time series with new data from a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame containing new data with timestamps as index</p> required <code>include_extra_timestep</code> <code>bool</code> <p>Whether the provided data already includes the extra timestep, by default False</p> <code>False</code>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.to_dataframe","title":"to_dataframe","text":"<pre><code>to_dataframe(\n    filtered: Literal['all', 'constant', 'non_constant'] = 'non_constant',\n    include_extra_timestep: bool = True,\n) -&gt; pd.DataFrame\n</code></pre> <p>Convert collection to DataFrame with optional filtering and timestep control.</p> <p>Parameters:</p> Name Type Description Default <code>filtered</code> <code>Literal['all', 'constant', 'non_constant']</code> <p>Filter time series by variability, by default 'non_constant'</p> <code>'non_constant'</code> <code>include_extra_timestep</code> <code>bool</code> <p>Whether to include the extra timestep in the result, by default True</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame representation of the collection</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset(include_constants: bool = True) -&gt; xr.Dataset\n</code></pre> <p>Combine all time series into a single Dataset with all timesteps.</p> <p>Parameters:</p> Name Type Description Default <code>include_constants</code> <code>bool</code> <p>Whether to include time series with constant values, by default True</p> <code>True</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset containing all selected time series with all timesteps</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.calculate_hours_per_timestep","title":"calculate_hours_per_timestep  <code>staticmethod</code>","text":"<pre><code>calculate_hours_per_timestep(timesteps_extra: DatetimeIndex) -&gt; xr.DataArray\n</code></pre> <p>Calculate duration of each timestep.</p>"},{"location":"api-reference/core/#flixopt.core-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.get_numeric_stats","title":"get_numeric_stats","text":"<pre><code>get_numeric_stats(data: DataArray, decimals: int = 2, padd: int = 10) -&gt; str\n</code></pre> <p>Calculates the mean, median, min, max, and standard deviation of a numeric DataArray.</p>"},{"location":"api-reference/effects/","title":"effects","text":""},{"location":"api-reference/effects/#flixopt.effects","title":"flixopt.effects","text":"<p>This module contains the effects of the flixopt framework. Furthermore, it contains the EffectCollection, which is used to collect all effects of a system. Different Datatypes are used to represent the effects with assigned values by the user, which are then transformed into the internal data structure.</p>"},{"location":"api-reference/effects/#flixopt.effects-attributes","title":"Attributes","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectValuesUser","title":"EffectValuesUser  <code>module-attribute</code>","text":"<pre><code>EffectValuesUser = Union[NumericDataTS, Dict[str, NumericDataTS]]\n</code></pre> <p>This datatype is used to define the share to an effect by a certain attribute.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectValuesUserScalar","title":"EffectValuesUserScalar  <code>module-attribute</code>","text":"<pre><code>EffectValuesUserScalar = Union[Scalar, Dict[str, Scalar]]\n</code></pre> <p>This datatype is used to define the share to an effect by a certain attribute. Only scalars are allowed.</p>"},{"location":"api-reference/effects/#flixopt.effects-classes","title":"Classes","text":""},{"location":"api-reference/effects/#flixopt.effects.Effect","title":"Effect","text":"<pre><code>Effect(\n    label: str,\n    unit: str,\n    description: str,\n    meta_data: Optional[Dict] = None,\n    is_standard: bool = False,\n    is_objective: bool = False,\n    specific_share_to_other_effects_operation: Optional[\n        EffectValuesUser\n    ] = None,\n    specific_share_to_other_effects_invest: Optional[EffectValuesUser] = None,\n    minimum_operation: Optional[Scalar] = None,\n    maximum_operation: Optional[Scalar] = None,\n    minimum_invest: Optional[Scalar] = None,\n    maximum_invest: Optional[Scalar] = None,\n    minimum_operation_per_hour: Optional[NumericDataTS] = None,\n    maximum_operation_per_hour: Optional[NumericDataTS] = None,\n    minimum_total: Optional[Scalar] = None,\n    maximum_total: Optional[Scalar] = None,\n)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Effect, i.g. costs, CO2 emissions, area, ... Components, FLows, and so on can contribute to an Effect. One Effect is chosen as the Objective of the Optimization</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>unit</code> <code>str</code> <p>The unit of effect, i.g. \u20ac, kg_CO2, kWh_primaryEnergy</p> required <code>description</code> <code>str</code> <p>The long name</p> required <code>is_standard</code> <code>bool</code> <p>true, if Standard-Effect (for direct input of value without effect (alternatively to dict)) , else false</p> <code>False</code> <code>is_objective</code> <code>bool</code> <p>true, if optimization target</p> <code>False</code> <code>specific_share_to_other_effects_operation</code> <code>Optional[EffectValuesUser]</code> <p>{effectType: TS, ...}, i.g. 180 \u20ac/t_CO2, input as {costs: 180}, optional share to other effects (only operation)</p> <code>None</code> <code>specific_share_to_other_effects_invest</code> <code>Optional[EffectValuesUser]</code> <p>{effectType: TS, ...}, i.g. 180 \u20ac/t_CO2, input as {costs: 180}, optional share to other effects (only invest).</p> <code>None</code> <code>minimum_operation</code> <code>Optional[Scalar]</code> <p>minimal sum (only operation) of the effect.</p> <code>None</code> <code>maximum_operation</code> <code>Optional[Scalar]</code> <p>maximal sum (nur operation) of the effect.</p> <code>None</code> <code>minimum_operation_per_hour</code> <code>Optional[NumericDataTS]</code> <p>max. value per hour (only operation) of effect (=sum of all effect-shares) for each timestep!</p> <code>None</code> <code>maximum_operation_per_hour</code> <code>Optional[NumericDataTS]</code> <p>min. value per hour (only operation) of effect (=sum of all effect-shares) for each timestep!</p> <code>None</code> <code>minimum_invest</code> <code>Optional[Scalar]</code> <p>minimal sum (only invest) of the effect</p> <code>None</code> <code>maximum_invest</code> <code>Optional[Scalar]</code> <p>maximal sum (only invest) of the effect</p> <code>None</code> <code>minimum_total</code> <code>Optional[Scalar]</code> <p>min sum of effect (invest+operation).</p> <code>None</code> <code>maximum_total</code> <code>Optional[Scalar]</code> <p>max sum of effect (invest+operation).</p> <code>None</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/effects/#flixopt.effects.Effect-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.Effect.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/effects/#flixopt.effects.Effect.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/effects/#flixopt.effects.EffectCollection","title":"EffectCollection","text":"<pre><code>EffectCollection(*effects: List[Effect])\n</code></pre> <p>Handling all Effects</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollection-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectCollection.create_effect_values_dict","title":"create_effect_values_dict","text":"<pre><code>create_effect_values_dict(\n    effect_values_user: EffectValuesUser,\n) -&gt; Optional[EffectValuesDict]\n</code></pre> <p>Converts effect values into a dictionary. If a scalar is provided, it is associated with a default effect type.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollection.create_effect_values_dict--examples","title":"Examples","text":"<p>effect_values_user = 20                             -&gt; {None: 20} effect_values_user = None                           -&gt; None effect_values_user = {effect1: 20, effect2: 0.3}    -&gt; {effect1: 20, effect2: 0.3}</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollection.create_effect_values_dict--returns","title":"Returns","text":"<p>dict or None     A dictionary with None or Effect as the key, or None if input is None.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel","title":"EffectCollectionModel","text":"<pre><code>EffectCollectionModel(model: SystemModel, effects: EffectCollection)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Handling all Effects</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel-attributes","title":"Attributes","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/effects/#flixopt.effects-functions","title":"Functions","text":""},{"location":"api-reference/elements/","title":"elements","text":""},{"location":"api-reference/elements/#flixopt.elements","title":"flixopt.elements","text":"<p>This module contains the basic elements of the flixopt framework.</p>"},{"location":"api-reference/elements/#flixopt.elements-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements-classes","title":"Classes","text":""},{"location":"api-reference/elements/#flixopt.elements.Component","title":"Component","text":"<pre><code>Component(\n    label: str,\n    inputs: Optional[List[Flow]] = None,\n    outputs: Optional[List[Flow]] = None,\n    on_off_parameters: Optional[OnOffParameters] = None,\n    prevent_simultaneous_flows: Optional[List[Flow]] = None,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>A Component contains incoming and outgoing <code>Flows</code>. It defines how these Flows interact with each other. The On or Off state of the Component is defined by all its Flows. Its on, if any of its FLows is On. It's mathematically advisable to define the On/Off state in a FLow rather than a Component if possible, as this introduces less binary variables to the Model Constraints to the On/Off state are defined by the <code>on_off_parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>inputs</code> <code>Optional[List[Flow]]</code> <p>input flows.</p> <code>None</code> <code>outputs</code> <code>Optional[List[Flow]]</code> <p>output flows.</p> <code>None</code> <code>on_off_parameters</code> <code>Optional[OnOffParameters]</code> <p>Information about on and off state of Component. Component is On/Off, if all connected Flows are On/Off. This induces an On-Variable (binary) in all Flows! If possible, use OnOffParameters in a single Flow instead to keep the number of binary variables low. See class OnOffParameters.</p> <code>None</code> <code>prevent_simultaneous_flows</code> <code>Optional[List[Flow]]</code> <p>Define a Group of Flows. Only one them can be on at a time. Induces On-Variable in all Flows! If possible, use OnOffParameters in a single Flow instead.</p> <code>None</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/elements/#flixopt.elements.Component-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Component.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/elements/#flixopt.elements.Component.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/elements/#flixopt.elements.Bus","title":"Bus","text":"<pre><code>Bus(\n    label: str,\n    excess_penalty_per_flow_hour: Optional[NumericDataTS] = 100000.0,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>A Bus represents a nodal balance between the flow rates of its incoming and outgoing Flows.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>excess_penalty_per_flow_hour</code> <code>Optional[NumericDataTS]</code> <p>excess costs / penalty costs (bus balance compensation) (none/ 0 -&gt; no penalty). The default is 1e5. (Take care: if you use a timeseries (no scalar), timeseries is aggregated if calculation_type = aggregated!)</p> <code>100000.0</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/elements/#flixopt.elements.Bus-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Bus.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/elements/#flixopt.elements.Bus.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/elements/#flixopt.elements.Connection","title":"Connection","text":"<pre><code>Connection()\n</code></pre> <p>This class is not yet implemented!</p>"},{"location":"api-reference/elements/#flixopt.elements.Connection-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Flow","title":"Flow","text":"<pre><code>Flow(\n    label: str,\n    bus: str,\n    size: Union[Scalar, InvestParameters] = None,\n    fixed_relative_profile: Optional[NumericDataTS] = None,\n    relative_minimum: NumericDataTS = 0,\n    relative_maximum: NumericDataTS = 1,\n    effects_per_flow_hour: Optional[EffectValuesUser] = None,\n    on_off_parameters: Optional[OnOffParameters] = None,\n    flow_hours_total_max: Optional[Scalar] = None,\n    flow_hours_total_min: Optional[Scalar] = None,\n    load_factor_min: Optional[Scalar] = None,\n    load_factor_max: Optional[Scalar] = None,\n    previous_flow_rate: Optional[NumericData] = None,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>A Flow moves energy (or material) between a Bus and a Component in a predefined direction. The flow-rate is the main optimization variable of the Flow.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the FLow. Used to identify it in the FlowSystem. Its <code>full_label</code> consists of the label of the Component and the label of the Flow.</p> required <code>bus</code> <code>str</code> <p>blabel of the bus the flow is connected to.</p> required <code>size</code> <code>Union[Scalar, InvestParameters]</code> <p>size of the flow. If InvestmentParameters is used, size is optimized. If size is None, a default value is used.</p> <code>None</code> <code>relative_minimum</code> <code>NumericDataTS</code> <p>min value is relative_minimum multiplied by size</p> <code>0</code> <code>relative_maximum</code> <code>NumericDataTS</code> <p>max value is relative_maximum multiplied by size. If size = max then relative_maximum=1</p> <code>1</code> <code>load_factor_min</code> <code>Optional[Scalar]</code> <p>minimal load factor  general: avg Flow per nominalVal/investSize (e.g. boiler, kW/kWh=h; solarthermal: kW/m\u00b2;  def: :math:<code>load\\_factor:= sumFlowHours/ (nominal\\_val \\cdot \\Delta t_{tot})</code></p> <code>None</code> <code>load_factor_max</code> <code>Optional[Scalar]</code> <p>maximal load factor (see minimal load factor)</p> <code>None</code> <code>effects_per_flow_hour</code> <code>Optional[EffectValuesUser]</code> <p>operational costs, costs per flow-\"work\"</p> <code>None</code> <code>on_off_parameters</code> <code>Optional[OnOffParameters]</code> <p>If present, flow can be \"off\", i.e. be zero (only relevant if relative_minimum &gt; 0) Therefore a binary var \"on\" is used. Further, several other restrictions and effects can be modeled through this On/Off State (See OnOffParameters)</p> <code>None</code> <code>flow_hours_total_max</code> <code>Optional[Scalar]</code> <p>maximum flow-hours (\"flow-work\") (if size is not const, maybe load_factor_max is the better choice!)</p> <code>None</code> <code>flow_hours_total_min</code> <code>Optional[Scalar]</code> <p>minimum flow-hours (\"flow-work\") (if size is not predefined, maybe load_factor_min is the better choice!)</p> <code>None</code> <code>fixed_relative_profile</code> <code>Optional[NumericDataTS]</code> <p>fixed relative values for flow (if given). flow_rate(t) := fixed_relative_profile(t) * size(t) With this value, the flow_rate is no optimization-variable anymore. (relative_minimum and relative_maximum are ignored) used for fixed load or supply profiles, i.g. heat demand, wind-power, solarthermal If the load-profile is just an upper limit, use relative_maximum instead.</p> <code>None</code> <code>previous_flow_rate</code> <code>Optional[NumericData]</code> <p>previous flow rate of the flow. Used to determine if and how long the flow is already on / off. If None, the flow is considered to be off for one timestep.</p> <code>None</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/elements/#flixopt.elements.Flow-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Flow.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/elements/#flixopt.elements.Flow.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/elements/#flixopt.elements.FlowModel","title":"FlowModel","text":"<pre><code>FlowModel(model: SystemModel, element: Flow)\n</code></pre> <p>               Bases: <code>ElementModel</code></p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements.FlowModel.flow_rate_bounds_on","title":"flow_rate_bounds_on  <code>property</code>","text":"<pre><code>flow_rate_bounds_on: Tuple[NumericData, NumericData]\n</code></pre> <p>Returns absolute flow rate bounds. Important for OnOffModel</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.flow_rate_lower_bound_relative","title":"flow_rate_lower_bound_relative  <code>property</code>","text":"<pre><code>flow_rate_lower_bound_relative: NumericData\n</code></pre> <p>Returns the lower bound of the flow_rate relative to its size</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.flow_rate_upper_bound_relative","title":"flow_rate_upper_bound_relative  <code>property</code>","text":"<pre><code>flow_rate_upper_bound_relative: NumericData\n</code></pre> <p>Returns the upper bound of the flow_rate relative to its size</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.flow_rate_lower_bound","title":"flow_rate_lower_bound  <code>property</code>","text":"<pre><code>flow_rate_lower_bound: NumericData\n</code></pre> <p>Returns the minimum bound the flow_rate can reach. Further constraining might be done in OnOffModel and InvestmentModel</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.flow_rate_upper_bound","title":"flow_rate_upper_bound  <code>property</code>","text":"<pre><code>flow_rate_upper_bound: NumericData\n</code></pre> <p>Returns the maximum bound the flow_rate can reach. Further constraining might be done in OnOffModel and InvestmentModel</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.FlowModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel","title":"ComponentModel","text":"<pre><code>ComponentModel(model: SystemModel, element: Component)\n</code></pre> <p>               Bases: <code>ElementModel</code></p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.do_modeling","title":"do_modeling","text":"<pre><code>do_modeling()\n</code></pre> <p>Initiates all FlowModels</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/elements/#flixopt.elements-functions","title":"Functions","text":""},{"location":"api-reference/features/","title":"features","text":""},{"location":"api-reference/features/#flixopt.features","title":"flixopt.features","text":"<p>This module contains the features of the flixopt framework. Features extend the functionality of Elements.</p>"},{"location":"api-reference/features/#flixopt.features-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features-classes","title":"Classes","text":""},{"location":"api-reference/features/#flixopt.features.InvestmentModel","title":"InvestmentModel","text":"<pre><code>InvestmentModel(\n    model: SystemModel,\n    label_of_element: str,\n    parameters: InvestParameters,\n    defining_variable: [Variable],\n    relative_bounds_of_defining_variable: Tuple[NumericData, NumericData],\n    label: Optional[str] = None,\n    on_variable: Optional[Variable] = None,\n)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Class for modeling an investment</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.InvestmentModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.InvestmentModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.StateModel","title":"StateModel","text":"<pre><code>StateModel(\n    model: SystemModel,\n    label_of_element: str,\n    defining_variables: List[Variable],\n    defining_bounds: List[Tuple[NumericData, NumericData]],\n    previous_values: List[Optional[NumericData]] = None,\n    use_off: bool = True,\n    on_hours_total_min: Optional[NumericData] = 0,\n    on_hours_total_max: Optional[NumericData] = None,\n    effects_per_running_hour: Dict[str, NumericData] = None,\n    label: Optional[str] = None,\n)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Handles basic on/off binary states for defining variables</p> <p>Models binary state variables based on a continous variable.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>SystemModel</code> <p>The SystemModel that is used to create the model.</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>defining_variables</code> <code>List[Variable]</code> <p>List of Variables that are used to define the state</p> required <code>defining_bounds</code> <code>List[Tuple[NumericData, NumericData]]</code> <p>List of Tuples, defining the absolute bounds of each defining variable</p> required <code>previous_values</code> <code>List[Optional[NumericData]]</code> <p>List of previous values of the defining variables</p> <code>None</code> <code>use_off</code> <code>bool</code> <p>Whether to use the off state or not</p> <code>True</code> <code>on_hours_total_min</code> <code>Optional[NumericData]</code> <p>min. overall sum of operating hours.</p> <code>0</code> <code>on_hours_total_max</code> <code>Optional[NumericData]</code> <p>max. overall sum of operating hours.</p> <code>None</code> <code>effects_per_running_hour</code> <code>Dict[str, NumericData]</code> <p>Costs per operating hours</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>Label of the OnOffModel</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.StateModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.StateModel.previous_states","title":"previous_states  <code>property</code>","text":"<pre><code>previous_states: ndarray\n</code></pre> <p>Computes the previous states {0, 1} of defining variables as a binary array from their previous values.</p>"},{"location":"api-reference/features/#flixopt.features.StateModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.StateModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.StateModel.compute_previous_states","title":"compute_previous_states  <code>staticmethod</code>","text":"<pre><code>compute_previous_states(\n    previous_values: List[NumericData], epsilon: float = 1e-05\n) -&gt; np.ndarray\n</code></pre> <p>Computes the previous states {0, 1} of defining variables as a binary array from their previous values.</p>"},{"location":"api-reference/features/#flixopt.features.StateModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.SwitchStateModel","title":"SwitchStateModel","text":"<pre><code>SwitchStateModel(\n    model: SystemModel,\n    label_of_element: str,\n    state_variable: Variable,\n    previous_state=0,\n    switch_on_max: Optional[Scalar] = None,\n    label: Optional[str] = None,\n)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Handles switch on/off transitions</p>"},{"location":"api-reference/features/#flixopt.features.SwitchStateModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.SwitchStateModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.SwitchStateModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.SwitchStateModel.do_modeling","title":"do_modeling","text":"<pre><code>do_modeling()\n</code></pre> <p>Create switch variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.SwitchStateModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel","title":"ConsecutiveStateModel","text":"<pre><code>ConsecutiveStateModel(\n    model: SystemModel,\n    label_of_element: str,\n    state_variable: Variable,\n    minimum_duration: Optional[NumericData] = None,\n    maximum_duration: Optional[NumericData] = None,\n    previous_states: Optional[NumericData] = None,\n    label: Optional[str] = None,\n)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Handles tracking consecutive durations in a state</p> <p>Model and constraint the consecutive duration of a state variable.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>SystemModel</code> <p>The SystemModel that is used to create the model.</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>state_variable</code> <code>Variable</code> <p>The state variable that is used to model the duration. state = {0, 1}</p> required <code>minimum_duration</code> <code>Optional[NumericData]</code> <p>The minimum duration of the state variable.</p> <code>None</code> <code>maximum_duration</code> <code>Optional[NumericData]</code> <p>The maximum duration of the state variable.</p> <code>None</code> <code>previous_states</code> <code>Optional[NumericData]</code> <p>The previous states of the state variable.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>The label of the model. Used to construct the full label of the model.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel.previous_duration","title":"previous_duration  <code>property</code>","text":"<pre><code>previous_duration: Scalar\n</code></pre> <p>Computes the previous duration of the state variable</p>"},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel.do_modeling","title":"do_modeling","text":"<pre><code>do_modeling()\n</code></pre> <p>Create consecutive duration variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel.compute_consecutive_hours_in_state","title":"compute_consecutive_hours_in_state  <code>staticmethod</code>","text":"<pre><code>compute_consecutive_hours_in_state(\n    binary_values: NumericData, hours_per_timestep: Union[int, float, ndarray]\n) -&gt; Scalar\n</code></pre> <p>Computes the final consecutive duration in state 'on' (=1) in hours, from a binary array.</p> <p>Parameters:</p> Name Type Description Default <code>binary_values</code> <code>NumericData</code> <p>An int or 1D binary array containing only <code>0</code>s and <code>1</code>s.</p> required <code>hours_per_timestep</code> <code>Union[int, float, ndarray]</code> <p>The duration of each timestep in hours. If a scalar is provided, it is used for all timesteps. If an array is provided, it must be as long as the last consecutive duration in binary_values.</p> required <p>Returns:</p> Type Description <code>Scalar</code> <p>The duration of the binary variable in hours.</p>"},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel.compute_consecutive_hours_in_state--raises","title":"Raises","text":"<p>TypeError     If the length of binary_values and dt_in_hours is not equal, but None is a scalar.</p>"},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.OnOffModel","title":"OnOffModel","text":"<pre><code>OnOffModel(\n    model: SystemModel,\n    on_off_parameters: OnOffParameters,\n    label_of_element: str,\n    defining_variables: List[Variable],\n    defining_bounds: List[Tuple[NumericData, NumericData]],\n    previous_values: List[Optional[NumericData]],\n    label: Optional[str] = None,\n)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Class for modeling the on and off state of a variable Uses component models to create a modular implementation</p> <p>Constructor for OnOffModel</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>SystemModel</code> <p>Reference to the SystemModel</p> required <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Parameters for the OnOffModel</p> required <code>label_of_element</code> <code>str</code> <p>Label of the Parent</p> required <code>defining_variables</code> <code>List[Variable]</code> <p>List of Variables that are used to define the OnOffModel</p> required <code>defining_bounds</code> <code>List[Tuple[NumericData, NumericData]]</code> <p>List of Tuples, defining the absolute bounds of each defining variable</p> required <code>previous_values</code> <code>List[Optional[NumericData]]</code> <p>List of previous values of the defining variables</p> required <code>label</code> <code>Optional[str]</code> <p>Label of the OnOffModel</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.OnOffModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.OnOffModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.OnOffModel.do_modeling","title":"do_modeling","text":"<pre><code>do_modeling()\n</code></pre> <p>Create all variables and constraints for the OnOffModel</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.PieceModel","title":"PieceModel","text":"<pre><code>PieceModel(\n    model: SystemModel,\n    label_of_element: str,\n    label: str,\n    as_time_series: bool = True,\n)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Class for modeling a linear piece of one or more variables in parallel</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.PieceModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.PieceModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel","title":"PiecewiseModel","text":"<pre><code>PiecewiseModel(\n    model: SystemModel,\n    label_of_element: str,\n    piecewise_variables: Dict[str, Piecewise],\n    zero_point: Optional[Union[bool, Variable]],\n    as_time_series: bool,\n    label: str = '',\n)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Modeling a Piecewise relation between miultiple variables. The relation is defined by a list of Pieces, which are assigned to the variables. Each Piece is a tuple of (start, end).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>SystemModel</code> <p>The SystemModel that is used to create the model.</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>label</code> <code>str</code> <p>The label of the model. Used to construct the full label of the model.</p> <code>''</code> <code>piecewise_variables</code> <code>Dict[str, Piecewise]</code> <p>The variables to which the Pieces are assigned.</p> required <code>zero_point</code> <code>Optional[Union[bool, Variable]]</code> <p>A variable that can be used to define a zero point for the Piecewise relation. If None or False, no zero point is defined.</p> required <code>as_time_series</code> <code>bool</code> <p>Whether the Piecewise relation is defined for a TimeSeries or a single variable.</p> required"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel","title":"ShareAllocationModel","text":"<pre><code>ShareAllocationModel(\n    model: SystemModel,\n    shares_are_time_series: bool,\n    label_of_element: Optional[str] = None,\n    label: Optional[str] = None,\n    label_full: Optional[str] = None,\n    total_max: Optional[Scalar] = None,\n    total_min: Optional[Scalar] = None,\n    max_per_hour: Optional[NumericData] = None,\n    min_per_hour: Optional[NumericData] = None,\n)\n</code></pre> <p>               Bases: <code>Model</code></p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.add_share","title":"add_share","text":"<pre><code>add_share(name: str, expression: LinearExpression)\n</code></pre> <p>Add a share to the share allocation model. If the share already exists, the expression is added to the existing share. The expression is added to the right hand side (rhs) of the constraint. The variable representing the total share is on the left hand side (lhs) of the constraint. var_total = sum(expressions)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the share.</p> required <code>expression</code> <code>LinearExpression</code> <p>The expression of the share. Added to the right hand side of the constraint.</p> required"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel","title":"PreventSimultaneousUsageModel","text":"<pre><code>PreventSimultaneousUsageModel(\n    model: SystemModel,\n    variables: List[Variable],\n    label_of_element: str,\n    label: str = 'PreventSimultaneousUsage',\n)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Prevents multiple Multiple Binary variables from being 1 at the same time</p> <p>Only 'classic type is modeled for now (# \"classic\" -&gt; alle Flows brauchen Bin\u00e4rvariable:) In 'new', the binary Variables need to be forced beforehand, which is not that straight forward... --&gt; TODO maybe</p>"},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel--new","title":"\"new\":","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel--eq-flow_1ont-flow_2ont-flow_ivaltflow_imax-1-1-flow-ohne-binarvariable","title":"eq: flow_1.on(t) + flow_2.on(t) + .. + flow_i.val(t)/flow_i.max &lt;= 1 (1 Flow ohne Bin\u00e4rvariable!)","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel--anmerkung-patrick-schonfeld-oemof-customlinkpy-macht-bei-2-flows-ohne-binarvariable-dies","title":"Anmerkung: Patrick Sch\u00f6nfeld (oemof, custom/link.py) macht bei 2 Flows ohne Bin\u00e4rvariable dies:","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel--1-bin-flow1flow1_max-1","title":"1)        bin + flow1/flow1_max &lt;= 1","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel--2-bin-flow2flow2_max-0","title":"2)        bin - flow2/flow2_max &gt;= 0","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel--3-geht-nur-wenn-alle-flowmin-0","title":"3)    geht nur, wenn alle flow.min &gt;= 0","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel---konnte-man-auch-umsetzen-statt-force_on_variable-fur-die-flows-aber-sollte-aufs-selbe-wie-new-kommen","title":"--&gt; k\u00f6nnte man auch umsetzen (statt force_on_variable() f\u00fcr die Flows, aber sollte aufs selbe wie \"new\" kommen)","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/flow_system/","title":"flow_system","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system","title":"flixopt.flow_system","text":"<p>This module contains the FlowSystem class, which is used to collect instances of many other classes by the end User.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system-attributes","title":"Attributes","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system-classes","title":"Classes","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem","title":"FlowSystem","text":"<pre><code>FlowSystem(\n    timesteps: DatetimeIndex,\n    hours_of_last_timestep: Optional[float] = None,\n    hours_of_previous_timesteps: Optional[Union[int, float, ndarray]] = None,\n)\n</code></pre> <p>A FlowSystem organizes the high level Elements (Components &amp; Effects).</p> <p>Parameters:</p> Name Type Description Default <code>timesteps</code> <code>DatetimeIndex</code> <p>The timesteps of the model.</p> required <code>hours_of_last_timestep</code> <code>Optional[float]</code> <p>The duration of the last time step. Uses the last time interval if not specified</p> <code>None</code> <code>hours_of_previous_timesteps</code> <code>Optional[Union[int, float, ndarray]]</code> <p>The duration of previous timesteps. If None, the first time increment of time_series is used. This is needed to calculate previous durations (for example consecutive_on_hours). If you use an array, take care that its long enough to cover all previous values!</p> <code>None</code>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem-functions","title":"Functions","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; FlowSystem\n</code></pre> <p>Load a FlowSystem from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the FlowSystem data.</p> required"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: Union[str, Path])\n</code></pre> <p>Load a FlowSystem from a netcdf file</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.add_elements","title":"add_elements","text":"<pre><code>add_elements(*elements: Element) -&gt; None\n</code></pre> <p>Add Components(Storages, Boilers, Heatpumps, ...), Buses or Effects to the FlowSystem</p> <p>Parameters:</p> Name Type Description Default <code>*elements</code> <code>Element</code> <p>childs of  Element like Boiler, HeatPump, Bus,... modeling Elements</p> <code>()</code>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the flow system to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the flow_system to others.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.as_dict","title":"as_dict","text":"<pre><code>as_dict(data_mode: Literal['data', 'name', 'stats'] = 'data') -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.as_dataset","title":"as_dataset","text":"<pre><code>as_dataset(constants_in_dataset: bool = False) -&gt; xr.Dataset\n</code></pre> <p>Convert the FlowSystem to a xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>constants_in_dataset</code> <code>bool</code> <p>If True, constants are included as Dataset variables.</p> <code>False</code>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(\n    path: Union[str, Path],\n    compression: int = 0,\n    constants_in_dataset: bool = True,\n)\n</code></pre> <p>Saves the FlowSystem to a netCDF file. Args:     path: The path to the netCDF file.     compression: The compression level to use when saving the file.     constants_in_dataset: If True, constants are included as Dataset variables.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.plot_network","title":"plot_network","text":"<pre><code>plot_network(\n    path: Union[bool, str, Path] = 'flow_system.html',\n    controls: Union[\n        bool,\n        List[\n            Literal[\n                'nodes',\n                'edges',\n                'layout',\n                'interaction',\n                'manipulation',\n                'physics',\n                'selection',\n                'renderer',\n            ]\n        ],\n    ] = True,\n    show: bool = False,\n) -&gt; Optional[pyvis.network.Network]\n</code></pre> <p>Visualizes the network structure of a FlowSystem using PyVis, saving it as an interactive HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[bool, str, Path]</code> <p>Path to save the HTML visualization. - <code>False</code>: Visualization is created but not saved. - <code>str</code> or <code>Path</code>: Specifies file path (default: 'flow_system.html').</p> <code>'flow_system.html'</code> <code>controls</code> <code>Union[bool, List[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]]</code> <p>UI controls to add to the visualization. - <code>True</code>: Enables all available controls. - <code>List</code>: Specify controls, e.g., ['nodes', 'layout']. - Options: 'nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer'.</p> <code>True</code> <code>show</code> <code>bool</code> <p>Whether to open the visualization in the web browser.</p> <code>False</code> <p>Returns: - Optional[pyvis.network.Network]: The <code>Network</code> instance representing the visualization, or <code>None</code> if <code>pyvis</code> is not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.plot_network()\n&gt;&gt;&gt; flow_system.plot_network(show=False)\n&gt;&gt;&gt; flow_system.plot_network(path='output/custom_network.html', controls=['nodes', 'layout'])\n</code></pre> <p>Notes: - This function requires <code>pyvis</code>. If not installed, the function prints a warning and returns <code>None</code>. - Nodes are styled based on type (e.g., circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.create_time_series","title":"create_time_series","text":"<pre><code>create_time_series(\n    name: str,\n    data: Optional[Union[NumericData, TimeSeriesData, TimeSeries]],\n    needs_extra_timestep: bool = False,\n) -&gt; Optional[TimeSeries]\n</code></pre> <p>Tries to create a TimeSeries from NumericData Data and adds it to the time_series_collection If the data already is a TimeSeries, nothing happens and the TimeSeries gets reset and returned If the data is a TimeSeriesData, it is converted to a TimeSeries, and the aggregation weights are applied. If the data is None, nothing happens.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.create_effect_time_series","title":"create_effect_time_series","text":"<pre><code>create_effect_time_series(\n    label_prefix: Optional[str],\n    effect_values: EffectValuesUser,\n    label_suffix: Optional[str] = None,\n) -&gt; Optional[EffectTimeSeries]\n</code></pre> <p>Transform EffectValues to EffectTimeSeries. Creates a TimeSeries for each key in the nested_values dictionary, using the value as the data.</p> <p>The resulting label of the TimeSeries is the label of the parent_element, followed by the label of the Effect in the nested_values and the label_suffix. If the key in the EffectValues is None, the alias 'Standard_Effect' is used</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system-functions","title":"Functions","text":""},{"location":"api-reference/interface/","title":"interface","text":""},{"location":"api-reference/interface/#flixopt.interface","title":"flixopt.interface","text":"<p>This module contains classes to collect Parameters for the Investment and OnOff decisions. These are tightly connected to features.py</p>"},{"location":"api-reference/interface/#flixopt.interface-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixopt.interface-classes","title":"Classes","text":""},{"location":"api-reference/interface/#flixopt.interface.Piece","title":"Piece","text":"<pre><code>Piece(start: NumericData, end: NumericData)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a Piece, which is part of a Piecewise object.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>NumericData</code> <p>The x-values of the piece.</p> required <code>end</code> <code>NumericData</code> <p>The end of the piece.</p> required"},{"location":"api-reference/interface/#flixopt.interface.Piece-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.Piece.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/interface/#flixopt.interface.Piece.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/interface/#flixopt.interface.Piecewise","title":"Piecewise","text":"<pre><code>Piecewise(pieces: List[Piece])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a Piecewise, consisting of a list of Pieces.</p> <p>Parameters:</p> Name Type Description Default <code>pieces</code> <code>List[Piece]</code> <p>The pieces of the piecewise.</p> required"},{"location":"api-reference/interface/#flixopt.interface.Piecewise-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.Piecewise.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion","title":"PiecewiseConversion","text":"<pre><code>PiecewiseConversion(piecewises: Dict[str, Piecewise])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a piecewise conversion between multiple Flows. --&gt; \"gaps\" can be expressed by a piece not starting at the end of the prior piece: [(1,3), (4,5)] --&gt; \"points\" can expressed as piece with same begin and end: [(3,3), (4,4)]</p> <p>Parameters:</p> Name Type Description Default <code>piecewises</code> <code>Dict[str, Piecewise]</code> <p>Dict of Piecewises defining the conversion factors. flow labels as keys, piecewise as values</p> required"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects","title":"PiecewiseEffects","text":"<pre><code>PiecewiseEffects(\n    piecewise_origin: Piecewise, piecewise_shares: Dict[str, Piecewise]\n)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define piecewise effects related to a variable.</p> <p>Parameters:</p> Name Type Description Default <code>piecewise_origin</code> <code>Piecewise</code> <p>Piecewise of the related variable</p> required <code>piecewise_shares</code> <code>Dict[str, Piecewise]</code> <p>Piecewise defining the shares to different Effects</p> required"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters","title":"InvestParameters","text":"<pre><code>InvestParameters(\n    fixed_size: Optional[Union[int, float]] = None,\n    minimum_size: Optional[Union[int, float]] = None,\n    maximum_size: Optional[Union[int, float]] = None,\n    optional: bool = True,\n    fix_effects: Optional[EffectValuesUserScalar] = None,\n    specific_effects: Optional[EffectValuesUserScalar] = None,\n    piecewise_effects: Optional[PiecewiseEffects] = None,\n    divest_effects: Optional[EffectValuesUserScalar] = None,\n)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>collects arguments for invest-stuff</p> <p>Parameters:</p> Name Type Description Default <code>fix_effects</code> <code>Optional[EffectValuesUserScalar]</code> <p>Fixed investment costs if invested. (Attention: Annualize costs to chosen period!)</p> <code>None</code> <code>divest_effects</code> <code>Optional[EffectValuesUserScalar]</code> <p>Fixed divestment costs (if not invested, e.g., demolition costs or contractual penalty).</p> <code>None</code> <code>fixed_size</code> <code>Optional[Union[int, float]]</code> <p>Determines if the investment size is fixed.</p> <code>None</code> <code>optional</code> <code>bool</code> <p>If True, investment is not forced.</p> <code>True</code> <code>specific_effects</code> <code>Optional[EffectValuesUserScalar]</code> <p>Specific costs, e.g., in \u20ac/kW_nominal or \u20ac/m\u00b2_nominal. Example: {costs: 3, CO2: 0.3} with costs and CO2 representing an Object of class Effect (Attention: Annualize costs to chosen period!)</p> <code>None</code> <code>piecewise_effects</code> <code>Optional[PiecewiseEffects]</code> <p>Linear piecewise relation [invest_pieces, cost_pieces]. Example 1:     [           [5, 25, 25, 100],       # size in kW      {costs:    [50,250,250,800],       # \u20ac       PE:       [5, 25, 25, 100]        # kWh_PrimaryEnergy       }     ] Example 2 (if only standard-effect):     [   [5, 25, 25, 100],  # kW # size in kW         [50,250,250,800]        # value for standart effect, typically \u20ac      ]  # \u20ac (Attention: Annualize costs to chosen period!) (Args 'specific_effects' and 'fix_effects' can be used in parallel to Investsizepieces)</p> <code>None</code> <code>minimum_size</code> <code>Optional[Union[int, float]]</code> <p>Min nominal value (only if: size_is_fixed = False). Defaults to CONFIG.modeling.EPSILON.</p> <code>None</code> <code>maximum_size</code> <code>Optional[Union[int, float]]</code> <p>Max nominal value (only if: size_is_fixed = False). Defaults to CONFIG.modeling.BIG.</p> <code>None</code>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters","title":"OnOffParameters","text":"<pre><code>OnOffParameters(\n    effects_per_switch_on: Optional[EffectValuesUser] = None,\n    effects_per_running_hour: Optional[EffectValuesUser] = None,\n    on_hours_total_min: Optional[int] = None,\n    on_hours_total_max: Optional[int] = None,\n    consecutive_on_hours_min: Optional[NumericData] = None,\n    consecutive_on_hours_max: Optional[NumericData] = None,\n    consecutive_off_hours_min: Optional[NumericData] = None,\n    consecutive_off_hours_max: Optional[NumericData] = None,\n    switch_on_total_max: Optional[int] = None,\n    force_switch_on: bool = False,\n)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Bundles information about the on and off state of an Element. If no parameters are given, the default is to create a binary variable for the on state without further constraints or effects and a variable for the total on hours.</p> <p>Parameters:</p> Name Type Description Default <code>effects_per_switch_on</code> <code>Optional[EffectValuesUser]</code> <p>cost of one switch from off (var_on=0) to on (var_on=1), unit i.g. in Euro</p> <code>None</code> <code>effects_per_running_hour</code> <code>Optional[EffectValuesUser]</code> <p>costs for operating, i.g. in \u20ac per hour</p> <code>None</code> <code>on_hours_total_min</code> <code>Optional[int]</code> <p>min. overall sum of operating hours.</p> <code>None</code> <code>on_hours_total_max</code> <code>Optional[int]</code> <p>max. overall sum of operating hours.</p> <code>None</code> <code>consecutive_on_hours_min</code> <code>Optional[NumericData]</code> <p>min sum of operating hours in one piece (last on-time period of timeseries is not checked and can be shorter)</p> <code>None</code> <code>consecutive_on_hours_max</code> <code>Optional[NumericData]</code> <p>max sum of operating hours in one piece</p> <code>None</code> <code>consecutive_off_hours_min</code> <code>Optional[NumericData]</code> <p>min sum of non-operating hours in one piece (last off-time period of timeseries is not checked and can be shorter)</p> <code>None</code> <code>consecutive_off_hours_max</code> <code>Optional[NumericData]</code> <p>max sum of non-operating hours in one piece</p> <code>None</code> <code>switch_on_total_max</code> <code>Optional[int]</code> <p>max nr of switchOn operations</p> <code>None</code> <code>force_switch_on</code> <code>bool</code> <p>force creation of switch on variable, even if there is no switch_on_total_max</p> <code>False</code>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.use_off","title":"use_off  <code>property</code>","text":"<pre><code>use_off: bool\n</code></pre> <p>Determines wether the OFF Variable is needed or not</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.use_consecutive_on_hours","title":"use_consecutive_on_hours  <code>property</code>","text":"<pre><code>use_consecutive_on_hours: bool\n</code></pre> <p>Determines wether a Variable for consecutive off hours is needed or not</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.use_consecutive_off_hours","title":"use_consecutive_off_hours  <code>property</code>","text":"<pre><code>use_consecutive_off_hours: bool\n</code></pre> <p>Determines wether a Variable for consecutive off hours is needed or not</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.use_switch_on","title":"use_switch_on  <code>property</code>","text":"<pre><code>use_switch_on: bool\n</code></pre> <p>Determines wether a Variable for SWITCH-ON is needed or not</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/interface/#flixopt.interface-functions","title":"Functions","text":""},{"location":"api-reference/io/","title":"io","text":""},{"location":"api-reference/io/#flixopt.io","title":"flixopt.io","text":""},{"location":"api-reference/io/#flixopt.io-classes","title":"Classes","text":""},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths","title":"CalculationResultsPaths  <code>dataclass</code>","text":"<pre><code>CalculationResultsPaths(folder: Path, name: str)\n</code></pre> <p>Container for all paths related to saving CalculationResults.</p>"},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths-functions","title":"Functions","text":""},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths.all_paths","title":"all_paths","text":"<pre><code>all_paths() -&gt; Dict[str, pathlib.Path]\n</code></pre> <p>Return a dictionary of all paths.</p>"},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths.create_folders","title":"create_folders","text":"<pre><code>create_folders(parents: bool = False) -&gt; None\n</code></pre> <p>Ensure the folder exists. Args:     parents: Whether to create the parent folders if they do not exist.</p>"},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths.update","title":"update","text":"<pre><code>update(\n    new_name: Optional[str] = None, new_folder: Optional[Path] = None\n) -&gt; None\n</code></pre> <p>Update name and/or folder and refresh all paths.</p>"},{"location":"api-reference/io/#flixopt.io-functions","title":"Functions","text":""},{"location":"api-reference/io/#flixopt.io.replace_timeseries","title":"replace_timeseries","text":"<pre><code>replace_timeseries(obj, mode: Literal['name', 'stats', 'data'] = 'name')\n</code></pre> <p>Recursively replaces TimeSeries objects with their names prefixed by '::::'.</p>"},{"location":"api-reference/io/#flixopt.io.insert_dataarray","title":"insert_dataarray","text":"<pre><code>insert_dataarray(obj, ds: Dataset)\n</code></pre> <p>Recursively inserts TimeSeries objects into a dataset.</p>"},{"location":"api-reference/io/#flixopt.io.remove_none_and_empty","title":"remove_none_and_empty","text":"<pre><code>remove_none_and_empty(obj)\n</code></pre> <p>Recursively removes None and empty dicts and lists values from a dictionary or list.</p>"},{"location":"api-reference/io/#flixopt.io.document_linopy_model","title":"document_linopy_model","text":"<pre><code>document_linopy_model(model: Model, path: Path = None) -&gt; Dict[str, str]\n</code></pre> <p>Convert all model variables and constraints to a structured string representation. This can take multiple seconds for large models. The output can be saved to a yaml file with readable formating applied.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to save the document. Defaults to None.</p> <code>None</code>"},{"location":"api-reference/io/#flixopt.io.save_dataset_to_netcdf","title":"save_dataset_to_netcdf","text":"<pre><code>save_dataset_to_netcdf(\n    ds: Dataset, path: Union[str, Path], compression: int = 0\n) -&gt; None\n</code></pre> <p>Save a dataset to a netcdf file. Store the attrs as a json string in the 'attrs' attribute.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset to save.</p> required <code>path</code> <code>Union[str, Path]</code> <p>Path to save the dataset to.</p> required <code>compression</code> <code>int</code> <p>Compression level for the dataset (0-9). 0 means no compression. 5 is a good default.</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path has an invalid file extension.</p>"},{"location":"api-reference/io/#flixopt.io.load_dataset_from_netcdf","title":"load_dataset_from_netcdf","text":"<pre><code>load_dataset_from_netcdf(path: Union[str, Path]) -&gt; xr.Dataset\n</code></pre> <p>Load a dataset from a netcdf file. Load the attrs from the 'attrs' attribute.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to load the dataset from.</p> required <p>Returns:</p> Name Type Description <code>Dataset</code> <code>Dataset</code> <p>Loaded dataset.</p>"},{"location":"api-reference/linear_converters/","title":"linear_converters","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters","title":"flixopt.linear_converters","text":"<p>This Module contains high-level classes to easily model a FlowSystem.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters-attributes","title":"Attributes","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters-classes","title":"Classes","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler","title":"Boiler","text":"<pre><code>Boiler(\n    label: str,\n    eta: NumericDataTS,\n    Q_fu: Flow,\n    Q_th: Flow,\n    on_off_parameters: OnOffParameters = None,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>eta</code> <code>NumericDataTS</code> <p>thermal efficiency.</p> required <code>Q_fu</code> <code>Flow</code> <p>fuel input-flow</p> required <code>Q_th</code> <code>Flow</code> <p>thermal output-flow.</p> required <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Parameters defining the on/off behavior of the component.</p> <code>None</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat","title":"Power2Heat","text":"<pre><code>Power2Heat(\n    label: str,\n    eta: NumericDataTS,\n    P_el: Flow,\n    Q_th: Flow,\n    on_off_parameters: OnOffParameters = None,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>eta</code> <code>NumericDataTS</code> <p>thermal efficiency.</p> required <code>P_el</code> <code>Flow</code> <p>electric input-flow</p> required <code>Q_th</code> <code>Flow</code> <p>thermal output-flow.</p> required <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Parameters defining the on/off behavior of the component.</p> <code>None</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump","title":"HeatPump","text":"<pre><code>HeatPump(\n    label: str,\n    COP: NumericDataTS,\n    P_el: Flow,\n    Q_th: Flow,\n    on_off_parameters: OnOffParameters = None,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>COP</code> <code>NumericDataTS</code> <p>Coefficient of performance.</p> required <code>P_el</code> <code>Flow</code> <p>electricity input-flow.</p> required <code>Q_th</code> <code>Flow</code> <p>thermal output-flow.</p> required <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Parameters defining the on/off behavior of the component.</p> <code>None</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower","title":"CoolingTower","text":"<pre><code>CoolingTower(\n    label: str,\n    specific_electricity_demand: NumericDataTS,\n    P_el: Flow,\n    Q_th: Flow,\n    on_off_parameters: OnOffParameters = None,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>specific_electricity_demand</code> <code>NumericDataTS</code> <p>auxiliary electricty demand per cooling power, i.g. 0.02 (2 %).</p> required <code>P_el</code> <code>Flow</code> <p>electricity input-flow.</p> required <code>Q_th</code> <code>Flow</code> <p>thermal input-flow.</p> required <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Parameters defining the on/off behavior of the component.</p> <code>None</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP","title":"CHP","text":"<pre><code>CHP(\n    label: str,\n    eta_th: NumericDataTS,\n    eta_el: NumericDataTS,\n    Q_fu: Flow,\n    P_el: Flow,\n    Q_th: Flow,\n    on_off_parameters: OnOffParameters = None,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>eta_th</code> <code>NumericDataTS</code> <p>thermal efficiency.</p> required <code>eta_el</code> <code>NumericDataTS</code> <p>electrical efficiency.</p> required <code>Q_fu</code> <code>Flow</code> <p>fuel input-flow.</p> required <code>P_el</code> <code>Flow</code> <p>electricity output-flow.</p> required <code>Q_th</code> <code>Flow</code> <p>heat output-flow.</p> required <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Parameters defining the on/off behavior of the component.</p> <code>None</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource","title":"HeatPumpWithSource","text":"<pre><code>HeatPumpWithSource(\n    label: str,\n    COP: NumericDataTS,\n    P_el: Flow,\n    Q_ab: Flow,\n    Q_th: Flow,\n    on_off_parameters: OnOffParameters = None,\n    meta_data: Optional[Dict] = None,\n)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem</p> required <code>COP</code> <code>NumericDataTS</code> <p>Coefficient of performance.</p> required <code>Q_ab</code> <code>Flow</code> <p>Heatsource input-flow.</p> required <code>P_el</code> <code>Flow</code> <p>electricity input-flow.</p> required <code>Q_th</code> <code>Flow</code> <p>thermal output-flow.</p> required <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Parameters defining the on/off behavior of the component.</p> <code>None</code> <code>meta_data</code> <code>Optional[Dict]</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.check_bounds","title":"check_bounds","text":"<pre><code>check_bounds(\n    value: NumericDataTS,\n    parameter_label: str,\n    element_label: str,\n    lower_bound: NumericDataTS,\n    upper_bound: NumericDataTS,\n) -&gt; None\n</code></pre> <p>Check if the value is within the bounds. The bounds are exclusive. If not, log a warning. Args:     value: The value to check.     parameter_label: The label of the value.     element_label: The label of the element.     lower_bound: The lower bound.     upper_bound: The upper bound.</p>"},{"location":"api-reference/plotting/","title":"plotting","text":""},{"location":"api-reference/plotting/#flixopt.plotting","title":"flixopt.plotting","text":"<p>This module contains the plotting functionality of the flixopt framework. It provides high level functions to plot data with plotly and matplotlib. It's meant to be used in results.py, but is designed to be used by the end user as well.</p>"},{"location":"api-reference/plotting/#flixopt.plotting-attributes","title":"Attributes","text":""},{"location":"api-reference/plotting/#flixopt.plotting.ColorType","title":"ColorType  <code>module-attribute</code>","text":"<pre><code>ColorType = Union[str, List[str], Dict[str, str]]\n</code></pre> <p>Identifier for the colors to use. Use the name of a colorscale, a list of colors or a dictionary of labels to colors. The colors must be valid color strings (HEX or names). Depending on the Engine used, other formats are possible. See also: - https://htmlcolorcodes.com/color-names/ - https://matplotlib.org/stable/tutorials/colors/colormaps.html - https://plotly.com/python/builtin-colorscales/</p>"},{"location":"api-reference/plotting/#flixopt.plotting.PlottingEngine","title":"PlottingEngine  <code>module-attribute</code>","text":"<pre><code>PlottingEngine = Literal['plotly', 'matplotlib']\n</code></pre> <p>Identifier for the plotting engine to use.</p>"},{"location":"api-reference/plotting/#flixopt.plotting-classes","title":"Classes","text":""},{"location":"api-reference/plotting/#flixopt.plotting.ColorProcessor","title":"ColorProcessor","text":"<pre><code>ColorProcessor(\n    engine: PlottingEngine = 'plotly', default_colormap: str = 'viridis'\n)\n</code></pre> <p>Class to handle color processing for different visualization engines.</p> <p>Initialize the color processor.</p> <p>Parameters:</p> Name Type Description Default <code>engine</code> <code>PlottingEngine</code> <p>The plotting engine to use ('plotly' or 'matplotlib')</p> <code>'plotly'</code> <code>default_colormap</code> <code>str</code> <p>Default colormap to use if none is specified</p> <code>'viridis'</code>"},{"location":"api-reference/plotting/#flixopt.plotting.ColorProcessor-functions","title":"Functions","text":""},{"location":"api-reference/plotting/#flixopt.plotting.ColorProcessor.process_colors","title":"process_colors","text":"<pre><code>process_colors(\n    colors: ColorType, labels: List[str], return_mapping: bool = False\n) -&gt; Union[List[Any], Dict[str, Any]]\n</code></pre> <p>Process colors for the specified labels.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>ColorType</code> <p>Color specification (colormap name, list of colors, or label-to-color mapping)</p> required <code>labels</code> <code>List[str]</code> <p>List of data labels that need colors assigned</p> required <code>return_mapping</code> <code>bool</code> <p>If True, returns a dictionary mapping labels to colors;            if False, returns a list of colors in the same order as labels</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[List[Any], Dict[str, Any]]</code> <p>Either a list of colors or a dictionary mapping labels to colors</p>"},{"location":"api-reference/plotting/#flixopt.plotting-functions","title":"Functions","text":""},{"location":"api-reference/plotting/#flixopt.plotting.with_plotly","title":"with_plotly","text":"<pre><code>with_plotly(\n    data: DataFrame,\n    mode: Literal['bar', 'line', 'area'] = 'area',\n    colors: ColorType = 'viridis',\n    title: str = '',\n    ylabel: str = '',\n    xlabel: str = 'Time in h',\n    fig: Optional[Figure] = None,\n) -&gt; go.Figure\n</code></pre> <p>Plot a DataFrame with Plotly, using either stacked bars or stepped lines.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame containing the data to plot, where the index represents time (e.g., hours),   and each column represents a separate data series.</p> required <code>mode</code> <code>Literal['bar', 'line', 'area']</code> <p>The plotting mode. Use 'bar' for stacked bar charts, 'line' for stepped lines,   or 'area' for stacked area charts.</p> <code>'area'</code> <code>colors</code> <code>ColorType</code> <p>Color specification, can be: - A string with a colorscale name (e.g., 'viridis', 'plasma') - A list of color strings (e.g., ['#ff0000', '#00ff00']) - A dictionary mapping column names to colors (e.g., {'Column1': '#ff0000'})</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The title of the plot.</p> <code>''</code> <code>ylabel</code> <code>str</code> <p>The label for the y-axis.</p> <code>''</code> <code>fig</code> <code>Optional[Figure]</code> <p>A Plotly figure object to plot on. If not provided, a new figure will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A Plotly figure object containing the generated plot.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.with_matplotlib","title":"with_matplotlib","text":"<pre><code>with_matplotlib(\n    data: DataFrame,\n    mode: Literal['bar', 'line'] = 'bar',\n    colors: ColorType = 'viridis',\n    title: str = '',\n    ylabel: str = '',\n    xlabel: str = 'Time in h',\n    figsize: Tuple[int, int] = (12, 6),\n    fig: Optional[Figure] = None,\n    ax: Optional[Axes] = None,\n) -&gt; Tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plot a DataFrame with Matplotlib using stacked bars or stepped lines.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame containing the data to plot. The index should represent time (e.g., hours),   and each column represents a separate data series.</p> required <code>mode</code> <code>Literal['bar', 'line']</code> <p>Plotting mode. Use 'bar' for stacked bar charts or 'line' for stepped lines.</p> <code>'bar'</code> <code>colors</code> <code>ColorType</code> <p>Color specification, can be: - A string with a colormap name (e.g., 'viridis', 'plasma') - A list of color strings (e.g., ['#ff0000', '#00ff00']) - A dictionary mapping column names to colors (e.g., {'Column1': '#ff0000'})</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The title of the plot.</p> <code>''</code> <code>ylabel</code> <code>str</code> <p>The ylabel of the plot.</p> <code>''</code> <code>xlabel</code> <code>str</code> <p>The xlabel of the plot.</p> <code>'Time in h'</code> <code>figsize</code> <code>Tuple[int, int]</code> <p>Specify the size of the figure</p> <code>(12, 6)</code> <code>fig</code> <code>Optional[Figure]</code> <p>A Matplotlib figure object to plot on. If not provided, a new figure will be created.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>A Matplotlib axes object to plot on. If not provided, a new axes will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Figure, Axes]</code> <p>A tuple containing the Matplotlib figure and axes objects used for the plot.</p> Notes <ul> <li>If <code>mode</code> is 'bar', bars are stacked for both positive and negative values.   Negative values are stacked separately without extra labels in the legend.</li> <li>If <code>mode</code> is 'line', stepped lines are drawn for each data series.</li> <li>The legend is placed below the plot to accommodate multiple data series.</li> </ul>"},{"location":"api-reference/plotting/#flixopt.plotting.heat_map_matplotlib","title":"heat_map_matplotlib","text":"<pre><code>heat_map_matplotlib(\n    data: DataFrame,\n    color_map: str = 'viridis',\n    title: str = '',\n    xlabel: str = 'Period',\n    ylabel: str = 'Step',\n    figsize: Tuple[float, float] = (12, 6),\n) -&gt; Tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plots a DataFrame as a heatmap using Matplotlib. The columns of the DataFrame will be displayed on the x-axis, the index will be displayed on the y-axis, and the values will represent the 'heat' intensity in the plot.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame containing the data to be visualized. The index will be used for the y-axis, and columns will be used for the x-axis. The values in the DataFrame will be represented as colors in the heatmap.</p> required <code>color_map</code> <code>str</code> <p>The colormap to use for the heatmap. Default is 'viridis'. Matplotlib supports various colormaps like 'plasma', 'inferno', 'cividis', etc.</p> <code>'viridis'</code> <code>figsize</code> <code>Tuple[float, float]</code> <p>The size of the figure to create. Default is (12, 6), which results in a width of 12 inches and a height of 6 inches.</p> <code>(12, 6)</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A tuple containing the Matplotlib <code>Figure</code> and <code>Axes</code> objects. The <code>Figure</code> contains the overall plot, while the <code>Axes</code> is the area</p> <code>Axes</code> <p>where the heatmap is drawn. These can be used for further customization or saving the plot to a file.</p> Notes <ul> <li>The y-axis is flipped so that the first row of the DataFrame is displayed at the top of the plot.</li> <li>The color scale is normalized based on the minimum and maximum values in the DataFrame.</li> <li>The x-axis labels (periods) are placed at the top of the plot.</li> <li>The colorbar is added horizontally at the bottom of the plot, with a label.</li> </ul>"},{"location":"api-reference/plotting/#flixopt.plotting.heat_map_plotly","title":"heat_map_plotly","text":"<pre><code>heat_map_plotly(\n    data: DataFrame,\n    color_map: str = 'viridis',\n    title: str = '',\n    xlabel: str = 'Period',\n    ylabel: str = 'Step',\n    categorical_labels: bool = True,\n) -&gt; go.Figure\n</code></pre> <p>Plots a DataFrame as a heatmap using Plotly. The columns of the DataFrame will be mapped to the x-axis, and the index will be displayed on the y-axis. The values in the DataFrame will represent the 'heat' in the plot.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame with the data to be visualized. The index will be used for the y-axis, and columns will be used for the x-axis. The values in the DataFrame will be represented as colors in the heatmap.</p> required <code>color_map</code> <code>str</code> <p>The color scale to use for the heatmap. Default is 'viridis'. Plotly supports various color scales like 'Cividis', 'Inferno', etc.</p> <code>'viridis'</code> <code>categorical_labels</code> <code>bool</code> <p>If True, the x and y axes are treated as categorical data (i.e., the index and columns will not be interpreted as continuous data). Default is True. If False, the axes are treated as continuous, which may be useful for time series or numeric data.</p> <code>True</code> <code>show</code> <p>Wether to show the figure after creation. (This includes saving the figure)</p> required <code>save</code> <p>Wether to save the figure after creation (without showing)</p> required <code>path</code> <p>Path to save the figure.</p> required <p>Returns:</p> Type Description <code>Figure</code> <p>A Plotly figure object containing the heatmap. This can be further customized and saved</p> <code>Figure</code> <p>or displayed using <code>fig.show()</code>.</p> Notes <p>The color bar is automatically scaled to the minimum and maximum values in the data. The y-axis is reversed to display the first row at the top.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.reshape_to_2d","title":"reshape_to_2d","text":"<pre><code>reshape_to_2d(data_1d: ndarray, nr_of_steps_per_column: int) -&gt; np.ndarray\n</code></pre> <p>Reshapes a 1D numpy array into a 2D array suitable for plotting as a colormap.</p> <p>The reshaped array will have the number of rows corresponding to the steps per column (e.g., 24 hours per day) and columns representing time periods (e.g., days or months).</p> <p>Parameters:</p> Name Type Description Default <code>data_1d</code> <code>ndarray</code> <p>A 1D numpy array with the data to reshape.</p> required <code>nr_of_steps_per_column</code> <code>int</code> <p>The number of steps (rows) per column in the resulting 2D array. For example, this could be 24 (for hours) or 31 (for days in a month).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The reshaped 2D array. Each internal array corresponds to one column, with the specified number of steps.</p> <code>ndarray</code> <p>Each column might represents a time period (e.g., day, month, etc.).</p>"},{"location":"api-reference/plotting/#flixopt.plotting.heat_map_data_from_df","title":"heat_map_data_from_df","text":"<pre><code>heat_map_data_from_df(\n    df: DataFrame,\n    periods: Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'],\n    steps_per_period: Literal['W', 'D', 'h', '15min', 'min'],\n    fill: Optional[Literal['ffill', 'bfill']] = None,\n) -&gt; pd.DataFrame\n</code></pre> <p>Reshapes a DataFrame with a DateTime index into a 2D array for heatmap plotting, based on a specified sample rate. If a non-valid combination of periods and steps per period is used, falls back to numerical indices</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A DataFrame with a DateTime index containing the data to reshape.</p> required <code>periods</code> <code>Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min']</code> <p>The time interval of each period (columns of the heatmap), such as 'YS' (year start), 'W' (weekly), 'D' (daily), 'h' (hourly) etc.</p> required <code>steps_per_period</code> <code>Literal['W', 'D', 'h', '15min', 'min']</code> <p>The time interval within each period (rows in the heatmap), such as 'YS' (year start), 'W' (weekly), 'D' (daily), 'h' (hourly) etc.</p> required <code>fill</code> <code>Optional[Literal['ffill', 'bfill']]</code> <p>Method to fill missing values: 'ffill' for forward fill or 'bfill' for backward fill.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame suitable for heatmap plotting, with rows representing steps within each period</p> <code>DataFrame</code> <p>and columns representing each period.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.plot_network","title":"plot_network","text":"<pre><code>plot_network(\n    node_infos: dict,\n    edge_infos: dict,\n    path: Optional[Union[str, Path]] = None,\n    controls: Union[\n        bool,\n        List[\n            Literal[\n                'nodes',\n                'edges',\n                'layout',\n                'interaction',\n                'manipulation',\n                'physics',\n                'selection',\n                'renderer',\n            ]\n        ],\n    ] = True,\n    show: bool = False,\n) -&gt; Optional[pyvis.network.Network]\n</code></pre> <p>Visualizes the network structure of a FlowSystem using PyVis, using info-dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Union[str, Path]]</code> <p>Path to save the HTML visualization. <code>False</code>: Visualization is created but not saved. <code>str</code> or <code>Path</code>: Specifies file path (default: 'results/network.html').</p> <code>None</code> <code>controls</code> <code>Union[bool, List[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]]</code> <p>UI controls to add to the visualization. <code>True</code>: Enables all available controls. <code>List</code>: Specify controls, e.g., ['nodes', 'layout']. Options: 'nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer'. You can play with these and generate a Dictionary from it that can be applied to the network returned by this function. network.set_options() https://pyvis.readthedocs.io/en/latest/tutorial.html</p> <code>True</code> <code>show</code> <code>bool</code> <p>Whether to open the visualization in the web browser. The calculation must be saved to show it. If no path is given, it defaults to 'network.html'.</p> <code>False</code> <p>Returns:     The <code>Network</code> instance representing the visualization, or <code>None</code> if <code>pyvis</code> is not installed.</p> <p>Notes: - This function requires <code>pyvis</code>. If not installed, the function prints a warning and returns <code>None</code>. - Nodes are styled based on type (e.g., circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.pie_with_plotly","title":"pie_with_plotly","text":"<pre><code>pie_with_plotly(\n    data: DataFrame,\n    colors: ColorType = 'viridis',\n    title: str = '',\n    legend_title: str = '',\n    hole: float = 0.0,\n    fig: Optional[Figure] = None,\n) -&gt; go.Figure\n</code></pre> <p>Create a pie chart with Plotly to visualize the proportion of values in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame containing the data to plot. If multiple rows exist,   they will be summed unless a specific index value is passed.</p> required <code>colors</code> <code>ColorType</code> <p>Color specification, can be: - A string with a colorscale name (e.g., 'viridis', 'plasma') - A list of color strings (e.g., ['#ff0000', '#00ff00']) - A dictionary mapping column names to colors (e.g., {'Column1': '#ff0000'})</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The title of the plot.</p> <code>''</code> <code>legend_title</code> <code>str</code> <p>The title for the legend.</p> <code>''</code> <code>hole</code> <code>float</code> <p>Size of the hole in the center for creating a donut chart (0.0 to 1.0).</p> <code>0.0</code> <code>fig</code> <code>Optional[Figure]</code> <p>A Plotly figure object to plot on. If not provided, a new figure will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A Plotly figure object containing the generated pie chart.</p> Notes <ul> <li>Negative values are not appropriate for pie charts and will be converted to absolute values with a warning.</li> <li>If the data contains very small values (less than 1% of the total), they can be grouped into an \"Other\" category   for better readability.</li> <li>By default, the sum of all columns is used for the pie chart. For time series data, consider preprocessing.</li> </ul>"},{"location":"api-reference/plotting/#flixopt.plotting.pie_with_matplotlib","title":"pie_with_matplotlib","text":"<pre><code>pie_with_matplotlib(\n    data: DataFrame,\n    colors: ColorType = 'viridis',\n    title: str = '',\n    legend_title: str = 'Categories',\n    hole: float = 0.0,\n    figsize: Tuple[int, int] = (10, 8),\n    fig: Optional[Figure] = None,\n    ax: Optional[Axes] = None,\n) -&gt; Tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Create a pie chart with Matplotlib to visualize the proportion of values in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame containing the data to plot. If multiple rows exist,   they will be summed unless a specific index value is passed.</p> required <code>colors</code> <code>ColorType</code> <p>Color specification, can be: - A string with a colormap name (e.g., 'viridis', 'plasma') - A list of color strings (e.g., ['#ff0000', '#00ff00']) - A dictionary mapping column names to colors (e.g., {'Column1': '#ff0000'})</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The title of the plot.</p> <code>''</code> <code>legend_title</code> <code>str</code> <p>The title for the legend.</p> <code>'Categories'</code> <code>hole</code> <code>float</code> <p>Size of the hole in the center for creating a donut chart (0.0 to 1.0).</p> <code>0.0</code> <code>figsize</code> <code>Tuple[int, int]</code> <p>The size of the figure (width, height) in inches.</p> <code>(10, 8)</code> <code>fig</code> <code>Optional[Figure]</code> <p>A Matplotlib figure object to plot on. If not provided, a new figure will be created.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>A Matplotlib axes object to plot on. If not provided, a new axes will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Figure, Axes]</code> <p>A tuple containing the Matplotlib figure and axes objects used for the plot.</p> Notes <ul> <li>Negative values are not appropriate for pie charts and will be converted to absolute values with a warning.</li> <li>If the data contains very small values (less than 1% of the total), they can be grouped into an \"Other\" category   for better readability.</li> <li>By default, the sum of all columns is used for the pie chart. For time series data, consider preprocessing.</li> </ul>"},{"location":"api-reference/plotting/#flixopt.plotting.dual_pie_with_plotly","title":"dual_pie_with_plotly","text":"<pre><code>dual_pie_with_plotly(\n    data_left: Series,\n    data_right: Series,\n    colors: ColorType = 'viridis',\n    title: str = '',\n    subtitles: Tuple[str, str] = ('Left Chart', 'Right Chart'),\n    legend_title: str = '',\n    hole: float = 0.2,\n    lower_percentage_group: float = 5.0,\n    hover_template: str = '%{label}: %{value} (%{percent})',\n    text_info: str = 'percent+label',\n    text_position: str = 'inside',\n) -&gt; go.Figure\n</code></pre> <p>Create two pie charts side by side with Plotly, with consistent coloring across both charts.</p> <p>Parameters:</p> Name Type Description Default <code>data_left</code> <code>Series</code> <p>Series for the left pie chart.</p> required <code>data_right</code> <code>Series</code> <p>Series for the right pie chart.</p> required <code>colors</code> <code>ColorType</code> <p>Color specification, can be: - A string with a colorscale name (e.g., 'viridis', 'plasma') - A list of color strings (e.g., ['#ff0000', '#00ff00']) - A dictionary mapping category names to colors (e.g., {'Category1': '#ff0000'})</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The main title of the plot.</p> <code>''</code> <code>subtitles</code> <code>Tuple[str, str]</code> <p>Tuple containing the subtitles for (left, right) charts.</p> <code>('Left Chart', 'Right Chart')</code> <code>legend_title</code> <code>str</code> <p>The title for the legend.</p> <code>''</code> <code>hole</code> <code>float</code> <p>Size of the hole in the center for creating donut charts (0.0 to 100).</p> <code>0.2</code> <code>lower_percentage_group</code> <code>float</code> <p>Whether to group small segments (below percentage (0...1)) into an \"Other\" category.</p> <code>5.0</code> <code>hover_template</code> <code>str</code> <p>Template for hover text. Use %{label}, %{value}, %{percent}.</p> <code>'%{label}: %{value} (%{percent})'</code> <code>text_info</code> <code>str</code> <p>What to show on pie segments: 'label', 'percent', 'value', 'label+percent',       'label+value', 'percent+value', 'label+percent+value', or 'none'.</p> <code>'percent+label'</code> <code>text_position</code> <code>str</code> <p>Position of text: 'inside', 'outside', 'auto', or 'none'.</p> <code>'inside'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A Plotly figure object containing the generated dual pie chart.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.dual_pie_with_matplotlib","title":"dual_pie_with_matplotlib","text":"<pre><code>dual_pie_with_matplotlib(\n    data_left: Series,\n    data_right: Series,\n    colors: ColorType = 'viridis',\n    title: str = '',\n    subtitles: Tuple[str, str] = ('Left Chart', 'Right Chart'),\n    legend_title: str = '',\n    hole: float = 0.2,\n    lower_percentage_group: float = 5.0,\n    figsize: Tuple[int, int] = (14, 7),\n    fig: Optional[Figure] = None,\n    axes: Optional[List[Axes]] = None,\n) -&gt; Tuple[plt.Figure, List[plt.Axes]]\n</code></pre> <p>Create two pie charts side by side with Matplotlib, with consistent coloring across both charts. Leverages the existing pie_with_matplotlib function.</p> <p>Parameters:</p> Name Type Description Default <code>data_left</code> <code>Series</code> <p>Series for the left pie chart.</p> required <code>data_right</code> <code>Series</code> <p>Series for the right pie chart.</p> required <code>colors</code> <code>ColorType</code> <p>Color specification, can be: - A string with a colormap name (e.g., 'viridis', 'plasma') - A list of color strings (e.g., ['#ff0000', '#00ff00']) - A dictionary mapping category names to colors (e.g., {'Category1': '#ff0000'})</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The main title of the plot.</p> <code>''</code> <code>subtitles</code> <code>Tuple[str, str]</code> <p>Tuple containing the subtitles for (left, right) charts.</p> <code>('Left Chart', 'Right Chart')</code> <code>legend_title</code> <code>str</code> <p>The title for the legend.</p> <code>''</code> <code>hole</code> <code>float</code> <p>Size of the hole in the center for creating donut charts (0.0 to 1.0).</p> <code>0.2</code> <code>lower_percentage_group</code> <code>float</code> <p>Whether to group small segments (below percentage) into an \"Other\" category.</p> <code>5.0</code> <code>figsize</code> <code>Tuple[int, int]</code> <p>The size of the figure (width, height) in inches.</p> <code>(14, 7)</code> <code>fig</code> <code>Optional[Figure]</code> <p>A Matplotlib figure object to plot on. If not provided, a new figure will be created.</p> <code>None</code> <code>axes</code> <code>Optional[List[Axes]]</code> <p>A list of Matplotlib axes objects to plot on. If not provided, new axes will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Figure, List[Axes]]</code> <p>A tuple containing the Matplotlib figure and list of axes objects used for the plot.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.export_figure","title":"export_figure","text":"<pre><code>export_figure(\n    figure_like: Union[Figure, Tuple[Figure, Axes]],\n    default_path: Path,\n    default_filetype: Optional[str] = None,\n    user_path: Optional[Path] = None,\n    show: bool = True,\n    save: bool = False,\n) -&gt; Union[plotly.graph_objs.Figure, Tuple[plt.Figure, plt.Axes]]\n</code></pre> <p>Export a figure to a file and or show it.</p> <p>Parameters:</p> Name Type Description Default <code>figure_like</code> <code>Union[Figure, Tuple[Figure, Axes]]</code> <p>The figure to export. Can be a Plotly figure or a tuple of Matplotlib figure and axes.</p> required <code>default_path</code> <code>Path</code> <p>The default file path if no user filename is provided.</p> required <code>default_filetype</code> <code>Optional[str]</code> <p>The default filetype if the path doesnt end with a filetype.</p> <code>None</code> <code>user_path</code> <code>Optional[Path]</code> <p>An optional user-specified file path.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Whether to display the figure (default: True).</p> <code>True</code> <code>save</code> <code>bool</code> <p>Whether to save the figure (default: False).</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no default filetype is provided and the path doesn't specify a filetype.</p> <code>TypeError</code> <p>If the figure type is not supported.</p>"},{"location":"api-reference/results/","title":"results","text":""},{"location":"api-reference/results/#flixopt.results","title":"flixopt.results","text":""},{"location":"api-reference/results/#flixopt.results-classes","title":"Classes","text":""},{"location":"api-reference/results/#flixopt.results.CalculationResults","title":"CalculationResults","text":"<pre><code>CalculationResults(\n    solution: Dataset,\n    flow_system: Dataset,\n    name: str,\n    summary: Dict,\n    folder: Optional[Path] = None,\n    model: Optional[Model] = None,\n)\n</code></pre> <p>Results container for Calculation results.</p> <p>This class is used to collect the results of a Calculation. It provides access to component, bus, and effect results, and includes methods for filtering, plotting, and saving results.</p> <p>The recommended way to create instances is through the class methods <code>from_file()</code> or <code>from_calculation()</code>, rather than direct initialization.</p> <p>Attributes:</p> Name Type Description <code>solution</code> <code>Dataset</code> <p>Dataset containing optimization results.</p> <code>flow_system</code> <code>Dataset</code> <p>Dataset containing the flow system.</p> <code>summary</code> <code>Dict</code> <p>Information about the calculation.</p> <code>name</code> <code>str</code> <p>Name identifier for the calculation.</p> <code>model</code> <code>Model</code> <p>The optimization model (if available).</p> <code>folder</code> <code>Path</code> <p>Path to the results directory.</p> <code>components</code> <code>Dict[str, ComponentResults]</code> <p>Results for each component.</p> <code>buses</code> <code>Dict[str, BusResults]</code> <p>Results for each bus.</p> <code>effects</code> <code>Dict[str, EffectResults]</code> <p>Results for each effect.</p> <code>timesteps_extra</code> <code>DatetimeIndex</code> <p>The extended timesteps.</p> <code>hours_per_timestep</code> <code>DataArray</code> <p>Duration of each timestep in hours.</p> Example <p>Load results from saved files:</p> <p>results = CalculationResults.from_file('results_dir', 'optimization_run_1') element_result = results['Boiler'] results.plot_heatmap('Boiler(Q_th)|flow_rate') results.to_file(compression=5) results.to_file(folder='new_results_dir', compression=5)  # Save the results to a new folder</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>Dataset</code> <p>The solution of the optimization.</p> required <code>flow_system</code> <code>Dataset</code> <p>The flow_system that was used to create the calculation as a datatset.</p> required <code>name</code> <code>str</code> <p>The name of the calculation.</p> required <code>summary</code> <code>Dict</code> <p>Information about the calculation,</p> required <code>folder</code> <code>Optional[Path]</code> <p>The folder where the results are saved.</p> <code>None</code> <code>model</code> <code>Optional[Model]</code> <p>The linopy model that was used to solve the calculation.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.CalculationResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.CalculationResults.storages","title":"storages  <code>property</code>","text":"<pre><code>storages: List[ComponentResults]\n</code></pre> <p>All storages in the results.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.objective","title":"objective  <code>property</code>","text":"<pre><code>objective: float\n</code></pre> <p>The objective result of the optimization.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>The variables of the optimization. Only available if the linopy.Model is available.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>The constraints of the optimization. Only available if the linopy.Model is available.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.CalculationResults.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(folder: Union[str, Path], name: str)\n</code></pre> <p>Create CalculationResults instance by loading from saved files.</p> <p>This method loads the calculation results from previously saved files, including the solution, flow system, model (if available), and metadata.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>Union[str, Path]</code> <p>Path to the directory containing the saved files.</p> required <code>name</code> <code>str</code> <p>Base name of the saved files (without file extensions).</p> required <p>Returns:</p> Name Type Description <code>CalculationResults</code> <p>A new instance containing the loaded data.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If required files cannot be found.</p> <code>ValueError</code> <p>If files exist but cannot be properly loaded.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.from_calculation","title":"from_calculation  <code>classmethod</code>","text":"<pre><code>from_calculation(calculation: Calculation)\n</code></pre> <p>Create CalculationResults directly from a Calculation object.</p> <p>This method extracts the solution, flow system, and other relevant information directly from an existing Calculation object.</p> <p>Parameters:</p> Name Type Description Default <code>calculation</code> <code>Calculation</code> <p>A Calculation object containing a solved model.</p> required <p>Returns:</p> Name Type Description <code>CalculationResults</code> <p>A new instance containing the results from the provided calculation.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the calculation doesn't have required attributes.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.filter_solution","title":"filter_solution","text":"<pre><code>filter_solution(\n    variable_dims: Optional[Literal['scalar', 'time']] = None,\n    element: Optional[str] = None,\n) -&gt; xr.Dataset\n</code></pre> <p>Filter the solution to a specific variable dimension and element. If no element is specified, all elements are included.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Optional[Literal['scalar', 'time']]</code> <p>The dimension of the variables to filter for.</p> <code>None</code> <code>element</code> <code>Optional[str]</code> <p>The element to filter for.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.plot_network","title":"plot_network","text":"<pre><code>plot_network(\n    controls: Union[\n        bool,\n        List[\n            Literal[\n                'nodes',\n                'edges',\n                'layout',\n                'interaction',\n                'manipulation',\n                'physics',\n                'selection',\n                'renderer',\n            ]\n        ],\n    ] = True,\n    path: Optional[Path] = None,\n    show: bool = False,\n) -&gt; pyvis.network.Network\n</code></pre> <p>See flixopt.flow_system.FlowSystem.plot_network</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.to_file","title":"to_file","text":"<pre><code>to_file(\n    folder: Optional[Union[str, Path]] = None,\n    name: Optional[str] = None,\n    compression: int = 5,\n    document_model: bool = True,\n    save_linopy_model: bool = False,\n)\n</code></pre> <p>Save the results to a file Args:     folder: The folder where the results should be saved. Defaults to the folder of the calculation.     name: The name of the results file. If not provided, Defaults to the name of the calculation.     compression: The compression level to use when saving the solution file (0-9). 0 means no compression.     document_model: Wether to document the mathematical formulations in the model.     save_linopy_model: Wether to save the model to file. If True, the (linopy) model is saved as a .nc4 file.         The model file size is rougly 100 times larger than the solution file.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults","title":"BusResults","text":"<pre><code>BusResults(\n    calculation_results: CalculationResults,\n    label: str,\n    variables: List[str],\n    constraints: List[str],\n    inputs: List[str],\n    outputs: List[str],\n)\n</code></pre> <p>               Bases: <code>_NodeResults</code></p> <p>Results for a Bus</p>"},{"location":"api-reference/results/#flixopt.results.BusResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.BusResults.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>Returns the variables of the element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the linopy model is not availlable.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>Returns the variables of the element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the linopy model is not availlable.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.BusResults.filter_solution","title":"filter_solution","text":"<pre><code>filter_solution(\n    variable_dims: Optional[Literal['scalar', 'time']] = None,\n) -&gt; xr.Dataset\n</code></pre> <p>Filter the solution of the element by dimension.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Optional[Literal['scalar', 'time']]</code> <p>The dimension of the variables to filter for.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.BusResults.plot_node_balance","title":"plot_node_balance","text":"<pre><code>plot_node_balance(\n    save: Union[bool, Path] = False,\n    show: bool = True,\n    colors: ColorType = 'viridis',\n    engine: PlottingEngine = 'plotly',\n) -&gt; Union[plotly.graph_objs.Figure, Tuple[plt.Figure, plt.Axes]]\n</code></pre> <p>Plots the node balance of the Component or Bus. Args:     save: Whether to save the plot or not. If a path is provided, the plot will be saved at that location.     show: Whether to show the plot or not.     engine: The engine to use for plotting. Can be either 'plotly' or 'matplotlib'.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults.plot_node_balance_pie","title":"plot_node_balance_pie","text":"<pre><code>plot_node_balance_pie(\n    lower_percentage_group: float = 5,\n    colors: ColorType = 'viridis',\n    text_info: str = 'percent+label+value',\n    save: Union[bool, Path] = False,\n    show: bool = True,\n    engine: PlottingEngine = 'plotly',\n) -&gt; plotly.graph_objects.Figure\n</code></pre> <p>Plots a pie chart of the flow hours of the inputs and outputs of buses or components.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>ColorType</code> <p>a colorscale or a list of colors to use for the plot</p> <code>'viridis'</code> <code>lower_percentage_group</code> <code>float</code> <p>The percentage of flow_hours that is grouped in \"Others\" (0...100)</p> <code>5</code> <code>text_info</code> <code>str</code> <p>What information to display on the pie plot</p> <code>'percent+label+value'</code> <code>save</code> <code>Union[bool, Path]</code> <p>Whether to save the figure.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to show the figure.</p> <code>True</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine to use. Only 'plotly' is implemented atm.</p> <code>'plotly'</code>"},{"location":"api-reference/results/#flixopt.results.ComponentResults","title":"ComponentResults","text":"<pre><code>ComponentResults(\n    calculation_results: CalculationResults,\n    label: str,\n    variables: List[str],\n    constraints: List[str],\n    inputs: List[str],\n    outputs: List[str],\n)\n</code></pre> <p>               Bases: <code>_NodeResults</code></p> <p>Results for a Component</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.ComponentResults.charge_state","title":"charge_state  <code>property</code>","text":"<pre><code>charge_state: DataArray\n</code></pre> <p>Get the solution of the charge state of the Storage.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>Returns the variables of the element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the linopy model is not availlable.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>Returns the variables of the element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the linopy model is not availlable.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.ComponentResults.plot_charge_state","title":"plot_charge_state","text":"<pre><code>plot_charge_state(\n    save: Union[bool, Path] = False,\n    show: bool = True,\n    colors: ColorType = 'viridis',\n    engine: PlottingEngine = 'plotly',\n) -&gt; plotly.graph_objs.Figure\n</code></pre> <p>Plots the charge state of a Storage. Args:     save: Whether to save the plot or not. If a path is provided, the plot will be saved at that location.     show: Whether to show the plot or not.     colors: The c     engine: Plotting engine to use. Only 'plotly' is implemented atm.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Component is not a Storage.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.node_balance_with_charge_state","title":"node_balance_with_charge_state","text":"<pre><code>node_balance_with_charge_state(\n    negate_inputs: bool = True,\n    negate_outputs: bool = False,\n    threshold: Optional[float] = 1e-05,\n) -&gt; xr.Dataset\n</code></pre> <p>Returns a dataset with the node balance of the Storage including its charge state. Args:     negate_inputs: Whether to negate the inputs of the Storage.     negate_outputs: Whether to negate the outputs of the Storage.     threshold: The threshold for small values.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Component is not a Storage.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.filter_solution","title":"filter_solution","text":"<pre><code>filter_solution(\n    variable_dims: Optional[Literal['scalar', 'time']] = None,\n) -&gt; xr.Dataset\n</code></pre> <p>Filter the solution of the element by dimension.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Optional[Literal['scalar', 'time']]</code> <p>The dimension of the variables to filter for.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.plot_node_balance","title":"plot_node_balance","text":"<pre><code>plot_node_balance(\n    save: Union[bool, Path] = False,\n    show: bool = True,\n    colors: ColorType = 'viridis',\n    engine: PlottingEngine = 'plotly',\n) -&gt; Union[plotly.graph_objs.Figure, Tuple[plt.Figure, plt.Axes]]\n</code></pre> <p>Plots the node balance of the Component or Bus. Args:     save: Whether to save the plot or not. If a path is provided, the plot will be saved at that location.     show: Whether to show the plot or not.     engine: The engine to use for plotting. Can be either 'plotly' or 'matplotlib'.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.plot_node_balance_pie","title":"plot_node_balance_pie","text":"<pre><code>plot_node_balance_pie(\n    lower_percentage_group: float = 5,\n    colors: ColorType = 'viridis',\n    text_info: str = 'percent+label+value',\n    save: Union[bool, Path] = False,\n    show: bool = True,\n    engine: PlottingEngine = 'plotly',\n) -&gt; plotly.graph_objects.Figure\n</code></pre> <p>Plots a pie chart of the flow hours of the inputs and outputs of buses or components.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>ColorType</code> <p>a colorscale or a list of colors to use for the plot</p> <code>'viridis'</code> <code>lower_percentage_group</code> <code>float</code> <p>The percentage of flow_hours that is grouped in \"Others\" (0...100)</p> <code>5</code> <code>text_info</code> <code>str</code> <p>What information to display on the pie plot</p> <code>'percent+label+value'</code> <code>save</code> <code>Union[bool, Path]</code> <p>Whether to save the figure.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to show the figure.</p> <code>True</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine to use. Only 'plotly' is implemented atm.</p> <code>'plotly'</code>"},{"location":"api-reference/results/#flixopt.results.EffectResults","title":"EffectResults","text":"<pre><code>EffectResults(\n    calculation_results: CalculationResults,\n    label: str,\n    variables: List[str],\n    constraints: List[str],\n)\n</code></pre> <p>               Bases: <code>_ElementResults</code></p> <p>Results for an Effect</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.EffectResults.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>Returns the variables of the element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the linopy model is not availlable.</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>Returns the variables of the element.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the linopy model is not availlable.</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.EffectResults.get_shares_from","title":"get_shares_from","text":"<pre><code>get_shares_from(element: str)\n</code></pre> <p>Get the shares from an Element (without subelements) to the Effect</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults.filter_solution","title":"filter_solution","text":"<pre><code>filter_solution(\n    variable_dims: Optional[Literal['scalar', 'time']] = None,\n) -&gt; xr.Dataset\n</code></pre> <p>Filter the solution of the element by dimension.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Optional[Literal['scalar', 'time']]</code> <p>The dimension of the variables to filter for.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults","title":"SegmentedCalculationResults","text":"<pre><code>SegmentedCalculationResults(\n    segment_results: List[CalculationResults],\n    all_timesteps: DatetimeIndex,\n    timesteps_per_segment: int,\n    overlap_timesteps: int,\n    name: str,\n    folder: Optional[Path] = None,\n)\n</code></pre> <p>Class to store the results of a SegmentedCalculation.</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(folder: Union[str, Path], name: str)\n</code></pre> <p>Create SegmentedCalculationResults directly from file</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults.solution_without_overlap","title":"solution_without_overlap","text":"<pre><code>solution_without_overlap(variable_name: str) -&gt; xr.DataArray\n</code></pre> <p>Returns the solution of a variable without overlapping timesteps</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults.plot_heatmap","title":"plot_heatmap","text":"<pre><code>plot_heatmap(\n    variable_name: str,\n    heatmap_timeframes: Literal[\n        'YS', 'MS', 'W', 'D', 'h', '15min', 'min'\n    ] = 'D',\n    heatmap_timesteps_per_frame: Literal['W', 'D', 'h', '15min', 'min'] = 'h',\n    color_map: str = 'portland',\n    save: Union[bool, Path] = False,\n    show: bool = True,\n    engine: PlottingEngine = 'plotly',\n) -&gt; Union[plotly.graph_objs.Figure, Tuple[plt.Figure, plt.Axes]]\n</code></pre> <p>Plots a heatmap of the solution of a variable.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>The name of the variable to plot.</p> required <code>heatmap_timeframes</code> <code>Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min']</code> <p>The timeframes to use for the heatmap.</p> <code>'D'</code> <code>heatmap_timesteps_per_frame</code> <code>Literal['W', 'D', 'h', '15min', 'min']</code> <p>The timesteps per frame to use for the heatmap.</p> <code>'h'</code> <code>color_map</code> <code>str</code> <p>The color map to use for the heatmap.</p> <code>'portland'</code> <code>save</code> <code>Union[bool, Path]</code> <p>Whether to save the plot or not. If a path is provided, the plot will be saved at that location.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to show the plot or not.</p> <code>True</code> <code>engine</code> <code>PlottingEngine</code> <p>The engine to use for plotting. Can be either 'plotly' or 'matplotlib'.</p> <code>'plotly'</code>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults.to_file","title":"to_file","text":"<pre><code>to_file(\n    folder: Optional[Union[str, Path]] = None,\n    name: Optional[str] = None,\n    compression: int = 5,\n)\n</code></pre> <p>Save the results to a file</p>"},{"location":"api-reference/results/#flixopt.results-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.plot_heatmap","title":"plot_heatmap","text":"<pre><code>plot_heatmap(\n    dataarray: DataArray,\n    name: str,\n    folder: Path,\n    heatmap_timeframes: Literal[\n        'YS', 'MS', 'W', 'D', 'h', '15min', 'min'\n    ] = 'D',\n    heatmap_timesteps_per_frame: Literal['W', 'D', 'h', '15min', 'min'] = 'h',\n    color_map: str = 'portland',\n    save: Union[bool, Path] = False,\n    show: bool = True,\n    engine: PlottingEngine = 'plotly',\n)\n</code></pre> <p>Plots a heatmap of the solution of a variable.</p> <p>Parameters:</p> Name Type Description Default <code>dataarray</code> <code>DataArray</code> <p>The dataarray to plot.</p> required <code>name</code> <code>str</code> <p>The name of the variable to plot.</p> required <code>folder</code> <code>Path</code> <p>The folder to save the plot to.</p> required <code>heatmap_timeframes</code> <code>Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min']</code> <p>The timeframes to use for the heatmap.</p> <code>'D'</code> <code>heatmap_timesteps_per_frame</code> <code>Literal['W', 'D', 'h', '15min', 'min']</code> <p>The timesteps per frame to use for the heatmap.</p> <code>'h'</code> <code>color_map</code> <code>str</code> <p>The color map to use for the heatmap.</p> <code>'portland'</code> <code>save</code> <code>Union[bool, Path]</code> <p>Whether to save the plot or not. If a path is provided, the plot will be saved at that location.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to show the plot or not.</p> <code>True</code> <code>engine</code> <code>PlottingEngine</code> <p>The engine to use for plotting. Can be either 'plotly' or 'matplotlib'.</p> <code>'plotly'</code>"},{"location":"api-reference/results/#flixopt.results.sanitize_dataset","title":"sanitize_dataset","text":"<pre><code>sanitize_dataset(\n    ds: Dataset,\n    timesteps: Optional[DatetimeIndex] = None,\n    threshold: Optional[float] = 1e-05,\n    negate: Optional[List[str]] = None,\n    drop_small_vars: bool = True,\n    zero_small_values: bool = False,\n) -&gt; xr.Dataset\n</code></pre> <p>Sanitizes a dataset by handling small values (dropping or zeroing) and optionally reindexing the time axis.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>The dataset to sanitize.</p> required <code>timesteps</code> <code>Optional[DatetimeIndex]</code> <p>The timesteps to reindex the dataset to. If None, the original timesteps are kept.</p> <code>None</code> <code>threshold</code> <code>Optional[float]</code> <p>The threshold for small values processing. If None, no processing is done.</p> <code>1e-05</code> <code>negate</code> <code>Optional[List[str]]</code> <p>The variables to negate. If None, no variables are negated.</p> <code>None</code> <code>drop_small_vars</code> <code>bool</code> <p>If True, drops variables where all values are below threshold.</p> <code>True</code> <code>zero_small_values</code> <code>bool</code> <p>If True, sets values below threshold to zero.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: The sanitized dataset.</p>"},{"location":"api-reference/results/#flixopt.results.filter_dataset","title":"filter_dataset","text":"<pre><code>filter_dataset(\n    ds: Dataset, variable_dims: Optional[Literal['scalar', 'time']] = None\n) -&gt; xr.Dataset\n</code></pre> <p>Filters a dataset by its dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>The dataset to filter.</p> required <code>variable_dims</code> <code>Optional[Literal['scalar', 'time']]</code> <p>The dimension of the variables to filter for.</p> <code>None</code>"},{"location":"api-reference/solvers/","title":"solvers","text":""},{"location":"api-reference/solvers/#flixopt.solvers","title":"flixopt.solvers","text":"<p>This module contains the solvers of the flixopt framework, making them available to the end user in a compact way.</p>"},{"location":"api-reference/solvers/#flixopt.solvers-classes","title":"Classes","text":""},{"location":"api-reference/solvers/#flixopt.solvers.GurobiSolver","title":"GurobiSolver  <code>dataclass</code>","text":"<pre><code>GurobiSolver(\n    mip_gap: float,\n    time_limit_seconds: int,\n    extra_options: Dict[str, Any] = dict(),\n)\n</code></pre> <p>               Bases: <code>_Solver</code></p> <p>Parameters:</p> Name Type Description Default <code>mip_gap</code> <code>float</code> <p>Solver's mip gap setting. The MIP gap describes the accepted (MILP) objective, and the lower bound, which is the theoretically optimal solution (LP)</p> required <code>time_limit_seconds</code> <code>int</code> <p>Solver's time limit in seconds.</p> required <code>extra_options</code> <code>str</code> <p>Filename for saving the solver log.</p> <code>dict()</code>"},{"location":"api-reference/solvers/#flixopt.solvers.GurobiSolver-attributes","title":"Attributes","text":""},{"location":"api-reference/solvers/#flixopt.solvers.GurobiSolver.options","title":"options  <code>property</code>","text":"<pre><code>options: Dict[str, Any]\n</code></pre> <p>Return a dictionary of solver options.</p>"},{"location":"api-reference/solvers/#flixopt.solvers.HighsSolver","title":"HighsSolver  <code>dataclass</code>","text":"<pre><code>HighsSolver(\n    mip_gap: float,\n    time_limit_seconds: int,\n    extra_options: Dict[str, Any] = dict(),\n)\n</code></pre> <p>               Bases: <code>_Solver</code></p> <p>Parameters:</p> Name Type Description Default <code>mip_gap</code> <code>float</code> <p>Solver's mip gap setting. The MIP gap describes the accepted (MILP) objective, and the lower bound, which is the theoretically optimal solution (LP)</p> required <code>time_limit_seconds</code> <code>int</code> <p>Solver's time limit in seconds.</p> required <code>threads</code> <code>int</code> <p>Number of threads to use.</p> required <code>extra_options</code> <code>str</code> <p>Filename for saving the solver log.</p> <code>dict()</code>"},{"location":"api-reference/solvers/#flixopt.solvers.HighsSolver-attributes","title":"Attributes","text":""},{"location":"api-reference/solvers/#flixopt.solvers.HighsSolver.options","title":"options  <code>property</code>","text":"<pre><code>options: Dict[str, Any]\n</code></pre> <p>Return a dictionary of solver options.</p>"},{"location":"api-reference/structure/","title":"structure","text":""},{"location":"api-reference/structure/#flixopt.structure","title":"flixopt.structure","text":"<p>This module contains the core structure of the flixopt framework. These classes are not directly used by the end user, but are used by other modules.</p>"},{"location":"api-reference/structure/#flixopt.structure-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure-classes","title":"Classes","text":""},{"location":"api-reference/structure/#flixopt.structure.SystemModel","title":"SystemModel","text":"<pre><code>SystemModel(flow_system: FlowSystem)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>The SystemModel is the linopy Model that is used to create the mathematical model of the flow_system. It is used to create and store the variables and constraints for the flow_system.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The flow_system that is used to create the model.</p> required"},{"location":"api-reference/structure/#flixopt.structure.SystemModel-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Interface","title":"Interface","text":"<p>This class is used to collect arguments about a Model. Its the base class for all Elements and Models in flixopt.</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Interface.transform_data","title":"transform_data","text":"<pre><code>transform_data(flow_system: FlowSystem)\n</code></pre> <p>Transforms the data of the interface to match the FlowSystem's dimensions</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/structure/#flixopt.structure.Interface.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/structure/#flixopt.structure.Element","title":"Element","text":"<pre><code>Element(label: str, meta_data: Dict = None)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>This class is the basic Element of flixopt. Every Element has a label</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the element</p> required <code>meta_data</code> <code>Dict</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure.Element-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Element.transform_data","title":"transform_data","text":"<pre><code>transform_data(flow_system: FlowSystem)\n</code></pre> <p>Transforms the data of the interface to match the FlowSystem's dimensions</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; Dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.to_json","title":"to_json","text":"<pre><code>to_json(path: Union[str, Path])\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>The path to the json file.</p> required"},{"location":"api-reference/structure/#flixopt.structure.Element.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: Dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/structure/#flixopt.structure.Model","title":"Model","text":"<pre><code>Model(\n    model: SystemModel,\n    label_of_element: str,\n    label: str = '',\n    label_full: Optional[str] = None,\n)\n</code></pre> <p>Stores Variables and Constraints.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>SystemModel</code> <p>The SystemModel that is used to create the model.</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>label</code> <code>str</code> <p>The label of the model. Used to construct the full label of the model.</p> <code>''</code> <code>label_full</code> <code>Optional[str]</code> <p>The full label of the model. Can overwrite the full label constructed from the other labels.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure.Model-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.Model.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/structure/#flixopt.structure.Model-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Model.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel","title":"ElementModel","text":"<pre><code>ElementModel(model: SystemModel, element: Element)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Stores the mathematical Variables and Constraints for Elements</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>SystemModel</code> <p>The SystemModel that is used to create the model.</p> required <code>element</code> <code>Element</code> <p>The element this model is created for.</p> required"},{"location":"api-reference/structure/#flixopt.structure.ElementModel-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.ElementModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.ElementModel.add","title":"add","text":"<pre><code>add(\n    item: Union[Variable, Constraint, Model], short_name: Optional[str] = None\n) -&gt; Union[linopy.Variable, linopy.Constraint, Model]\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Union[Variable, Constraint, Model]</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>Optional[str]</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.register_class_for_io","title":"register_class_for_io","text":"<pre><code>register_class_for_io(cls)\n</code></pre> <p>Register a class for serialization/deserialization.</p>"},{"location":"api-reference/structure/#flixopt.structure.copy_and_convert_datatypes","title":"copy_and_convert_datatypes","text":"<pre><code>copy_and_convert_datatypes(\n    data: Any, use_numpy: bool = True, use_element_label: bool = False\n) -&gt; Any\n</code></pre> <p>Converts values in a nested data structure into JSON-compatible types while preserving or transforming numpy arrays and custom <code>Element</code> objects based on the specified options.</p> <p>The function handles various data types and transforms them into a consistent, readable format: - Primitive types (<code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, <code>None</code>) are returned as-is. - Numpy scalars are converted to their corresponding Python scalar types. - Collections (<code>list</code>, <code>tuple</code>, <code>set</code>, <code>dict</code>) are recursively processed to ensure all elements are compatible. - Numpy arrays are preserved or converted to lists, depending on <code>use_numpy</code>. - Custom <code>Element</code> objects can be represented either by their <code>label</code> or their initialization parameters as a dictionary. - Timestamps (<code>datetime</code>) are converted to ISO 8601 strings.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data to process, which may be deeply nested and contain a mix of types.</p> required <code>use_numpy</code> <code>bool</code> <p>If <code>True</code>, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If <code>False</code>, they are converted to lists. Default is <code>True</code>.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>If <code>True</code>, <code>Element</code> objects are represented by their <code>label</code>. If <code>False</code>, they are converted into a dictionary based on their initialization parameters. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>A transformed version of the input data, containing only JSON-compatible types:</p> <code>Any</code> <ul> <li><code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, <code>None</code></li> </ul> <code>Any</code> <ul> <li><code>list</code>, <code>dict</code></li> </ul> <code>Any</code> <ul> <li><code>np.ndarray</code> (if <code>use_numpy=True</code>. This is NOT JSON-compatible)</li> </ul> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the data cannot be converted to the specified types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; copy_and_convert_datatypes({'a': np.array([1, 2, 3]), 'b': Element(label='example')})\n{'a': array([1, 2, 3]), 'b': {'class': 'Element', 'label': 'example'}}\n</code></pre> <pre><code>&gt;&gt;&gt; copy_and_convert_datatypes({'a': np.array([1, 2, 3]), 'b': Element(label='example')}, use_numpy=False)\n{'a': [1, 2, 3], 'b': {'class': 'Element', 'label': 'example'}}\n</code></pre> Notes <ul> <li>The function gracefully handles unexpected types by issuing a warning and returning a deep copy of the data.</li> <li>Empty collections (lists, dictionaries) and default parameter values in <code>Element</code> objects are omitted from the output.</li> <li>Numpy arrays with non-numeric data types are automatically converted to lists.</li> </ul>"},{"location":"api-reference/structure/#flixopt.structure.get_compact_representation","title":"get_compact_representation","text":"<pre><code>get_compact_representation(\n    data: Any, array_threshold: int = 50, decimals: int = 2\n) -&gt; Dict\n</code></pre> <p>Generate a compact json serializable representation of deeply nested data. Numpy arrays are statistically described if they exceed a threshold and converted to lists.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to format and represent.</p> required <code>array_threshold</code> <code>int</code> <p>Maximum length of NumPy arrays to display. Longer arrays are statistically described.</p> <code>50</code> <code>decimals</code> <code>int</code> <p>Number of decimal places in which to describe the arrays.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>A dictionary representation of the data</p>"},{"location":"api-reference/structure/#flixopt.structure.get_str_representation","title":"get_str_representation","text":"<pre><code>get_str_representation(\n    data: Any, array_threshold: int = 50, decimals: int = 2\n) -&gt; str\n</code></pre> <p>Generate a string representation of deeply nested data using <code>rich.print</code>. NumPy arrays are shortened to the specified length and converted to strings.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to format and represent.</p> required <code>array_threshold</code> <code>int</code> <p>Maximum length of NumPy arrays to display. Longer arrays are statistically described.</p> <code>50</code> <code>decimals</code> <code>int</code> <p>Number of decimal places in which to describe the arrays.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted string representation of the data.</p>"},{"location":"api-reference/utils/","title":"utils","text":""},{"location":"api-reference/utils/#flixopt.utils","title":"flixopt.utils","text":"<p>This module contains several utility functions used throughout the flixopt framework.</p>"},{"location":"api-reference/utils/#flixopt.utils-functions","title":"Functions","text":""},{"location":"api-reference/utils/#flixopt.utils.is_number","title":"is_number","text":"<pre><code>is_number(number_alias: Union[int, float, str])\n</code></pre> <p>Returns True is string is a number.</p>"},{"location":"api-reference/utils/#flixopt.utils.convert_dataarray","title":"convert_dataarray","text":"<pre><code>convert_dataarray(\n    data: DataArray, mode: Literal['py', 'numpy', 'xarray', 'structure']\n) -&gt; Union[List, np.ndarray, xr.DataArray, str]\n</code></pre> <p>Convert a DataArray to a different format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataArray</code> <p>The DataArray to convert.</p> required <code>mode</code> <code>Literal['py', 'numpy', 'xarray', 'structure']</code> <p>The mode to convert to. - 'py': Convert to python native types (for json) - 'numpy': Convert to numpy array - 'xarray': Convert to xarray.DataArray - 'structure': Convert to strings (for structure, storing variable names)</p> required <p>Returns:</p> Type Description <code>Union[List, ndarray, DataArray, str]</code> <p>The converted data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the mode is unknown.</p>"},{"location":"examples/","title":"Examples","text":"<p>Here you can find a collection of examples that demonstrate how to use FlixOpt.</p> <p>We work on improving this gallery. If you have something to share, please contact us!</p>"},{"location":"examples/00-Minimal%20Example/","title":"Minimal Example","text":"<pre><code>\"\"\"\nThis script shows how to use the flixopt framework to model a super minimalistic energy system.\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\nfrom rich.pretty import pprint\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # --- Define the Flow System, that will hold all elements, and the time steps you want to model ---\n    timesteps = pd.date_range('2020-01-01', periods=3, freq='h')\n    flow_system = fx.FlowSystem(timesteps)\n\n    # --- Define Thermal Load Profile ---\n    # Load profile (e.g., kW) for heating demand over time\n    thermal_load_profile = np.array([30, 0, 20])\n\n    # --- Define Energy Buses ---\n    # These are balancing nodes (inputs=outputs) and balance the different energy carriers your system\n    flow_system.add_elements(fx.Bus('District Heating'), fx.Bus('Natural Gas'))\n\n    # --- Define Objective Effect (Cost) ---\n    # Cost effect representing the optimization objective (minimizing costs)\n    cost_effect = fx.Effect('costs', '\u20ac', 'Cost', is_standard=True, is_objective=True)\n\n    # --- Define Flow System Components ---\n    # Boiler component with thermal output (heat) and fuel input (gas)\n    boiler = fx.linear_converters.Boiler(\n        'Boiler',\n        eta=0.5,\n        Q_th=fx.Flow(label='Thermal Output', bus='District Heating', size=50),\n        Q_fu=fx.Flow(label='Fuel Input', bus='Natural Gas'),\n    )\n\n    # Heat load component with a fixed thermal demand profile\n    heat_load = fx.Sink(\n        'Heat Demand',\n        sink=fx.Flow(label='Thermal Load', bus='District Heating', size=1, fixed_relative_profile=thermal_load_profile),\n    )\n\n    # Gas source component with cost-effect per flow hour\n    gas_source = fx.Source(\n        'Natural Gas Tariff',\n        source=fx.Flow(label='Gas Flow', bus='Natural Gas', size=1000, effects_per_flow_hour=0.04),  # 0.04 \u20ac/kWh\n    )\n\n    # --- Build the Flow System ---\n    # Add all components and effects to the system\n    flow_system.add_elements(cost_effect, boiler, heat_load, gas_source)\n\n    # --- Define, model and solve a Calculation ---\n    calculation = fx.FullCalculation('Simulation1', flow_system)\n    calculation.do_modeling()\n    calculation.solve(fx.solvers.HighsSolver(0.01, 60))\n\n    # --- Analyze Results ---\n    # Access the results of an element\n    df1 = calculation.results['costs'].filter_solution('time').to_dataframe()\n\n    # Plot the results of a specific element\n    calculation.results['District Heating'].plot_node_balance_pie()\n    calculation.results['District Heating'].plot_node_balance()\n\n    # Save results to a file\n    df2 = calculation.results['District Heating'].node_balance().to_dataframe()\n    # df2.to_csv('results/District Heating.csv')  # Save results to csv\n\n    # Print infos to the console.\n    pprint(calculation.summary)\n</code></pre>"},{"location":"examples/01-Basic%20Example/","title":"Simple example","text":"<pre><code>\"\"\"\nThis script shows how to use the flixopt framework to model a simple energy system.\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\nfrom rich.pretty import pprint  # Used for pretty printing\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # --- Create Time Series Data ---\n    # Heat demand profile (e.g., kW) over time and corresponding power prices\n    heat_demand_per_h = np.array([30, 0, 90, 110, 110, 20, 20, 20, 20])\n    power_prices = 1 / 1000 * np.array([80, 80, 80, 80, 80, 80, 80, 80, 80])\n\n    # Create datetime array starting from '2020-01-01' for the given time period\n    timesteps = pd.date_range('2020-01-01', periods=len(heat_demand_per_h), freq='h')\n    flow_system = fx.FlowSystem(timesteps=timesteps)\n\n    # --- Define Energy Buses ---\n    # These represent nodes, where the used medias are balanced (electricity, heat, and gas)\n    flow_system.add_elements(fx.Bus(label='Strom'), fx.Bus(label='Fernw\u00e4rme'), fx.Bus(label='Gas'))\n\n    # --- Define Effects (Objective and CO2 Emissions) ---\n    # Cost effect: used as the optimization objective --&gt; minimizing costs\n    costs = fx.Effect(\n        label='costs',\n        unit='\u20ac',\n        description='Kosten',\n        is_standard=True,  # standard effect: no explicit value needed for costs\n        is_objective=True,  # Minimizing costs as the optimization objective\n    )\n\n    # CO2 emissions effect with an associated cost impact\n    CO2 = fx.Effect(\n        label='CO2',\n        unit='kg',\n        description='CO2_e-Emissionen',\n        specific_share_to_other_effects_operation={costs.label: 0.2},\n        maximum_operation_per_hour=1000,  # Max CO2 emissions per hour\n    )\n\n    # --- Define Flow System Components ---\n    # Boiler: Converts fuel (gas) into thermal energy (heat)\n    boiler = fx.linear_converters.Boiler(\n        label='Boiler',\n        eta=0.5,\n        Q_th=fx.Flow(label='Q_th', bus='Fernw\u00e4rme', size=50, relative_minimum=0.1, relative_maximum=1),\n        Q_fu=fx.Flow(label='Q_fu', bus='Gas'),\n    )\n\n    # Combined Heat and Power (CHP): Generates both electricity and heat from fuel\n    chp = fx.linear_converters.CHP(\n        label='CHP',\n        eta_th=0.5,\n        eta_el=0.4,\n        P_el=fx.Flow('P_el', bus='Strom', size=60, relative_minimum=5 / 60),\n        Q_th=fx.Flow('Q_th', bus='Fernw\u00e4rme'),\n        Q_fu=fx.Flow('Q_fu', bus='Gas'),\n    )\n\n    # Storage: Energy storage system with charging and discharging capabilities\n    storage = fx.Storage(\n        label='Storage',\n        charging=fx.Flow('Q_th_load', bus='Fernw\u00e4rme', size=1000),\n        discharging=fx.Flow('Q_th_unload', bus='Fernw\u00e4rme', size=1000),\n        capacity_in_flow_hours=fx.InvestParameters(fix_effects=20, fixed_size=30, optional=False),\n        initial_charge_state=0,  # Initial storage state: empty\n        relative_maximum_charge_state=1 / 100 * np.array([80, 70, 80, 80, 80, 80, 80, 80, 80, 80]),\n        eta_charge=0.9,\n        eta_discharge=1,  # Efficiency factors for charging/discharging\n        relative_loss_per_hour=0.08,  # 8% loss per hour. Absolute loss depends on current charge state\n        prevent_simultaneous_charge_and_discharge=True,  # Prevent charging and discharging at the same time\n    )\n\n    # Heat Demand Sink: Represents a fixed heat demand profile\n    heat_sink = fx.Sink(\n        label='Heat Demand',\n        sink=fx.Flow(label='Q_th_Last', bus='Fernw\u00e4rme', size=1, fixed_relative_profile=heat_demand_per_h),\n    )\n\n    # Gas Source: Gas tariff source with associated costs and CO2 emissions\n    gas_source = fx.Source(\n        label='Gastarif',\n        source=fx.Flow(label='Q_Gas', bus='Gas', size=1000, effects_per_flow_hour={costs.label: 0.04, CO2.label: 0.3}),\n    )\n\n    # Power Sink: Represents the export of electricity to the grid\n    power_sink = fx.Sink(\n        label='Einspeisung', sink=fx.Flow(label='P_el', bus='Strom', effects_per_flow_hour=-1 * power_prices)\n    )\n\n    # --- Build the Flow System ---\n    # Add all defined components and effects to the flow system\n    flow_system.add_elements(costs, CO2, boiler, storage, chp, heat_sink, gas_source, power_sink)\n\n    # Visualize the flow system for validation purposes\n    flow_system.plot_network(show=True)\n\n    # --- Define and Run Calculation ---\n    # Create a calculation object to model the Flow System\n    calculation = fx.FullCalculation(name='Sim1', flow_system=flow_system)\n    calculation.do_modeling()  # Translate the model to a solvable form, creating equations and Variables\n\n    # --- Solve the Calculation and Save Results ---\n    calculation.solve(fx.solvers.HighsSolver(mip_gap=0, time_limit_seconds=30))\n\n    # --- Analyze Results ---\n    calculation.results['Fernw\u00e4rme'].plot_node_balance_pie()\n    calculation.results['Fernw\u00e4rme'].plot_node_balance()\n    calculation.results['Storage'].plot_node_balance()\n    calculation.results.plot_heatmap('CHP(Q_th)|flow_rate')\n\n    # Convert the results for the storage component to a dataframe and display\n    df = calculation.results['Storage'].node_balance_with_charge_state()\n    print(df)\n\n    # Save results to file for later usage\n    calculation.results.to_file()\n</code></pre>"},{"location":"examples/02-Complex%20Example/","title":"Complex example","text":"<p>This saves the results of a calculation to file and reloads them to analyze the results</p>"},{"location":"examples/02-Complex%20Example/#build-the-model","title":"Build the Model","text":"<pre><code>\"\"\"\nThis script shows how to use the flixopt framework to model a more complex energy system.\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\nfrom rich.pretty import pprint  # Used for pretty printing\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # --- Experiment Options ---\n    # Configure options for testing various parameters and behaviors\n    check_penalty = False\n    excess_penalty = 1e5\n    use_chp_with_piecewise_conversion = True\n    time_indices = None  # Define specific time steps for custom calculations, or use the entire series\n\n    # --- Define Demand and Price Profiles ---\n    # Input data for electricity and heat demands, as well as electricity price\n    electricity_demand = np.array([70, 80, 90, 90, 90, 90, 90, 90, 90])\n    heat_demand = (\n        np.array([30, 0, 90, 110, 2000, 20, 20, 20, 20])\n        if check_penalty\n        else np.array([30, 0, 90, 110, 110, 20, 20, 20, 20])\n    )\n    electricity_price = np.array([40, 40, 40, 40, 40, 40, 40, 40, 40])\n\n    # --- Define the Flow System, that will hold all elements, and the time steps you want to model ---\n    timesteps = pd.date_range('2020-01-01', periods=len(heat_demand), freq='h')\n    flow_system = fx.FlowSystem(timesteps)  # Create FlowSystem\n\n    # --- Define Energy Buses ---\n    # Represent node balances (inputs=outputs) for the different energy carriers (electricity, heat, gas) in the system\n    flow_system.add_elements(\n        fx.Bus('Strom', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Fernw\u00e4rme', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Gas', excess_penalty_per_flow_hour=excess_penalty),\n    )\n\n    # --- Define Effects ---\n    # Specify effects related to costs, CO2 emissions, and primary energy consumption\n    Costs = fx.Effect('costs', '\u20ac', 'Kosten', is_standard=True, is_objective=True)\n    CO2 = fx.Effect('CO2', 'kg', 'CO2_e-Emissionen', specific_share_to_other_effects_operation={Costs.label: 0.2})\n    PE = fx.Effect('PE', 'kWh_PE', 'Prim\u00e4renergie', maximum_total=3.5e3)\n\n    # --- Define Components ---\n    # 1. Define Boiler Component\n    # A gas boiler that converts fuel into thermal output, with investment and on-off parameters\n    Gaskessel = fx.linear_converters.Boiler(\n        'Kessel',\n        eta=0.5,  # Efficiency ratio\n        on_off_parameters=fx.OnOffParameters(\n            effects_per_running_hour={Costs.label: 0, CO2.label: 1000}\n        ),  # CO2 emissions per hour\n        Q_th=fx.Flow(\n            label='Q_th',  # Thermal output\n            bus='Fernw\u00e4rme',  # Linked bus\n            size=fx.InvestParameters(\n                fix_effects=1000,  # Fixed investment costs\n                fixed_size=50,  # Fixed size\n                optional=False,  # Forced investment\n                specific_effects={Costs.label: 10, PE.label: 2},  # Specific costs\n            ),\n            load_factor_max=1.0,  # Maximum load factor (50 kW)\n            load_factor_min=0.1,  # Minimum load factor (5 kW)\n            relative_minimum=5 / 50,  # Minimum part load\n            relative_maximum=1,  # Maximum part load\n            previous_flow_rate=50,  # Previous flow rate\n            flow_hours_total_max=1e6,  # Total energy flow limit\n            on_off_parameters=fx.OnOffParameters(\n                on_hours_total_min=0,  # Minimum operating hours\n                on_hours_total_max=1000,  # Maximum operating hours\n                consecutive_on_hours_max=10,  # Max consecutive operating hours\n                consecutive_on_hours_min=np.array(\n                    [1, 1, 1, 1, 1, 2, 2, 2, 2]\n                ),  # min consecutive operation hoursconsecutive_off_hours_max=10,  # Max consecutive off hours\n                effects_per_switch_on=0.01,  # Cost per switch-on\n                switch_on_total_max=1000,  # Max number of starts\n            ),\n        ),\n        Q_fu=fx.Flow(label='Q_fu', bus='Gas', size=200),\n    )\n\n    # 2. Define CHP Unit\n    # Combined Heat and Power unit that generates both electricity and heat from fuel\n    bhkw = fx.linear_converters.CHP(\n        'BHKW2',\n        eta_th=0.5,\n        eta_el=0.4,\n        on_off_parameters=fx.OnOffParameters(effects_per_switch_on=0.01),\n        P_el=fx.Flow('P_el', bus='Strom', size=60, relative_minimum=5 / 60),\n        Q_th=fx.Flow('Q_th', bus='Fernw\u00e4rme', size=1e3),\n        Q_fu=fx.Flow('Q_fu', bus='Gas', size=1e3, previous_flow_rate=20),  # The CHP was ON previously\n    )\n\n    # 3. Define CHP with Piecewise Conversion\n    # This CHP unit uses piecewise conversion for more dynamic behavior over time\n    P_el = fx.Flow('P_el', bus='Strom', size=60, previous_flow_rate=20)\n    Q_th = fx.Flow('Q_th', bus='Fernw\u00e4rme')\n    Q_fu = fx.Flow('Q_fu', bus='Gas')\n    piecewise_conversion = fx.PiecewiseConversion(\n        {\n            P_el.label: fx.Piecewise([fx.Piece(5, 30), fx.Piece(40, 60)]),\n            Q_th.label: fx.Piecewise([fx.Piece(6, 35), fx.Piece(45, 100)]),\n            Q_fu.label: fx.Piecewise([fx.Piece(12, 70), fx.Piece(90, 200)]),\n        }\n    )\n\n    bhkw_2 = fx.LinearConverter(\n        'BHKW2',\n        inputs=[Q_fu],\n        outputs=[P_el, Q_th],\n        piecewise_conversion=piecewise_conversion,\n        on_off_parameters=fx.OnOffParameters(effects_per_switch_on=0.01),\n    )\n\n    # 4. Define Storage Component\n    # Storage with variable size and piecewise investment effects\n    segmented_investment_effects = fx.PiecewiseEffects(\n        piecewise_origin=fx.Piecewise([fx.Piece(5, 25), fx.Piece(25, 100)]),\n        piecewise_shares={\n            Costs.label: fx.Piecewise([fx.Piece(50, 250), fx.Piece(250, 800)]),\n            PE.label: fx.Piecewise([fx.Piece(5, 25), fx.Piece(25, 100)]),\n        },\n    )\n\n    speicher = fx.Storage(\n        'Speicher',\n        charging=fx.Flow('Q_th_load', bus='Fernw\u00e4rme', size=1e4),\n        discharging=fx.Flow('Q_th_unload', bus='Fernw\u00e4rme', size=1e4),\n        capacity_in_flow_hours=fx.InvestParameters(\n            piecewise_effects=segmented_investment_effects,  # Investment effects\n            optional=False,  # Forced investment\n            minimum_size=0,\n            maximum_size=1000,  # Optimizing between 0 and 1000 kWh\n        ),\n        initial_charge_state=0,  # Initial charge state\n        maximal_final_charge_state=10,  # Maximum final charge state\n        eta_charge=0.9,\n        eta_discharge=1,  # Charge/discharge efficiency\n        relative_loss_per_hour=0.08,  # Energy loss per hour, relative to current charge state\n        prevent_simultaneous_charge_and_discharge=True,  # Prevent simultaneous charge/discharge\n    )\n\n    # 5. Define Sinks and Sources\n    # 5.a) Heat demand profile\n    Waermelast = fx.Sink(\n        'W\u00e4rmelast',\n        sink=fx.Flow(\n            'Q_th_Last',  # Heat sink\n            bus='Fernw\u00e4rme',  # Linked bus\n            size=1,\n            fixed_relative_profile=heat_demand,  # Fixed demand profile\n        ),\n    )\n\n    # 5.b) Gas tariff\n    Gasbezug = fx.Source(\n        'Gastarif',\n        source=fx.Flow(\n            'Q_Gas',\n            bus='Gas',  # Gas source\n            size=1000,  # Nominal size\n            effects_per_flow_hour={Costs.label: 0.04, CO2.label: 0.3},\n        ),\n    )\n\n    # 5.c) Feed-in of electricity\n    Stromverkauf = fx.Sink(\n        'Einspeisung',\n        sink=fx.Flow(\n            'P_el',\n            bus='Strom',  # Feed-in tariff for electricity\n            effects_per_flow_hour=-1 * electricity_price,  # Negative price for feed-in\n        ),\n    )\n\n    # --- Build FlowSystem ---\n    # Select components to be included in the flow system\n    flow_system.add_elements(Costs, CO2, PE, Gaskessel, Waermelast, Gasbezug, Stromverkauf, speicher)\n    flow_system.add_elements(bhkw_2) if use_chp_with_piecewise_conversion else flow_system.add_elements(bhkw)\n\n    pprint(flow_system)  # Get a string representation of the FlowSystem\n\n    # --- Solve FlowSystem ---\n    calculation = fx.FullCalculation('complex example', flow_system, time_indices)\n    calculation.do_modeling()\n\n    calculation.solve(fx.solvers.HighsSolver(0.01, 60))\n\n    # --- Results ---\n    # You can analyze results directly or save them to file and reload them later.\n    calculation.results.to_file()\n\n    # But let's plot some results anyway\n    calculation.results.plot_heatmap('BHKW2(Q_th)|flow_rate')\n    calculation.results['BHKW2'].plot_node_balance()\n    calculation.results['Speicher'].plot_charge_state()\n    calculation.results['Fernw\u00e4rme'].plot_node_balance_pie()\n</code></pre>"},{"location":"examples/02-Complex%20Example/#load-the-results-from-file","title":"Load the Results from file","text":"<pre><code>\"\"\"\nThis script shows how load results of a prior calcualtion and how to analyze them.\n\"\"\"\n\nimport pandas as pd\nimport plotly.offline\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # --- Load Results ---\n    try:\n        results = fx.results.CalculationResults.from_file('results', 'complex example')\n    except FileNotFoundError as e:\n        raise FileNotFoundError(\n            f\"Results file not found in the specified directory ('results'). \"\n            f\"Please ensure that the file is generated by running 'complex_example.py'. \"\n            f'Original error: {e}'\n        ) from e\n\n    # --- Basic overview ---\n    results.plot_network(show=True)\n    results['Fernw\u00e4rme'].plot_node_balance()\n\n    # --- Detailed Plots ---\n    # In depth plot for individual flow rates ('__' is used as the delimiter between Component and Flow\n    results.plot_heatmap('W\u00e4rmelast(Q_th_Last)|flow_rate')\n    for flow_rate in results['BHKW2'].inputs + results['BHKW2'].outputs:\n        results.plot_heatmap(flow_rate)\n\n    # --- Plotting internal variables manually ---\n    results.plot_heatmap('BHKW2(Q_th)|on')\n    results.plot_heatmap('Kessel(Q_th)|on')\n\n    # Dataframes from results:\n    fw_bus = results['Fernw\u00e4rme'].node_balance().to_dataframe()\n    all = results.solution.to_dataframe()\n</code></pre>"},{"location":"examples/03-Calculation%20Modes/","title":"Calculation Mode comparison","text":"<p>Note: This example relies on time series data. You can find it in the <code>examples</code> folder of the FlixOpt repository. <pre><code>\"\"\"\nThis script demonstrates how to use the different calcualtion types in the flixOPt framework\nto model the same energy system. THe Results will be compared to each other.\n\"\"\"\n\nimport pathlib\nfrom typing import Dict, List, Union\n\nimport numpy as np\nimport pandas as pd\nimport xarray as xr\nfrom rich.pretty import pprint  # Used for pretty printing\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # Calculation Types\n    full, segmented, aggregated = True, True, True\n\n    # Segmented Properties\n    segment_length, overlap_length = 96, 1\n\n    # Aggregated Properties\n    aggregation_parameters = fx.AggregationParameters(\n        hours_per_period=6,\n        nr_of_periods=4,\n        fix_storage_flows=False,\n        aggregate_data_and_fix_non_binary_vars=True,\n        percentage_of_period_freedom=0,\n        penalty_of_period_freedom=0,\n    )\n    keep_extreme_periods = True\n    excess_penalty = 1e5  # or set to None if not needed\n\n    # Data Import\n    data_import = pd.read_csv(pathlib.Path('Zeitreihen2020.csv'), index_col=0).sort_index()\n    filtered_data = data_import['2020-01-01':'2020-01-2 23:45:00']\n    # filtered_data = data_import[0:500]  # Alternatively filter by index\n\n    filtered_data.index = pd.to_datetime(filtered_data.index)\n    timesteps = filtered_data.index\n\n    # Access specific columns and convert to 1D-numpy array\n    electricity_demand = filtered_data['P_Netz/MW'].to_numpy()\n    heat_demand = filtered_data['Q_Netz/MW'].to_numpy()\n    electricity_price = filtered_data['Strompr.\u20ac/MWh'].to_numpy()\n    gas_price = filtered_data['Gaspr.\u20ac/MWh'].to_numpy()\n\n    # TimeSeriesData objects\n    TS_heat_demand = fx.TimeSeriesData(heat_demand)\n    TS_electricity_demand = fx.TimeSeriesData(electricity_demand, agg_weight=0.7)\n    TS_electricity_price_sell = fx.TimeSeriesData(-(electricity_demand - 0.5), agg_group='p_el')\n    TS_electricity_price_buy = fx.TimeSeriesData(electricity_price + 0.5, agg_group='p_el')\n\n    flow_system = fx.FlowSystem(timesteps)\n    flow_system.add_elements(\n        fx.Bus('Strom', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Fernw\u00e4rme', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Gas', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Kohle', excess_penalty_per_flow_hour=excess_penalty),\n    )\n\n    # Effects\n    costs = fx.Effect('costs', '\u20ac', 'Kosten', is_standard=True, is_objective=True)\n    CO2 = fx.Effect('CO2', 'kg', 'CO2_e-Emissionen')\n    PE = fx.Effect('PE', 'kWh_PE', 'Prim\u00e4renergie')\n\n    # Component Definitions\n\n    # 1. Boiler\n    a_gaskessel = fx.linear_converters.Boiler(\n        'Kessel',\n        eta=0.85,\n        Q_th=fx.Flow(label='Q_th', bus='Fernw\u00e4rme'),\n        Q_fu=fx.Flow(\n            label='Q_fu',\n            bus='Gas',\n            size=95,\n            relative_minimum=12 / 95,\n            previous_flow_rate=20,\n            on_off_parameters=fx.OnOffParameters(effects_per_switch_on=1000),\n        ),\n    )\n\n    # 2. CHP\n    a_kwk = fx.linear_converters.CHP(\n        'BHKW2',\n        eta_th=0.58,\n        eta_el=0.22,\n        on_off_parameters=fx.OnOffParameters(effects_per_switch_on=24000),\n        P_el=fx.Flow('P_el', bus='Strom', size=200),\n        Q_th=fx.Flow('Q_th', bus='Fernw\u00e4rme', size=200),\n        Q_fu=fx.Flow('Q_fu', bus='Kohle', size=288, relative_minimum=87 / 288, previous_flow_rate=100),\n    )\n\n    # 3. Storage\n    a_speicher = fx.Storage(\n        'Speicher',\n        capacity_in_flow_hours=684,\n        initial_charge_state=137,\n        minimal_final_charge_state=137,\n        maximal_final_charge_state=158,\n        eta_charge=1,\n        eta_discharge=1,\n        relative_loss_per_hour=0.001,\n        prevent_simultaneous_charge_and_discharge=True,\n        charging=fx.Flow('Q_th_load', size=137, bus='Fernw\u00e4rme'),\n        discharging=fx.Flow('Q_th_unload', size=158, bus='Fernw\u00e4rme'),\n    )\n\n    # 4. Sinks and Sources\n    # Heat Load Profile\n    a_waermelast = fx.Sink(\n        'W\u00e4rmelast', sink=fx.Flow('Q_th_Last', bus='Fernw\u00e4rme', size=1, fixed_relative_profile=TS_heat_demand)\n    )\n\n    # Electricity Feed-in\n    a_strom_last = fx.Sink(\n        'Stromlast', sink=fx.Flow('P_el_Last', bus='Strom', size=1, fixed_relative_profile=TS_electricity_demand)\n    )\n\n    # Gas Tariff\n    a_gas_tarif = fx.Source(\n        'Gastarif',\n        source=fx.Flow('Q_Gas', bus='Gas', size=1000, effects_per_flow_hour={costs.label: gas_price, CO2.label: 0.3}),\n    )\n\n    # Coal Tariff\n    a_kohle_tarif = fx.Source(\n        'Kohletarif',\n        source=fx.Flow('Q_Kohle', bus='Kohle', size=1000, effects_per_flow_hour={costs.label: 4.6, CO2.label: 0.3}),\n    )\n\n    # Electricity Tariff and Feed-in\n    a_strom_einspeisung = fx.Sink(\n        'Einspeisung', sink=fx.Flow('P_el', bus='Strom', size=1000, effects_per_flow_hour=TS_electricity_price_sell)\n    )\n\n    a_strom_tarif = fx.Source(\n        'Stromtarif',\n        source=fx.Flow(\n            'P_el', bus='Strom', size=1000, effects_per_flow_hour={costs.label: TS_electricity_price_buy, CO2: 0.3}\n        ),\n    )\n\n    # Flow System Setup\n    flow_system.add_elements(costs, CO2, PE)\n    flow_system.add_elements(\n        a_gaskessel,\n        a_waermelast,\n        a_strom_last,\n        a_gas_tarif,\n        a_kohle_tarif,\n        a_strom_einspeisung,\n        a_strom_tarif,\n        a_kwk,\n        a_speicher,\n    )\n    flow_system.plot_network(controls=False, show=True)\n\n    # Calculations\n    calculations: List[Union[fx.FullCalculation, fx.AggregatedCalculation, fx.SegmentedCalculation]] = []\n\n    if full:\n        calculation = fx.FullCalculation('Full', flow_system)\n        calculation.do_modeling()\n        calculation.solve(fx.solvers.HighsSolver(0, 60))\n        calculations.append(calculation)\n\n    if segmented:\n        calculation = fx.SegmentedCalculation('Segmented', flow_system, segment_length, overlap_length)\n        calculation.do_modeling_and_solve(fx.solvers.HighsSolver(0, 60))\n        calculations.append(calculation)\n\n    if aggregated:\n        if keep_extreme_periods:\n            aggregation_parameters.time_series_for_high_peaks = [TS_heat_demand]\n            aggregation_parameters.time_series_for_low_peaks = [TS_electricity_demand, TS_heat_demand]\n        calculation = fx.AggregatedCalculation('Aggregated', flow_system, aggregation_parameters)\n        calculation.do_modeling()\n        calculation.solve(fx.solvers.HighsSolver(0, 60))\n        calculations.append(calculation)\n\n    # Get solutions for plotting for different calculations\n    def get_solutions(calcs: List, variable: str) -&gt; xr.Dataset:\n        dataarrays = []\n        for calc in calcs:\n            if calc.name == 'Segmented':\n                dataarrays.append(calc.results.solution_without_overlap(variable).rename(calc.name))\n            else:\n                dataarrays.append(calc.results.model.variables[variable].solution.rename(calc.name))\n        return xr.merge(dataarrays)\n\n    # --- Plotting for comparison ---\n    fx.plotting.with_plotly(\n        get_solutions(calculations, 'Speicher|charge_state').to_dataframe(),\n        mode='line',\n        title='Charge State Comparison',\n        ylabel='Charge state',\n    ).write_html('results/Charge State.html')\n\n    fx.plotting.with_plotly(\n        get_solutions(calculations, 'BHKW2(Q_th)|flow_rate').to_dataframe(),\n        mode='line',\n        title='BHKW2(Q_th) Flow Rate Comparison',\n        ylabel='Flow rate',\n    ).write_html('results/BHKW2 Thermal Power.html')\n\n    fx.plotting.with_plotly(\n        get_solutions(calculations, 'costs(operation)|total_per_timestep').to_dataframe(),\n        mode='line',\n        title='Operation Cost Comparison',\n        ylabel='Costs [\u20ac]',\n    ).write_html('results/Operation Costs.html')\n\n    fx.plotting.with_plotly(\n        pd.DataFrame(get_solutions(calculations, 'costs(operation)|total_per_timestep').to_dataframe().sum()).T,\n        mode='bar',\n        title='Total Cost Comparison',\n        ylabel='Costs [\u20ac]',\n    ).update_layout(barmode='group').write_html('results/Total Costs.html')\n\n    fx.plotting.with_plotly(\n        pd.DataFrame([calc.durations for calc in calculations], index=[calc.name for calc in calculations]), 'bar'\n    ).update_layout(title='Duration Comparison', xaxis_title='Calculation type', yaxis_title='Time (s)').write_html(\n        'results/Speed Comparison.html'\n    )\n</code></pre></p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#work-in-progress","title":"Work in progress","text":""},{"location":"faq/contribute/","title":"Contributing to the Project","text":"<p>We warmly welcome contributions from the community! This guide will help you get started with contributing to our project.</p>"},{"location":"faq/contribute/#development-setup","title":"Development Setup","text":"<ol> <li>Clone the repository <code>git clone https://github.com/flixOpt/flixopt.git</code></li> <li>Install the development dependencies <code>pip install -editable .[dev, docs]</code></li> <li>Run <code>pytest</code> and <code>ruff check .</code> to ensure your code passes all tests</li> </ol>"},{"location":"faq/contribute/#documentation","title":"Documentation","text":"<p>FlixOpt uses mkdocs to generate documentation. To preview the documentation locally, run <code>mkdocs serve</code> in the root directory.</p>"},{"location":"faq/contribute/#helpful-commands","title":"Helpful Commands","text":"<ul> <li><code>mkdocs serve</code> to preview the documentation locally. Navigate to <code>http://127.0.0.1:8000/</code> to view the documentation.</li> <li><code>pytest</code> to run the test suite (You can also run the provided python script <code>run_all_test.py</code>)</li> <li><code>ruff check .</code> to run the linter</li> <li><code>ruff check . --fix</code> to automatically fix linting issues</li> </ul>"},{"location":"faq/contribute/#best-practices","title":"Best practices","text":""},{"location":"faq/contribute/#coding-guidelines","title":"Coding Guidelines","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Write clear, commented code</li> <li>Include type hints</li> <li>Create or update tests for new functionality</li> <li>Ensure 100% test coverage for new code</li> </ul>"},{"location":"faq/contribute/#branches","title":"Branches","text":"<p>As we start to think FlixOpt in Releases, we decided to introduce multiple dev-branches instead of only one: Following the Semantic Versioning guidelines, we introduced: - <code>next/patch</code>: This is where all pull requests for the next patch release (1.0.x) go. - <code>next/minor</code>: This is where all pull requests for the next minor release (1.x.0) go. - <code>next/major</code>: This is where all pull requests for the next major release (x.0.0) go.</p> <p>Everything else remains in <code>feature/...</code>-branches.</p>"},{"location":"faq/contribute/#pull-requests","title":"Pull requests","text":"<p>Every feature or bugfix should be merged into one of the 3 release branches, using Squash and merge or a regular single commit. At some point, <code>next/minor</code> or <code>next/major</code> will get merged into <code>main</code> using a regular Merge  (not squash). This ensures that Features are kept separate, and the <code>next/...</code>branches stay in synch with <code>`main</code>.</p>"},{"location":"faq/contribute/#releases","title":"Releases","text":"<p>As stated, we follow Semantic Versioning. Right after one of the 3 release branches is merged into main, a Tag should be added to the merge commit and pushed to the main branch. The tag has the form <code>v1.2.3</code>. With this tag,  a release with Release Notes must be created. </p> <p>This is our current best practice</p>"},{"location":"user-guide/","title":"FlixOpt Concepts","text":"<p>FlixOpt is built around a set of core concepts that work together to represent and optimize energy and material flow systems. This page provides a high-level overview of these concepts and how they interact.</p>"},{"location":"user-guide/#core-concepts","title":"Core Concepts","text":""},{"location":"user-guide/#flowsystem","title":"FlowSystem","text":"<p>The <code>FlowSystem</code> is the central organizing unit in FlixOpt.  Every FlixOpt model starts with creating a FlowSystem. It:</p> <ul> <li>Defines the timesteps for the optimization</li> <li>Contains and connects components, buses, and flows</li> <li>Manages the effects (objectives and constraints)</li> </ul>"},{"location":"user-guide/#flows","title":"Flows","text":"<p><code>Flow</code> objects represent the movement of energy or material between a Bus and a Component in a predefined direction.</p> <ul> <li>Have a <code>size</code> which, generally speaking, defines how fast energy or material can be moved. Usually measured in MW, kW, m\u00b3/h, etc.</li> <li>Have a <code>flow_rate</code>, which is defines how fast energy or material is transported. Usually measured in MW, kW, m\u00b3/h, etc.</li> <li>Have constraints to limit the flow-rate (min/max, total flow hours, on/off etc.)</li> <li>Can have fixed profiles (for demands or renewable generation)</li> <li>Can have Effects associated by their use (operation, investment, on/off, ...)</li> </ul>"},{"location":"user-guide/#flow-hours","title":"Flow Hours","text":"<p>While the Flow Rate defines the rate in which energy or material is transported, the Flow Hours define the amount of energy or material that is transported. Its defined by the flow_rate times the duration of the timestep in hours.</p> <p>Examples:</p> Flow Rate Timestep Flow Hours 10 (MW) 1 hour 10 (MWh) 10 (MW) 6 minutes 0.1 (MWh) 10 (kg/h) 1 hour 10 (kg)"},{"location":"user-guide/#buses","title":"Buses","text":"<p><code>Bus</code> objects represent nodes or connection points in a FlowSystem. They:</p> <ul> <li>Balance incoming and outgoing flows</li> <li>Can represent physical networks like heat, electricity, or gas </li> <li>Handle infeasible balances gently by allowing the balance to be closed in return for a big Penalty (optional)</li> </ul>"},{"location":"user-guide/#components","title":"Components","text":"<p><code>Component</code> objects usually represent physical entities in your system that interact with <code>Flows</code>. They include:</p> <ul> <li><code>LinearConverters</code> - Converts input flows to output flows with (piecewise) linear relationships</li> <li><code>Storages</code> - Stores energy or material over time</li> <li><code>Sources</code> / <code>Sinks</code> / <code>SourceAndSinks</code> - Produce or consume flows. They are usually used to model external demands or supplies.</li> <li><code>Transmissions</code> - Moves flows between locations with possible losses</li> <li>Specialized <code>LinearConverters</code> like <code>Boilers</code>, <code>HeatPumps</code>, <code>CHPs</code>, etc. These simplify the usage of the <code>LinearConverter</code> class and can also be used as blueprint on how to define custom classes or parameterize existing ones.</li> </ul>"},{"location":"user-guide/#effects","title":"Effects","text":"<p><code>Effect</code> objects represent impacts or metrics related to your system, such as:</p> <ul> <li>Costs (investment, operation)</li> <li>Emissions (CO\u2082, NOx, etc.)</li> <li>Resource consumption</li> <li>Area demand</li> </ul> <p>These can be freely defined and crosslink to each other (<code>CO\u2082</code> \u2500\u2500[specific CO\u2082-costs]\u2500\u2192 <code>Costs</code>). One effect is designated as the optimization objective (typically Costs), while others can be constrained. This approach allows for a multi-criteria optimization using both...  - ... the Weigted SumMethod, by Optimizing a theoretical Effect which other Effects crosslink to.  - ... the (\\(\\epsilon\\)-constraint method) by constraining effects.</p>"},{"location":"user-guide/#calculation","title":"Calculation","text":"<p>A <code>FlowSystem</code> can be converted to a Model and optimized by creating a <code>Calculation</code> from it.</p> <p>FlixOpt offers different calculation modes:</p> <ul> <li><code>FullCalculation</code> - Solves the entire problem at once</li> <li><code>SegmentedCalculation</code> - Solves the problem in segments (with optioinal overlap), improving performance for large problems</li> <li><code>AggregatedCalculation</code> - Uses typical periods to reduce computational requirements</li> </ul>"},{"location":"user-guide/#results","title":"Results","text":"<p>The results of a calculation are stored in a <code>CalculationResults</code> object. This object contains the solutions of the optimization as well as all information about the <code>Calculation</code> and the <code>FlowSystem</code> it was created from. The solutions is stored as an <code>xarray.Dataset</code>, but can be accessed through their assotiated Component, Bus or Effect.</p> <p>This <code>CalculationResults</code> object can be saved to file and reloaded from file, allowing you to analyze the results anytime after the solve.</p>"},{"location":"user-guide/#how-these-concepts-work-together","title":"How These Concepts Work Together","text":"<p>The process of working with FlixOpt can be divided into 3 steps:</p> <ol> <li>Create a <code>FlowSystem</code>, containing all the elements and data of your system<ul> <li>Define the time series of your system</li> <li>Add <code>Components</code> like <code>Boilers</code>, <code>HeatPumps</code>, <code>CHPs</code>, etc.</li> <li>Add <code>Buses</code> as connection points in your system</li> <li>Add <code>Effects</code> to represent costs, emissions, etc.</li> <li>This <code>FlowSystem</code> can also be loaded from a netCDF file</li> </ul> </li> <li>Translate the model to a mathematical optimization problem<ul> <li>Create a <code>Calculation</code> from your FlowSystem and choose a Solver</li> <li>...The Calculation is translated internaly to a mathematical optimization problem...</li> <li>...and solved by the chosen solver.</li> </ul> </li> <li>Analyze the results<ul> <li>The results are stored in a <code>CalculationResults</code> object</li> <li>This object can be saved to file and reloaded from file, retaining all information about the calculation</li> <li>As it contains the used <code>FlowSystem</code>, it can be used to start a new calculation</li> </ul> </li> </ol> <p> </p> Conceptual Usage and IO operations of FlixOpt"},{"location":"user-guide/#advanced-usage","title":"Advanced Usage","text":"<p>As flixopt is build on linopy, any model created with FlixOpt can be extended or modified using the great linopy API. This allows to adjust your model to very specific requirements without loosing the convenience of FlixOpt.</p>"},{"location":"user-guide/Mathematical%20Notation/","title":"Mathematical Notation","text":""},{"location":"user-guide/Mathematical%20Notation/#naming-conventions","title":"Naming Conventions","text":"<p>FlixOpt uses the following naming conventions:</p> <ul> <li>All optimization variables are denoted by italic letters (e.g., \\(x\\), \\(y\\), \\(z\\))</li> <li>All parameters and constants are denoted by non italic small letters (e.g., \\(\\text{a}\\), \\(\\text{b}\\), \\(\\text{c}\\))</li> <li>All Sets are denoted by greek capital letters (e.g., \\(\\mathcal{F}\\), \\(\\mathcal{E}\\))</li> <li>All units of a set are denoted by greek small letters (e.g., \\(\\mathcal{f}\\), \\(\\mathcal{e}\\))</li> <li>The letter \\(i\\) is used to denote an index (e.g., \\(i=1,\\dots,\\text n\\))</li> <li>All time steps are denoted by the letter \\(\\text{t}\\) (e.g., \\(\\text{t}_0\\), \\(\\text{t}_1\\), \\(\\text{t}_i\\))</li> </ul>"},{"location":"user-guide/Mathematical%20Notation/#timesteps","title":"Timesteps","text":"<p>Time steps are defined as a sequence of discrete time steps \\(\\text{t}_i \\in \\mathcal{T} \\quad \\text{for} \\quad i \\in \\{1, 2, \\dots, \\text{n}\\}\\) (left-aligned in its timespan). From this sequence, the corresponding time intervals \\(\\Delta \\text{t}_i \\in \\Delta \\mathcal{T}\\) are derived as </p> \\[\\Delta \\text{t}_i = \\text{t}_{i+1} - \\text{t}_i \\quad \\text{for} \\quad i \\in \\{1, 2, \\dots, \\text{n}-1\\}\\] <p>The final time interval \\(\\Delta \\text{t}_\\text n\\) defaults to \\(\\Delta \\text{t}_\\text n = \\Delta \\text{t}_{\\text n-1}\\), but is of course customizable. Non-equidistant time steps are also supported.</p>"},{"location":"user-guide/Mathematical%20Notation/Bus/","title":"Bus","text":"<p>A Bus is a simple nodal balance between its incoming and outgoing flow rates.</p> \\[ \\label{eq:bus_balance}   \\sum_{f_\\text{in} \\in \\mathcal{F}_\\text{in}} p_{f_\\text{in}}(\\text{t}_i) =   \\sum_{f_\\text{out} \\in \\mathcal{F}_\\text{out}} p_{f_\\text{out}}(\\text{t}_i) \\] <p>Optionally, a Bus can have a <code>excess_penalty_per_flow_hour</code> parameter, which allows to penaltize the balance for missing or excess flow-rates. This is usefull as it handles a possible ifeasiblity gently.</p> <p>This changes the balance to</p> \\[ \\label{eq:bus_balance-excess}   \\sum_{f_\\text{in} \\in \\mathcal{F}_\\text{in}} p_{f_ \\text{in}}(\\text{t}_i) + \\phi_\\text{in}(\\text{t}_i) =   \\sum_{f_\\text{out} \\in \\mathcal{F}_\\text{out}} p_{f_\\text{out}}(\\text{t}_i) + \\phi_\\text{out}(\\text{t}_i) \\] <p>The penalty term is defined as</p> \\[ \\label{eq:bus_penalty}   s_{b \\rightarrow \\Phi}(\\text{t}_i) =       \\text a_{b \\rightarrow \\Phi}(\\text{t}_i) \\cdot \\Delta \\text{t}_i       \\cdot [ \\phi_\\text{in}(\\text{t}_i) + \\phi_\\text{out}(\\text{t}_i) ] \\] <p>With:</p> <ul> <li>\\(\\mathcal{F}_\\text{in}\\) and \\(\\mathcal{F}_\\text{out}\\) being the set of all incoming and outgoing flows</li> <li>\\(p_{f_\\text{in}}(\\text{t}_i)\\) and \\(p_{f_\\text{out}}(\\text{t}_i)\\) being the flow-rate at time \\(\\text{t}_i\\) for flow \\(f_\\text{in}\\) and \\(f_\\text{out}\\), respectively</li> <li>\\(\\phi_\\text{in}(\\text{t}_i)\\) and \\(\\phi_\\text{out}(\\text{t}_i)\\) being the missing or excess flow-rate at time \\(\\text{t}_i\\), respectively</li> <li>\\(\\text{t}_i\\) being the time step</li> <li>\\(s_{b \\rightarrow \\Phi}(\\text{t}_i)\\) being the penalty term</li> <li>\\(\\text a_{b \\rightarrow \\Phi}(\\text{t}_i)\\) being the penalty coefficient (<code>excess_penalty_per_flow_hour</code>)</li> </ul>"},{"location":"user-guide/Mathematical%20Notation/Effects%2C%20Penalty%20%26%20Objective/","title":"Effects, Penalty & Objective","text":""},{"location":"user-guide/Mathematical%20Notation/Effects%2C%20Penalty%20%26%20Objective/#effects","title":"Effects","text":"<p><code>Effects</code> are used to allocate things like costs, emissions, or other \"effects\" occuring in the system. These arise from so called Shares, which originate from Elements like Flows.</p> <p>Example:</p> <p><code>Flows</code> have an attribute called <code>effects_per_flow_hour</code>, defining the effect amount of per flow hour. Assiziated effects could be: - costs - given in [\u20ac/kWh]... - ...or emissions - given in [kg/kWh]. -  Effects are allocated seperatly for investments and operation.</p>"},{"location":"user-guide/Mathematical%20Notation/Effects%2C%20Penalty%20%26%20Objective/#shares-to-effects","title":"Shares to Effects","text":"\\[ \\label{eq:Share_invest} s_{l \\rightarrow e, \\text{inv}} = \\sum_{v \\in \\mathcal{V}_{l, \\text{inv}}} v \\cdot \\text a_{v \\rightarrow e}  \\] \\[ \\label{eq:Share_operation} s_{l \\rightarrow e, \\text{op}}(\\text{t}_i) = \\sum_{v \\in \\mathcal{V}_{l,\\text{op}}} v(\\text{t}_i) \\cdot \\text a_{v \\rightarrow e}(\\text{t}_i)            \\] <p>With:</p> <ul> <li>\\(\\text{t}_i\\) being the time step</li> <li>\\(\\mathcal{V_l}\\) being the set of all optimization variables of element \\(e\\)</li> <li>\\(\\mathcal{V}_{l, \\text{inv}}\\) being the set of all optimization variables of element \\(e\\) related to investment</li> <li>\\(\\mathcal{V}_{l, \\text{op}}\\) being the set of all optimization variables of element \\(e\\) related to operation</li> <li>\\(v\\) being an optimization variable of the element \\(l\\)</li> <li>\\(v(\\text{t}_i)\\) being an optimization variable of the element \\(l\\) at timestep \\(\\text{t}_i\\)</li> <li>\\(\\text a_{v \\rightarrow e}\\) being the factor between the optimization variable \\(v\\) to effect \\(e\\)</li> <li>\\(\\text a_{v \\rightarrow e}(\\text{t}_i)\\) being the factor between the optimization variable \\(v\\) to effect \\(e\\) for timestep \\(\\text{t}_i\\)</li> <li>\\(s_{l \\rightarrow e, \\text{inv}}\\) being the share of element \\(l\\) to the investment part of effect \\(e\\)</li> <li>\\(s_{l \\rightarrow e, \\text{op}}(\\text{t}_i)\\) being the share of element \\(l\\) to the operation part of effect \\(e\\)</li> </ul>"},{"location":"user-guide/Mathematical%20Notation/Effects%2C%20Penalty%20%26%20Objective/#shares-between-different-effects","title":"Shares between different Effects","text":"<p>Furthermore, the Effect \\(x\\) can contribute a share to another Effect \\({e} \\in \\mathcal{E}\\backslash x\\).  This share is defined by the factor \\(\\text r_{x \\rightarrow e}\\). </p> <p>For example, the Effect \"CO\\(_2\\) emissions\" (unit: kg)  can cause an additional share to Effect \"monetary costs\" (unit: \u20ac).  In this case, the factor \\(\\text a_{x \\rightarrow e}\\) is the specific CO\\(_2\\) price in \u20ac/kg. However, circular references have to be avoided.</p> <p>The overall sum of investment shares of an Effect \\(e\\) is given by \\(\\eqref{Effect_invest}\\)</p> \\[ \\label{eq:Effect_invest} E_{e, \\text{inv}} =  \\sum_{l \\in \\mathcal{L}} s_{l \\rightarrow e,\\text{inv}} +  \\sum_{x \\in \\mathcal{E}\\backslash e} E_{x, \\text{inv}}  \\cdot \\text{r}_{x \\rightarrow  e,\\text{inv}} \\] <p>The overall sum of operation shares is given by \\(\\eqref{eq:Effect_Operation}\\)</p> \\[ \\label{eq:Effect_Operation} E_{e, \\text{op}}(\\text{t}_{i}) =  \\sum_{l \\in \\mathcal{L}} s_{l \\rightarrow e, \\text{op}}(\\text{t}_i) +  \\sum_{x \\in \\mathcal{E}\\backslash e} E_{x, \\text{op}}(\\text{t}_i) \\cdot \\text{r}_{x \\rightarrow {e},\\text{op}}(\\text{t}_i) \\] <p>and totals to \\(\\eqref{eq:Effect_Operation_total}\\) $$\\label{eq:Effect_Operation_total} E_{e,\\text{op},\\text{tot}} = \\sum_{i=1}^n  E_{e,\\text{op}}(\\text{t}_{i}) $$</p> <p>With:</p> <ul> <li>\\(\\mathcal{L}\\) being the set of all elements in the FlowSystem</li> <li>\\(\\mathcal{E}\\) being the set of all effects in the FlowSystem</li> <li>\\(\\text r_{x \\rightarrow e, \\text{inv}}\\) being the factor between the operation part of Effect \\(x\\) and Effect \\(e\\)</li> <li> <p>\\(\\text r_{x \\rightarrow e, \\text{op}}(\\text{t}_i)\\) being the factor between the invest part of Effect \\(x\\) and Effect \\(e\\)</p> </li> <li> <p>\\(\\text{t}_i\\) being the time step</p> </li> <li>\\(s_{l \\rightarrow e, \\text{inv}}\\) being the share of element \\(l\\) to the investment part of effect \\(e\\)</li> <li>\\(s_{l \\rightarrow e, \\text{op}}(\\text{t}_i)\\) being the share of element \\(l\\) to the operation part of effect \\(e\\)</li> </ul> <p>The total of an effect \\(E_{e}\\) is given as \\(\\eqref{eq:Effect_Total}\\)</p> \\[ \\label{eq:Effect_Total} E_{e} = E_{\\text{inv},e} +E_{\\text{op},\\text{tot},e} \\]"},{"location":"user-guide/Mathematical%20Notation/Effects%2C%20Penalty%20%26%20Objective/#constraining-effects","title":"Constraining Effects","text":"<p>For each variable \\(v \\in \\{ E_{e,\\text{inv}}, E_{e,\\text{op},\\text{tot}}, E_e\\}\\), a lower bound \\(v^\\text{L}\\) and upper bound \\(v^\\text{U}\\) can be defined as</p> \\[ \\label{eq:Bounds_Single} \\text v^\\text{L} \\leq v \\leq \\text v^\\text{U} \\] <p>Furthermore, bounds for the operational shares can be set for each time step</p> \\[ \\label{eq:Bounds_Time_Steps} \\text E_{e,\\text{op}}^\\text{L}(\\text{t}_i) \\leq E_{e,\\text{op}}(\\text{t}_i) \\leq \\text E_{e,\\text{op}}^\\text{U}(\\text{t}_i) \\]"},{"location":"user-guide/Mathematical%20Notation/Effects%2C%20Penalty%20%26%20Objective/#penalty","title":"Penalty","text":"<p>Additionally to the user defined Effects, a Penalty \\(\\Phi\\) is part of every FlixOpt Model. Its used to prevent unsolvable problems and simplify troubleshooting. Shares to the penalty can originate from every Element and are constructed similarly to  \\(\\eqref{Share_invest}\\) and  \\(\\eqref{Share_operation}\\).</p> \\[ \\label{eq:Penalty} \\Phi = \\sum_{l \\in \\mathcal{L}} \\left( s_{l \\rightarrow \\Phi}  +\\sum_{\\text{t}_i \\in \\mathcal{T}} s_{l \\rightarrow \\Phi}(\\text{t}_{i}) \\right) \\] <p>With:</p> <ul> <li>\\(\\mathcal{L}\\) being the set of all elements in the FlowSystem</li> <li>\\(\\mathcal{T}\\) being the set of all timesteps</li> <li>\\(s_{l \\rightarrow \\Phi}\\) being the share of element \\(l\\) to the penalty</li> </ul> <p>At the moment, penalties only occur in Buses</p>"},{"location":"user-guide/Mathematical%20Notation/Effects%2C%20Penalty%20%26%20Objective/#objective","title":"Objective","text":"<p>The optimization objective of a FlixOpt Model is defined as \\(\\eqref{eq:Objective}\\) $$ \\label{eq:Objective} \\min(E_{\\Omega} + \\Phi) $$</p> <p>With:</p> <ul> <li>\\(\\Omega\\) being the chosen Objective Effect (see \\(\\eqref{eq:Effect_Total}\\))</li> <li>\\(\\Phi\\) being the Penalty</li> </ul> <p>This approach allows for a multi-criteria optimization using both...  - ... the Weigted SumMethod, as the chosen Objective Effect can incorporate other Effects.  - ... the (\\(\\epsilon\\)-constraint method) by constraining effects.</p>"},{"location":"user-guide/Mathematical%20Notation/Flow/","title":"Flow","text":"<p>The flow_rate is the main optimization variable of the Flow. It's limited by the size of the Flow and relative bounds \\eqref{eq:flow_rate}.</p> \\[ \\label{eq:flow_rate}     \\text P \\cdot \\text p^{\\text{L}}_{\\text{rel}}(\\text{t}_{i})     \\leq p(\\text{t}_{i}) \\leq     \\text P \\cdot \\text p^{\\text{U}}_{\\text{rel}}(\\text{t}_{i}) \\] <p>With:</p> <ul> <li>\\(\\text P\\) being the size of the Flow</li> <li>\\(p(\\text{t}_{i})\\) being the flow-rate at time \\(\\text{t}_{i}\\)</li> <li>\\(\\text p^{\\text{L}}_{\\text{rel}}(\\text{t}_{i})\\) being the relative lower bound (typically 0)</li> <li>\\(\\text p^{\\text{U}}_{\\text{rel}}(\\text{t}_{i})\\) being the relative upper bound (typically 1)</li> </ul> <p>With \\(\\text p^{\\text{L}}_{\\text{rel}}(\\text{t}_{i}) = 0\\) and \\(\\text p^{\\text{U}}_{\\text{rel}}(\\text{t}_{i}) = 1\\), equation \\eqref{eq:flow_rate} simplifies to</p> \\[     0 \\leq p(\\text{t}_{i}) \\leq \\text P \\] <p>This mathematical Formulation can be extended or changed when using OnOffParameters to define the On/Off state of the Flow, or InvestParameters, which changes the size of the Flow from a constant to an optimization variable.</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%202/","title":"Investments","text":""},{"location":"user-guide/Mathematical%20Notation/Investment%202/#current-state","title":"Current state","text":"<p>$$ \\beta_{\\text{invest}} \\cdot \\text{max}(\\epsilon, \\text V^{\\text L}) \\leq V \\leq  \\beta_{\\text{invest}} \\cdot \\text V^{\\text U} $$ With: - \\(V\\) = size - \\(V^{\\text L}\\) = minimum size - \\(V^{\\text U}\\) = maximum size - \\(\\epsilon\\) = epsilon, a small number (such as \\(1e^{-5}\\)) - \\(\\beta_{invest} \\in {0,1}\\) = wether the size is invested or not</p> <p>Please edit the use cases as needed</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%202/#quickfix-1-optimize-the-single-best-size-overall","title":"Quickfix 1: Optimize the single best size overall","text":""},{"location":"user-guide/Mathematical%20Notation/Investment%202/#single-variable","title":"Single variable","text":"<p>This is already possible and should be, as this is a needed use case An additional factor to when the size is actually available might me practical (Which indicates the (fixed) time of investment)</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%202/#math","title":"Math","text":"<p>$$ V(p) = V * a(p) $$ with: - \\(V\\) = size - \\(a(p)\\) = factor for availlability per period</p> <p>Factor \\(a(p)\\) is simply multiplied with relative minimum or maximum(t). This is already possible by doing this yourself. Effectively, the relative minimum or maximum are altered before using the same constraiints as before. THis might lead to some issues regariding minimum_load factor, or others, as the size is not 0 in a scenario where the component cant produce. **Therefore this might not be the best choice. See (#Variable per Scenario)</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%202/#variable-per-scenario","title":"Variable per Scenario","text":"<ul> <li>size and invest as a variable per period \\(V(s)\\) and \\(\\beta_{invest}(s)\\)</li> <li>with scenario \\(s \\in S\\)</li> </ul>"},{"location":"user-guide/Mathematical%20Notation/Investment%202/#usecase-1-optimize-the-size-for-each-scenario-independently","title":"Usecase 1: Optimize the size for each Scenario independently","text":"<p>Restrictions are seperatly for each scenario No changes needed. This could be the default behaviour.</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%202/#usecase-2-optimize-one-size-for-all-scenarios","title":"Usecase 2: Optimize ONE size for ALL scenarios","text":"<p>The size is the same globally, but not a scalar, but a variable per scenario \\(V(s)\\)</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%202/#2a-the-same-size-in-all-scenarios","title":"2a: The same size in all scenarios","text":"\\[ V(s) = V(s') \\quad \\forall s,s' \\in S \\] <p>With: - \\(V(s)\\) and \\(V(s')\\) = size - \\(S\\) = set of scenarios</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%202/#2b-the-same-size-but-can-be-0-prior-to-the-first-increment","title":"2b: The same size, but can be 0 prior to the first increment","text":"<ul> <li>Find the Optimal time of investment.</li> <li>Force an investment in a certain scenario (parameter optional as a list/array ob booleans)</li> <li>Combine optional and minimum/maximum size to force an investment inside a range if scenarios</li> </ul> \\[ \\beta_{\\text{invest}}(s) \\leq \\beta_{\\text{invest}}(s+1) \\quad \\forall s \\in \\{1,2,\\ldots,S-1\\} \\] \\[ V(s') - V(s) \\leq M \\cdot (2 - \\beta_{\\text{invest}}(s) - \\beta_{\\text{invest}}(s')) \\quad \\forall s, s' \\in S $$ $$ V(s') - V(s) \\geq M \\cdot (2 - \\beta_{\\text{invest}}(s) - \\beta_{\\text{invest}}(s')) \\quad \\forall s, s' \\in S \\] <p>This could be the default behaviour. (which would be consistent with other variables)</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%202/#switch","title":"Switch","text":"\\[ \\begin{aligned} &amp; \\text{SWITCH}_s \\in \\{0,1\\} \\quad \\forall s \\in \\{1,2,\\ldots,S\\} \\\\ &amp; \\sum_{s=1}^{S} \\text{SWITCH}_s = 1 \\\\ &amp; \\beta_{\\text{invest}}(s) = \\sum_{s'=1}^{s} \\text{SWITCH}_{s'} \\quad \\forall s \\in \\{1,2,\\ldots,S\\} \\\\ \\end{aligned} \\] \\[ \\begin{aligned} &amp; V(s) \\leq V_{\\text{actual}} \\quad \\forall s \\in \\{1,2,\\ldots,S\\} \\\\ &amp; V(s) \\geq V_{\\text{actual}} - M \\cdot (1 - \\beta_{\\text{invest}}(s)) \\quad \\forall s \\in \\{1,2,\\ldots,S\\} \\end{aligned} \\]"},{"location":"user-guide/Mathematical%20Notation/Investment%202/#usecase-3-find-the-best-scenario-to-increment-the-size-timing-of-the-investment","title":"Usecase 3: Find the best scenario to increment the size (Timing of the investment)","text":"<p>The size can only increment once (based on a starting point). This allows to optimize the timing of an investment.</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%202/#math_1","title":"Math","text":"<p>Treat \\(\\beta_{invest}\\) like an ON/OFF variable, and introduce a SwitchOn, that can only be active once.</p> <p>Thoughts: - Treating \\(\\beta_{invest}\\) like an ON/OFF variable suggest using the already presentconstraints linked to On/OffModel - The timing could be constraint to be first in scenario x, or last in scenario y - Restrict the number of consecutive scenarios THis might needs the OnOffModel to be more generic (HOURS). Further, the span between scenarios needs to be weighted (like dt_in_hours), or the scenarios need to be measureable (integers)</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%202/#others","title":"Others","text":""},{"location":"user-guide/Mathematical%20Notation/Investment%202/#usecase-4-only-increasedecrease-the-size","title":"Usecase 4: Only increase/decrease the size","text":"<p>Start from a certain size. For each scenario, the size can increase, but never decrease. (Or the other way around). This would mean that a size expansion is possible,</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%202/#usecase-5-restrict-the-increment-in-size-per-scenario","title":"Usecase 5: Restrict the increment in size per scenario","text":"<p>Restrict how much the size can increase/decrease for in scenario, based on the prior scenario.</p> <p>Many more are possible</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%203/","title":"Investments","text":""},{"location":"user-guide/Mathematical%20Notation/Investment%203/#current-state","title":"Current state","text":"<p>$$ \\beta_{\\text{invest}} \\cdot \\text{max}(\\epsilon, \\text V^{\\text L}) \\leq V \\leq  \\beta_{\\text{invest}} \\cdot \\text V^{\\text U} $$ With: - \\(V\\) = size - \\(V^{\\text L}\\) = minimum size - \\(V^{\\text U}\\) = maximum size - \\(\\epsilon\\) = epsilon, a small number (such as \\(1e^{-5}\\)) - \\(\\beta_{invest} \\in {0,1}\\) = wether the size is invested or not</p> <p>Please edit the use cases as needed</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%203/#quickfix-1-optimize-the-single-best-size-overall","title":"Quickfix 1: Optimize the single best size overall","text":""},{"location":"user-guide/Mathematical%20Notation/Investment%203/#single-variable","title":"Single variable","text":"<p>This is already possible and should be, as this is a needed use case An additional factor to when the size is actually available might me practical (Which indicates the (fixed) time of investment)</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%203/#math","title":"Math","text":"<p>$$ V(p) = V * a(p) $$ with: - \\(V\\) = size - \\(a(p)\\) = factor for availlability per period</p> <p>Factor \\(a(p)\\) is simply multiplied with relative minimum or maximum(t). This is already possible by doing this yourself. Effectively, the relative minimum or maximum are altered before using the same constraiints as before. THis might lead to some issues regariding minimum_load factor, or others, as the size is not 0 in a scenario where the component cant produce. **Therefore this might not be the best choice. See (#Variable per Scenario)</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%203/#variable-per-scenario","title":"Variable per Scenario","text":"<ul> <li>size and invest as a variable per period \\(V(s)\\) and \\(\\beta_{invest}(s)\\)</li> <li>with scenario \\(s \\in S\\)</li> </ul>"},{"location":"user-guide/Mathematical%20Notation/Investment%203/#usecase-1-optimize-the-size-for-each-scenario-independently","title":"Usecase 1: Optimize the size for each Scenario independently","text":"<p>Restrictions are seperatly for each scenario No changes needed. This could be the default behaviour.</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%203/#usecase-2-optimize-one-size-for-all-scenarios","title":"Usecase 2: Optimize ONE size for ALL scenarios","text":"<p>The size is the same globally, but not a scalar, but a variable per scenario \\(V(s)\\)</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%203/#2a-the-same-size-in-all-scenarios","title":"2a: The same size in all scenarios","text":"\\[ V(s) = V(s') \\quad \\forall s,s' \\in S \\] <p>With: - \\(V(s)\\) and \\(V(s')\\) = size - \\(S\\) = set of scenarios</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%203/#2b-the-same-size-but-can-be-0-prior-to-the-first-increment","title":"2b: The same size, but can be 0 prior to the first increment","text":"<ul> <li>Find the Optimal time of investment.</li> <li>Force an investment in a certain scenario (parameter optional as a list/array ob booleans)</li> <li>Combine optional and minimum/maximum size to force an investment inside a range if scenarios</li> </ul> \\[ \\beta_{\\text{invest}}(s) \\leq \\beta_{\\text{invest}}(s+1) \\quad \\forall s \\in \\{1,2,\\ldots,S-1\\} \\] \\[ V(s') - V(s) \\leq M \\cdot (2 - \\beta_{\\text{invest}}(s) - \\beta_{\\text{invest}}(s')) \\quad \\forall s, s' \\in S $$ $$ V(s') - V(s) \\geq M \\cdot (2 - \\beta_{\\text{invest}}(s) - \\beta_{\\text{invest}}(s')) \\quad \\forall s, s' \\in S \\] <p>This could be the default behaviour. (which would be consistent with other variables)</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%203/#switch","title":"Switch","text":"\\[ \\begin{aligned} &amp; \\text{SWITCH}_s \\in \\{0,1\\} \\quad \\forall s \\in \\{1,2,\\ldots,S\\} \\\\ &amp; \\sum_{s=1}^{S} \\text{SWITCH}_s = 1 \\\\ &amp; \\beta_{\\text{invest}}(s) = \\sum_{s'=1}^{s} \\text{SWITCH}_{s'} \\quad \\forall s \\in \\{1,2,\\ldots,S\\} \\\\ \\end{aligned} \\] \\[ \\begin{aligned} &amp; V(s) \\leq V_{\\text{actual}} \\quad \\forall s \\in \\{1,2,\\ldots,S\\} \\\\ &amp; V(s) \\geq V_{\\text{actual}} - M \\cdot (1 - \\beta_{\\text{invest}}(s)) \\quad \\forall s \\in \\{1,2,\\ldots,S\\} \\end{aligned} \\]"},{"location":"user-guide/Mathematical%20Notation/Investment%203/#usecase-3-find-the-best-scenario-to-increment-the-size-timing-of-the-investment","title":"Usecase 3: Find the best scenario to increment the size (Timing of the investment)","text":"<p>The size can only increment once (based on a starting point). This allows to optimize the timing of an investment.</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%203/#math_1","title":"Math","text":"<p>Treat \\(\\beta_{invest}\\) like an ON/OFF variable, and introduce a SwitchOn, that can only be active once.</p> <p>Thoughts: - Treating \\(\\beta_{invest}\\) like an ON/OFF variable suggest using the already presentconstraints linked to On/OffModel - The timing could be constraint to be first in scenario x, or last in scenario y - Restrict the number of consecutive scenarios THis might needs the OnOffModel to be more generic (HOURS). Further, the span between scenarios needs to be weighted (like dt_in_hours), or the scenarios need to be measureable (integers)</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%203/#others","title":"Others","text":""},{"location":"user-guide/Mathematical%20Notation/Investment%203/#usecase-4-only-increasedecrease-the-size","title":"Usecase 4: Only increase/decrease the size","text":"<p>Start from a certain size. For each scenario, the size can increase, but never decrease. (Or the other way around). This would mean that a size expansion is possible,</p>"},{"location":"user-guide/Mathematical%20Notation/Investment%203/#usecase-5-restrict-the-increment-in-size-per-scenario","title":"Usecase 5: Restrict the increment in size per scenario","text":"<p>Restrict how much the size can increase/decrease for in scenario, based on the prior scenario.</p> <p>Many more are possible</p>"},{"location":"user-guide/Mathematical%20Notation/LinearConverter/","title":"LinearConverter","text":"<p><code>LinearConverters</code> define a ratio between incoming and outgoing Flows.</p> \\[ \\label{eq:Linear-Transformer-Ratio}     \\sum_{f_{\\text{in}} \\in \\mathcal F_{in}} \\text a_{f_{\\text{in}}}(\\text{t}_i) \\cdot p_{f_\\text{in}}(\\text{t}_i) = \\sum_{f_{\\text{out}} \\in \\mathcal F_{out}}  \\text b_{f_\\text{out}}(\\text{t}_i) \\cdot p_{f_\\text{out}}(\\text{t}_i) \\] <p>With:</p> <ul> <li>\\(\\mathcal F_{in}\\) and \\(\\mathcal F_{out}\\) being the set of all incoming and outgoing flows</li> <li>\\(p_{f_\\text{in}}(\\text{t}_i)\\) and \\(p_{f_\\text{out}}(\\text{t}_i)\\) being the flow-rate at time \\(\\text{t}_i\\) for flow \\(f_\\text{in}\\) and \\(f_\\text{out}\\), respectively</li> <li>\\(\\text a_{f_\\text{in}}(\\text{t}_i)\\) and \\(\\text b_{f_\\text{out}}(\\text{t}_i)\\) being the ratio of the flow-rate at time \\(\\text{t}_i\\) for flow \\(f_\\text{in}\\) and \\(f_\\text{out}\\), respectively</li> </ul> <p>With one incoming Flow and one outgoing Flow, this can be simplified to: </p> \\[ \\label{eq:Linear-Transformer-Ratio-simple}     \\text a(\\text{t}_i) \\cdot p_{f_\\text{in}}(\\text{t}_i) = p_{f_\\text{out}}(\\text{t}_i) \\] <p>where \\(\\text a\\) can be interpreted as the conversion efficiency of the LinearTransformer.</p>"},{"location":"user-guide/Mathematical%20Notation/LinearConverter/#piecewise-concersion-factors","title":"Piecewise Concersion factors","text":"<p>The conversion efficiency can be defined as a piecewise linear approximation. See Piecewise for more details.</p>"},{"location":"user-guide/Mathematical%20Notation/Piecewise/","title":"Piecewise","text":"<p>A Piecewise is a collection of <code>Pieces</code>, which each define a valid range for a variable \\(v\\)</p> \\[ \\label{eq:active_piece}     \\beta_\\text{k} = \\lambda_\\text{0, k} + \\lambda_\\text{1, k} \\] \\[ \\label{eq:piece}     v_\\text{k} = \\lambda_\\text{0, k} * \\text{v}_{\\text{start,k}} + \\lambda_\\text{1,k} * \\text{v}_{\\text{end,k}} \\] \\[ \\label{eq:piecewise_in_pieces} \\sum_{k=1}^k \\beta_{k} = 1 \\] <p>With:</p> <ul> <li>\\(v\\): The variable to be defined by the Piecewise</li> <li>\\(\\text{v}_{\\text{start,k}}\\): the start point of the piece for variable \\(v\\)</li> <li>\\(\\text{v}_{\\text{end,k}}\\): the end point of the piece for variable \\(v\\)</li> <li>\\(\\beta_\\text{k} \\in \\{0, 1\\}\\): defining wether the Piece \\(k\\) is active</li> <li>\\(\\lambda_\\text{0,k} \\in [0, 1]\\): A variable defining the fraction of \\(\\text{v}_{\\text{start,k}}\\) that is active</li> <li>\\(\\lambda_\\text{1,k} \\in [0, 1]\\): A variable defining the fraction of \\(\\text{v}_{\\text{end,k}}\\) that is active</li> </ul> <p>Which can also be described as \\(v \\in 0 \\cup [\\text{v}_\\text{start}, \\text{v}_\\text{end}]\\).</p> <p>Instead of \\eqref{eq:piecewise_in_pieces}, the following constraint is used to also allow all variables to be zero:</p> \\[ \\label{eq:piecewise_in_pieces_zero} \\sum_{k=1}^k \\beta_{k} = \\beta_\\text{zero} \\] <p>With:</p> <ul> <li>\\(\\beta_\\text{zero} \\in \\{0, 1\\}\\).</li> </ul> <p>Which can also be described as \\(v \\in \\{0\\} \\cup [\\text{v}_{\\text{start_k}}, \\text{v}_{\\text{end_k}}]\\)</p>"},{"location":"user-guide/Mathematical%20Notation/Piecewise/#combining-multiple-piecewises","title":"Combining multiple Piecewises","text":"<p>Piecewise allows representing non-linear relationships.  This is a powerful technique in linear optimization to model non-linear behaviors while maintaining the problem's linearity.</p> <p>Therefore, each Piecewise must have the same number of Pieces \\(k\\).</p> <p>The variables described in Piecewise are created for each Piece, but nor for each Piecewise. Rather, \\eqref{eq:piece} is the only constraint that is created for each Piecewise, using the start and endpoints \\(\\text{v}_{\\text{start,k}}\\) and \\(\\text{v}_{\\text{end,k}}\\) of each Piece for the corresponding variable \\(v\\)</p>"},{"location":"user-guide/Mathematical%20Notation/Storage/","title":"Storages","text":"<p>Storages have one incoming and one outgoing Flow with a charging and discharging efficiency. A storage has a state of charge \\(c(\\text{t}_i)\\) which is limited by its <code>size</code> \\(\\text C\\) and relative bounds \\(\\eqref{eq:Storage_Bounds}\\).</p> \\[ \\label{eq:Storage_Bounds}     \\text C \\cdot \\text c^{\\text{L}}_{\\text{rel}}(\\text t_{i})     \\leq c(\\text{t}_i) \\leq     \\text C \\cdot \\text c^{\\text{U}}_{\\text{rel}}(\\text t_{i}) \\] <p>Where:</p> <ul> <li>\\(\\text C\\) is the size of the storage</li> <li>\\(c(\\text{t}_i)\\) is the state of charge at time \\(\\text{t}_i\\)</li> <li>\\(\\text c^{\\text{L}}_{\\text{rel}}(\\text t_{i})\\) is the relative lower bound (typically 0)</li> <li>\\(\\text c^{\\text{U}}_{\\text{rel}}(\\text t_{i})\\) is the relative upper bound (typically 1)</li> </ul> <p>With \\(\\text c^{\\text{L}}_{\\text{rel}}(\\text t_{i}) = 0\\) and \\(\\text c^{\\text{U}}_{\\text{rel}}(\\text t_{i}) = 1\\), Equation \\(\\eqref{eq:Storage_Bounds}\\) simplifies to</p> \\[ 0 \\leq c(\\text t_{i}) \\leq \\text C \\] <p>The state of charge \\(c(\\text{t}_i)\\) decreases by a fraction of the prior state of charge. The belonging parameter $ \\dot{ \\text c}_\\text{rel, loss}(\\text{t}_i)$ expresses the \"loss fraction per hour\". The storage balance from  \\(\\text{t}_i\\) to \\(\\text t_{i+1}\\) is</p> \\[ \\begin{align*}     c(\\text{t}_{i+1}) &amp;= c(\\text{t}_{i}) \\cdot (1-\\dot{\\text{c}}_\\text{rel,loss}(\\text{t}_i) \\cdot \\Delta \\text{t}_{i}) \\\\     &amp;\\quad + p_{f_\\text{in}}(\\text{t}_i) \\cdot \\Delta \\text{t}_i \\cdot \\eta_\\text{in}(\\text{t}_i) \\\\     &amp;\\quad - \\frac{p_{f_\\text{out}}(\\text{t}_i) \\cdot \\Delta \\text{t}_i}{\\eta_\\text{out}(\\text{t}_i)}     \\tag{3} \\end{align*} \\] <p>Where:</p> <ul> <li>\\(c(\\text{t}_{i+1})\\) is the state of charge at time \\(\\text{t}_{i+1}\\)</li> <li>\\(c(\\text{t}_{i})\\) is the state of charge at time \\(\\text{t}_{i}\\)</li> <li>\\(\\dot{\\text{c}}_\\text{rel,loss}(\\text{t}_i)\\) is the relative loss rate (self-discharge) per hour</li> <li>\\(\\Delta \\text{t}_{i}\\) is the time step duration in hours</li> <li>\\(p_{f_\\text{in}}(\\text{t}_i)\\) is the input flow rate at time \\(\\text{t}_i\\)</li> <li>\\(\\eta_\\text{in}(\\text{t}_i)\\) is the charging efficiency at time \\(\\text{t}_i\\)</li> <li>\\(p_{f_\\text{out}}(\\text{t}_i)\\) is the output flow rate at time \\(\\text{t}_i\\)</li> <li>\\(\\eta_\\text{out}(\\text{t}_i)\\) is the discharging efficiency at time \\(\\text{t}_i\\)</li> </ul>"},{"location":"user-guide/Mathematical%20Notation/others/","title":"Work in Progress","text":"<p>This is a work in progress.</p>"}]}