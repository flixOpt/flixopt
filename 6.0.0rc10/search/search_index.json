{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"flixOpt <p>Flexible \u00b7 Low-entry \u00b7 Investment \u00b7 X-sector \u00b7 OPTimization</p> <p>Model more than costs \u00b7 Easy to prototype \u00b7 Based on dispatch \u00b7 Sector coupling \u00b7 Mathematical optimization</p> <p>Model, optimize, and analyze complex energy systems with a powerful Python framework designed for flexibility and performance.</p> <p> \ud83d\ude80 Get Started \ud83d\udca1 View Examples \u2b50 GitHub </p>"},{"location":"#quick-navigation","title":"Quick Navigation","text":"<ul> <li> <p> Getting Started</p> <p>New to FlixOpt? Start here with installation and your first model</p> </li> <li> <p> Examples Gallery</p> <p>Explore real-world examples from simple to complex systems</p> </li> <li> <p> API Reference</p> <p>Detailed documentation of all classes, methods and parameters</p> </li> <li> <p> Recipes</p> <p>Common patterns and best practices for modeling energy systems</p> </li> <li> <p> Mathematical Notation</p> <p>Understand the mathematical formulations behind the framework</p> </li> <li> <p> Roadmap</p> <p>See what's coming next and contribute to the future of FlixOpt</p> </li> </ul>"},{"location":"#framework-architecture","title":"\ud83c\udfd7\ufe0f Framework Architecture","text":"Conceptual Usage and IO operations of FlixOpt <p>FlixOpt provides a complete workflow for energy system optimization:</p> <ul> <li> Define your system using Python components</li> <li> Optimize with powerful solvers (HiGHS, Gurobi, CPLEX)</li> <li> Analyze results with built-in visualization tools</li> <li> Export to various formats for further analysis</li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li> <p> GitHub</p> <p>Report issues, request features, and contribute to the codebase</p> <p>Visit Repository \u2192</p> </li> <li> <p> Discussions</p> <p>Ask questions and share your projects with the community</p> <p>Join Discussion \u2192</p> </li> <li> <p> Contributing</p> <p>Help improve FlixOpt by contributing code, docs, or examples</p> <p>Learn How \u2192</p> </li> </ul>"},{"location":"#recent-updates","title":"Recent Updates","text":"<p>What's New in v3.0.0</p> <p>Major improvements and breaking changes. Check the Migration Guide for upgrading from v2.x.</p> <p>\ud83d\udccb See the full Release Notes for detailed version history.</p> Ready to optimize your energy system? <p> \u25b6\ufe0f Start Building </p>"},{"location":"#basic-installation","title":"Basic Installation","text":"<pre><code>pip install flixopt\n</code></pre> <p>Includes the HiGHS solver - you're ready to optimize immediately.</p>"},{"location":"#full-installation","title":"Full Installation","text":"<p>For additional features (interactive network visualization, time series aggregation):</p> <pre><code>pip install \"flixopt[full]\"\n</code></pre>"},{"location":"#solver-support","title":"Solver Support","text":"<p>FlixOpt supports many solvers via linopy: HiGHS (included), Gurobi, CPLEX, CBC, GLPK, and more.</p> <p>\u2192 Installation guide</p>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>FlixOpt thrives on community input. Whether you're fixing bugs, adding components, improving docs, or sharing use cases - we welcome your contributions.</p> <p>\u2192 Contribution guide</p>"},{"location":"#citation","title":"\ud83d\udcd6 Citation","text":"<p>If FlixOpt supports your research or project, please cite:</p> <ul> <li>Main Citation: DOI:10.18086/eurosun.2022.04.07</li> <li>Short Overview: DOI:10.13140/RG.2.2.14948.24969</li> </ul> <p>To pinpoint which version you used in your work, please reference one of these doi's here: - </p>"},{"location":"changelog/","title":"Changelog","text":"<p>This project adheres to Semantic Versioning. Formatting is based on Keep a Changelog &amp; Gitmoji. For more details regarding the individual PRs and contributors, please refer to our GitHub releases.</p> <p>Tip</p> <p>If upgrading from v5.x, see the Migration Guide v6. If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide v3.</p>"},{"location":"changelog/#v6.0.0","title":"v6.0.0 Upcoming","text":"<p>Summary: Major release featuring tsam v3 migration, complete rewrite of the clustering/aggregation system, 2-3x faster I/O for large systems, new <code>plotly</code> plotting accessor, FlowSystem comparison tools, and removal of deprecated v5.0 classes.</p> <p>Breaking Changes</p> <p>This release removes <code>ClusteredOptimization</code> and <code>ClusteringParameters</code> which were deprecated in v5.0.0. Use <code>flow_system.transform.cluster()</code> instead. See Migration below.</p> <p>The clustering API now uses tsam v3's configuration objects (<code>ClusterConfig</code>, <code>ExtremeConfig</code>) instead of individual parameters. See tsam v3 Migration below.</p>"},{"location":"changelog/#key-features","title":"Key Features","text":"<ul> <li>tsam v3 Migration (#584) - Updated to tsam 3.0+ with new configuration-based API</li> <li>Clustering/Aggregation Rework (#549, #552, #584) - Complete rewrite with tsam integration, inter-cluster storage linking, segmentation support, and 4 storage modes</li> <li>I/O Performance (#584) - 2-3x faster NetCDF I/O for large systems via variable stacking</li> <li>plotly Plotting Accessor (#548) - Universal xarray plotting with automatic faceting</li> <li>Comparison Module (#550) - Compare multiple FlowSystems side-by-side</li> <li>Improved Notebooks (#542, #551) - Better tutorial data and faster CI execution</li> </ul>"},{"location":"changelog/#added","title":"\u2728 Added","text":""},{"location":"changelog/#time-series-clustering-549-552-584","title":"Time-Series Clustering (#549, #552, #584)","text":"<p>Reduce large time series to representative typical periods for faster investment optimization, then expand results back to full resolution.</p> <pre><code>from tsam import ClusterConfig, ExtremeConfig\n\n# Stage 1: Cluster and optimize (fast sizing)\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=12,                    # 12 typical days from a year\n    cluster_duration='1D',            # Each cluster represents one day\n    cluster=ClusterConfig(method='hierarchical'),\n    extremes=ExtremeConfig(method='new_cluster', max_value=['HeatDemand(Q)|fixed_relative_profile']),\n)\nfs_clustered.optimize(solver)\n\n# Stage 2: Expand back to full resolution\nfs_expanded = fs_clustered.transform.expand()\n</code></pre> <p>Storage Modes for Clustering: Control how storage behaves across clustered periods via <code>Storage(cluster_mode=...)</code>:</p> Mode Description Use Case <code>'intercluster_cyclic'</code> Links storage across clusters + yearly cyclic (default) Seasonal storage with yearly optimization <code>'intercluster'</code> Links storage across clusters, free start/end Multi-year optimization without cyclic constraint <code>'cyclic'</code> Each cluster independent, but cyclic (start = end) Daily storage only, ignores seasonal patterns <code>'independent'</code> Each cluster fully independent, free start/end Fastest solve, no long-term storage value <p>Clustering Parameters:</p> Parameter Description <code>n_clusters</code> Number of representative periods to create <code>cluster_duration</code> Duration of each cluster (e.g., <code>'1D'</code>, <code>'24h'</code>, or hours as float) <code>weights</code> Dict mapping variable names to importance weights for clustering <code>cluster</code> <code>ClusterConfig</code> object for clustering algorithm settings (method, representation, etc.) <code>extremes</code> <code>ExtremeConfig</code> object for peak/valley preservation settings <code>predef_cluster_assignments</code> Predefined cluster assignment for reproducibility <code>**tsam_kwargs</code> Additional arguments passed to tsam <p>See tsam documentation for <code>ClusterConfig</code> and <code>ExtremeConfig</code> options.</p> <p>Key Features:</p> <ul> <li>Inter-cluster storage linking: For <code>'intercluster'</code> and <code>'intercluster_cyclic'</code> modes, a <code>SOC_boundary</code> variable tracks absolute state-of-charge at period boundaries, enabling accurate seasonal storage modeling</li> <li>Self-discharge decay: Storage losses are correctly applied during solution expansion using the formula: <code>actual_SOC(t) = SOC_boundary \u00d7 (1 - loss)^t + \u0394E(t)</code></li> <li>Multi-dimensional support: Works with periods, scenarios, and clusters dimensions simultaneously</li> <li>Solution expansion: <code>transform.expand()</code> maps clustered results back to original timesteps with proper storage state reconstruction</li> <li>Clustering IO: Save and load clustered FlowSystems with full state preservation via <code>to_netcdf()</code> / <code>from_netcdf()</code></li> </ul> <p>Example: Seasonal Storage with Clustering:</p> <pre><code># Configure storage for seasonal behavior\nstorage = fx.Storage(\n    'SeasonalPit',\n    capacity_in_flow_hours=5000,\n    cluster_mode='intercluster_cyclic',  # Enable seasonal storage in clustering\n    relative_loss_per_hour=0.0001,       # Small self-discharge\n    ...\n)\n\n# Cluster, optimize, and expand\nfs_clustered = flow_system.transform.cluster(n_clusters=12, cluster_duration='1D')\nfs_clustered.optimize(solver)\nfs_expanded = fs_clustered.transform.expand()\n\n# Full-resolution charge state now available\ncharge_state = fs_expanded.solution['SeasonalPit|charge_state']\n</code></pre> <p>Choosing the Right Storage Mode</p> <p>Use <code>'intercluster_cyclic'</code> (default) for seasonal storage like pit storage or underground thermal storage. Use <code>'cyclic'</code> for short-term storage like batteries or hot water tanks where only daily patterns matter. Use <code>'independent'</code> for quick estimates when storage behavior isn't critical.</p>"},{"location":"changelog/#time-series-segmentation-584","title":"Time-Series Segmentation (#584)","text":"<p>New <code>transform.segment()</code> method for piecewise-constant time-series approximation. Useful for reducing problem size while preserving temporal structure:</p> <pre><code># Segment time series into 24 segments per day\nfs_segmented = flow_system.transform.segment(\n    segment_duration='1D',\n    n_segments=24,\n)\nfs_segmented.optimize(solver)\nfs_expanded = fs_segmented.transform.expand()\n</code></pre>"},{"location":"changelog/#io-performance-improvements-584","title":"I/O Performance Improvements (#584)","text":"<ul> <li>Variable stacking: 2-3x faster NetCDF I/O for large systems by grouping variables with same dimensions</li> <li>Fast DataArray construction: Bypasses slow xarray internals (~15x faster per variable)</li> <li>Version tracking: Datasets now include <code>flixopt_version</code> attribute for compatibility checking</li> </ul> <pre><code># Version is automatically stored\nds = flow_system.to_dataset()\nprint(ds.attrs['flixopt_version'])  # e.g., '6.0.0'\n</code></pre>"},{"location":"changelog/#plotly-accessor-548","title":"Plotly Accessor (#548)","text":"<p>New global xarray accessors for universal plotting with automatic faceting and smart dimension handling. Works on any xarray Dataset, not just flixopt results.</p> <pre><code>import flixopt as fx  # Registers accessors automatically\n\n# Plot any xarray Dataset with automatic faceting\ndataset.plotly.bar(x='component')\ndataset.plotly.area(x='time')\ndataset.plotly.imshow(x='time', y='component')\ndataset.plotly.line(x='time', facet_col='scenario')\n\n# DataArray support\ndata_array.plotly.line()\n\n# Statistics transformations\ndataset.fxstats.to_duration_curve()\n</code></pre> <p>Available Plot Methods:</p> Method Description <code>.plotly.bar()</code> Bar charts (use <code>barmode='group'</code> or <code>'relative'</code> for stacked) <code>.plotly.line()</code> Line charts with faceting <code>.plotly.area()</code> Stacked area charts <code>.plotly.imshow()</code> Heatmap visualizations <code>.plotly.scatter()</code> Scatter plots <code>.plotly.pie()</code> Pie charts with faceting <code>.fxstats.to_duration_curve()</code> Transform to duration curve format <p>Key Features:</p> <ul> <li>Auto-faceting: Automatically assigns extra dimensions (period, scenario, cluster) to <code>facet_col</code>, <code>facet_row</code>, or <code>animation_frame</code></li> <li>Smart x-axis: Intelligently selects x dimension based on priority (time &gt; duration &gt; period &gt; scenario)</li> <li>Universal: Works on any xarray Dataset/DataArray, not limited to flixopt</li> <li>Configurable: Customize via <code>CONFIG.Plotting</code> (colorscales, facet columns, line shapes)</li> </ul>"},{"location":"changelog/#flowsystem-comparison-550","title":"FlowSystem Comparison (#550)","text":"<p>New <code>Comparison</code> class for comparing multiple FlowSystems side-by-side:</p> <pre><code># Compare systems (uses FlowSystem.name by default)\ncomp = fx.Comparison([fs_base, fs_modified])\n\n# Or with custom names\ncomp = fx.Comparison([fs1, fs2, fs3], names=['baseline', 'low_cost', 'high_eff'])\n\n# Side-by-side plots (auto-facets by 'case' dimension)\ncomp.statistics.plot.balance('Heat')\ncomp.statistics.flow_rates.plotly.line()\n\n# Access combined data with 'case' dimension\ncomp.solution  # xr.Dataset\ncomp.statistics.flow_rates  # xr.Dataset\n\n# Compute differences relative to a reference case\ncomp.diff()  # vs first case\ncomp.diff('baseline')  # vs named case\n</code></pre> <ul> <li>Concatenates solutions and statistics from multiple FlowSystems with a <code>'case'</code> dimension</li> <li>Mirrors all <code>StatisticsAccessor</code> properties (<code>flow_rates</code>, <code>flow_hours</code>, <code>sizes</code>, <code>charge_states</code>, <code>temporal_effects</code>, <code>periodic_effects</code>, <code>total_effects</code>)</li> <li>Mirrors all <code>StatisticsPlotAccessor</code> methods (<code>balance</code>, <code>carrier_balance</code>, <code>flows</code>, <code>sizes</code>, <code>duration_curve</code>, <code>effects</code>, <code>charge_states</code>, <code>heatmap</code>, <code>storage</code>)</li> <li>Existing plotting infrastructure automatically handles faceting by <code>'case'</code></li> </ul>"},{"location":"changelog/#component-color-parameter-585","title":"Component Color Parameter (#585)","text":"<p>All component classes now accept a <code>color</code> parameter for visualization customization:</p> <pre><code># Set color at instantiation\nboiler = fx.Boiler('Boiler', ..., color='#D35400')\nstorage = fx.Storage('Battery', ..., color='green')\n\n# Bulk assignment via topology accessor\nflow_system.topology.set_component_colors({'Boiler': 'red', 'CHP': 'blue'})\nflow_system.topology.set_component_colors({'Oranges': ['Solar1', 'Solar2']})  # Colorscale\nflow_system.topology.set_component_colors('turbo', overwrite=False)  # Only unset colors\n</code></pre>"},{"location":"changelog/#flowcontainer-for-component-flows-587","title":"FlowContainer for Component Flows (#587)","text":"<p><code>Component.inputs</code>, <code>Component.outputs</code>, and <code>Component.flows</code> now use <code>FlowContainer</code> (dict-like) with dual access by index or label: <code>inputs[0]</code> or <code>inputs['Q_th']</code>.</p>"},{"location":"changelog/#breaking-changes","title":"\ud83d\udca5 Breaking Changes","text":""},{"location":"changelog/#tsam-v3-migration","title":"tsam v3 Migration","text":"<p>The clustering API now uses tsam v3's configuration objects instead of individual parameters:</p> <pre><code># Old API (v5.x with tsam 2.x)\nfs.transform.cluster(\n    n_clusters=8,\n    cluster_method='hierarchical',\n    time_series_for_high_peaks=['demand'],\n)\n\n# New API (v6.x with tsam 3.x)\nfrom tsam import ClusterConfig, ExtremeConfig\n\nfs.transform.cluster(\n    n_clusters=8,\n    cluster=ClusterConfig(method='hierarchical'),\n    extremes=ExtremeConfig(method='new_cluster', max_value=['demand']),\n)\n</code></pre> <p>Parameter mapping:</p> Old Parameter New Parameter <code>cluster_method</code> <code>cluster=ClusterConfig(method=...)</code> <code>representation_method</code> <code>cluster=ClusterConfig(representation=...)</code> <code>time_series_for_high_peaks</code> <code>extremes=ExtremeConfig(max_value=[...])</code> <code>time_series_for_low_peaks</code> <code>extremes=ExtremeConfig(min_value=[...])</code> <code>extreme_period_method</code> <code>extremes=ExtremeConfig(method=...)</code> <code>predef_cluster_order</code> <code>predef_cluster_assignments</code>"},{"location":"changelog/#other-breaking-changes","title":"Other Breaking Changes","text":"<ul> <li><code>FlowSystem.scenario_weights</code> are now always normalized to sum to 1 when set (including after <code>.sel()</code> subsetting)</li> <li><code>Component.inputs</code>/<code>outputs</code> and <code>Bus.inputs</code>/<code>outputs</code> are now <code>FlowContainer</code> (dict-like). Use <code>.values()</code> to iterate flows.</li> </ul>"},{"location":"changelog/#changed","title":"\u267b\ufe0f Changed","text":"<ul> <li><code>FlowSystem.weights</code> returns <code>dict[str, xr.DataArray]</code> (unit weights instead of <code>1.0</code> float fallback)</li> <li><code>FlowSystemDimensions</code> type now includes <code>'cluster'</code></li> <li><code>statistics.plot.balance()</code>, <code>carrier_balance()</code>, and <code>storage()</code> now use <code>xarray_plotly.fast_bar()</code> internally (styled stacked areas for better performance)</li> </ul>"},{"location":"changelog/#deprecated","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<p>The following items are deprecated and will be removed in v7.0.0:</p> <p>Classes (use FlowSystem methods instead):</p> <ul> <li><code>Optimization</code> class \u2192 Use <code>flow_system.optimize(solver)</code></li> <li><code>SegmentedOptimization</code> class \u2192 Use <code>flow_system.optimize.rolling_horizon()</code></li> <li><code>Results</code> class \u2192 Use <code>flow_system.solution</code> and <code>flow_system.statistics</code></li> <li><code>SegmentedResults</code> class \u2192 Use segment FlowSystems directly</li> </ul> <p>FlowSystem methods (use <code>transform</code> or <code>topology</code> accessor instead):</p> <ul> <li><code>flow_system.sel()</code> \u2192 Use <code>flow_system.transform.sel()</code></li> <li><code>flow_system.isel()</code> \u2192 Use <code>flow_system.transform.isel()</code></li> <li><code>flow_system.resample()</code> \u2192 Use <code>flow_system.transform.resample()</code></li> <li><code>flow_system.plot_network()</code> \u2192 Use <code>flow_system.topology.plot()</code></li> <li><code>flow_system.start_network_app()</code> \u2192 Use <code>flow_system.topology.start_app()</code></li> <li><code>flow_system.stop_network_app()</code> \u2192 Use <code>flow_system.topology.stop_app()</code></li> <li><code>flow_system.network_infos()</code> \u2192 Use <code>flow_system.topology.infos()</code></li> </ul> <p>Parameters:</p> <ul> <li><code>normalize_weights</code> parameter in <code>create_model()</code>, <code>build_model()</code>, <code>optimize()</code></li> </ul> <p>Topology method name simplifications (old names still work with deprecation warnings, removal in v7.0.0):</p> Old (v5.x) New (v6.0.0) <code>topology.plot_network()</code> <code>topology.plot()</code> <code>topology.start_network_app()</code> <code>topology.start_app()</code> <code>topology.stop_network_app()</code> <code>topology.stop_app()</code> <code>topology.network_infos()</code> <code>topology.infos()</code> <p>Note: <code>topology.plot()</code> now renders a Sankey diagram. The old PyVis visualization is available via <code>topology.plot_legacy()</code>.</p>"},{"location":"changelog/#removed","title":"\ud83d\udd25 Removed","text":"<p>Clustering classes removed (deprecated in v5.0.0):</p> <ul> <li><code>ClusteredOptimization</code> class - Use <code>flow_system.transform.cluster()</code> then <code>optimize()</code></li> <li><code>ClusteringParameters</code> class - Parameters are now passed directly to <code>transform.cluster()</code></li> <li><code>flixopt/clustering.py</code> module - Restructured to <code>flixopt/clustering/</code> package with new classes</li> </ul>"},{"location":"changelog/#migration-from-clusteredoptimization","title":"Migration from ClusteredOptimization","text":"v5.x (Old - No longer works)v6.0.0 (New) <pre><code>from flixopt import ClusteredOptimization, ClusteringParameters\n\nparams = ClusteringParameters(hours_per_period=24, nr_of_periods=8)\ncalc = ClusteredOptimization('model', flow_system, params)\ncalc.do_modeling_and_solve(solver)\nresults = calc.results\n</code></pre> <pre><code># Cluster using transform accessor\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=8,           # was: nr_of_periods\n    cluster_duration='1D',  # was: hours_per_period=24\n)\nfs_clustered.optimize(solver)\n\n# Results on the clustered FlowSystem\ncosts = fs_clustered.solution['costs'].item()\n\n# Expand back to full resolution if needed\nfs_expanded = fs_clustered.transform.expand()\n</code></pre>"},{"location":"changelog/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li><code>temporal_weight</code> and <code>sum_temporal()</code> now use consistent implementation</li> <li><code>FlowSystem.from_old_results()</code> now sets <code>previous_flow_rate=0</code> for flows of components with <code>status_parameters</code>, fixing startup cost calculation mismatch when re-optimizing migrated v4 results</li> </ul>"},{"location":"changelog/#docs","title":"\ud83d\udcdd Docs","text":"<p>New Documentation Pages:</p> <ul> <li>Time-Series Clustering Guide - Comprehensive guide to clustering workflows</li> <li>Cluster architecture design documentation (<code>docs/design/cluster_architecture.md</code>)</li> </ul> <p>New Jupyter Notebooks (#542):</p> <ul> <li>08c-clustering.ipynb - Introduction to time-series clustering</li> <li>08c2-clustering-storage-modes.ipynb - Comparison of all 4 storage cluster modes</li> <li>08d-clustering-multiperiod.ipynb - Clustering with periods and scenarios</li> <li>08e-clustering-internals.ipynb - Understanding clustering internals</li> </ul> <p>Improved Tutorials:</p> <ul> <li>Added <code>tutorial_data.py</code> helper module for cleaner notebook examples</li> <li>Updated all existing notebooks to use new clustering and plotting APIs</li> </ul>"},{"location":"changelog/#development","title":"\ud83d\udc77 Development","text":"<p>CI Improvements (#551):</p> <ul> <li>Speedup notebook execution in documentation builds</li> </ul> <p>New Test Suites for Clustering:</p> <ul> <li><code>TestStorageClusterModes</code>: Tests for all 4 storage <code>cluster_mode</code> options</li> <li><code>TestInterclusterStorageLinking</code>: Tests for <code>SOC_boundary</code> variable and expansion logic</li> <li><code>TestMultiPeriodClustering</code>: Tests for clustering with periods and scenarios dimensions</li> <li><code>TestPeakSelection</code>: Tests for <code>time_series_for_high_peaks</code> and <code>time_series_for_low_peaks</code> parameters</li> </ul> <p>New Test Suites for Other Features:</p> <ul> <li><code>test_clustering_io.py</code> - Tests for clustering serialization roundtrip</li> <li><code>test_sel_isel_single_selection.py</code> - Tests for transform selection methods</li> </ul>"},{"location":"changelog/#v5.0.4","title":"v5.0.4 5<sup>th</sup> January 2026","text":"<p>Summary: Dependency updates.</p>"},{"location":"changelog/#fixed_1","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed netcdf dependency</li> </ul>"},{"location":"changelog/#dependencies","title":"\ud83d\udce6 Dependencies","text":"<ul> <li>tsam: Updated from <code>&gt;= 2.3.1, &lt; 3</code> to <code>&gt;= 3.0.0, &lt; 4</code> (#584)</li> <li>Updated <code>mkdocs-material</code> to v9.7.1</li> <li>Updated <code>mkdocstrings-python</code> to v1.19.0</li> <li>Updated <code>ruff</code> to v0.14.10</li> <li>Updated <code>pymdown-extensions</code> to v10.19.1</li> <li>Updated <code>werkzeug</code> to v3.1.4</li> </ul>"},{"location":"changelog/#development_1","title":"\ud83d\udc77 Development","text":"<ul> <li>Updated <code>actions/checkout</code> action to v6</li> </ul>"},{"location":"changelog/#v5.0.3","title":"v5.0.3 18<sup>th</sup> December 2025","text":"<p>Summary: Cleaner notebook outputs and improved <code>CONFIG.notebook()</code> preset.</p>"},{"location":"changelog/#changed_1","title":"\u267b\ufe0f Changed","text":"<ul> <li><code>CONFIG.notebook()</code> now suppresses linopy progress bars via <code>progress=False</code> in solve calls</li> <li>Downgraded \"FlowSystem not connected\" message from WARNING to INFO (auto-connects anyway)</li> </ul>"},{"location":"changelog/#fixed_2","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed notebooks triggering unnecessary warnings (removed <code>relative_minimum</code> without <code>status_parameters</code>)</li> </ul>"},{"location":"changelog/#docs_1","title":"\ud83d\udcdd Docs","text":"<ul> <li>Consolidated verbose print statements into concise single-line summaries across all tutorial notebooks</li> <li>Added output suppression (<code>;</code>) to <code>optimize()</code> calls for cleaner cell output</li> <li>Fixed notebook 07 parameters so CHP investment produces interesting results (was 0 kW, now 100 kW)</li> </ul>"},{"location":"changelog/#v5.0.2","title":"v5.0.2 17<sup>th</sup> December 2025","text":""},{"location":"changelog/#changed_2","title":"\u267b\ufe0f Changed","text":"<ul> <li><code>statistics.plot.effects()</code> now defaults to <code>by=None</code> for aggregated totals; use <code>by='component'</code> for the previous behavior</li> </ul>"},{"location":"changelog/#v5.0.1","title":"v5.0.1 17<sup>th</sup> December 2025","text":""},{"location":"changelog/#development_2","title":"\ud83d\udc77 Development","text":"<ul> <li>Fixed docs deployment in CI workflow</li> </ul>"},{"location":"changelog/#v5.0.0","title":"v5.0.0 16<sup>th</sup> December 2025","text":"<p>Summary: This is a major release that introduces the new FlowSystem-centric API, dramatically simplifying workflows by integrating optimization, results access, and visualization directly into the FlowSystem object. This release also completes the terminology standardization (OnOff \u2192 Status) and deprecates the old Optimization/Results workflow (to be removed in v6.0.0).</p> <p>Migration Guide</p> <p>See the Migration Guide v5 for step-by-step upgrade instructions.</p>"},{"location":"changelog/#added_1","title":"\u2728 Added","text":"<p>FlowSystem-Centric Architecture: The FlowSystem is now the central hub for all operations:</p> <pre><code>import flixopt as fx\n\n# Create and configure your system\nflow_system = fx.FlowSystem(timesteps)\nflow_system.add_elements(boiler, heat_bus, costs)\n\n# Optimize directly on FlowSystem\nflow_system.optimize(fx.solvers.HighsSolver())\n\n# Access results via solution Dataset\ntotal_costs = flow_system.solution['costs'].item()\nflow_rate = flow_system.solution['Boiler(Q_th)|flow_rate'].values\n\n# Plot with new accessor API\nflow_system.statistics.plot.balance('HeatBus')\nflow_system.statistics.plot.sankey.flows()\n</code></pre> <p>New Accessor-Based API: Four accessor patterns provide organized, discoverable interfaces:</p> Accessor Purpose Example <code>flow_system.statistics</code> Data access (flow rates, sizes, effects) <code>flow_system.statistics.flow_rates</code> <code>flow_system.statistics.plot</code> Visualization methods <code>flow_system.statistics.plot.balance('Bus')</code> <code>flow_system.transform</code> FlowSystem transformations <code>flow_system.transform.cluster(params)</code> <code>flow_system.topology</code> Network structure &amp; visualization <code>flow_system.topology.plot_network()</code> <p>Statistics Accessor: Access aggregated results data with clean, consistent naming:</p> <pre><code>stats = flow_system.statistics\n\n# Flow data (clean labels, no |flow_rate suffix needed)\nstats.flow_rates['Boiler(Q_th)']\nstats.flow_hours['Boiler(Q_th)']\nstats.sizes['Boiler(Q_th)']\nstats.charge_states['Battery']\n\n# Effect breakdown by contributor\nstats.temporal_effects['costs']   # Per timestep, per contributor\nstats.periodic_effects['costs']   # Investment costs per contributor\nstats.total_effects['costs']      # Total per contributor\n</code></pre> <p>Comprehensive Plotting API: All plots return <code>PlotResult</code> objects with chainable methods:</p> <pre><code># Balance plots for buses and components\nflow_system.statistics.plot.balance('ElectricityBus')\nflow_system.statistics.plot.balance('Boiler', mode='area')\n\n# Storage visualization with charge state\nflow_system.statistics.plot.storage('Battery')\n\n# Heatmaps with automatic time reshaping\nflow_system.statistics.plot.heatmap('Boiler(Q_th)|flow_rate', reshape=('D', 'h'))\n\n# Flow-based Sankey diagrams\nflow_system.statistics.plot.sankey.flows()\nflow_system.statistics.plot.sankey.flows(select={'bus': 'ElectricityBus'})\n\n# Effect contribution Sankey\nflow_system.statistics.plot.sankey.effects('costs')\n\n# Method chaining for customization and export\nflow_system.statistics.plot.balance('Bus') \\\n    .update(title='Custom Title', height=600) \\\n    .to_html('plot.html') \\\n    .to_csv('data.csv') \\\n    .show()\n</code></pre> <p>Carrier Management: New <code>Carrier</code> class for consistent styling across visualizations:</p> <pre><code># Define custom carriers\nelectricity = fx.Carrier('electricity', '#FFD700', 'kW', 'Electrical power')\ndistrict_heat = fx.Carrier('district_heat', '#FF6B6B', 'kW_th')\n\n# Register with FlowSystem\nflow_system.add_carrier(electricity)\n\n# Use with buses (reference by name)\nelec_bus = fx.Bus('MainGrid', carrier='electricity')\n\n# Or use predefined carriers from CONFIG\nfx.CONFIG.Carriers.electricity\nfx.CONFIG.Carriers.heat\n</code></pre> <p>Transform Accessor: Transformations that create new FlowSystem instances:</p> <pre><code># Time selection and resampling\nfs_subset = flow_system.transform.sel(time=slice('2023-01-01', '2023-06-30'))\nfs_resampled = flow_system.transform.resample(time='4h', method='mean')\n\n# Clustered optimization\nparams = fx.ClusteringParameters(hours_per_period=24, nr_of_periods=8)\nclustered_fs = flow_system.transform.cluster(params)\nclustered_fs.optimize(solver)\n</code></pre> <p>Rolling Horizon Optimization: Decompose large operational problems into sequential segments:</p> <pre><code># Solve with rolling horizon\nsegments = flow_system.optimize.rolling_horizon(\n    solver,\n    horizon=192,    # Timesteps per segment\n    overlap=48,     # Lookahead for storage optimization\n)\n\n# Combined solution available on original FlowSystem\ntotal_cost = flow_system.solution['costs'].item()\n\n# Individual segments also available\nfor seg in segments:\n    print(seg.solution['costs'].item())\n</code></pre> <p>Solution Persistence: FlowSystem now stores and persists solutions:</p> <pre><code># Optimize and save with solution\nflow_system.optimize(solver)\nflow_system.to_netcdf('results/my_model.nc4')\n\n# Load FlowSystem with solution intact\nloaded_fs = fx.FlowSystem.from_netcdf('results/my_model.nc4')\nprint(loaded_fs.solution['costs'].item())  # Solution is available!\n</code></pre> <p>Migration Helper for Old Results (deprecated, temporary):</p> <pre><code># Migrate old result files to new FlowSystem format\nfs = fx.FlowSystem.from_old_results('results_folder', 'my_model')\n# Or convert Results object directly\nfs = results.convert_to_flow_system()\n</code></pre> <p>FlowSystem Locking: FlowSystem automatically locks after optimization to prevent accidental modifications:</p> <pre><code>flow_system.optimize(solver)\n\n# This would raise an error:\n# flow_system.add_elements(new_component)  # Locked!\n\n# Call reset() to unlock for modifications\nflow_system.reset()\nflow_system.add_elements(new_component)  # Now works\n</code></pre> <p>NetCDF Improvements: - Default compression level 5 for smaller files - <code>overwrite=False</code> parameter to prevent accidental overwrites - Solution data included in FlowSystem NetCDF files - Automatic name assignment from filename</p> <p>PlotResult Class: All plotting methods return a <code>PlotResult</code> object containing both: - <code>data</code>: An xarray Dataset with the prepared data - <code>figure</code>: A Plotly Figure object</p> <p>Component color parameter: Components now accept a <code>color</code> parameter for consistent visualization styling.</p>"},{"location":"changelog/#breaking-changes_1","title":"\ud83d\udca5 Breaking Changes","text":"<p>Renamed <code>OnOffParameters</code> \u2192 <code>StatusParameters</code>: Complete terminology update to align with industry standards (PyPSA, unit commitment). Old NetCDF files with <code>OnOffParameters</code> are automatically converted on load.</p> Old Term New Term <code>OnOffParameters</code> <code>StatusParameters</code> <code>on_off_parameters</code> <code>status_parameters</code> <code>on</code> variable <code>status</code> <code>switch_on</code> <code>startup</code> <code>switch_off</code> <code>shutdown</code> <code>switch_on_nr</code> <code>startup_count</code> <code>on_hours_total</code> <code>active_hours</code> <code>consecutive_on_hours</code> <code>uptime</code> <code>consecutive_off_hours</code> <code>downtime</code> <code>effects_per_switch_on</code> <code>effects_per_startup</code> <code>effects_per_running_hour</code> <code>effects_per_active_hour</code> <code>consecutive_on_hours_min</code> <code>min_uptime</code> <code>consecutive_on_hours_max</code> <code>max_uptime</code> <code>consecutive_off_hours_min</code> <code>min_downtime</code> <code>consecutive_off_hours_max</code> <code>max_downtime</code> <code>switch_on_total_max</code> <code>startup_limit</code> <code>force_switch_on</code> <code>force_startup_tracking</code> <code>on_hours_min</code> <code>active_hours_min</code> <code>on_hours_max</code> <code>active_hours_max</code> <p>Bus imbalance terminology and default changed: - <code>excess_penalty_per_flow_hour</code> \u2192 <code>imbalance_penalty_per_flow_hour</code> - Default changed from <code>1e5</code> to <code>None</code> (strict balance) - <code>with_excess</code> \u2192 <code>allows_imbalance</code> - <code>excess_input</code> \u2192 <code>virtual_supply</code> - <code>excess_output</code> \u2192 <code>virtual_demand</code></p> <p>Storage charge_state changes: - <code>charge_state</code> no longer has an extra timestep - Final charge state is now a separate variable: <code>charge_state|final</code></p> <p>Effect.description now defaults to <code>''</code> (empty string) instead of <code>None</code>.</p> <p>Stricter I/O: NetCDF loading is stricter to prevent silent errors. Missing or corrupted data now raises explicit errors.</p> <p>Validation: Component with <code>status_parameters</code> now validates that all flows have sizes (required for big-M constraints).</p>"},{"location":"changelog/#changed_3","title":"\u267b\ufe0f Changed","text":"<ul> <li>Renamed <code>BusModel.excess_input</code> \u2192 <code>virtual_supply</code> and <code>BusModel.excess_output</code> \u2192 <code>virtual_demand</code> for clearer semantics</li> <li>Renamed <code>Bus.excess_penalty_per_flow_hour</code> \u2192 <code>imbalance_penalty_per_flow_hour</code></li> <li>Renamed <code>Bus.with_excess</code> \u2192 <code>allows_imbalance</code></li> </ul>"},{"location":"changelog/#deprecated_1","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<p>All deprecated items will be removed in v6.0.0.</p> <p>Old Optimization Workflow - Use FlowSystem methods instead:</p> <pre><code># Old (deprecated, still works with warning)\noptimization = fx.Optimization('model', flow_system)\noptimization.do_modeling()\noptimization.solve(solver)\nresults = optimization.results\ncosts = results.model['costs'].solution.item()\n\n# New (recommended)\nflow_system.optimize(solver)\ncosts = flow_system.solution['costs'].item()\n</code></pre> <p>Classes deprecated: - <code>Optimization</code> \u2192 Use <code>flow_system.optimize(solver)</code> - <code>ClusteredOptimization</code> \u2192 Use <code>flow_system.transform.cluster()</code> then <code>optimize()</code> - <code>SegmentedOptimization</code> \u2192 Use <code>flow_system.optimize.rolling_horizon()</code> - <code>Results</code> \u2192 Use <code>flow_system.solution</code> and <code>flow_system.statistics</code> - <code>SegmentedResults</code> \u2192 Use segment FlowSystems directly</p> <p>FlowSystem methods deprecated: - <code>flow_system.sel()</code> \u2192 Use <code>flow_system.transform.sel()</code> - <code>flow_system.isel()</code> \u2192 Use <code>flow_system.transform.isel()</code> - <code>flow_system.resample()</code> \u2192 Use <code>flow_system.transform.resample()</code> - <code>flow_system.plot_network()</code> \u2192 Use <code>flow_system.topology.plot_network()</code> - <code>flow_system.start_network_app()</code> \u2192 Use <code>flow_system.topology.start_network_app()</code> - <code>flow_system.stop_network_app()</code> \u2192 Use <code>flow_system.topology.stop_network_app()</code> - <code>flow_system.network_infos()</code> \u2192 Use <code>flow_system.topology.network_infos()</code></p> <p>Results methods deprecated: - <code>results.flow_rates()</code> \u2192 Use <code>flow_system.statistics.flow_rates</code> - <code>results.flow_hours()</code> \u2192 Use <code>flow_system.statistics.flow_hours</code></p> <p>Migration helpers (temporary, also deprecated): - <code>FlowSystem.from_old_results()</code> \u2192 For migrating old result files - <code>Results.convert_to_flow_system()</code> \u2192 For converting Results objects</p> <p>Plotting parameters deprecated: - <code>indexer</code> parameter \u2192 Use <code>select</code> instead - <code>heatmap_timeframes</code> parameter \u2192 Use <code>reshape_time=(timeframes, timesteps_per_frame)</code> instead - <code>heatmap_timesteps_per_frame</code> parameter \u2192 Use <code>reshape_time=(timeframes, timesteps_per_frame)</code> instead - <code>color_map</code> parameter \u2192 Use <code>colors</code> instead</p>"},{"location":"changelog/#removed_1","title":"\ud83d\udd25 Removed","text":"<p>Python version changes: - Dropped Python 3.10 support - Added Python 3.14 support</p> <p>Classes removed (already renamed/deprecated in v4.x): - <code>OnOffParameters</code> \u2192 Use <code>StatusParameters</code> - <code>Calculation</code> \u2192 Use <code>Optimization</code> (deprecated) or <code>flow_system.optimize()</code> (recommended) - <code>FullCalculation</code> \u2192 Use <code>Optimization</code> (deprecated) or <code>flow_system.optimize()</code> (recommended) - <code>AggregatedCalculation</code> \u2192 Use <code>ClusteredOptimization</code> (deprecated) or <code>flow_system.transform.cluster()</code> (recommended) - <code>SegmentedCalculation</code> \u2192 Use <code>SegmentedOptimization</code> (deprecated) or <code>flow_system.optimize.rolling_horizon()</code> (recommended) - <code>Aggregation</code> \u2192 Use <code>Clustering</code> - <code>AggregationParameters</code> \u2192 Use <code>ClusteringParameters</code> - <code>AggregationModel</code> \u2192 Use <code>ClusteringModel</code> - <code>CalculationResults</code> \u2192 Use <code>Results</code> (deprecated) or <code>flow_system.solution</code> (recommended) - <code>SegmentedCalculationResults</code> \u2192 Use <code>SegmentedResults</code> (deprecated)</p> <p>Modules removed: - <code>calculation.py</code> module \u2192 Use <code>optimization.py</code> (deprecated) or FlowSystem methods (recommended)</p> <p>Functions removed: - <code>change_logging_level()</code> \u2192 Use <code>CONFIG.Logging.enable_console()</code></p> <p>Properties removed: - <code>FlowSystem.all_elements</code> \u2192 Use dict-like interface (<code>flow_system['label']</code>, <code>.keys()</code>, <code>.values()</code>, <code>.items()</code>) - <code>FlowSystem.weights</code> \u2192 Use <code>scenario_weights</code></p>"},{"location":"changelog/#docs_2","title":"\ud83d\udcdd Docs","text":"<p>Comprehensive Tutorial Notebooks - 12 new Jupyter notebooks covering all major use cases:</p> <ol> <li>01-Quickstart - Minimal working example</li> <li>02-Heat System - District heating with storage</li> <li>03-Investment Optimization - Optimal equipment sizing</li> <li>04-Operational Constraints - Startup costs, uptime/downtime</li> <li>05-Multi-Carrier System - CHP producing electricity and heat</li> <li>06a-Time-Varying Parameters - Temperature-dependent COP</li> <li>06b-Piecewise Conversion - Load-dependent efficiency</li> <li>06c-Piecewise Effects - Economies of scale</li> <li>07-Scenarios and Periods - Multi-year planning</li> <li>08-Large-Scale Optimization - Resampling and two-stage</li> <li>09-Plotting and Data Access - Visualization guide</li> <li>10-Transmission - Connecting sites with pipelines/cables</li> </ol> <p>New Documentation Pages: - Migration Guide v5 - Step-by-step upgrade instructions - Results &amp; Plotting Guide - Comprehensive plotting documentation - Building Models Guide - Component selection and modeling patterns - FAQ - Common questions and answers - Troubleshooting - Problem diagnosis and solutions</p>"},{"location":"changelog/#development_3","title":"\ud83d\udc77 Development","text":"<p>New Test Suites: - <code>test_flow_system_locking.py</code> - FlowSystem locking behavior - <code>test_solution_and_plotting.py</code> - Statistics accessor and plotting - <code>test_solution_persistence.py</code> - Solution save/load - <code>test_io_conversion.py</code> - Old file format conversion - <code>test_topology_accessor.py</code> - Network visualization</p> <p>CI Improvements: - Separate docs build and deploy workflow - Improved test organization with deprecated tests in separate folder</p>"},{"location":"changelog/#migration-checklist","title":"Migration Checklist","text":"<p>The old <code>Optimization</code>/<code>Results</code> workflow still works with deprecation warnings. Migrate at your own pace before v6.0.0.</p> Task Action Update <code>OnOffParameters</code> Rename to <code>StatusParameters</code> with new parameter names (breaking) Update <code>on_off_parameters</code> Rename to <code>status_parameters</code> (breaking) Update Bus excess parameters Use <code>imbalance_penalty_per_flow_hour</code> (breaking) Replace <code>Optimization</code> class Use <code>flow_system.optimize(solver)</code> (deprecated) Replace <code>SegmentedOptimization</code> Use <code>flow_system.optimize.rolling_horizon(solver, ...)</code> (deprecated) Replace <code>Results</code> access Use <code>flow_system.solution['var_name']</code> (deprecated) Update transform methods Use <code>flow_system.transform.sel/isel/resample()</code> (deprecated) Update I/O code Use <code>to_netcdf()</code> / <code>from_netcdf()</code> on FlowSystem Migrate old result files Use <code>FlowSystem.from_old_results(folder, name)</code> (temporary helper)"},{"location":"changelog/#v4.3.5","title":"v4.3.5 29<sup>th</sup> November 2025","text":"<p>Summary: Fix zenodo again</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#v4.3.4","title":"v4.3.4 27<sup>th</sup> November 2025","text":"<p>Summary: Fix zenodo again</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#v4.3.3","title":"v4.3.3 27<sup>th</sup> November 2025","text":"<p>Summary: Fix zenodo again</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#v4.3.2","title":"v4.3.2 27<sup>th</sup> November 2025","text":"<p>Summary: Fix zenodo</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#v4.3.1","title":"v4.3.1 26<sup>th</sup> November 2025","text":"<p>Summary: Add zenodo for better citations and archiving.</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#docs_3","title":"\ud83d\udcdd Docs","text":"<ul> <li>Added Zenodo DOI badge to README.md (placeholder, to be updated after first Zenodo release)</li> </ul>"},{"location":"changelog/#development_4","title":"\ud83d\udc77 Development","text":"<ul> <li>Added Zenodo integration for automatic archival and citation</li> <li>Created <code>.zenodo.json</code> file for Zenodo metadata configuration</li> <li>Repository now ready for DOI assignment upon next release</li> </ul>"},{"location":"changelog/#v4.3.0","title":"v4.3.0 25<sup>th</sup> November 2025","text":"<p>Summary: Penalty is now a first-class Effect - add penalty contributions anywhere (e.g., <code>effects_per_flow_hour={'Penalty': 2.5}</code>) and optionally define bounds as with any other effect.</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#added_2","title":"\u2728 Added","text":"<ul> <li>Penalty as first-class Effect: Users can now add Penalty contributions anywhere effects are used:   <pre><code>fx.Flow('Q', 'Bus', effects_per_flow_hour={'Penalty': 2.5})\nfx.InvestParameters(..., effects_of_investment={'Penalty': 100})\n</code></pre></li> <li>User-definable Penalty: Optionally define custom Penalty with constraints (auto-created if not defined):   <pre><code>penalty = fx.Effect(fx.PENALTY_EFFECT_LABEL, unit='\u20ac', maximum_total=1e6)\nflow_system.add_elements(penalty)\n</code></pre></li> </ul>"},{"location":"changelog/#changed_4","title":"\u267b\ufe0f Changed","text":"<ul> <li>Penalty is now a standard Effect with temporal/periodic dimensions, and periodic weights in the objective</li> <li>Results structure: Penalty now has same structure as other effects in solution Dataset</li> <li>Use <code>results.solution['Penalty']</code> for total penalty value (same as before, but now it's an effect variable)</li> <li>Access components via <code>results.solution['Penalty(temporal)']</code> and <code>results.solution['Penalty(periodic)']</code> if needed</li> </ul>"},{"location":"changelog/#docs_4","title":"\ud83d\udcdd Docs","text":"<ul> <li>Updated mathematical notation for Penalty as Effect</li> </ul>"},{"location":"changelog/#development_5","title":"\ud83d\udc77 Development","text":"<ul> <li>Unified interface: Penalty uses same <code>add_share_to_effects()</code> as other effects (internal only)</li> </ul>"},{"location":"changelog/#v4.2.0","title":"v4.2.0 25<sup>th</sup> November 2025","text":"<p>Summary: Renamed classes and parameters related to <code>Calculation</code>, <code>Aggregation</code> and <code>Results</code>. Fully backwards compatible</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#added_3","title":"\u2728 Added","text":"<ul> <li><code>overwrite</code> parameter when saving results to file. If True, overwrite existing files.</li> </ul>"},{"location":"changelog/#changed_5","title":"\u267b\ufe0f Changed","text":"<ul> <li>Now creates the Results folder even if parents didnt exist</li> </ul>"},{"location":"changelog/#deprecated_2","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<p>Class and module renaming: - <code>FullCalculation</code> \u2192 <code>Optimization</code> - <code>AggregatedCalculation</code> \u2192 <code>ClusteredOptimization</code> - <code>SegmentedCalculation</code> \u2192 <code>SegmentedOptimization</code> - <code>CalculationResults</code> \u2192 <code>Results</code> - <code>SegmentedCalculationResults</code> \u2192 <code>SegmentedResults</code> - <code>Aggregation</code> \u2192 <code>Clustering</code> - <code>AggregationParameters</code> \u2192 <code>ClusteringParameters</code> - <code>AggregationModel</code> \u2192 <code>ClusteringModel</code> - Module: <code>calculation.py</code> \u2192 <code>optimization.py</code> - Module: <code>aggregation.py</code> \u2192 <code>clustering.py</code></p> <p>Old names remain available with deprecation warnings (removed in v5.0.0).</p>"},{"location":"changelog/#fixed_3","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed <code>fix_sizes()</code> docstring/implementation inconsistency for optional <code>ds</code> parameter</li> </ul>"},{"location":"changelog/#development_6","title":"\ud83d\udc77 Development","text":"<ul> <li>Fixed <code>active_timesteps</code> type annotation to include <code>None</code></li> <li>Fixed xarray truth-value ambiguity in <code>main_results</code> buses with excess filter</li> <li>Added validation for <code>nr_of_previous_values</code> in <code>SegmentedOptimization</code> to prevent silent indexing bugs</li> </ul>"},{"location":"changelog/#v4.1.4","title":"v4.1.4 25<sup>th</sup> November 2025","text":"<p>Summary: Added file logging encoding to prevent issues</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#fixed_4","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Issues with windows file system when logging to file due to non ASCII characters</li> </ul>"},{"location":"changelog/#v4.1.3","title":"v4.1.3 25<sup>th</sup> November 2025","text":"<p>Summary: Re-add mistakenly removed method for loading a config from file</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#fixed_5","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Re-added <code>CONFIG.load_from_file()</code> method that was accidentally removed</li> </ul>"},{"location":"changelog/#v4.1.2","title":"v4.1.2 24<sup>th</sup> November 2025","text":"<p>Summary:</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#added_4","title":"\u2728 Added","text":"<ul> <li>Exported SUCCESS log level (<code>SUCCESS_LEVEL</code>) for use with <code>logger.log(SUCCESS_LEVEL, ...)</code></li> <li>Added proper deprecation tests</li> </ul>"},{"location":"changelog/#changed_6","title":"\u267b\ufe0f Changed","text":"<ul> <li>logger coloring improved</li> </ul>"},{"location":"changelog/#development_7","title":"\ud83d\udc77 Development","text":"<ul> <li>Fixed Deprecation warnings in tests</li> </ul>"},{"location":"changelog/#v4.1.1","title":"v4.1.1 23<sup>rd</sup> November 2025","text":"<p>Summary: Finalize preparations for removal of all deprecated parameters in v5.0.0</p>"},{"location":"changelog/#added_5","title":"\u2728 Added","text":"<ul> <li>Added missing infos about removal to remaining deprecated parameters and methods</li> </ul>"},{"location":"changelog/#fixed_6","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Missing release notes of v4.1.0</li> </ul>"},{"location":"changelog/#v4.1.0","title":"v4.1.0 21<sup>st</sup> November 2025","text":"<p>Summary: Logging migrated from loguru to standard Python logging for stability and security. Simpler API with convenient presets.</p> <p>Migration Required?</p> <p>Most users: No action needed (silent by default). Methods like <code>CONFIG.exploring()</code>, <code>CONFIG.debug()</code>, etc. continue to work exactly as before. If you customized logging: Simple API update (see migration below). If you used loguru directly: Breaking change (loguru only in v3.6.0-v4.0.0, ~4 days).</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#added_6","title":"\u2728 Added","text":"<p>New logging presets: <pre><code>CONFIG.production('app.log')    # File-only, no console/plots\n</code></pre></p> <p>New logging methods: - <code>CONFIG.Logging.enable_console(level, colored, stream)</code> - Console output with colors - <code>CONFIG.Logging.enable_file(level, path, max_bytes, backup_count)</code> - File logging with rotation - <code>CONFIG.Logging.disable()</code> - Disable all logging - <code>CONFIG.Logging.set_colors(log_colors)</code> - Customize colors</p> <p>Enhanced formatting: - Multi-line messages with box borders (\u250c\u2500, \u2502, \u2514\u2500) - Exception tracebacks with proper indentation - Timestamps: <code>2025-11-21 14:30:45.123</code></p>"},{"location":"changelog/#breaking-changes_2","title":"\ud83d\udca5 Breaking Changes","text":"<p>Logging migration (edge cases only):</p> Old (v3.6.0-v4.0.0) New (v4.1.0+) <code>CONFIG.Logging.level = 'INFO'</code><code>CONFIG.Logging.console = True</code><code>CONFIG.apply()</code> <code>CONFIG.Logging.enable_console('INFO')</code>or <code>CONFIG.exploring()</code> <code>CONFIG.Logging.file = 'app.log'</code> <code>CONFIG.Logging.enable_file('INFO', 'app.log')</code> <code>logger.opt(lazy=True)</code> Built-in (automatic) <p>Migration: <pre><code># Before (v3.6.0-v4.0.0)\nCONFIG.Logging.level = 'INFO'\nCONFIG.Logging.console = True\nCONFIG.apply()\n\n# After (v4.1.0+)\nCONFIG.Logging.enable_console('INFO')  # or CONFIG.exploring()\n</code></pre></p>"},{"location":"changelog/#changed_7","title":"\u267b\ufe0f Changed","text":"<ul> <li>Replaced loguru with Python <code>logging</code> + optional <code>colorlog</code> for colors</li> <li>Configuration immediate (no <code>CONFIG.apply()</code> needed)</li> <li>Log format: <code>[dimmed timestamp] [colored level] \u2502 message</code></li> <li>Logs to <code>stdout</code> by default (configurable)</li> <li>SUCCESS level preserved (green, level 25)</li> <li>Performance: Expensive operations guarded with <code>logger.isEnabledFor()</code> checks</li> </ul>"},{"location":"changelog/#deprecated_3","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<ul> <li><code>change_logging_level(level)</code> \u2192 Use <code>CONFIG.Logging.enable_console(level)</code>. Removal in v5.0.0.</li> </ul>"},{"location":"changelog/#removed_2","title":"\ud83d\udd25 Removed","text":"<p>CONFIG methods/attributes: - <code>CONFIG.apply()</code> \u2192 Use helper methods directly - <code>CONFIG.Logging.level</code>, <code>.console</code>, <code>.file</code> \u2192 Use <code>enable_console()</code>/<code>enable_file()</code> - <code>CONFIG.Logging.verbose_tracebacks</code>, <code>.rich</code>, <code>.Colors</code>, <code>.date_format</code>, <code>.format</code>, <code>.console_width</code>, <code>.show_path</code>, <code>.show_logger_name</code> \u2192 Use standard logging - loguru features (<code>logger.opt()</code>, etc.)</p>"},{"location":"changelog/#fixed_7","title":"\ud83d\udc1b Fixed","text":"<ul> <li><code>TypeError</code> in <code>check_bounds()</code> with loguru-style formatting</li> <li>Exception tracebacks not appearing in custom formatters</li> <li>Inconsistent formatting between console and file logs</li> </ul>"},{"location":"changelog/#security","title":"\ud83d\udd12 Security","text":"<ul> <li>Removed loguru dependency for reduced supply chain risk</li> </ul>"},{"location":"changelog/#dependencies_1","title":"\ud83d\udce6 Dependencies","text":"<ul> <li>Removed: <code>loguru &gt;= 0.7.0</code></li> <li>Added: <code>colorlog &gt;= 6.8.0, &lt; 7</code> (optional)</li> </ul>"},{"location":"changelog/#docs_5","title":"\ud83d\udcdd Docs","text":"<ul> <li>Preset comparison table in <code>CONFIG.Logging</code> docstring</li> <li>Color customization examples</li> <li>Migration guide with before/after code</li> </ul>"},{"location":"changelog/#v4.0.0","title":"v4.0.0 19<sup>th</sup> November 2025","text":"<p>Summary: This release introduces clearer parameter naming for linear converters and constraints, enhanced period handling with automatic weight computation, and new sum-over-all-periods constraints for multi-period optimization. All deprecated parameter names continue to work with warnings.</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#key-features_1","title":"\u2728 Key Features","text":"<p>Sum-over-all-periods constraints: New constraint parameters enable limiting weighted totals across all periods: - <code>Effect</code>: <code>minimum_over_periods</code> and <code>maximum_over_periods</code> - <code>Flow</code>: <code>flow_hours_max_over_periods</code> and <code>flow_hours_min_over_periods</code></p> <pre><code># Per-period: limits apply to EACH period individually\neffect = fx.Effect('costs', maximum_total=1000)  # \u22641000 per period\n\n# Over-periods: limits apply to WEIGHTED SUM across ALL periods\n# With periods=[2020, 2030, 2040] (weights: [10, 10, 10] from 10-year intervals)\neffect = fx.Effect('costs', maximum_over_periods=25000)  # 10\u00d7costs\u2082\u2080\u2082\u2080 + 10\u00d7costs\u2082\u2080\u2083\u2080 + 10\u00d7costs\u2082\u2080\u2084\u2080 \u2264 25000\n</code></pre> <p>Improved period weight handling: - Period weights now computed automatically from period index (like <code>hours_per_timestep</code> for time) - Weights correctly recalculate when using <code>.sel()</code> or <code>.isel()</code> on periods - Separate tracking of <code>period_weights</code>, <code>scenario_weights</code>, and combined <code>weights</code></p> <p>Simplified workflow: - <code>Calculation.solve()</code> now automatically calls <code>do_modeling()</code> if needed</p>"},{"location":"changelog/#breaking-changes_3","title":"\ud83d\udca5 Breaking Changes","text":"<p>FlowSystem weights parameter renamed: <pre><code># Old (v3.x)\nfs = FlowSystem(..., weights=np.array([0.3, 0.5, 0.2]))\n\n# New (v4.0)\nfs = FlowSystem(..., scenario_weights=np.array([0.3, 0.5, 0.2]))\n</code></pre> Period weights are now always computed from the period index.</p> <p>Note: If you were previously passing period \u00d7 scenario weights to <code>weights</code>, you now need to:   1. Pass only scenario weights to <code>scenario_weights</code>   2. Period weights will be computed automatically from your <code>periods</code> index</p>"},{"location":"changelog/#deprecated-parameters","title":"\ud83d\uddd1\ufe0f Deprecated Parameters","text":"<p>Linear converters (<code>Boiler</code>, <code>CHP</code>, <code>HeatPump</code>, etc.) - descriptive names replace abbreviations: - Flow: <code>Q_fu</code> \u2192 <code>fuel_flow</code>, <code>P_el</code> \u2192 <code>electrical_flow</code>, <code>Q_th</code> \u2192 <code>thermal_flow</code>, <code>Q_ab</code> \u2192 <code>heat_source_flow</code> - Efficiency: <code>eta</code> \u2192 <code>thermal_efficiency</code>, <code>eta_th</code> \u2192 <code>thermal_efficiency</code>, <code>eta_el</code> \u2192 <code>electrical_efficiency</code>, <code>COP</code> \u2192 <code>cop</code> (lowercase)</p> <p>Constraint parameters - removed redundant <code>_total</code> suffix: - <code>Flow</code>: <code>flow_hours_total_max</code> \u2192 <code>flow_hours_max</code>, <code>flow_hours_total_min</code> \u2192 <code>flow_hours_min</code> - <code>OnOffParameters</code>: <code>on_hours_total_max</code> \u2192 <code>on_hours_max</code>, <code>on_hours_total_min</code> \u2192 <code>on_hours_min</code>, <code>switch_on_total_max</code> \u2192 <code>switch_on_max</code></p> <p>Storage: - <code>initial_charge_state=\"lastValueOfSim\"</code> \u2192 <code>initial_charge_state=\"equals_final\"</code></p> <p>All deprecated names continue working with warnings. They will be removed in v5.0.0.</p> <p>Additional property deprecations now include removal version: - <code>InvestParameters</code>: <code>fix_effects</code>, <code>specific_effects</code>, <code>divest_effects</code>, <code>piecewise_effects</code> - <code>OnOffParameters</code>: <code>on_hours_total_min</code>, <code>on_hours_total_max</code>, <code>switch_on_total_max</code> - <code>Flow</code>: <code>flow_hours_total_min</code>, <code>flow_hours_total_max</code></p>"},{"location":"changelog/#fixed_8","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed inconsistent boundary checks in linear converters with array-like inputs</li> </ul>"},{"location":"changelog/#development_8","title":"\ud83d\udc77 Development","text":"<ul> <li>Eliminated circular dependencies with two-phase modeling pattern</li> <li>Enhanced validation for cross-element references and FlowSystem assignment</li> <li>Added helper methods for cleaner data transformation code</li> <li>Improved logging and cache invalidation</li> <li>Improved argument consistency in internal effect coordinate fitting</li> </ul>"},{"location":"changelog/#v3.6.1","title":"v3.6.1 17<sup>th</sup> November 2025","text":"<p>Summary: Documentation improvements and dependency updates.</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#dependencies_2","title":"\ud83d\udce6 Dependencies","text":"<ul> <li>Updated <code>astral-sh/uv</code> to v0.9.8</li> <li>Updated <code>mkdocs-git-revision-date-localized-plugin</code> to v1.5.0</li> </ul>"},{"location":"changelog/#docs_6","title":"\ud83d\udcdd Docs","text":"<ul> <li>Improved type specifications in <code>flixopt/types.py</code> for better documentation generation</li> <li>Fixed minor mkdocs warnings in <code>flixopt/io.py</code> and <code>mkdocs.yml</code></li> </ul>"},{"location":"changelog/#v3.6.0","title":"v3.6.0 15<sup>th</sup> November 2025","text":"<p>Summary: Type system overhaul and migration to loguru for logging. If you are heavily using our logs, this might be breaking!</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#added_7","title":"\u2728 Added","text":"<ul> <li>New type system (<code>flixopt/types.py</code>):<ul> <li>Introduced dimension-aware type aliases using suffix notation (<code>_TPS</code>, <code>_PS</code>, <code>_S</code>) to clearly indicate which dimensions data can have</li> <li>Added <code>Numeric_TPS</code>, <code>Numeric_PS</code>, <code>Numeric_S</code> for numeric data with Time/Period/Scenario dimensions</li> <li>Added <code>Bool_TPS</code>, <code>Bool_PS</code>, <code>Bool_S</code> for boolean data with dimension support</li> <li>Added <code>Effect_TPS</code>, <code>Effect_PS</code>, <code>Effect_S</code> for effect dictionaries with dimension support</li> <li>Added <code>Scalar</code> type for scalar-only numeric values</li> <li>Added <code>NumericOrBool</code> utility type for internal use</li> <li>Type system supports scalars, numpy arrays, pandas Series/DataFrames, and xarray DataArrays</li> </ul> </li> <li>Lazy logging evaluation - expensive log operations only execute when log level is active</li> <li><code>CONFIG.Logging.verbose_tracebacks</code> option for detailed debugging with variable values</li> </ul>"},{"location":"changelog/#breaking-changes_4","title":"\ud83d\udca5 Breaking Changes","text":"<ul> <li>Logging framework: Migrated to loguru<ul> <li>Removed <code>CONFIG.Logging</code> parameters: <code>rich</code>, <code>Colors</code>, <code>date_format</code>, <code>format</code>, <code>console_width</code>, <code>show_path</code>, <code>show_logger_name</code></li> <li>For advanced formatting, use loguru's API directly after <code>CONFIG.apply()</code></li> </ul> </li> </ul>"},{"location":"changelog/#changed_8","title":"\u267b\ufe0f Changed","text":"<ul> <li>Code structure: Removed <code>commons.py</code> module and moved all imports directly to <code>__init__.py</code> for cleaner code organization (no public API changes)</li> <li>Type handling improvements: Updated internal data handling to work seamlessly with the new type system</li> </ul>"},{"location":"changelog/#fixed_9","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed <code>ShareAllocationModel</code> inconsistency where None/inf conversion happened in <code>__init__</code> instead of during modeling, which could cause issues with parameter validation</li> <li>Fixed numerous type hint inconsistencies across the codebase</li> </ul>"},{"location":"changelog/#dependencies_3","title":"\ud83d\udce6 Dependencies","text":"<ul> <li>Updated <code>mkdocs-material</code> to v9.6.23</li> <li>Replaced <code>rich &gt;= 13.0.0</code> with <code>loguru &gt;= 0.7.0</code> for logging</li> </ul>"},{"location":"changelog/#docs_7","title":"\ud83d\udcdd Docs","text":"<ul> <li>Enhanced documentation in <code>flixopt/types.py</code> with comprehensive examples and dimension explanation table</li> <li>Clarified Effect type docstrings - Effect types are dicts, but single numeric values work through union types</li> <li>Added clarifying comments in <code>effects.py</code> explaining parameter handling and transformation</li> <li>Improved OnOffParameters attribute documentation</li> <li>Updated getting-started guide with loguru examples</li> <li>Updated <code>config.py</code> docstrings for loguru integration</li> </ul>"},{"location":"changelog/#development_9","title":"\ud83d\udc77 Development","text":"<ul> <li>Added test for FlowSystem resampling</li> </ul>"},{"location":"changelog/#v3.5.0","title":"v3.5.0 6<sup>th</sup> November 2025","text":"<p>Summary: Improve representations and improve resampling</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#added_8","title":"\u2728 Added","text":"<ul> <li>Added options to resample and select subsets of flowsystems without converting to and from Dataset each time. Use the new methods <code>FlowSystem.__dataset_resample()</code>, <code>FlowSystem.__dataset_sel()</code> and <code>FlowSystem.__dataset_isel()</code>. All of them expect and return a dataset.</li> </ul>"},{"location":"changelog/#breaking-changes_5","title":"\ud83d\udca5 Breaking Changes","text":""},{"location":"changelog/#changed_9","title":"\u267b\ufe0f Changed","text":"<ul> <li>Truncate repr of FlowSystem and CalculationResults to only show the first 10 items of each category</li> <li>Greatly sped up the resampling of a FlowSystem again</li> </ul>"},{"location":"changelog/#v3.4.1","title":"v3.4.1 4<sup>th</sup> November 2025","text":"<p>Summary: Speed up resampling by 20-40 times.</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#changed_10","title":"\u267b\ufe0f Changed","text":"<ul> <li>Greatly sped up the resampling of a FlowSystem (x20 - x40) by converting to dataarray internally</li> </ul>"},{"location":"changelog/#v3.4.0","title":"v3.4.0 1<sup>st</sup> November 2025","text":"<p>Summary: Enhanced solver configuration with new CONFIG.Solving section for centralized solver parameter management.</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#added_9","title":"\u2728 Added","text":"<p>Solver configuration: - New <code>CONFIG.Solving</code> configuration section for centralized solver parameter management:     - <code>mip_gap</code>: Default MIP gap tolerance for solver convergence (default: 0.01)     - <code>time_limit_seconds</code>: Default time limit in seconds for solver runs (default: 300)     - <code>log_to_console</code>: Whether solver should output to console (default: True)     - <code>log_main_results</code>: Whether to log main results after solving (default: True) - Solvers (<code>HighsSolver</code>, <code>GurobiSolver</code>) now use <code>CONFIG.Solving</code> defaults for parameters, allowing global configuration - Solver parameters can still be explicitly overridden when creating solver instances - New <code>log_to_console</code> parameter in all Solver classes</p>"},{"location":"changelog/#changed_11","title":"\u267b\ufe0f Changed","text":"<ul> <li>Individual solver output is now hidden in SegmentedCalculation. To return to the prior behaviour, set <code>show_individual_solves=True</code> in <code>do_modeling_and_solve()</code>.</li> </ul>"},{"location":"changelog/#fixed_10","title":"\ud83d\udc1b Fixed","text":"<ul> <li>New compacted list representation for periods and scenarios also in results log and console print</li> </ul>"},{"location":"changelog/#docs_8","title":"\ud83d\udcdd Docs","text":"<ul> <li>Unified contributing guides in docs and on github</li> </ul>"},{"location":"changelog/#development_10","title":"\ud83d\udc77 Development","text":"<ul> <li>Added type hints for submodel in all Interface classes</li> </ul>"},{"location":"changelog/#v3.3.1","title":"v3.3.1 30<sup>th</sup> October 2025","text":"<p>Summary: Small Bugfix and improving readability</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#changed_12","title":"\u267b\ufe0f Changed","text":"<ul> <li>Improved <code>summary.yaml</code> to use a compacted list representation for periods and scenarios</li> </ul>"},{"location":"changelog/#fixed_11","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Using <code>switch_on_total_max</code> with periods or scenarios failed</li> </ul>"},{"location":"changelog/#docs_9","title":"\ud83d\udcdd Docs","text":"<ul> <li>Add more comprehensive <code>CONTRIBUTE.md</code></li> <li>Improve logical structure in User Guide</li> </ul>"},{"location":"changelog/#v3.3.0","title":"v3.3.0 30<sup>th</sup> October 2025","text":"<p>Summary: Better access to Elements stored in the FLowSystem and better representations (repr)</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#changed_13","title":"\u267b\ufe0f Changed","text":"<p>Improved repr methods: - Results classes (<code>ComponentResults</code>, <code>BusResults</code>, <code>FlowResults</code>, <code>EffectResults</code>) now show concise header with key metadata followed by xarray Dataset repr - Element classes (<code>Component</code>, <code>Bus</code>, <code>Flow</code>, <code>Effect</code>, <code>Storage</code>) now show one-line summaries with essential information (connections, sizes, capacities, constraints)</p> <p>Container-based access: - FlowSystem now provides dict-like access patterns for all elements - Use <code>flow_system['element_label']</code>, <code>flow_system.keys()</code>, <code>flow_system.values()</code>, and <code>flow_system.items()</code> for unified element access - Specialized containers (<code>components</code>, <code>buses</code>, <code>effects</code>, <code>flows</code>) offer type-specific access with helpful error messages</p>"},{"location":"changelog/#deprecated_4","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<ul> <li><code>FlowSystem.all_elements</code> property is deprecated in favor of dict-like interface (<code>flow_system['label']</code>, <code>.keys()</code>, <code>.values()</code>, <code>.items()</code>). Will be removed in v4.0.0.</li> </ul>"},{"location":"changelog/#v3.2.1","title":"v3.2.1 29<sup>th</sup> October 2025","text":"<p>Summary:</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#fixed_12","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed resampling of FlowSystem to reset <code>hours_of_last_timestep</code> and <code>hours_of_previous_timesteps</code> properly</li> </ul>"},{"location":"changelog/#development_11","title":"\ud83d\udc77 Development","text":"<ul> <li>Improved issue templates</li> </ul>"},{"location":"changelog/#v3.2.0","title":"v3.2.0 26<sup>th</sup> October 2025","text":"<p>Summary: Enhanced plotting capabilities with consistent color management, custom plotting kwargs support, and centralized I/O handling.</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#added_10","title":"\u2728 Added","text":"<p>Color management: - <code>setup_colors()</code> method for <code>CalculationResults</code> and <code>SegmentedCalculationResults</code> to configure consistent colors across all plots     - Group components by colorscales: <code>results.setup_colors({'CHP': 'reds', 'Storage': 'blues', 'Greys': ['Grid', 'Demand']})</code>     - Automatically propagates to all segments in segmented calculations     - Colors persist across all plot calls unless explicitly overridden - Flexible color inputs: Supports colorscale names (e.g., 'turbo', 'plasma'), color lists, or label-to-color dictionaries - Cross-backend compatibility: Seamless color handling for both Plotly and Matplotlib</p> <p>Plotting customization: - Plotting kwargs support: Pass additional arguments to plotting backends via <code>px_kwargs</code>, <code>plot_kwargs</code>, and <code>backend_kwargs</code> parameters - New <code>CONFIG.Plotting</code> configuration section:     - <code>default_show</code>: Control default plot visibility     - <code>default_engine</code>: Choose 'plotly' or 'matplotlib'     - <code>default_dpi</code>: Set resolution for saved plots     - <code>default_facet_cols</code>: Configure default faceting columns     - <code>default_sequential_colorscale</code>: Default for heatmaps (now 'turbo')     - <code>default_qualitative_colorscale</code>: Default for categorical plots (now 'plotly')</p> <p>I/O improvements: - Centralized JSON/YAML I/O with auto-format detection - Enhanced NetCDF handling with consistent engine usage - Better numeric formatting in YAML exports</p>"},{"location":"changelog/#changed_14","title":"\u267b\ufe0f Changed","text":"<ul> <li>Default colorscale: Changed from 'viridis' to 'turbo' for better perceptual uniformity</li> <li>Color terminology: Standardized from \"colormap\" to \"colorscale\" throughout for Plotly consistency</li> <li>Plotting internals: Now use <code>xr.Dataset</code> as primary data type (DataFrames automatically converted)</li> <li>NetCDF engine: Switched back to netcdf4 engine following xarray updates and performance benchmarks</li> </ul>"},{"location":"changelog/#removed_3","title":"\ud83d\udd25 Removed","text":"<ul> <li>Removed unused <code>plotting.pie_with_plotly()</code> method</li> </ul>"},{"location":"changelog/#fixed_13","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Improved error messages when using <code>engine='matplotlib'</code> with multidimensional data</li> <li>Better dimension validation in <code>results.plot_heatmap()</code></li> </ul>"},{"location":"changelog/#docs_10","title":"\ud83d\udcdd Docs","text":"<ul> <li>Enhanced examples demonstrating <code>setup_colors()</code> usage</li> <li>Updated terminology from \"colormap\" to \"colorscale\" in docstrings</li> </ul>"},{"location":"changelog/#development_12","title":"\ud83d\udc77 Development","text":"<ul> <li>Fixed concurrency issue in CI</li> <li>Centralized color processing logic into dedicated module</li> <li>Refactored to function-based color handling for simpler API</li> </ul>"},{"location":"changelog/#v3.1.1","title":"v3.1.1 20<sup>th</sup> October 2025","text":"<p>Summary: Fixed a bug when accessing the <code>effects_per_component</code> dataset in results without periodic effects.</p> <p>If upgrading from v2.x, see the v3.0.0 release notes and Migration Guide.</p>"},{"location":"changelog/#fixed_14","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed ValueError in effects_per_component when all periodic effects are scalars/NaN by explicitly creating mode-specific templates (via _create_template_for_mode) with correct dimensions</li> </ul>"},{"location":"changelog/#development_13","title":"\ud83d\udc77 Development","text":"<ul> <li>Converted all remaining numpy style docstrings to google style</li> </ul>"},{"location":"changelog/#v3.1.0","title":"v3.1.0 19<sup>th</sup> October 2025","text":"<p>Summary: This release adds faceting and animation support for multidimensional plots and redesigns the documentation website. Plotting results across scenarios or periods is now significantly simpler (Plotly only).</p> <p>If upgrading from v2.x, see the Migration Guide and v3.0.0 release notes.</p>"},{"location":"changelog/#added_11","title":"\u2728 Added","text":"<ul> <li>Faceting and animation for multidimensional plots: All plotting methods now support <code>facet_by</code> and <code>animate_by</code> parameters to create subplot grids and animations from multidimensional data (scenarios, periods, etc.). Plotly only.</li> <li>Flexible data selection with <code>select</code> parameter: Select data using single values, lists, slices, or index arrays for precise control over what gets plotted</li> <li>Heatmap fill control: New <code>fill</code> parameter in heatmap methods controls how missing values are filled after reshaping (<code>'ffill'</code> or <code>'bfill'</code>)</li> <li>Smart line styling for mixed variables: Area plots now automatically style variables containing both positive and negative values with dashed lines, while stacking purely positive or negative variables</li> </ul>"},{"location":"changelog/#changed_15","title":"\u267b\ufe0f Changed","text":"<ul> <li>Breaking: Selection behavior: Plotting methods no longer automatically select the first value for non-time dimensions. Use the <code>select</code> parameter for explicit selection of scenarios, periods, or other dimensions</li> <li>Better error messages: Enhanced error messages when using Matplotlib with multidimensional data, with clearer guidance on dimension requirements and suggestions to use Plotly</li> <li>Improved examples: Enhanced <code>scenario_example.py</code> with better demonstration of new features</li> <li>Robust validation: Improved dimension validation in <code>plot_heatmap()</code> with clearer error messages</li> </ul>"},{"location":"changelog/#deprecated_5","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<ul> <li><code>indexer</code> parameter: Use the new <code>select</code> parameter instead. The <code>indexer</code> parameter will be removed in v4.0.0</li> <li><code>heatmap_timeframes</code> and <code>heatmap_timesteps_per_frame</code> parameters: Use the new <code>reshape_time=(timeframes, timesteps_per_frame)</code> parameter instead in heatmap plotting methods</li> <li><code>color_map</code> parameter: Use the new <code>colors</code> parameter instead in heatmap plotting methods</li> </ul>"},{"location":"changelog/#fixed_15","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed cryptic errors when working with empty buses by adding proper validation</li> <li>Added early validation for non-existent periods when using linked periods with tuples</li> </ul>"},{"location":"changelog/#documentation","title":"\ud83d\udcdd Documentation","text":"<ul> <li>Redesigned documentation website with custom css</li> </ul>"},{"location":"changelog/#development_14","title":"\ud83d\udc77 Development","text":"<ul> <li>Renamed internal <code>_apply_indexer_to_data()</code> to <code>_apply_selection_to_data()</code> for consistency with new API naming</li> </ul>"},{"location":"changelog/#v3.0.3","title":"v3.0.3 16<sup>th</sup> October 2025","text":"<p>Summary: Hotfixing new plotting parameter <code>style</code>. Continue to use <code>mode</code>.</p> <p>Note: If upgrading from v2.x, see the Migration Guide and v3.0.0 release notes.</p>"},{"location":"changelog/#fixed_16","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Reverted breaking change from v3.0.0: continue to use <code>mode parameter in plotting instead of new</code>style`</li> <li>Renamed new <code>mode</code> parameter in plotting methods to <code>unit_type</code></li> </ul>"},{"location":"changelog/#docs_11","title":"\ud83d\udcdd Docs","text":"<ul> <li>Updated Migration Guide and added missing entries.</li> <li>Improved Changelog of v3.0.0</li> </ul>"},{"location":"changelog/#v3.0.2","title":"v3.0.2 15<sup>th</sup> October 2025","text":"<p>Summary: This is a follow-up release to v3.0.0, improving the documentation.</p> <p>Note: If upgrading from v2.x, see the Migration Guide and v3.0.0 release notes.</p>"},{"location":"changelog/#docs_12","title":"\ud83d\udcdd Docs","text":"<ul> <li>Update the Readme</li> <li>Add a project roadmap to the docs</li> <li>Change Development status to \"Production/Stable\"</li> <li>Regroup parts in docs</li> </ul>"},{"location":"changelog/#v3.0.1","title":"v3.0.1 14<sup>th</sup> October 2025","text":"<p>Summary: This is a follow-up release to v3.0.0, adding a Migration Guide and bugfixing the docs.</p> <p>Note: If upgrading from v2.x, see the Migration Guide and v3.0.0 release notes.</p>"},{"location":"changelog/#docs_13","title":"\ud83d\udcdd Docs","text":"<ul> <li>Fixed deployed docs</li> <li>Added Migration Guide for flixopt 3</li> </ul>"},{"location":"changelog/#development_15","title":"\ud83d\udc77 Development","text":"<ul> <li>Added missing type hints</li> </ul>"},{"location":"changelog/#v3.0.0","title":"v3.0.0 13<sup>th</sup> October 2025","text":"<p>Summary: This release introduces new model dimensions (periods and scenarios) for multi-period investments and stochastic modeling, along with a redesigned effect sharing system and enhanced I/O capabilities.</p> <p>Note: If upgrading from v2.x, see the Migration Guide and v3.0.0 release notes.</p>"},{"location":"changelog/#added_12","title":"\u2728 Added","text":"<p>New model dimensions:</p> <ul> <li>Period dimension: Enables multi-period investment modeling with distinct decisions in each period for transformation pathway optimization</li> <li>Scenario dimension: Supports stochastic modeling with weighted scenarios for robust decision-making under uncertainty (demand, prices, weather)<ul> <li>Control variable independence across scenarios via <code>scenario_independent_sizes</code> and <code>scenario_independent_flow_rates</code> parameters</li> <li>By default, investment sizes are shared across scenarios while flow rates vary per scenario</li> </ul> </li> </ul> <p>Redesigned effect sharing system:</p> <p>Effects now use intuitive <code>share_from_*</code> syntax that clearly shows contribution sources:</p> <pre><code>costs = fx.Effect('costs', '\u20ac', 'Total costs',\n    share_from_temporal={'CO2': 0.2},      # From temporal effects\n    share_from_periodic={'land': 100})     # From periodic effects\n</code></pre> <p>This replaces <code>specific_share_to_other_effects_*</code> parameters and inverts the direction for clearer relationships.</p> <p>Enhanced I/O and data handling:</p> <ul> <li>NetCDF/JSON serialization for all Interface objects and FlowSystem with round-trip support</li> <li>FlowSystem manipulation: <code>sel()</code>, <code>isel()</code>, <code>resample()</code>, <code>copy()</code>, <code>__eq__()</code> methods</li> <li>Direct access to FlowSystem from results without manual restoring (lazily loaded)</li> <li>New <code>FlowResults</code> class and precomputed DataArrays for sizes/flow_rates/flow_hours</li> <li><code>effects_per_component</code> dataset for component impact evaluation, including all indirect effects through effect shares</li> </ul> <p>Other additions:</p> <ul> <li>Balanced storage - charging and discharging sizes can be forced equal via <code>balanced</code> parameter</li> <li>New Storage parameters: <code>relative_minimum_final_charge_state</code> and <code>relative_maximum_final_charge_state</code> for final state control</li> <li>Improved filter methods in results</li> <li>Example for 2-stage investment decisions leveraging FlowSystem resampling</li> </ul>"},{"location":"changelog/#breaking-changes_6","title":"\ud83d\udca5 Breaking Changes","text":"<p>API and Behavior Changes:</p> <ul> <li>Effect system redesigned (no deprecation):<ul> <li>Terminology changes: Effect domains renamed for clarity: <code>operation</code> \u2192 <code>temporal</code>, <code>invest</code>/<code>investment</code> \u2192 <code>periodic</code></li> <li>Sharing system: The old <code>specific_share_to_other_effects_*</code> parameters were completely replaced with the new <code>share_from_temporal</code> and <code>share_from_periodic</code> syntax (see \ud83d\udd25 Removed section)</li> </ul> </li> <li>FlowSystem independence: FlowSystems cannot be shared across multiple Calculations anymore. A copy of the FlowSystem is created instead, making every Calculation independent. Each Subcalculation in <code>SegmentedCalculation</code> now has its own distinct <code>FlowSystem</code> object</li> <li>Bus and Effect object assignment: Direct assignment of Bus/Effect objects is no longer supported. Use labels (strings) instead:<ul> <li><code>Flow.bus</code> must receive a string label, not a Bus object</li> <li>Effect shares must use effect labels (strings) in dictionaries, not Effect objects</li> </ul> </li> <li>Logging defaults (from v2.2.0): Console and file logging are now disabled by default. Enable explicitly with <code>CONFIG.Logging.console = True</code> and <code>CONFIG.apply()</code></li> </ul> <p>Class and Method Renaming:</p> <ul> <li>Renamed class <code>SystemModel</code> to <code>FlowSystemModel</code></li> <li>Renamed class <code>Model</code> to <code>Submodel</code></li> <li>Renamed <code>mode</code> parameter in plotting methods to <code>style</code></li> <li><code>Calculation.do_modeling()</code> now returns the <code>Calculation</code> object instead of its <code>linopy.Model</code>. Callers that previously accessed the linopy model directly should now use <code>calculation.do_modeling().model</code> instead of <code>calculation.do_modeling()</code></li> </ul> <p>Variable Renaming in Results:</p> <ul> <li>Investment binary variable: <code>is_invested</code> \u2192 <code>invested</code> in <code>InvestmentModel</code></li> <li>Switch tracking variables in <code>OnOffModel</code>:<ul> <li><code>switch_on</code> \u2192 <code>switch|on</code></li> <li><code>switch_off</code> \u2192 <code>switch|off</code></li> <li><code>switch_on_nr</code> \u2192 <code>switch|count</code></li> </ul> </li> <li>Effect submodel variables (following terminology changes):<ul> <li><code>Effect(invest)|total</code> \u2192 <code>Effect(periodic)</code></li> <li><code>Effect(operation)|total</code> \u2192 <code>Effect(temporal)</code></li> <li><code>Effect(operation)|total_per_timestep</code> \u2192 <code>Effect(temporal)|per_timestep</code></li> <li><code>Effect|total</code> \u2192 <code>Effect</code></li> </ul> </li> </ul> <p>Data Structure Changes:</p> <ul> <li><code>relative_minimum_charge_state</code> and <code>relative_maximum_charge_state</code> don't have an extra timestep anymore. Use the new <code>relative_minimum_final_charge_state</code> and <code>relative_maximum_final_charge_state</code> parameters for final state control</li> </ul>"},{"location":"changelog/#changed_16","title":"\u267b\ufe0f Changed","text":"<ul> <li>Type system overhaul - added clear separation between temporal and non-temporal data throughout codebase for better clarity</li> <li>Enhanced FlowSystem interface with improved <code>__repr__()</code> and <code>__str__()</code> methods</li> <li>Improved Model Structure - Views and organisation is now divided into:<ul> <li>Model: The main Model (linopy.Model) that is used to create and store the variables and constraints for the FlowSystem.</li> <li>Submodel: The base class for all submodels. Each is a subset of the Model, for simpler access and clearer code.</li> </ul> </li> <li>Made docstrings in <code>config.py</code> more compact and easier to read</li> <li>Improved format handling in configuration module</li> <li>Enhanced console output to support both <code>stdout</code> and <code>stderr</code> stream selection</li> <li>Added <code>show_logger_name</code> parameter to <code>CONFIG.Logging</code> for displaying logger names in messages</li> </ul>"},{"location":"changelog/#deprecated_6","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<ul> <li>The <code>agg_group</code> and <code>agg_weight</code> parameters of <code>TimeSeriesData</code> are deprecated and will be removed in a future version. Use <code>aggregation_group</code> and <code>aggregation_weight</code> instead.</li> <li>The <code>active_timesteps</code> parameter of <code>Calculation</code> is deprecated and will be removed in a future version. Use the new <code>sel(time=...)</code> method on the FlowSystem instead.</li> <li>InvestParameters parameters renamed for improved clarity around investment and retirement effects:<ul> <li><code>fix_effects</code> \u2192 <code>effects_of_investment</code></li> <li><code>specific_effects</code> \u2192 <code>effects_of_investment_per_size</code></li> <li><code>divest_effects</code> \u2192 <code>effects_of_retirement</code></li> <li><code>piecewise_effects</code> \u2192 <code>piecewise_effects_of_investment</code></li> </ul> </li> <li>Effect parameters renamed:<ul> <li><code>minimum_investment</code> \u2192 <code>minimum_periodic</code></li> <li><code>maximum_investment</code> \u2192 <code>maximum_periodic</code></li> <li><code>minimum_operation</code> \u2192 <code>minimum_temporal</code></li> <li><code>maximum_operation</code> \u2192 <code>maximum_temporal</code></li> <li><code>minimum_operation_per_hour</code> \u2192 <code>minimum_per_hour</code></li> <li><code>maximum_operation_per_hour</code> \u2192 <code>maximum_per_hour</code></li> </ul> </li> <li>Component parameters renamed:<ul> <li><code>Source.source</code> \u2192 <code>Source.outputs</code></li> <li><code>Sink.sink</code> \u2192 <code>Sink.inputs</code></li> <li><code>SourceAndSink.source</code> \u2192 <code>SourceAndSink.outputs</code></li> <li><code>SourceAndSink.sink</code> \u2192 <code>SourceAndSink.inputs</code></li> <li><code>SourceAndSink.prevent_simultaneous_sink_and_source</code> \u2192 <code>SourceAndSink.prevent_simultaneous_flow_rates</code></li> </ul> </li> </ul>"},{"location":"changelog/#removed_4","title":"\ud83d\udd25 Removed","text":"<ul> <li>Effect share parameters: The old <code>specific_share_to_other_effects_*</code> parameters were replaced WITHOUT DEPRECATION<ul> <li><code>specific_share_to_other_effects_operation</code> \u2192 <code>share_from_temporal</code> (with inverted direction)</li> <li><code>specific_share_to_other_effects_invest</code> \u2192 <code>share_from_periodic</code> (with inverted direction)</li> </ul> </li> </ul>"},{"location":"changelog/#fixed_17","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Enhanced NetCDF I/O with proper attribute preservation for DataArrays</li> <li>Improved error handling and validation in serialization processes</li> <li>Better type consistency across all framework components</li> <li>Added extra validation in <code>config.py</code> to improve error handling</li> </ul>"},{"location":"changelog/#docs_14","title":"\ud83d\udcdd Docs","text":"<ul> <li>Reorganized mathematical notation docs: moved to lowercase <code>mathematical-notation/</code> with subdirectories (<code>elements/</code>, <code>features/</code>, <code>modeling-patterns/</code>)</li> <li>Added comprehensive documentation pages: <code>dimensions.md</code> (time/period/scenario), <code>effects-penalty-objective.md</code>, modeling patterns</li> <li>Enhanced all element pages with implementation details, cross-references, and \"See Also\" sections</li> <li>Rewrote README and landing page with clearer vision, roadmap, and universal applicability emphasis</li> <li>Removed deprecated <code>docs/SUMMARY.md</code>, updated <code>mkdocs.yml</code> for new structure</li> <li>Tightened docstrings in core modules with better cross-referencing</li> <li>Added recipes section to docs</li> </ul>"},{"location":"changelog/#known-issues","title":"\ud83d\udea7 Known Issues","text":"<ul> <li>IO for single Interfaces/Elements to Datasets might not work properly if the Interface/Element is not part of a fully transformed and connected FlowSystem. This arises from Numeric Data not being stored as xr.DataArray by the user. To avoid this, always use the <code>to_dataset()</code> on Elements inside a FlowSystem that's connected and transformed.</li> </ul>"},{"location":"changelog/#development_16","title":"\ud83d\udc77 Development","text":"<ul> <li>Centralized deprecation pattern: Added <code>_handle_deprecated_kwarg()</code> helper method to <code>Interface</code> base class that provides reusable deprecation handling with consistent warnings, conflict detection, and optional value transformation. Applied across 5 classes (InvestParameters, Source, Sink, SourceAndSink, Effect) reducing deprecation boilerplate by 72%.</li> <li>FlowSystem data management simplified - removed <code>time_series_collection</code> pattern in favor of direct timestep properties</li> <li>Change modeling hierarchy to allow for more flexibility in future development. This leads to minimal changes in the access and creation of Submodels and their variables.</li> <li>Added new module <code>.modeling</code> that contains modeling primitives and utilities</li> <li>Clearer separation between the main Model and \"Submodels\"</li> <li>Improved access to the Submodels and their variables, constraints and submodels</li> <li>Added <code>__repr__()</code> for Submodels to easily inspect its content</li> <li>Enhanced data handling methods<ul> <li><code>fit_to_model_coords()</code> method for data alignment</li> <li><code>fit_effects_to_model_coords()</code> method for effect data processing</li> <li><code>connect_and_transform()</code> method replacing several operations</li> </ul> </li> <li>Testing improvements: Eliminated warnings during test execution<ul> <li>Updated deprecated code patterns in tests and examples (e.g., <code>sink</code>/<code>source</code> \u2192 <code>inputs</code>/<code>outputs</code>, <code>'H'</code> \u2192 <code>'h'</code> frequency)</li> <li>Refactored plotting logic to handle test environments explicitly with non-interactive backends</li> <li>Added comprehensive warning filters in <code>__init__.py</code> and <code>pyproject.toml</code> to suppress third-party library warnings</li> <li>Improved test fixtures with proper figure cleanup to prevent memory leaks</li> <li>Enhanced backend detection and handling in <code>plotting.py</code> for both Matplotlib and Plotly</li> <li>Always run dependent tests in order</li> </ul> </li> </ul>"},{"location":"changelog/#v2.2.0","title":"v2.2.0 11<sup>th</sup> October 2025","text":"<p>Summary: This release is a Configuration and Logging management release.</p>"},{"location":"changelog/#added_13","title":"\u2728 Added","text":"<ul> <li>Added <code>CONFIG.reset()</code> method to restore configuration to default values</li> <li>Added configurable log file rotation settings: <code>CONFIG.Logging.max_file_size</code> and <code>CONFIG.Logging.backup_count</code></li> <li>Added configurable log format settings: <code>CONFIG.Logging.date_format</code> and <code>CONFIG.Logging.format</code></li> <li>Added configurable console settings: <code>CONFIG.Logging.console_width</code> and <code>CONFIG.Logging.show_path</code></li> <li>Added <code>CONFIG.Logging.Colors</code> nested class for customizable log level colors using ANSI escape codes (works with both standard and Rich handlers)</li> <li>All examples now enable console logging to demonstrate proper logging usage</li> <li>Console logging now outputs to <code>sys.stdout</code> instead of <code>sys.stderr</code> for better compatibility with output redirection</li> </ul>"},{"location":"changelog/#breaking-changes_7","title":"\ud83d\udca5 Breaking Changes","text":"<ul> <li>Console logging is now disabled by default (<code>CONFIG.Logging.console = False</code>). Enable it explicitly in your scripts with <code>CONFIG.Logging.console = True</code> and <code>CONFIG.apply()</code></li> <li>File logging is now disabled by default (<code>CONFIG.Logging.file = None</code>). Set a file path to enable file logging</li> </ul>"},{"location":"changelog/#changed_17","title":"\u267b\ufe0f Changed","text":"<ul> <li>Logging and Configuration management changed</li> <li>Improved default logging colors: DEBUG is now gray (<code>\\033[90m</code>) for de-emphasized messages, INFO uses terminal default color (<code>\\033[0m</code>) for clean output</li> </ul>"},{"location":"changelog/#deprecated_7","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<ul> <li><code>change_logging_level()</code> function is now deprecated in favor of <code>CONFIG.Logging.level</code> and <code>CONFIG.apply()</code>. Will be removed in version 3.0.0.</li> </ul>"},{"location":"changelog/#removed_5","title":"\ud83d\udd25 Removed","text":"<ul> <li>Removed unused <code>config.merge_configs</code> function from configuration module</li> </ul>"},{"location":"changelog/#development_17","title":"\ud83d\udc77 Development","text":"<ul> <li>Greatly expanded test coverage for <code>config.py</code> module</li> <li>Added <code>@pytest.mark.xdist_group</code> to <code>TestConfigModule</code> tests to prevent global config interference</li> </ul>"},{"location":"changelog/#v2.1.11","title":"v2.1.11 5<sup>th</sup> October 2025","text":"<p>Summary: Important bugfix in <code>Storage</code> leading to wrong results due to incorrect discharge losses.</p>"},{"location":"changelog/#changed_18","title":"\u267b\ufe0f Changed","text":"<ul> <li>Using <code>h5netcdf</code> instead of <code>netCDF4</code> for dataset I/O operations. This follows the update in <code>xarray==2025.09.01</code></li> </ul>"},{"location":"changelog/#fixed_18","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fix <code>charge_state</code> Constraint in <code>Storage</code> leading to incorrect losses in discharge and therefore incorrect charge states and discharge values.</li> </ul>"},{"location":"changelog/#dependencies_4","title":"\ud83d\udce6 Dependencies","text":"<ul> <li>Updated <code>renovate.config</code> to treat CalVer packages (xarray and dask) with more care</li> <li>Updated packaging configuration</li> </ul>"},{"location":"changelog/#v2.1.10","title":"v2.1.10 29<sup>th</sup> September 2025","text":"<p>Summary: This release is a Documentation and Development release.</p>"},{"location":"changelog/#docs_15","title":"\ud83d\udcdd Docs","text":"<ul> <li>Improved CHANGELOG.md formatting by adding better categories and formating by Gitmoji.</li> <li>Added a script to extract the release notes from the CHANGELOG.md file for better organized documentation.</li> </ul>"},{"location":"changelog/#development_18","title":"\ud83d\udc77 Development","text":"<ul> <li>Improved <code>renovate.config</code></li> <li>Sped up CI by not running examples in every run and using <code>pytest-xdist</code></li> </ul>"},{"location":"changelog/#v2.1.9","title":"v2.1.9 23<sup>rd</sup> September 2025","text":"<p>Summary: Small bugfix release addressing network visualization error handling.</p>"},{"location":"changelog/#fixed_19","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fix error handling in network visualization if <code>networkx</code> is not installed</li> </ul>"},{"location":"changelog/#v2.1.8","title":"v2.1.8 22<sup>nd</sup> September 2025","text":"<p>Summary: Code quality improvements, enhanced documentation, and bug fixes for heat pump components and visualization features.</p>"},{"location":"changelog/#added_14","title":"\u2728 Added","text":"<ul> <li>Extra Check for HeatPumpWithSource.COP to be strictly &gt; 1 to avoid division by zero</li> <li>Apply deterministic color assignment by using sorted() in <code>plotting.py</code></li> <li>Add missing args in docstrings in <code>plotting.py</code>, <code>solvers.py</code>, and <code>core.py</code>.</li> </ul>"},{"location":"changelog/#changed_19","title":"\u267b\ufe0f Changed","text":"<ul> <li>Greatly improved docstrings and documentation of all public classes</li> <li>Make path handling to be gentle about missing .html suffix in <code>plotting.py</code></li> <li>Default for <code>relative_losses</code> in <code>Transmission</code> is now 0 instead of None</li> <li>Setter of COP in <code>HeatPumpWithSource</code> now completely overwrites the conversion factors, which is safer.</li> <li>Fix some docstrings in plotting.py</li> <li>Change assertions to raise Exceptions in <code>plotting.py</code></li> </ul>"},{"location":"changelog/#fixed_20","title":"\ud83d\udc1b Fixed","text":"<p>Core Components: - Fix COP getter and setter of <code>HeatPumpWithSource</code> returning and setting wrong conversion factors - Fix custom compression levels in <code>io.save_dataset_to_netcdf</code> - Fix <code>total_max</code> did not work when total min was not used</p> <p>Visualization: - Fix color scheme selection in network_app; color pickers now update when a scheme is selected</p>"},{"location":"changelog/#docs_16","title":"\ud83d\udcdd Docs","text":"<ul> <li>Fix broken links in docs</li> <li>Fix some docstrings in plotting.py</li> </ul>"},{"location":"changelog/#development_19","title":"\ud83d\udc77 Development","text":"<ul> <li>Pin dev dependencies to specific versions</li> <li>Improve CI workflows to run faster and smarter</li> </ul>"},{"location":"changelog/#v2.1.7","title":"v2.1.7 13<sup>th</sup> September 2025","text":"<p>Summary: Maintenance release to improve Code Quality, CI and update the dependencies. There are no changes or new features.</p>"},{"location":"changelog/#added_15","title":"\u2728 Added","text":"<ul> <li>Added <code>__version__</code> to flixopt</li> </ul>"},{"location":"changelog/#development_20","title":"\ud83d\udc77 Development","text":"<ul> <li>ruff format the whole Codebase</li> <li>Added renovate config</li> <li>Added pre-commit</li> <li>lint and format in CI</li> <li>improved CI</li> <li>Updated Dependencies</li> <li>Updated Issue Templates</li> </ul>"},{"location":"changelog/#v2.1.6","title":"v2.1.6 2<sup>nd</sup> September 2025","text":"<p>Summary: Enhanced Sink/Source components with multi-flow support and new interactive network visualization.</p>"},{"location":"changelog/#added_16","title":"\u2728 Added","text":"<ul> <li>Network Visualization: Added <code>FlowSystem.start_network_app()</code> and <code>FlowSystem.stop_network_app()</code> to easily visualize the network structure of a flow system in an interactive Dash web app<ul> <li>Note: This is still experimental and might change in the future</li> </ul> </li> </ul>"},{"location":"changelog/#changed_20","title":"\u267b\ufe0f Changed","text":"<ul> <li>Multi-Flow Support: <code>Sink</code>, <code>Source</code>, and <code>SourceAndSink</code> now accept multiple <code>flows</code> as <code>inputs</code> and <code>outputs</code> instead of just one. This enables modeling more use cases with these classes</li> <li>Flow Control: Both <code>Sink</code> and <code>Source</code> now have a <code>prevent_simultaneous_flow_rates</code> argument to prevent simultaneous flow rates of more than one of their flows</li> </ul>"},{"location":"changelog/#deprecated_8","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<ul> <li>For the classes <code>Sink</code>, <code>Source</code> and <code>SourceAndSink</code>: <code>.sink</code>, <code>.source</code> and <code>.prevent_simultaneous_sink_and_source</code> are deprecated in favor of the new arguments <code>inputs</code>, <code>outputs</code> and <code>prevent_simultaneous_flow_rates</code></li> </ul>"},{"location":"changelog/#fixed_21","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed testing issue with new <code>linopy</code> version 0.5.6</li> </ul>"},{"location":"changelog/#development_21","title":"\ud83d\udc77 Development","text":"<ul> <li>Added dependency \"nbformat&gt;=4.2.0\" to dev dependencies to resolve issue with plotly CI</li> </ul>"},{"location":"changelog/#v2.1.5","title":"v2.1.5 8<sup>th</sup> July 2025","text":""},{"location":"changelog/#fixed_22","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed Docs deployment</li> </ul>"},{"location":"changelog/#v2.1.4","title":"v2.1.4 8<sup>th</sup> July 2025","text":""},{"location":"changelog/#fixed_23","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixing release notes of 2.1.3, as well as documentation build.</li> </ul>"},{"location":"changelog/#v2.1.3","title":"v2.1.3 8<sup>th</sup> July 2025","text":""},{"location":"changelog/#fixed_24","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Using <code>Effect.maximum_operation_per_hour</code> raised an error, needing an extra timestep. This has been fixed thanks to @PRse4.</li> </ul>"},{"location":"changelog/#v2.1.2","title":"v2.1.2 14<sup>th</sup> June 2025","text":""},{"location":"changelog/#fixed_25","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Storage losses per hour were not calculated correctly, as mentioned by @brokenwings01. This might have led to issues when modeling large losses and long timesteps.<ul> <li>Old implementation:     \\(c(\\text{t}_{i}) \\cdot (1-\\dot{\\text{c}}_\\text{rel,loss}(\\text{t}_i)) \\cdot \\Delta \\text{t}_{i}\\)</li> <li>Correct implementation: \\(c(\\text{t}_{i}) \\cdot (1-\\dot{\\text{c}}_\\text{rel,loss}(\\text{t}_i)) ^{\\Delta \\text{t}_{i}}\\)</li> </ul> </li> </ul>"},{"location":"changelog/#known-issues_1","title":"\ud83d\udea7 Known Issues","text":"<ul> <li>Just to mention: Plotly &gt;= 6 may raise errors if \"nbformat\" is not installed. We pinned plotly to &lt;6, but this may be fixed in the future.</li> </ul>"},{"location":"changelog/#v2.1.1","title":"v2.1.1 8<sup>th</sup> May 2025","text":""},{"location":"changelog/#changed_21","title":"\u267b\ufe0f Changed","text":"<ul> <li>Improved docstring and tests</li> </ul>"},{"location":"changelog/#fixed_26","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed bug in the <code>_ElementResults.constraints</code> not returning the constraints but rather the variables</li> </ul>"},{"location":"changelog/#v2.1.0","title":"v2.1.0 11<sup>th</sup> April 2025","text":""},{"location":"changelog/#added_17","title":"\u2728 Added","text":"<ul> <li>Python 3.13 support added</li> <li>Logger warning if relative_minimum is used without on_off_parameters in Flow</li> <li>Greatly improved internal testing infrastructure by leveraging linopy's testing framework</li> </ul>"},{"location":"changelog/#breaking-changes_8","title":"\ud83d\udca5 Breaking Changes","text":"<ul> <li>Restructured the modeling of the On/Off state of Flows or Components<ul> <li>Variable renaming: <code>...|consecutive_on_hours</code> \u2192 <code>...|ConsecutiveOn|hours</code></li> <li>Variable renaming: <code>...|consecutive_off_hours</code> \u2192 <code>...|ConsecutiveOff|hours</code></li> <li>Constraint renaming: <code>...|consecutive_on_hours_con1</code> \u2192 <code>...|ConsecutiveOn|con1</code></li> <li>Similar pattern for all consecutive on/off constraints</li> </ul> </li> </ul>"},{"location":"changelog/#fixed_27","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed the lower bound of <code>flow_rate</code> when using optional investments without OnOffParameters</li> <li>Fixed bug that prevented divest effects from working</li> <li>Added lower bounds of 0 to two unbounded vars (numerical improvement)</li> </ul>"},{"location":"changelog/#v2.0.1","title":"v2.0.1 10<sup>th</sup> April 2025","text":""},{"location":"changelog/#added_18","title":"\u2728 Added","text":"<ul> <li>Logger warning if relative_minimum is used without on_off_parameters in Flow</li> </ul>"},{"location":"changelog/#fixed_28","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Replace \"|\" with \"__\" in filenames when saving figures (Windows compatibility)</li> <li>Fixed bug that prevented the load factor from working without InvestmentParameters</li> </ul>"},{"location":"changelog/#v2.0.0","title":"v2.0.0 29<sup>th</sup> March 2025","text":"<p>Summary: \ud83d\udca5 MAJOR RELEASE - Complete framework migration from Pyomo to Linopy with redesigned architecture.</p>"},{"location":"changelog/#added_19","title":"\u2728 Added","text":"<p>Model Capabilities: - Full model serialization support - save and restore unsolved Models - Enhanced model documentation with YAML export containing human-readable mathematical formulations - Extend flixopt models with native linopy language support - Full Model Export/Import capabilities via linopy.Model</p> <p>Results &amp; Data: - Unified solution exploration through <code>Calculation.results</code> attribute - Compression support for result files - <code>to_netcdf/from_netcdf</code> methods for FlowSystem and core components - xarray integration for TimeSeries with improved datatypes support</p>"},{"location":"changelog/#breaking-changes_9","title":"\ud83d\udca5 Breaking Changes","text":"<p>Framework Migration: - Optimization Engine: Complete migration from Pyomo to Linopy optimization framework - Package Import: Framework renamed from flixOpt to flixopt (<code>import flixopt as fx</code>) - Data Architecture: Redesigned data handling to rely on xarray.Dataset throughout the package - Results System: Results handling completely redesigned with new <code>CalculationResults</code> class</p> <p>Variable Structure: - Restructured the modeling of the On/Off state of Flows or Components     - Variable renaming: <code>...|consecutive_on_hours</code> \u2192 <code>...|ConsecutiveOn|hours</code>     - Variable renaming: <code>...|consecutive_off_hours</code> \u2192 <code>...|ConsecutiveOff|hours</code>     - Constraint renaming: <code>...|consecutive_on_hours_con1</code> \u2192 <code>...|ConsecutiveOn|con1</code>     - Similar pattern for all consecutive on/off constraints</p>"},{"location":"changelog/#removed_6","title":"\ud83d\udd25 Removed","text":"<ul> <li>Pyomo dependency (replaced by linopy)</li> <li>Period concepts in time management (simplified to timesteps)</li> </ul>"},{"location":"changelog/#fixed_29","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Improved infeasible model detection and reporting</li> <li>Enhanced time series management and serialization</li> <li>Reduced file size through improved compression</li> </ul>"},{"location":"changelog/#docs_17","title":"\ud83d\udcdd Docs","text":"<ul> <li>Google Style Docstrings throughout the codebase</li> </ul>"},{"location":"contribute/","title":"Contributing to FlixOpt","text":"<p>We warmly welcome contributions from the community! Whether you're fixing bugs, adding features, improving documentation, or sharing examples, your contributions are valuable.</p>"},{"location":"contribute/#ways-to-contribute","title":"Ways to Contribute","text":""},{"location":"contribute/#report-issues","title":"\ud83d\udc1b Report Issues","text":"<p>Found a bug or have a feature request? Please open an issue on GitHub.</p> <p>When reporting issues, please include: - A clear description of the problem - Steps to reproduce the issue - Expected vs. actual behavior - Your environment (OS, Python version, FlixOpt version) - Minimal code example if applicable</p>"},{"location":"contribute/#share-examples","title":"\ud83d\udca1 Share Examples","text":"<p>Help others learn FlixOpt by contributing examples: - Real-world use cases - Tutorial notebooks - Integration examples with other tools - Add them to the <code>examples/</code> directory</p>"},{"location":"contribute/#improve-documentation","title":"\ud83d\udcd6 Improve Documentation","text":"<p>Documentation improvements are always welcome: - Fix typos or clarify existing docs - Add missing documentation - Translate documentation - Improve code comments</p>"},{"location":"contribute/#submit-code-contributions","title":"\ud83d\udd27 Submit Code Contributions","text":"<p>Ready to contribute code? Great! See the sections below for setup and guidelines.</p>"},{"location":"contribute/#development-setup","title":"Development Setup","text":""},{"location":"contribute/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Fork and clone the repository:    <pre><code>git clone https://github.com/flixOpt/flixopt.git\ncd flixopt\n</code></pre></p> </li> <li> <p>Install development dependencies:    <pre><code>pip install -e \".[full, dev]\"\n</code></pre></p> </li> <li> <p>Set up pre-commit hooks (one-time setup):    <pre><code>pre-commit install\n</code></pre></p> </li> <li> <p>Verify your setup:    <pre><code>pytest\n</code></pre></p> </li> </ol>"},{"location":"contribute/#working-with-documentation","title":"Working with Documentation","text":"<p>FlixOpt uses mkdocs to generate documentation.</p> <p>To work on documentation: <pre><code>pip install -e \".[docs]\"\nmkdocs serve\n</code></pre> Then navigate to http://127.0.0.1:8000/</p>"},{"location":"contribute/#code-quality-standards","title":"Code Quality Standards","text":""},{"location":"contribute/#automated-checks","title":"Automated Checks","text":"<p>We use Ruff for linting and formatting. After the one-time setup above, code quality checks run automatically on every commit.</p>"},{"location":"contribute/#manual-checks","title":"Manual Checks","text":"<p>To run checks manually: - <code>ruff check --fix .</code> - Check and fix linting issues - <code>ruff format .</code> - Format code - <code>pre-commit run --all-files</code> - Run all pre-commit checks</p>"},{"location":"contribute/#testing","title":"Testing","text":"<p>All tests are located in the <code>tests/</code> directory with a flat structure: - <code>test_component.py</code> - Component tests - <code>test_flow.py</code> - Flow tests - <code>test_storage.py</code> - Storage tests - etc.</p>"},{"location":"contribute/#running-tests","title":"Running Tests","text":"<ul> <li><code>pytest</code> - Run the full test suite (excluding examples by default)</li> <li><code>pytest tests/test_component.py</code> - Run a specific test file</li> <li><code>pytest tests/test_component.py::TestClassName</code> - Run a specific test class</li> <li><code>pytest tests/test_component.py::TestClassName::test_method</code> - Run a specific test</li> <li><code>pytest -m slow</code> - Run only slow tests</li> <li><code>pytest -m examples</code> - Run example tests (normally skipped)</li> <li><code>pytest -k \"keyword\"</code> - Run tests matching a keyword</li> </ul>"},{"location":"contribute/#common-test-patterns","title":"Common Test Patterns","text":"<p>The <code>tests/conftest.py</code> file provides shared fixtures: - <code>solver_fixture</code> - Parameterized solver fixture (HiGHS, Gurobi) - <code>highs_solver</code> - HiGHS solver instance - Coordinate configuration fixtures for timesteps, periods, scenarios</p> <p>Use these fixtures by adding them as function parameters: <pre><code>def test_my_feature(solver_fixture):\n    # solver_fixture is automatically provided by pytest\n    model = fx.FlowSystem(...)\n    model.solve(solver_fixture)\n</code></pre></p>"},{"location":"contribute/#testing-guidelines","title":"Testing Guidelines","text":"<ul> <li>Write tests for all new functionality</li> <li>Ensure all tests pass before submitting a PR</li> <li>Aim for 100% test coverage for new code</li> <li>Use descriptive test names that explain what's being tested</li> <li>Add the <code>@pytest.mark.slow</code> decorator for tests that take &gt;5 seconds</li> </ul>"},{"location":"contribute/#coding-guidelines","title":"Coding Guidelines","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Write clear, self-documenting code with helpful comments</li> <li>Include type hints for function signatures</li> <li>Create or update tests for new functionality</li> <li>Aim for 100% test coverage for new code</li> </ul>"},{"location":"contribute/#workflow","title":"Workflow","text":""},{"location":"contribute/#branches-pull-requests","title":"Branches &amp; Pull Requests","text":"<ol> <li> <p>Create a feature branch from <code>main</code>:    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make your changes and commit them with clear messages</p> </li> <li> <p>Push your branch and open a Pull Request</p> </li> <li> <p>Ensure all CI checks pass</p> </li> </ol>"},{"location":"contribute/#branch-naming","title":"Branch Naming","text":"<ul> <li>Features: <code>feature/feature-name</code></li> <li>Bug fixes: <code>fix/bug-description</code></li> <li>Documentation: <code>docs/what-changed</code></li> </ul>"},{"location":"contribute/#commit-messages","title":"Commit Messages","text":"<ul> <li>Use clear, descriptive commit messages</li> <li>Start with a verb (Add, Fix, Update, Remove, etc.)</li> <li>Keep the first line under 72 characters</li> </ul>"},{"location":"contribute/#releases","title":"Releases","text":"<p>We follow Semantic Versioning (MAJOR.MINOR.PATCH). Releases are created manually from the <code>main</code> branch by maintainers.</p>"},{"location":"contribute/#questions","title":"Questions?","text":"<p>If you have questions or need help, feel free to: - Open a discussion on GitHub - Ask in an issue - Reach out to the maintainers</p> <p>Thank you for contributing to FlixOpt!</p>"},{"location":"roadmap/","title":"Roadmap and Vision","text":""},{"location":"roadmap/#our-vision","title":"\ud83c\udfaf Our Vision","text":"<p>FlixOpt aims to be the most accessible, flexible, and universal Python framework for energy and material flow optimization.</p> <p>We believe optimization modeling should be approachable for beginners yet powerful for experts, minimizing context switching between short-term dispatch and long-term investment planning.</p>"},{"location":"roadmap/#short-term-next-6-months","title":"\ud83d\ude80 Short-term (Next 6 months)","text":"<ul> <li>Recipe collection - Community-driven library of common modeling patterns, data manipulation techniques, and optimization strategies</li> <li>Examples of stochastic and multi-period modeling - The new v3.0 features currently lack comprehensive showcases</li> <li>Advanced result analysis - Automated reporting and enhanced visualization options</li> <li>Interactive tutorials - Browser-based, reactive tutorials for learning FlixOpt without local installation using Marimo</li> </ul>"},{"location":"roadmap/#medium-term-6-12-months","title":"\ud83d\udd2e Medium-term (6-12 months)","text":"<ul> <li>Modeling to Generate Alternatives (MGA) - Built-in support for exploring near-optimal solution spaces to produce more robust, diverse solutions under uncertainty. See PyPSA and Calliope for reference implementations</li> <li>Advanced stochastic optimization - Build sophisticated new <code>Optimization</code> classes to perform different stochastic optimization approaches, like PyPSA's two-stage stochastic programming and risk preferences with Conditional Value-at-Risk (CVaR)</li> <li>Enhanced component library - More pre-built, domain-specific components (sector coupling, hydrogen systems, thermal networks, demand-side management)</li> </ul>"},{"location":"roadmap/#long-term-12-months","title":"\ud83c\udf1f Long-term (12+ months)","text":"<ul> <li>Showcase universal applicability - FlixOpt already handles any flow-based system (supply chains, water networks, production planning, chemical processes) - we need more examples and domain-specific component libraries to demonstrate this</li> <li>Community ecosystem - Rich library of user-contributed components, examples, and domain-specific extensions</li> </ul>"},{"location":"roadmap/#how-to-help","title":"\ud83e\udd1d How to Help","text":"<ul> <li>Code: Implement features, fix bugs, add tests</li> <li>Docs: Write tutorials, improve examples, create case studies</li> <li>Components: Contribute domain-specific components</li> <li>Feedback: Report issues, join discussions</li> </ul> <p>See our contribution guide to get started.</p>"},{"location":"roadmap/#release-philosophy","title":"\ud83d\udcc5 Release Philosophy","text":"<p>FlixOpt follows semantic versioning: - Major (v3\u2192v4): Breaking changes, major features - Minor (v3.0\u2192v3.1): New features, backward compatible - Patch (v3.0.0\u2192v3.0.1): Bug fixes only</p> <p>Target: Patch releases as needed, minor releases every 2-3 months.</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>This section contains the documentation for all modules and classes in flixopt. For more information on how to use the classes and functions, see the User Guide section.</p>"},{"location":"api-reference/carrier/","title":"Carrier","text":""},{"location":"api-reference/carrier/#flixopt.carrier","title":"flixopt.carrier","text":"<p>Carrier class for energy/material type definitions.</p> <p>Carriers represent types of energy or materials that flow through buses, such as electricity, heat, gas, or water. They provide consistent styling and metadata across visualizations.</p>"},{"location":"api-reference/carrier/#flixopt.carrier-classes","title":"Classes","text":""},{"location":"api-reference/carrier/#flixopt.carrier.Carrier","title":"Carrier","text":"<pre><code>Carrier(name: str, color: str = '', unit: str = '', description: str = '')\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Definition of an energy or material carrier type.</p> <p>Carriers represent the type of energy or material flowing through a Bus. They provide consistent color, unit, and description across all visualizations and can be shared between multiple buses of the same type.</p> <p>Inherits from Interface to provide serialization capabilities.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Identifier for the carrier (e.g., 'electricity', 'heat', 'gas').</p> required <code>color</code> <code>str</code> <p>Hex color string for visualizations (e.g., '#FFD700').</p> <code>''</code> <code>unit</code> <code>str</code> <p>Unit string for display (e.g., 'kW', 'kW_th', 'm\u00b3/h').</p> <code>''</code> <code>description</code> <code>str</code> <p>Optional human-readable description.</p> <code>''</code> <p>Examples:</p> <p>Creating custom carriers:</p> <pre><code>import flixopt as fx\n\n# Define custom carriers\nelectricity = fx.Carrier('electricity', '#FFD700', 'kW', 'Electrical power')\ndistrict_heat = fx.Carrier('district_heat', '#FF6B6B', 'kW_th', 'District heating')\nhydrogen = fx.Carrier('hydrogen', '#00CED1', 'kg/h', 'Hydrogen fuel')\n\n# Register with FlowSystem\nflow_system.add_carrier(electricity)\nflow_system.add_carrier(district_heat)\n\n# Use with buses (just reference by name)\nelec_bus = fx.Bus('MainGrid', carrier='electricity')\nheat_bus = fx.Bus('HeatingNetwork', carrier='district_heat')\n</code></pre> <p>Using predefined carriers from CONFIG:</p> <pre><code># Access built-in carriers\nelec = fx.CONFIG.Carriers.electricity\nheat = fx.CONFIG.Carriers.heat\n\n# Use directly\nbus = fx.Bus('Grid', carrier='electricity')\n</code></pre> <p>Adding custom carriers to CONFIG:</p> <pre><code># Add a new carrier globally\nfx.CONFIG.Carriers.add(fx.Carrier('biogas', '#228B22', 'kW', 'Biogas'))\n\n# Now available as\nfx.CONFIG.Carriers.biogas\n</code></pre> Note <p>Carriers are compared by name for equality, allowing flexible usage patterns where the same carrier type can be referenced by name string or Carrier object interchangeably.</p> <p>Initialize a Carrier.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Identifier for the carrier (normalized to lowercase).</p> required <code>color</code> <code>str</code> <p>Hex color string for visualizations.</p> <code>''</code> <code>unit</code> <code>str</code> <p>Unit string for display.</p> <code>''</code> <code>description</code> <code>str</code> <p>Optional human-readable description.</p> <code>''</code>"},{"location":"api-reference/carrier/#flixopt.carrier.Carrier-attributes","title":"Attributes","text":""},{"location":"api-reference/carrier/#flixopt.carrier.Carrier.label","title":"label  <code>property</code>","text":"<pre><code>label: str\n</code></pre> <p>Label for container keying (alias for name).</p>"},{"location":"api-reference/carrier/#flixopt.carrier.Carrier.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/carrier/#flixopt.carrier.Carrier.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/carrier/#flixopt.carrier.Carrier-functions","title":"Functions","text":""},{"location":"api-reference/carrier/#flixopt.carrier.Carrier.transform_data","title":"transform_data","text":"<pre><code>transform_data(name_prefix: str = '') -&gt; None\n</code></pre> <p>Transform data to match FlowSystem dimensions.</p> <p>Carriers don't have time-series data, so this is a no-op.</p> <p>Parameters:</p> Name Type Description Default <code>name_prefix</code> <code>str</code> <p>Ignored for Carrier.</p> <code>''</code>"},{"location":"api-reference/carrier/#flixopt.carrier.Carrier.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system: FlowSystem, prefix: str = '') -&gt; None\n</code></pre> <p>Link this interface and all nested interfaces to a FlowSystem.</p> <p>This method is called automatically during element registration to enable elements to access FlowSystem properties without passing the reference through every method call. It also sets the prefix used for naming transformed data.</p> <p>Subclasses with nested Interface objects should override this method to propagate the link to their nested interfaces by calling <code>super().link_to_flow_system(flow_system, prefix)</code> first, then linking nested objects with appropriate prefixes.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to link to</p> required <code>prefix</code> <code>str</code> <p>The prefix for naming transformed data (e.g., 'Boiler(Q_th)')</p> <code>''</code> <p>Examples:</p> <p>Override in a subclass with nested interfaces:</p> <pre><code>def link_to_flow_system(self, flow_system, prefix: str = '') -&gt; None:\n    super().link_to_flow_system(flow_system, prefix)\n    if self.nested_interface is not None:\n        self.nested_interface.link_to_flow_system(flow_system, f'{prefix}|nested' if prefix else 'nested')\n</code></pre> <p>Creating an Interface dynamically during modeling:</p> <pre><code># In a Model class\nif flow.status_parameters is None:\n    flow.status_parameters = StatusParameters()\n    flow.status_parameters.link_to_flow_system(self._model.flow_system, f'{flow.label_full}')\n</code></pre>"},{"location":"api-reference/carrier/#flixopt.carrier.Carrier.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/carrier/#flixopt.carrier.Carrier.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/carrier/#flixopt.carrier.Carrier.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/carrier/#flixopt.carrier.Carrier.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/carrier/#flixopt.carrier.Carrier.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/carrier/#flixopt.carrier.Carrier.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/carrier/#flixopt.carrier.Carrier.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/carrier/#flixopt.carrier.CarrierContainer","title":"CarrierContainer","text":"<pre><code>CarrierContainer(carriers: list[Carrier] | dict[str, Carrier] | None = None)\n</code></pre> <p>               Bases: <code>ContainerMixin['Carrier']</code></p> <p>Container for Carrier objects.</p> <p>Uses carrier.name for keying. Provides dict-like access to carriers registered with a FlowSystem.</p> <p>Examples:</p> <pre><code># Access via FlowSystem\ncarriers = flow_system.carriers\n\n# Dict-like access\nelec = carriers['electricity']\n'heat' in carriers  # True/False\n\n# Iteration\nfor name in carriers:\n    print(name)\n</code></pre> <p>Initialize a CarrierContainer.</p> <p>Parameters:</p> Name Type Description Default <code>carriers</code> <code>list[Carrier] | dict[str, Carrier] | None</code> <p>Initial carriers to add.</p> <code>None</code>"},{"location":"api-reference/carrier/#flixopt.carrier.CarrierContainer-functions","title":"Functions","text":""},{"location":"api-reference/carrier/#flixopt.carrier.CarrierContainer.add","title":"add","text":"<pre><code>add(element: T) -&gt; None\n</code></pre> <p>Add an element to the container.</p>"},{"location":"api-reference/carrier/#flixopt.carrier-functions","title":"Functions","text":""},{"location":"api-reference/color_processing/","title":"Color processing","text":""},{"location":"api-reference/color_processing/#flixopt.color_processing","title":"flixopt.color_processing","text":"<p>Simplified color handling for visualization.</p> <p>This module provides clean color processing that transforms various input formats into a label-to-color mapping dictionary, without needing to know about the plotting engine.</p>"},{"location":"api-reference/color_processing/#flixopt.color_processing-attributes","title":"Attributes","text":""},{"location":"api-reference/color_processing/#flixopt.color_processing.ColorType","title":"ColorType  <code>module-attribute</code>","text":"<pre><code>ColorType = str | list[str] | dict[str, str]\n</code></pre> <p>Flexible color specification type supporting multiple input formats for visualization.</p> <p>Color specifications can take several forms to accommodate different use cases:</p> <p>Named colorscales (str):     - Standard colorscales: 'turbo', 'plasma', 'cividis', 'tab10', 'Set1'     - Energy-focused: 'portland' (custom flixopt colorscale for energy systems)     - Backend-specific maps available in Plotly and Matplotlib</p> <p>Color Lists (list[str]):     - Explicit color sequences: ['red', 'blue', 'green', 'orange']     - HEX codes: ['#FF0000', '#0000FF', '#00FF00', '#FFA500']     - Mixed formats: ['red', '#0000FF', 'green', 'orange']</p> <p>Label-to-Color Mapping (dict[str, str]):     - Explicit associations: {'Wind': 'skyblue', 'Solar': 'gold', 'Gas': 'brown'}     - Ensures consistent colors across different plots and datasets     - Ideal for energy system components with semantic meaning</p> <p>Examples:</p> <pre><code># Named colorscale\ncolors = 'turbo'  # Automatic color generation\n\n# Explicit color list\ncolors = ['red', 'blue', 'green', '#FFD700']\n\n# Component-specific mapping\ncolors = {\n    'Wind_Turbine': 'skyblue',\n    'Solar_Panel': 'gold',\n    'Natural_Gas': 'brown',\n    'Battery': 'green',\n    'Electric_Load': 'darkred'\n}\n</code></pre> Color Format Support <ul> <li>Named Colors: 'red', 'blue', 'forestgreen', 'darkorange'</li> <li>HEX Codes: '#FF0000', '#0000FF', '#228B22', '#FF8C00'</li> <li>RGB Tuples: (255, 0, 0), (0, 0, 255) [Matplotlib only]</li> <li>RGBA: 'rgba(255,0,0,0.8)' [Plotly only]</li> </ul> References <ul> <li>HTML Color Names: https://htmlcolorcodes.com/color-names/</li> <li>Matplotlib colorscales: https://matplotlib.org/stable/tutorials/colors/colorscales.html</li> <li>Plotly Built-in Colorscales: https://plotly.com/python/builtin-colorscales/</li> </ul>"},{"location":"api-reference/color_processing/#flixopt.color_processing-functions","title":"Functions","text":""},{"location":"api-reference/color_processing/#flixopt.color_processing.color_to_rgba","title":"color_to_rgba","text":"<pre><code>color_to_rgba(color: str | None, alpha: float = 1.0) -&gt; str\n</code></pre> <p>Convert any valid color to RGBA string format.</p> <p>Handles hex colors (with or without #), named colors, and rgb/rgba strings.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str | None</code> <p>Color in any valid format (hex '#FF0000' or 'FF0000',    named 'red', rgb 'rgb(255,0,0)', rgba 'rgba(255,0,0,1)').</p> required <code>alpha</code> <code>float</code> <p>Alpha/opacity value between 0.0 and 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>str</code> <p>Color in RGBA format 'rgba(R, G, B, A)'.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; color_to_rgba('#FF0000')\n'rgba(255, 0, 0, 1.0)'\n&gt;&gt;&gt; color_to_rgba('FF0000')\n'rgba(255, 0, 0, 1.0)'\n&gt;&gt;&gt; color_to_rgba('red', 0.5)\n'rgba(255, 0, 0, 0.5)'\n&gt;&gt;&gt; color_to_rgba('forestgreen', 0.4)\n'rgba(34, 139, 34, 0.4)'\n&gt;&gt;&gt; color_to_rgba(None)\n'rgba(200, 200, 200, 1.0)'\n</code></pre>"},{"location":"api-reference/color_processing/#flixopt.color_processing.process_colors","title":"process_colors","text":"<pre><code>process_colors(colors: None | str | list[str] | dict[str, str], labels: list[str], default_colorscale: str | None = None) -&gt; dict[str, str]\n</code></pre> <p>Process color input and return a label-to-color mapping.</p> <p>This function takes flexible color input and always returns a dictionary mapping each label to a specific color string. The plotting engine can then use this mapping as needed.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>None | str | list[str] | dict[str, str]</code> <p>Color specification in one of four formats: - None: Use the default colorscale - str: Name of a colorscale (e.g., 'turbo', 'plasma', 'Set1', 'portland') - list[str]: List of color strings (hex, named colors, etc.) - dict[str, str]: Direct label-to-color mapping</p> required <code>labels</code> <code>list[str]</code> <p>List of labels that need colors assigned</p> required <code>default_colorscale</code> <code>str | None</code> <p>Fallback colorscale name if requested scale not found. Defaults to CONFIG.Plotting.default_qualitative_colorscale.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary mapping each label to a color string</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Using None - applies default colorscale\n&gt;&gt;&gt; process_colors(None, ['A', 'B', 'C'])\n{'A': '#0d0887', 'B': '#7e03a8', 'C': '#cc4778'}\n</code></pre> <pre><code>&gt;&gt;&gt; # Using a colorscale name\n&gt;&gt;&gt; process_colors('plasma', ['A', 'B', 'C'])\n{'A': '#0d0887', 'B': '#7e03a8', 'C': '#cc4778'}\n</code></pre> <pre><code>&gt;&gt;&gt; # Using a list of colors\n&gt;&gt;&gt; process_colors(['red', 'blue', 'green'], ['A', 'B', 'C'])\n{'A': 'red', 'B': 'blue', 'C': 'green'}\n</code></pre> <pre><code>&gt;&gt;&gt; # Using a pre-made mapping\n&gt;&gt;&gt; process_colors({'A': 'red', 'B': 'blue'}, ['A', 'B', 'C'])\n{'A': 'red', 'B': 'blue', 'C': '#0d0887'}  # C gets color from default scale\n</code></pre>"},{"location":"api-reference/comparison/","title":"Comparison","text":""},{"location":"api-reference/comparison/#flixopt.comparison","title":"flixopt.comparison","text":"<p>Compare multiple FlowSystems side-by-side.</p>"},{"location":"api-reference/comparison/#flixopt.comparison-attributes","title":"Attributes","text":""},{"location":"api-reference/comparison/#flixopt.comparison-classes","title":"Classes","text":""},{"location":"api-reference/comparison/#flixopt.comparison.Comparison","title":"Comparison","text":"<pre><code>Comparison(flow_systems: list[FlowSystem], names: list[str] | None = None)\n</code></pre> <p>Compare multiple FlowSystems side-by-side.</p> <p>Combines solutions, statistics, and inputs from multiple FlowSystems into unified xarray Datasets with a 'case' dimension. The existing plotting infrastructure automatically handles faceting by the 'case' dimension.</p> <p>For comparing solutions/statistics, all FlowSystems must be optimized and have matching dimensions. For comparing inputs only, optimization is not required.</p> <p>Parameters:</p> Name Type Description Default <code>flow_systems</code> <code>list[FlowSystem]</code> <p>List of FlowSystems to compare.</p> required <code>names</code> <code>list[str] | None</code> <p>Optional names for each case. If None, uses FlowSystem.name.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If case names are not unique.</p> <code>RuntimeError</code> <p>If accessing solution/statistics without optimized FlowSystems.</p> <p>Examples:</p> <pre><code># Compare two systems (uses FlowSystem.name by default)\ncomp = fx.Comparison([fs_base, fs_modified])\n\n# Or with custom names\ncomp = fx.Comparison([fs_base, fs_modified], names=['baseline', 'modified'])\n\n# Side-by-side plots (auto-facets by 'case')\ncomp.statistics.plot.balance('Heat')\ncomp.statistics.flow_rates.plotly.line()\n\n# Access combined data\ncomp.solution  # xr.Dataset with 'case' dimension\ncomp.statistics.flow_rates  # xr.Dataset with 'case' dimension\n\n# Compute differences relative to first case\ncomp.diff()  # Returns xr.Dataset of differences\ncomp.diff('baseline')  # Or specify reference by name\n\n# For systems with different dimensions, align first:\nfs_both = ...  # Has scenario dimension\nfs_mild = fs_both.transform.sel(scenario='Mild')  # Select one scenario\nfs_other = ...  # Also select to match\ncomp = fx.Comparison([fs_mild, fs_other])  # Now dimensions match\n</code></pre>"},{"location":"api-reference/comparison/#flixopt.comparison.Comparison-attributes","title":"Attributes","text":""},{"location":"api-reference/comparison/#flixopt.comparison.Comparison.names","title":"names  <code>property</code>","text":"<pre><code>names: list[str]\n</code></pre> <p>Case names for each FlowSystem.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.Comparison.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Combined solution Dataset with 'case' dimension.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.Comparison.statistics","title":"statistics  <code>property</code>","text":"<pre><code>statistics: ComparisonStatistics\n</code></pre> <p>Combined statistics accessor with 'case' dimension.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.Comparison.inputs","title":"inputs  <code>property</code>","text":"<pre><code>inputs: Dataset\n</code></pre> <p>Combined input data Dataset with 'case' dimension.</p> <p>Concatenates input parameters from all FlowSystems. Each FlowSystem's <code>.inputs</code> Dataset is combined with a 'case' dimension.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset with all input parameters. Variable naming follows</p> <code>Dataset</code> <p>the pattern <code>{element.label_full}|{parameter_name}</code>.</p> <p>Examples:</p> <pre><code>comp = fx.Comparison([fs1, fs2], names=['Base', 'Modified'])\ncomp.inputs  # All inputs with 'case' dimension\ncomp.inputs['Boiler(Q_th)|relative_minimum']  # Specific parameter\n</code></pre>"},{"location":"api-reference/comparison/#flixopt.comparison.Comparison-functions","title":"Functions","text":""},{"location":"api-reference/comparison/#flixopt.comparison.Comparison.diff","title":"diff","text":"<pre><code>diff(reference: str | int = 0) -&gt; xr.Dataset\n</code></pre> <p>Compute differences relative to a reference case.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str | int</code> <p>Reference case name or index (default: 0, first case).</p> <code>0</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset with differences (each case minus reference).</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics","title":"ComparisonStatistics","text":"<pre><code>ComparisonStatistics(comparison: Comparison)\n</code></pre> <p>Combined statistics accessor for comparing FlowSystems.</p> <p>Mirrors StatisticsAccessor properties, concatenating data with a 'case' dimension. Access via <code>Comparison.statistics</code>.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics-attributes","title":"Attributes","text":""},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.flow_rates","title":"flow_rates  <code>property</code>","text":"<pre><code>flow_rates: Dataset\n</code></pre> <p>Combined flow rates with 'case' dimension.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.flow_hours","title":"flow_hours  <code>property</code>","text":"<pre><code>flow_hours: Dataset\n</code></pre> <p>Combined flow hours (energy) with 'case' dimension.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.flow_sizes","title":"flow_sizes  <code>property</code>","text":"<pre><code>flow_sizes: Dataset\n</code></pre> <p>Combined flow investment sizes with 'case' dimension.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.storage_sizes","title":"storage_sizes  <code>property</code>","text":"<pre><code>storage_sizes: Dataset\n</code></pre> <p>Combined storage capacity sizes with 'case' dimension.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.sizes","title":"sizes  <code>property</code>","text":"<pre><code>sizes: Dataset\n</code></pre> <p>Combined sizes (flow + storage) with 'case' dimension.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.charge_states","title":"charge_states  <code>property</code>","text":"<pre><code>charge_states: Dataset\n</code></pre> <p>Combined storage charge states with 'case' dimension.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.temporal_effects","title":"temporal_effects  <code>property</code>","text":"<pre><code>temporal_effects: Dataset\n</code></pre> <p>Combined temporal effects with 'case' dimension.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.periodic_effects","title":"periodic_effects  <code>property</code>","text":"<pre><code>periodic_effects: Dataset\n</code></pre> <p>Combined periodic effects with 'case' dimension.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.total_effects","title":"total_effects  <code>property</code>","text":"<pre><code>total_effects: Dataset\n</code></pre> <p>Combined total effects with 'case' dimension.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.carrier_colors","title":"carrier_colors  <code>property</code>","text":"<pre><code>carrier_colors: dict[str, str]\n</code></pre> <p>Merged carrier colors from all cases.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.component_colors","title":"component_colors  <code>property</code>","text":"<pre><code>component_colors: dict[str, str]\n</code></pre> <p>Merged component colors from all cases.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.bus_colors","title":"bus_colors  <code>property</code>","text":"<pre><code>bus_colors: dict[str, str]\n</code></pre> <p>Merged bus colors from all cases.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.carrier_units","title":"carrier_units  <code>property</code>","text":"<pre><code>carrier_units: dict[str, str]\n</code></pre> <p>Merged carrier units from all cases.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.effect_units","title":"effect_units  <code>property</code>","text":"<pre><code>effect_units: dict[str, str]\n</code></pre> <p>Merged effect units from all cases.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatistics.plot","title":"plot  <code>property</code>","text":"<pre><code>plot: ComparisonStatisticsPlot\n</code></pre> <p>Access plot methods for comparison statistics.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatisticsPlot","title":"ComparisonStatisticsPlot","text":"<pre><code>ComparisonStatisticsPlot(statistics: ComparisonStatistics)\n</code></pre> <p>Plot accessor for comparison statistics.</p> <p>Wraps StatisticsPlotAccessor methods, combining data from all FlowSystems with a 'case' dimension for faceting.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatisticsPlot-functions","title":"Functions","text":""},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatisticsPlot.balance","title":"balance","text":"<pre><code>balance(node: str, *, select: SelectType | None = None, include: str | list[str] | None = None, exclude: str | list[str] | None = None, unit: Literal['flow_rate', 'flow_hours'] = 'flow_rate', colors: ColorType | None = None, show: bool | None = None, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot node balance comparison across cases.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Bus or component label to plot balance for.</p> required <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>include</code> <code>str | list[str] | None</code> <p>Filter to include only matching flow labels.</p> <code>None</code> <code>exclude</code> <code>str | list[str] | None</code> <p>Filter to exclude matching flow labels.</p> <code>None</code> <code>unit</code> <code>Literal['flow_rate', 'flow_hours']</code> <p>'flow_rate' or 'flow_hours'.</p> <code>'flow_rate'</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (dict, list, or colorscale name).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure.</p> <code>None</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to plotly.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with combined balance data and figure.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatisticsPlot.carrier_balance","title":"carrier_balance","text":"<pre><code>carrier_balance(carrier: str, *, select: SelectType | None = None, include: str | list[str] | None = None, exclude: str | list[str] | None = None, unit: Literal['flow_rate', 'flow_hours'] = 'flow_rate', colors: ColorType | None = None, show: bool | None = None, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot carrier balance comparison across cases.</p> <p>Parameters:</p> Name Type Description Default <code>carrier</code> <code>str</code> <p>Carrier name to plot balance for.</p> required <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>include</code> <code>str | list[str] | None</code> <p>Filter to include only matching flow labels.</p> <code>None</code> <code>exclude</code> <code>str | list[str] | None</code> <p>Filter to exclude matching flow labels.</p> <code>None</code> <code>unit</code> <code>Literal['flow_rate', 'flow_hours']</code> <p>'flow_rate' or 'flow_hours'.</p> <code>'flow_rate'</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (dict, list, or colorscale name).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure.</p> <code>None</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to plotly.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with combined carrier balance data and figure.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatisticsPlot.flows","title":"flows","text":"<pre><code>flows(*, start: str | list[str] | None = None, end: str | list[str] | None = None, component: str | list[str] | None = None, select: SelectType | None = None, unit: Literal['flow_rate', 'flow_hours'] = 'flow_rate', colors: ColorType | None = None, show: bool | None = None, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot flows comparison across cases.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | list[str] | None</code> <p>Filter by source node(s).</p> <code>None</code> <code>end</code> <code>str | list[str] | None</code> <p>Filter by destination node(s).</p> <code>None</code> <code>component</code> <code>str | list[str] | None</code> <p>Filter by parent component(s).</p> <code>None</code> <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>unit</code> <code>Literal['flow_rate', 'flow_hours']</code> <p>'flow_rate' or 'flow_hours'.</p> <code>'flow_rate'</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (dict, list, or colorscale name).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure.</p> <code>None</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to plotly.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with combined flows data and figure.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatisticsPlot.storage","title":"storage","text":"<pre><code>storage(storage: str, *, select: SelectType | None = None, unit: Literal['flow_rate', 'flow_hours'] = 'flow_rate', colors: ColorType | None = None, show: bool | None = None, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot storage operation comparison across cases.</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>str</code> <p>Storage component label.</p> required <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>unit</code> <code>Literal['flow_rate', 'flow_hours']</code> <p>'flow_rate' or 'flow_hours'.</p> <code>'flow_rate'</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification for flow bars.</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure.</p> <code>None</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to plotly.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with combined storage operation data and figure.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatisticsPlot.charge_states","title":"charge_states","text":"<pre><code>charge_states(storages: str | list[str] | None = None, *, select: SelectType | None = None, colors: ColorType | None = None, show: bool | None = None, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot charge states comparison across cases.</p> <p>Parameters:</p> Name Type Description Default <code>storages</code> <code>str | list[str] | None</code> <p>Storage label(s) to plot. If None, plots all.</p> <code>None</code> <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (dict, list, or colorscale name).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure.</p> <code>None</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to plotly.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with combined charge state data and figure.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatisticsPlot.duration_curve","title":"duration_curve","text":"<pre><code>duration_curve(variables: str | list[str], *, select: SelectType | None = None, normalize: bool = False, colors: ColorType | None = None, show: bool | None = None, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot duration curves comparison across cases.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>str | list[str]</code> <p>Flow label(s) or variable name(s) to plot.</p> required <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>normalize</code> <code>bool</code> <p>If True, normalize x-axis to 0-100%.</p> <code>False</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (dict, list, or colorscale name).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure.</p> <code>None</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to plotly.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with combined duration curve data and figure.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatisticsPlot.sizes","title":"sizes","text":"<pre><code>sizes(*, max_size: float | None = 1000000.0, select: SelectType | None = None, colors: ColorType | None = None, show: bool | None = None, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot investment sizes comparison across cases.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>float | None</code> <p>Maximum size to include (filters defaults).</p> <code>1000000.0</code> <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (dict, list, or colorscale name).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure.</p> <code>None</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to plotly.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with combined sizes data and figure.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatisticsPlot.effects","title":"effects","text":"<pre><code>effects(aspect: Literal['total', 'temporal', 'periodic'] = 'total', *, effect: str | None = None, by: Literal['component', 'contributor', 'time'] | None = None, select: SelectType | None = None, colors: ColorType | None = None, show: bool | None = None, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot effects comparison across cases.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>Literal['total', 'temporal', 'periodic']</code> <p>Which aspect to plot - 'total', 'temporal', or 'periodic'.</p> <code>'total'</code> <code>effect</code> <code>str | None</code> <p>Specific effect name to plot. If None, plots all.</p> <code>None</code> <code>by</code> <code>Literal['component', 'contributor', 'time'] | None</code> <p>Group by 'component', 'contributor', or 'time'.</p> <code>None</code> <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (dict, list, or colorscale name).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure.</p> <code>None</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to plotly.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with combined effects data and figure.</p>"},{"location":"api-reference/comparison/#flixopt.comparison.ComparisonStatisticsPlot.heatmap","title":"heatmap","text":"<pre><code>heatmap(variables: str | list[str], *, select: SelectType | None = None, reshape: tuple[str, str] | Literal['auto'] | None = 'auto', colors: str | list[str] | None = None, show: bool | None = None, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot heatmap comparison across cases.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>str | list[str]</code> <p>Flow label(s) or variable name(s) to plot.</p> required <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>reshape</code> <code>tuple[str, str] | Literal['auto'] | None</code> <p>Time reshape frequencies, 'auto', or None.</p> <code>'auto'</code> <code>colors</code> <code>str | list[str] | None</code> <p>Colorscale name or list of colors.</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure.</p> <code>None</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to plotly.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with combined heatmap data and figure.</p>"},{"location":"api-reference/comparison/#flixopt.comparison-functions","title":"Functions","text":""},{"location":"api-reference/components/","title":"Components","text":""},{"location":"api-reference/components/#flixopt.components","title":"flixopt.components","text":"<p>This module contains the basic components of the flixopt framework.</p>"},{"location":"api-reference/components/#flixopt.components-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components-classes","title":"Classes","text":""},{"location":"api-reference/components/#flixopt.components.LinearConverter","title":"LinearConverter","text":"<pre><code>LinearConverter(label: str, inputs: list[Flow], outputs: list[Flow], status_parameters: StatusParameters | None = None, conversion_factors: list[dict[str, Numeric_TPS]] | None = None, piecewise_conversion: PiecewiseConversion | None = None, meta_data: dict | None = None, color: str | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Converts input-Flows into output-Flows via linear conversion factors.</p> <p>LinearConverter models equipment that transforms one or more input flows into one or more output flows through linear relationships. This includes heat exchangers, electrical converters, chemical reactors, and other equipment where the relationship between inputs and outputs can be expressed as linear equations.</p> <p>The component supports two modeling approaches: simple conversion factors for straightforward linear relationships, or piecewise conversion for complex non-linear behavior approximated through piecewise linear segments.</p> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/elements/LinearConverter/</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow]</code> <p>list of input Flows that feed into the converter.</p> required <code>outputs</code> <code>list[Flow]</code> <p>list of output Flows that are produced by the converter.</p> required <code>status_parameters</code> <code>StatusParameters | None</code> <p>Information about active and inactive state of LinearConverter. Component is active/inactive if all connected Flows are active/inactive. This induces a status variable (binary) in all Flows! If possible, use StatusParameters in a single Flow instead to keep the number of binary variables low.</p> <code>None</code> <code>conversion_factors</code> <code>list[dict[str, Numeric_TPS]] | None</code> <p>Linear relationships between flows expressed as a list of dictionaries. Each dictionary maps flow labels to their coefficients in one linear equation. The number of conversion factors must be less than the total number of flows to ensure degrees of freedom &gt; 0. Either 'conversion_factors' OR 'piecewise_conversion' can be used, but not both. For examples also look into the linear_converters.py file.</p> <code>None</code> <code>piecewise_conversion</code> <code>PiecewiseConversion | None</code> <p>Define piecewise linear relationships between flow rates of different flows. Enables modeling of non-linear conversion behavior through linear approximation. Either 'conversion_factors' or 'piecewise_conversion' can be used, but not both.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally, but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Simple 1:1 heat exchanger with 95% efficiency:</p> <pre><code>heat_exchanger = LinearConverter(\n    label='primary_hx',\n    inputs=[hot_water_in],\n    outputs=[hot_water_out],\n    conversion_factors=[{'hot_water_in': 0.95, 'hot_water_out': 1}],\n)\n</code></pre> <p>Multi-input heat pump with COP=3:</p> <pre><code>heat_pump = LinearConverter(\n    label='air_source_hp',\n    inputs=[electricity_in],\n    outputs=[heat_output],\n    conversion_factors=[{'electricity_in': 3, 'heat_output': 1}],\n)\n</code></pre> <p>Combined heat and power (CHP) unit with multiple outputs:</p> <pre><code>chp_unit = LinearConverter(\n    label='gas_chp',\n    inputs=[natural_gas],\n    outputs=[electricity_out, heat_out],\n    conversion_factors=[\n        {'natural_gas': 0.35, 'electricity_out': 1},\n        {'natural_gas': 0.45, 'heat_out': 1},\n    ],\n)\n</code></pre> <p>Electrolyzer with multiple conversion relationships:</p> <pre><code>electrolyzer = LinearConverter(\n    label='pem_electrolyzer',\n    inputs=[electricity_in, water_in],\n    outputs=[hydrogen_out, oxygen_out],\n    conversion_factors=[\n        {'electricity_in': 1, 'hydrogen_out': 50},  # 50 kWh/kg H2\n        {'water_in': 1, 'hydrogen_out': 9},  # 9 kg H2O/kg H2\n        {'hydrogen_out': 8, 'oxygen_out': 1},  # Mass balance\n    ],\n)\n</code></pre> <p>Complex converter with piecewise efficiency:</p> <pre><code>variable_efficiency_converter = LinearConverter(\n    label='variable_converter',\n    inputs=[fuel_in],\n    outputs=[power_out],\n    piecewise_conversion=PiecewiseConversion(\n        {\n            'fuel_in': Piecewise(\n                [\n                    Piece(0, 10),  # Low load operation\n                    Piece(10, 25),  # High load operation\n                ]\n            ),\n            'power_out': Piecewise(\n                [\n                    Piece(0, 3.5),  # Lower efficiency at part load\n                    Piece(3.5, 10),  # Higher efficiency at full load\n                ]\n            ),\n        }\n    ),\n)\n</code></pre> Note <p>Conversion factors define linear relationships where the sum of (coefficient \u00d7 flow_rate) equals zero for each equation: factor1\u00d7flow1 + factor2\u00d7flow2 + ... = 0 Conversion factors define linear relationships: <code>{flow1: a1, flow2: a2, ...}</code> yields <code>a1\u00d7flow_rate1 + a2\u00d7flow_rate2 + ... = 0</code>. Note: The input format may be unintuitive. For example, <code>{\"electricity\": 1, \"H2\": 50}</code> implies <code>1\u00d7electricity = 50\u00d7H2</code>, i.e., 50 units of electricity produce 1 unit of H2.</p> <p>The system must have fewer conversion factors than total flows (degrees of freedom &gt; 0) to avoid over-constraining the problem. For n total flows, use at most n-1 conversion factors.</p> <p>When using piecewise_conversion, the converter operates on one piece at a time, with binary variables determining which piece is active.</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.LinearConverter.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.flows","title":"flows  <code>cached</code> <code>property</code>","text":"<pre><code>flows: FlowContainer\n</code></pre> <p>All flows (inputs and outputs) as a FlowContainer.</p> Supports access by label_full or short label <p>component.flows['Boiler(Q_th)']  # Full label component.flows['Q_th']          # Short label</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.LinearConverter.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to parent Component and piecewise_conversion.</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/components/#flixopt.components.Storage","title":"Storage","text":"<pre><code>Storage(label: str, charging: Flow, discharging: Flow, capacity_in_flow_hours: Numeric_PS | InvestParameters | None = None, relative_minimum_charge_state: Numeric_TPS = 0, relative_maximum_charge_state: Numeric_TPS = 1, initial_charge_state: Numeric_PS | Literal['equals_final'] | None = 0, minimal_final_charge_state: Numeric_PS | None = None, maximal_final_charge_state: Numeric_PS | None = None, relative_minimum_final_charge_state: Numeric_PS | None = None, relative_maximum_final_charge_state: Numeric_PS | None = None, eta_charge: Numeric_TPS = 1, eta_discharge: Numeric_TPS = 1, relative_loss_per_hour: Numeric_TPS = 0, prevent_simultaneous_charge_and_discharge: bool = True, balanced: bool = False, cluster_mode: Literal['independent', 'cyclic', 'intercluster', 'intercluster_cyclic'] = 'intercluster_cyclic', meta_data: dict | None = None, color: str | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Storage models the temporary storage and release of energy or material.</p> <p>Storages have one incoming and one outgoing Flow, each with configurable efficiency factors. They maintain a charge state variable that represents the stored amount, bounded by capacity limits and evolving over time based on charging, discharging, and self-discharge losses.</p> <p>The storage model handles complex temporal dynamics including initial conditions, final state constraints, and time-varying parameters. It supports both fixed-size and investment-optimized storage systems with comprehensive techno-economic modeling.</p> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/elements/Storage/</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Element identifier used in the FlowSystem.</p> required <code>charging</code> <code>Flow</code> <p>Incoming flow for loading the storage.</p> required <code>discharging</code> <code>Flow</code> <p>Outgoing flow for unloading the storage.</p> required <code>capacity_in_flow_hours</code> <code>Numeric_PS | InvestParameters | None</code> <p>Storage capacity in flow-hours (kWh, m\u00b3, kg). Scalar for fixed size, InvestParameters for optimization, or None (unbounded). Default: None (unbounded capacity). When using InvestParameters, maximum_size (or fixed_size) must be explicitly set for proper model scaling.</p> <code>None</code> <code>relative_minimum_charge_state</code> <code>Numeric_TPS</code> <p>Minimum charge state (0-1). Default: 0.</p> <code>0</code> <code>relative_maximum_charge_state</code> <code>Numeric_TPS</code> <p>Maximum charge state (0-1). Default: 1.</p> <code>1</code> <code>initial_charge_state</code> <code>Numeric_PS | Literal['equals_final'] | None</code> <p>Charge at start. Numeric, 'equals_final', or None (free). Default: 0.</p> <code>0</code> <code>minimal_final_charge_state</code> <code>Numeric_PS | None</code> <p>Minimum absolute charge required at end (optional).</p> <code>None</code> <code>maximal_final_charge_state</code> <code>Numeric_PS | None</code> <p>Maximum absolute charge allowed at end (optional).</p> <code>None</code> <code>relative_minimum_final_charge_state</code> <code>Numeric_PS | None</code> <p>Minimum relative charge at end. Defaults to last value of relative_minimum_charge_state.</p> <code>None</code> <code>relative_maximum_final_charge_state</code> <code>Numeric_PS | None</code> <p>Maximum relative charge at end. Defaults to last value of relative_maximum_charge_state.</p> <code>None</code> <code>eta_charge</code> <code>Numeric_TPS</code> <p>Charging efficiency (0-1). Default: 1.</p> <code>1</code> <code>eta_discharge</code> <code>Numeric_TPS</code> <p>Discharging efficiency (0-1). Default: 1.</p> <code>1</code> <code>relative_loss_per_hour</code> <code>Numeric_TPS</code> <p>Self-discharge per hour (0-0.1). Default: 0.</p> <code>0</code> <code>prevent_simultaneous_charge_and_discharge</code> <code>bool</code> <p>Prevent charging and discharging simultaneously. Adds binary variables. Default: True.</p> <code>True</code> <code>cluster_mode</code> <code>Literal['independent', 'cyclic', 'intercluster', 'intercluster_cyclic']</code> <p>How this storage is treated during clustering optimization. Only relevant when using <code>transform.cluster()</code>. Options:</p> <ul> <li><code>'independent'</code>: Clusters are fully decoupled. No constraints between   clusters, each cluster has free start/end SOC. Fast but ignores   seasonal storage value.</li> <li><code>'cyclic'</code>: Each cluster is self-contained. The SOC at the start of   each cluster equals its end (cluster returns to initial state).   Good for \"average day\" modeling.</li> <li><code>'intercluster'</code>: Link storage state across the original timeline using   SOC boundary variables (Kotzur et al. approach). Properly values   seasonal storage patterns. Overall SOC can drift.</li> <li><code>'intercluster_cyclic'</code> (default): Like 'intercluster' but also enforces   that overall SOC returns to initial state (yearly cyclic).</li> </ul> <code>'intercluster_cyclic'</code> <code>meta_data</code> <code>dict | None</code> <p>Additional information stored in results. Python native types only.</p> <code>None</code> <p>Examples:</p> <p>Battery energy storage system:</p> <pre><code>battery = Storage(\n    label='lithium_battery',\n    charging=battery_charge_flow,\n    discharging=battery_discharge_flow,\n    capacity_in_flow_hours=100,  # 100 kWh capacity\n    eta_charge=0.95,  # 95% charging efficiency\n    eta_discharge=0.95,  # 95% discharging efficiency\n    relative_loss_per_hour=0.001,  # 0.1% loss per hour\n    relative_minimum_charge_state=0.1,  # Never below 10% SOC\n    relative_maximum_charge_state=0.9,  # Never above 90% SOC\n)\n</code></pre> <p>Thermal storage with cycling constraints:</p> <pre><code>thermal_storage = Storage(\n    label='hot_water_tank',\n    charging=heat_input,\n    discharging=heat_output,\n    capacity_in_flow_hours=500,  # 500 kWh thermal capacity\n    initial_charge_state=250,  # Start half full\n    # Impact of temperature on energy capacity\n    relative_maximum_charge_state=water_temperature_spread / rated_temeprature_spread,\n    eta_charge=0.90,  # Heat exchanger losses\n    eta_discharge=0.85,  # Distribution losses\n    relative_loss_per_hour=0.02,  # 2% thermal loss per hour\n    prevent_simultaneous_charge_and_discharge=True,\n)\n</code></pre> <p>Pumped hydro storage with investment optimization:</p> <pre><code>pumped_hydro = Storage(\n    label='pumped_hydro',\n    charging=pump_flow,\n    discharging=turbine_flow,\n    capacity_in_flow_hours=InvestParameters(\n        minimum_size=1000,  # Minimum economic scale\n        maximum_size=10000,  # Site constraints\n        specific_effects={'cost': 150},  # \u20ac150/MWh capacity\n        fix_effects={'cost': 50_000_000},  # \u20ac50M fixed costs\n    ),\n    eta_charge=0.85,  # Pumping efficiency\n    eta_discharge=0.90,  # Turbine efficiency\n    initial_charge_state='equals_final',  # Ensuring no deficit compared to start\n    relative_loss_per_hour=0.0001,  # Minimal evaporation\n)\n</code></pre> <p>Material storage with inventory management:</p> <pre><code>fuel_storage = Storage(\n    label='natural_gas_storage',\n    charging=gas_injection,\n    discharging=gas_withdrawal,\n    capacity_in_flow_hours=10000,  # 10,000 m\u00b3 storage volume\n    initial_charge_state=3000,  # Start with 3,000 m\u00b3\n    minimal_final_charge_state=1000,  # Strategic reserve\n    maximal_final_charge_state=9000,  # Prevent overflow\n    eta_charge=0.98,  # Compression losses\n    eta_discharge=0.95,  # Pressure reduction losses\n    relative_loss_per_hour=0.0005,  # 0.05% leakage per hour\n    prevent_simultaneous_charge_and_discharge=False,  # Allow flow-through\n)\n</code></pre> Note <p>Mathematical formulation: See Storage for charge state evolution equations and balance constraints.</p> <p>Efficiency parameters (eta_charge, eta_discharge) are dimensionless (0-1 range). The relative_loss_per_hour represents exponential decay per hour.</p> <p>Binary variables: When prevent_simultaneous_charge_and_discharge is True, binary variables enforce mutual exclusivity, increasing solution time but preventing unrealistic simultaneous charging and discharging.</p> <p>Unbounded capacity: When capacity_in_flow_hours is None (default), the storage has unlimited capacity. Note that prevent_simultaneous_charge_and_discharge requires the charging and discharging flows to have explicit sizes. Use prevent_simultaneous_charge_and_discharge=False with unbounded storages, or set flow sizes explicitly.</p> <p>Units: Flow rates and charge states are related by the concept of 'flow hours' (=flow_rate * time). With flow rates in kW, the charge state is therefore (usually) kWh. With flow rates in m3/h, the charge state is therefore in m3.</p>"},{"location":"api-reference/components/#flixopt.components.Storage-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.Storage.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/components/#flixopt.components.Storage.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/components/#flixopt.components.Storage.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/components/#flixopt.components.Storage.flows","title":"flows  <code>cached</code> <code>property</code>","text":"<pre><code>flows: FlowContainer\n</code></pre> <p>All flows (inputs and outputs) as a FlowContainer.</p> Supports access by label_full or short label <p>component.flows['Boiler(Q_th)']  # Full label component.flows['Q_th']          # Short label</p>"},{"location":"api-reference/components/#flixopt.components.Storage-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Storage.create_model","title":"create_model","text":"<pre><code>create_model(model: FlowSystemModel) -&gt; StorageModel\n</code></pre> <p>Create the appropriate storage model based on cluster_mode and flow system state.</p> <p>For intercluster modes ('intercluster', 'intercluster_cyclic'), uses :class:<code>InterclusterStorageModel</code> which implements S-N linking. For other modes, uses the base :class:<code>StorageModel</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FlowSystemModel</code> <p>The FlowSystemModel to add constraints to.</p> required <p>Returns:</p> Type Description <code>StorageModel</code> <p>StorageModel or InterclusterStorageModel instance.</p>"},{"location":"api-reference/components/#flixopt.components.Storage.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to parent Component and capacity_in_flow_hours if it's InvestParameters.</p>"},{"location":"api-reference/components/#flixopt.components.Storage.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/components/#flixopt.components.Storage.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Storage.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/components/#flixopt.components.Storage.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/components/#flixopt.components.Storage.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/components/#flixopt.components.Storage.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Storage.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/components/#flixopt.components.Transmission","title":"Transmission","text":"<pre><code>Transmission(label: str, in1: Flow, out1: Flow, in2: Flow | None = None, out2: Flow | None = None, relative_losses: Numeric_TPS | None = None, absolute_losses: Numeric_TPS | None = None, status_parameters: StatusParameters | None = None, prevent_simultaneous_flows_in_both_directions: bool = True, balanced: bool = False, meta_data: dict | None = None, color: str | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Models transmission infrastructure that transports flows between two locations with losses.</p> <p>Transmission components represent physical infrastructure like pipes, cables, transmission lines, or conveyor systems that transport energy or materials between two points. They can model both unidirectional and bidirectional flow with configurable loss mechanisms and operational constraints.</p> <p>The component supports complex transmission scenarios including relative losses (proportional to flow), absolute losses (fixed when active), and bidirectional operation with flow direction constraints.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>in1</code> <code>Flow</code> <p>The primary inflow (side A). Pass InvestParameters here for capacity optimization.</p> required <code>out1</code> <code>Flow</code> <p>The primary outflow (side B).</p> required <code>in2</code> <code>Flow | None</code> <p>Optional secondary inflow (side B) for bidirectional operation. If in1 has InvestParameters, in2 will automatically have matching capacity.</p> <code>None</code> <code>out2</code> <code>Flow | None</code> <p>Optional secondary outflow (side A) for bidirectional operation.</p> <code>None</code> <code>relative_losses</code> <code>Numeric_TPS | None</code> <p>Proportional losses as fraction of throughput (e.g., 0.02 for 2% loss). Applied as: output = input \u00d7 (1 - relative_losses)</p> <code>None</code> <code>absolute_losses</code> <code>Numeric_TPS | None</code> <p>Fixed losses that occur when transmission is active. Automatically creates binary variables for active/inactive states.</p> <code>None</code> <code>status_parameters</code> <code>StatusParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>prevent_simultaneous_flows_in_both_directions</code> <code>bool</code> <p>If True, prevents simultaneous flow in both directions. Increases binary variables but reflects physical reality for most transmission systems. Default is True.</p> <code>True</code> <code>balanced</code> <code>bool</code> <p>Whether to equate the size of the in1 and in2 Flow. Needs InvestParameters in both Flows.</p> <code>False</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Simple electrical transmission line:</p> <pre><code>power_line = Transmission(\n    label='110kv_line',\n    in1=substation_a_out,\n    out1=substation_b_in,\n    relative_losses=0.03,  # 3% line losses\n)\n</code></pre> <p>Bidirectional natural gas pipeline:</p> <pre><code>gas_pipeline = Transmission(\n    label='interstate_pipeline',\n    in1=compressor_station_a,\n    out1=distribution_hub_b,\n    in2=compressor_station_b,\n    out2=distribution_hub_a,\n    relative_losses=0.005,  # 0.5% friction losses\n    absolute_losses=50,  # 50 kW compressor power when active\n    prevent_simultaneous_flows_in_both_directions=True,\n)\n</code></pre> <p>District heating network with investment optimization:</p> <pre><code>heating_network = Transmission(\n    label='dh_main_line',\n    in1=Flow(\n        label='heat_supply',\n        bus=central_plant_bus,\n        size=InvestParameters(\n            minimum_size=1000,  # Minimum 1 MW capacity\n            maximum_size=10000,  # Maximum 10 MW capacity\n            specific_effects={'cost': 200},  # \u20ac200/kW capacity\n            fix_effects={'cost': 500000},  # \u20ac500k fixed installation\n        ),\n    ),\n    out1=district_heat_demand,\n    relative_losses=0.15,  # 15% thermal losses in distribution\n)\n</code></pre> <p>Material conveyor with active/inactive status:</p> <pre><code>conveyor_belt = Transmission(\n    label='material_transport',\n    in1=loading_station,\n    out1=unloading_station,\n    absolute_losses=25,  # 25 kW motor power when running\n    status_parameters=StatusParameters(\n        effects_per_startup={'maintenance': 0.1},\n        min_uptime=2,  # Minimum 2-hour operation\n        startup_limit=10,  # Maximum 10 starts per period\n    ),\n)\n</code></pre> Note <p>The transmission equation balances flows with losses: output_flow = input_flow \u00d7 (1 - relative_losses) - absolute_losses</p> <p>For bidirectional transmission, each direction has independent loss calculations.</p> <p>When using InvestParameters on in1, the capacity automatically applies to in2 to maintain consistent bidirectional capacity without additional investment variables.</p> <p>Absolute losses force the creation of binary on/inactive variables, which increases computational complexity but enables realistic modeling of equipment with standby power consumption.</p>"},{"location":"api-reference/components/#flixopt.components.Transmission-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.Transmission.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.flows","title":"flows  <code>cached</code> <code>property</code>","text":"<pre><code>flows: FlowContainer\n</code></pre> <p>All flows (inputs and outputs) as a FlowContainer.</p> Supports access by label_full or short label <p>component.flows['Boiler(Q_th)']  # Full label component.flows['Q_th']          # Short label</p>"},{"location":"api-reference/components/#flixopt.components.Transmission-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Transmission.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to nested Interface objects and flows.</p> <p>Elements use their label_full as prefix by default, ignoring the passed prefix.</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel","title":"TransmissionModel","text":"<pre><code>TransmissionModel(model: FlowSystemModel, element: Transmission)\n</code></pre> <p>               Bases: <code>ComponentModel</code></p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.TransmissionModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.previous_status","title":"previous_status  <code>property</code>","text":"<pre><code>previous_status: DataArray | None\n</code></pre> <p>Previous status of the component, derived from its flows</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.TransmissionModel.create_transmission_equation","title":"create_transmission_equation","text":"<pre><code>create_transmission_equation(name: str, in_flow: Flow, out_flow: Flow) -&gt; linopy.Constraint\n</code></pre> <p>Creates an Equation for the Transmission efficiency and adds it to the model</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverterModel","title":"LinearConverterModel","text":"<pre><code>LinearConverterModel(model: FlowSystemModel, element: LinearConverter)\n</code></pre> <p>               Bases: <code>ComponentModel</code></p> <p>Mathematical model implementation for LinearConverter components.</p> <p>Creates optimization constraints for linear conversion relationships between input and output flows, supporting both simple conversion factors and piecewise non-linear approximations.</p> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/elements/LinearConverter/</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverterModel-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.LinearConverterModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverterModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverterModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverterModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverterModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverterModel.previous_status","title":"previous_status  <code>property</code>","text":"<pre><code>previous_status: DataArray | None\n</code></pre> <p>Previous status of the component, derived from its flows</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverterModel-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.LinearConverterModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverterModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverterModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverterModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverterModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverterModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel","title":"StorageModel","text":"<pre><code>StorageModel(model: FlowSystemModel, element: Storage)\n</code></pre> <p>               Bases: <code>ComponentModel</code></p> <p>Mathematical model implementation for Storage components.</p> <p>Creates optimization variables and constraints for charge state tracking, storage balance equations, and optional investment sizing.</p> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/elements/Storage/</p> Note <p>This class uses a template method pattern. Subclasses (e.g., InterclusterStorageModel) can override individual methods to customize behavior without duplicating code.</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.StorageModel.investment","title":"investment  <code>property</code>","text":"<pre><code>investment: InvestmentModel | None\n</code></pre> <p>Investment feature</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.charge_state","title":"charge_state  <code>property</code>","text":"<pre><code>charge_state: Variable\n</code></pre> <p>Charge state variable</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.netto_discharge","title":"netto_discharge  <code>property</code>","text":"<pre><code>netto_discharge: Variable\n</code></pre> <p>Netto discharge variable</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.previous_status","title":"previous_status  <code>property</code>","text":"<pre><code>previous_status: DataArray | None\n</code></pre> <p>Previous status of the component, derived from its flows</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.StorageModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel","title":"InterclusterStorageModel","text":"<pre><code>InterclusterStorageModel(model: FlowSystemModel, element: Storage)\n</code></pre> <p>               Bases: <code>StorageModel</code></p> <p>Storage model with inter-cluster linking for clustered optimization.</p> <p>This class extends :class:<code>StorageModel</code> to support inter-cluster storage linking when using time series aggregation (clustering). It implements the S-N linking model from Blanke et al. (2022) to properly value seasonal storage in clustered optimizations.</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel--the-problem-with-naive-clustering","title":"The Problem with Naive Clustering","text":"<p>When time series are clustered (e.g., 365 days \u2192 8 typical days), storage behavior is fundamentally misrepresented if each cluster operates independently:</p> <ul> <li>Seasonal patterns are lost: A battery might charge in summer and discharge in   winter, but with independent clusters, each \"typical summer day\" cannot transfer   energy to the \"typical winter day\".</li> <li>Storage value is underestimated: Without inter-cluster linking, storage can only   provide intra-day flexibility, not seasonal arbitrage.</li> </ul>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel--the-s-n-linking-model","title":"The S-N Linking Model","text":"<p>This model introduces two key concepts:</p> <ol> <li> <p>SOC_boundary: Absolute state-of-charge at the boundary between original periods.    With N original periods, there are N+1 boundary points (including start and end).</p> </li> <li> <p>charge_state (\u0394E): Relative change in SOC within each representative cluster,    measured from the cluster start (where \u0394E = 0).</p> </li> </ol> <p>The actual SOC at any timestep t within original period d is::</p> <pre><code>SOC(t) = SOC_boundary[d] + \u0394E(t)\n</code></pre>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel--key-constraints","title":"Key Constraints","text":"<ol> <li> <p>Cluster start constraint: <code>\u0394E(cluster_start) = 0</code>    Each representative cluster starts with zero relative charge.</p> </li> <li> <p>Linking constraint: <code>SOC_boundary[d+1] = SOC_boundary[d] + delta_SOC[cluster_assignments[d]]</code>    The boundary SOC after period d equals the boundary before plus the net    charge/discharge of the representative cluster for that period.</p> </li> <li> <p>Combined bounds: <code>0 \u2264 SOC_boundary[d] + \u0394E(t) \u2264 capacity</code>    The actual SOC must stay within physical bounds.</p> </li> <li> <p>Cyclic constraint (for <code>intercluster_cyclic</code> mode):    <code>SOC_boundary[0] = SOC_boundary[N]</code>    The storage returns to its initial state over the full time horizon.</p> </li> </ol>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel--variables-created","title":"Variables Created","text":"<ul> <li><code>SOC_boundary</code>: Absolute SOC at each original period boundary.   Shape: (n_original_clusters + 1,) plus any period/scenario dimensions.</li> </ul>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel--constraints-created","title":"Constraints Created","text":"<ul> <li><code>cluster_start</code>: Forces \u0394E = 0 at start of each representative cluster.</li> <li><code>link</code>: Links consecutive SOC_boundary values via delta_SOC.</li> <li><code>cyclic</code> or <code>initial_SOC_boundary</code>: Initial/final boundary condition.</li> <li><code>soc_lb_start/mid/end</code>: Lower bound on combined SOC at sample points.</li> <li><code>soc_ub_start/mid/end</code>: Upper bound on combined SOC (if investment).</li> <li><code>SOC_boundary_ub</code>: Links SOC_boundary to investment size (if investment).</li> <li><code>charge_state|lb/ub</code>: Symmetric bounds on \u0394E for intercluster modes.</li> </ul>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel--references","title":"References","text":"<ul> <li>Blanke, T., et al. (2022). \"Inter-Cluster Storage Linking for Time Series   Aggregation in Energy System Optimization Models.\"</li> <li>Kotzur, L., et al. (2018). \"Time series aggregation for energy system design:   Modeling seasonal storage.\"</li> </ul>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel--see-also","title":"See Also","text":"<p>:class:<code>StorageModel</code> : Base storage model without inter-cluster linking. :class:<code>Storage</code> : The element class that creates this model.</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel--example","title":"Example","text":"<p>The model is automatically used when a Storage has <code>cluster_mode='intercluster'</code> or <code>cluster_mode='intercluster_cyclic'</code> and the FlowSystem has been clustered::</p> <pre><code>storage = Storage(\n    label='seasonal_storage',\n    charging=charge_flow,\n    discharging=discharge_flow,\n    capacity_in_flow_hours=InvestParameters(maximum_size=10000),\n    cluster_mode='intercluster_cyclic',  # Enable inter-cluster linking\n)\n\n# Cluster the flow system\nfs_clustered = flow_system.transform.cluster(n_clusters=8)\nfs_clustered.optimize(solver)\n\n# Access the SOC_boundary in results\nsoc_boundary = fs_clustered.solution['seasonal_storage|SOC_boundary']\n</code></pre>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.previous_status","title":"previous_status  <code>property</code>","text":"<pre><code>previous_status: DataArray | None\n</code></pre> <p>Previous status of the component, derived from its flows</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.investment","title":"investment  <code>property</code>","text":"<pre><code>investment: InvestmentModel | None\n</code></pre> <p>Investment feature</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.charge_state","title":"charge_state  <code>property</code>","text":"<pre><code>charge_state: Variable\n</code></pre> <p>Charge state variable</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.netto_discharge","title":"netto_discharge  <code>property</code>","text":"<pre><code>netto_discharge: Variable\n</code></pre> <p>Netto discharge variable</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/components/#flixopt.components.InterclusterStorageModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink","title":"SourceAndSink","text":"<pre><code>SourceAndSink(label: str, inputs: list[Flow] | None = None, outputs: list[Flow] | None = None, prevent_simultaneous_flow_rates: bool = True, meta_data: dict | None = None, color: str | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A SourceAndSink combines both supply and demand capabilities in a single component.</p> <p>SourceAndSink components can both consume AND provide energy or material flows from and to the system, making them ideal for modeling markets, (simple) storage facilities, or bidirectional grid connections where buying and selling occur at the same location.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>Input-flows into the SourceAndSink representing consumption/demand side.</p> <code>None</code> <code>outputs</code> <code>list[Flow] | None</code> <p>Output-flows from the SourceAndSink representing supply/generation side.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, prevents simultaneous input and output flows. This enforces that the component operates either as a source OR sink at any given time, but not both simultaneously. Default is True.</p> <code>True</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Electricity market connection (buy/sell to grid):</p> <pre><code>electricity_market = SourceAndSink(\n    label='grid_connection',\n    inputs=[electricity_purchase],  # Buy from grid\n    outputs=[electricity_sale],  # Sell to grid\n    prevent_simultaneous_flow_rates=True,  # Can't buy and sell simultaneously\n)\n</code></pre> <p>Natural gas storage facility:</p> <pre><code>gas_storage_facility = SourceAndSink(\n    label='underground_gas_storage',\n    inputs=[gas_injection_flow],  # Inject gas into storage\n    outputs=[gas_withdrawal_flow],  # Withdraw gas from storage\n    prevent_simultaneous_flow_rates=True,  # Injection or withdrawal, not both\n)\n</code></pre> <p>District heating network connection:</p> <pre><code>dh_connection = SourceAndSink(\n    label='district_heating_tie',\n    inputs=[heat_purchase_flow],  # Purchase heat from network\n    outputs=[heat_sale_flow],  # Sell excess heat to network\n    prevent_simultaneous_flow_rates=False,  # May allow simultaneous flows\n)\n</code></pre> <p>Industrial waste heat exchange:</p> <pre><code>waste_heat_exchange = SourceAndSink(\n    label='industrial_heat_hub',\n    inputs=[\n        waste_heat_input_a,  # Receive waste heat from process A\n        waste_heat_input_b,  # Receive waste heat from process B\n    ],\n    outputs=[\n        useful_heat_supply_c,  # Supply heat to process C\n        useful_heat_supply_d,  # Supply heat to process D\n    ],\n    prevent_simultaneous_flow_rates=False,  # Multiple simultaneous flows allowed\n)\n</code></pre> Note <p>When prevent_simultaneous_flow_rates is True, binary variables are created to ensure mutually exclusive operation between input and output flows, which increases computational complexity but reflects realistic market or storage operation constraints.</p> <p>SourceAndSink is particularly useful for modeling: - Energy markets with bidirectional trading - Storage facilities with injection/withdrawal operations - Grid tie points with import/export capabilities - Waste exchange networks with multiple participants</p> Deprecated <p>The deprecated <code>sink</code> and <code>source</code> kwargs are accepted for compatibility but will be removed in future releases.</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.SourceAndSink.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.flows","title":"flows  <code>cached</code> <code>property</code>","text":"<pre><code>flows: FlowContainer\n</code></pre> <p>All flows (inputs and outputs) as a FlowContainer.</p> Supports access by label_full or short label <p>component.flows['Boiler(Q_th)']  # Full label component.flows['Q_th']          # Short label</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.SourceAndSink.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to nested Interface objects and flows.</p> <p>Elements use their label_full as prefix by default, ignoring the passed prefix.</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/components/#flixopt.components.Source","title":"Source","text":"<pre><code>Source(label: str, outputs: list[Flow] | None = None, meta_data: dict | None = None, prevent_simultaneous_flow_rates: bool = False, color: str | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Source generates or provides energy or material flows into the system.</p> <p>Sources represent supply points like power plants, fuel suppliers, renewable energy sources, or any system boundary where flows originate. They provide unlimited supply capability subject to flow constraints, demand patterns and effects.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>outputs</code> <code>list[Flow] | None</code> <p>Output-flows from the source. Can be single flow or list of flows for sources providing multiple commodities or services.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, only one output flow can be active at a time. Useful for modeling mutually exclusive supply options. Default is False.</p> <code>False</code> <p>Examples:</p> <p>Simple electricity grid connection:</p> <pre><code>grid_source = Source(label='electrical_grid', outputs=[grid_electricity_flow])\n</code></pre> <p>Natural gas supply with cost and capacity constraints:</p> <pre><code>gas_supply = Source(\n    label='gas_network',\n    outputs=[\n        Flow(\n            label='natural_gas_flow',\n            bus=gas_bus,\n            size=1000,  # Maximum 1000 kW supply capacity\n            effects_per_flow_hour={'cost': 0.04},  # \u20ac0.04/kWh gas cost\n        )\n    ],\n)\n</code></pre> <p>Multi-fuel power plant with switching constraints:</p> <pre><code>multi_fuel_plant = Source(\n    label='flexible_generator',\n    outputs=[coal_electricity, gas_electricity, biomass_electricity],\n    prevent_simultaneous_flow_rates=True,  # Can only use one fuel at a time\n)\n</code></pre> <p>Renewable energy source with investment optimization:</p> <pre><code>solar_farm = Source(\n    label='solar_pv',\n    outputs=[\n        Flow(\n            label='solar_power',\n            bus=electricity_bus,\n            size=InvestParameters(\n                minimum_size=0,\n                maximum_size=50000,  # Up to 50 MW\n                specific_effects={'cost': 800},  # \u20ac800/kW installed\n                fix_effects={'cost': 100000},  # \u20ac100k development costs\n            ),\n            fixed_relative_profile=solar_profile,  # Hourly generation profile\n        )\n    ],\n)\n</code></pre> Deprecated <p>The deprecated <code>source</code> kwarg is accepted for compatibility but will be removed in future releases.</p>"},{"location":"api-reference/components/#flixopt.components.Source-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.Source.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/components/#flixopt.components.Source.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/components/#flixopt.components.Source.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/components/#flixopt.components.Source.flows","title":"flows  <code>cached</code> <code>property</code>","text":"<pre><code>flows: FlowContainer\n</code></pre> <p>All flows (inputs and outputs) as a FlowContainer.</p> Supports access by label_full or short label <p>component.flows['Boiler(Q_th)']  # Full label component.flows['Q_th']          # Short label</p>"},{"location":"api-reference/components/#flixopt.components.Source-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Source.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to nested Interface objects and flows.</p> <p>Elements use their label_full as prefix by default, ignoring the passed prefix.</p>"},{"location":"api-reference/components/#flixopt.components.Source.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/components/#flixopt.components.Source.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Source.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/components/#flixopt.components.Source.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/components/#flixopt.components.Source.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/components/#flixopt.components.Source.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Source.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/components/#flixopt.components.Sink","title":"Sink","text":"<pre><code>Sink(label: str, inputs: list[Flow] | None = None, meta_data: dict | None = None, prevent_simultaneous_flow_rates: bool = False, color: str | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Sink consumes energy or material flows from the system.</p> <p>Sinks represent demand points like electrical loads, heat demands, material consumption, or any system boundary where flows terminate. They provide unlimited consumption capability subject to flow constraints, demand patterns and effects.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>Input-flows into the sink. Can be single flow or list of flows for sinks consuming multiple commodities or services.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, only one input flow can be active at a time. Useful for modeling mutually exclusive consumption options. Default is False.</p> <code>False</code> <p>Examples:</p> <p>Simple electrical demand:</p> <pre><code>electrical_load = Sink(label='building_load', inputs=[electricity_demand_flow])\n</code></pre> <p>Heat demand with time-varying profile:</p> <pre><code>heat_demand = Sink(\n    label='district_heating_load',\n    inputs=[\n        Flow(\n            label='heat_consumption',\n            bus=heat_bus,\n            fixed_relative_profile=hourly_heat_profile,  # Demand profile\n            size=2000,  # Peak demand of 2000 kW\n        )\n    ],\n)\n</code></pre> <p>Multi-energy building with switching capabilities:</p> <pre><code>flexible_building = Sink(\n    label='smart_building',\n    inputs=[electricity_heating, gas_heating, heat_pump_heating],\n    prevent_simultaneous_flow_rates=True,  # Can only use one heating mode\n)\n</code></pre> <p>Industrial process with variable demand:</p> <pre><code>factory_load = Sink(\n    label='manufacturing_plant',\n    inputs=[\n        Flow(\n            label='electricity_process',\n            bus=electricity_bus,\n            size=5000,  # Base electrical load\n            effects_per_flow_hour={'cost': -0.1},  # Value of service (negative cost)\n        ),\n        Flow(\n            label='steam_process',\n            bus=steam_bus,\n            size=3000,  # Process steam demand\n            fixed_relative_profile=production_schedule,\n        ),\n    ],\n)\n</code></pre> Deprecated <p>The deprecated <code>sink</code> kwarg is accepted for compatibility but will be removed in future releases.</p> <p>Initialize a Sink (consumes flow from the system).</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Unique element label.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>Input flows for the sink.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Arbitrary metadata attached to the element.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, prevents simultaneous nonzero flow rates across the element's inputs by wiring that restriction into the base Component setup.</p> <code>False</code> <code>color</code> <code>str | None</code> <p>Optional color for visualizations.</p> <code>None</code>"},{"location":"api-reference/components/#flixopt.components.Sink-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.Sink.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/components/#flixopt.components.Sink.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/components/#flixopt.components.Sink.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/components/#flixopt.components.Sink.flows","title":"flows  <code>cached</code> <code>property</code>","text":"<pre><code>flows: FlowContainer\n</code></pre> <p>All flows (inputs and outputs) as a FlowContainer.</p> Supports access by label_full or short label <p>component.flows['Boiler(Q_th)']  # Full label component.flows['Q_th']          # Short label</p>"},{"location":"api-reference/components/#flixopt.components.Sink-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Sink.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to nested Interface objects and flows.</p> <p>Elements use their label_full as prefix by default, ignoring the passed prefix.</p>"},{"location":"api-reference/components/#flixopt.components.Sink.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/components/#flixopt.components.Sink.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Sink.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/components/#flixopt.components.Sink.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/components/#flixopt.components.Sink.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/components/#flixopt.components.Sink.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/components/#flixopt.components.Sink.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/components/#flixopt.components-functions","title":"Functions","text":""},{"location":"api-reference/config/","title":"Config","text":""},{"location":"api-reference/config/#flixopt.config","title":"flixopt.config","text":""},{"location":"api-reference/config/#flixopt.config-classes","title":"Classes","text":""},{"location":"api-reference/config/#flixopt.config.MultilineFormatter","title":"MultilineFormatter","text":"<pre><code>MultilineFormatter(*args, **kwargs)\n</code></pre> <p>               Bases: <code>Formatter</code></p> <p>Custom formatter that handles multi-line messages with box-style borders.</p> <p>Uses Unicode box-drawing characters for prettier output, with a fallback to simple formatting if any encoding issues occur.</p>"},{"location":"api-reference/config/#flixopt.config.MultilineFormatter-functions","title":"Functions","text":""},{"location":"api-reference/config/#flixopt.config.MultilineFormatter.format","title":"format","text":"<pre><code>format(record)\n</code></pre> <p>Format multi-line messages with box-style borders for better readability.</p>"},{"location":"api-reference/config/#flixopt.config.ColoredMultilineFormatter","title":"ColoredMultilineFormatter","text":"<p>               Bases: <code>ColoredFormatter</code></p> <p>Colored formatter with multi-line message support.</p> <p>Uses Unicode box-drawing characters for prettier output, with a fallback to simple formatting if any encoding issues occur.</p>"},{"location":"api-reference/config/#flixopt.config.ColoredMultilineFormatter-functions","title":"Functions","text":""},{"location":"api-reference/config/#flixopt.config.ColoredMultilineFormatter.format","title":"format","text":"<pre><code>format(record)\n</code></pre> <p>Format multi-line messages with colors and box-style borders.</p>"},{"location":"api-reference/config/#flixopt.config.CONFIG","title":"CONFIG","text":"<p>Configuration for flixopt library.</p> <p>Attributes:</p> Name Type Description <code>Logging</code> <p>Logging configuration (see CONFIG.Logging for details).</p> <code>Modeling</code> <p>Optimization modeling parameters.</p> <code>Solving</code> <p>Solver configuration and default parameters.</p> <code>Plotting</code> <p>Plotting configuration.</p> <code>config_name</code> <code>str</code> <p>Configuration name.</p> <p>Examples:</p> <pre><code># Quick logging setup\nCONFIG.Logging.enable_console('INFO')\n\n# Or use presets (affects logging, plotting, solver output)\nCONFIG.exploring()  # Interactive exploration\nCONFIG.debug()  # Troubleshooting\nCONFIG.production()  # Production deployment\nCONFIG.silent()  # No output\n\n# Adjust other settings\nCONFIG.Solving.mip_gap = 0.001\nCONFIG.Plotting.default_dpi = 600\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG-classes","title":"Classes","text":""},{"location":"api-reference/config/#flixopt.config.CONFIG.Logging","title":"Logging","text":"<p>Logging configuration helpers.</p> <p>flixopt is silent by default (WARNING level, no handlers).</p> Quick Start - Use Presets <p>These presets configure logging along with plotting and solver output:</p> Preset Console Logs File Logs Plots Solver Output Use Case <code>CONFIG.exploring()</code> INFO (colored) No Browser Yes Interactive exploration <code>CONFIG.debug()</code> DEBUG (colored) No Default Yes Troubleshooting <code>CONFIG.production('app.log')</code> No INFO No No Production deployments <code>CONFIG.silent()</code> No No No No Silent operation <p>Examples:     <pre><code>CONFIG.exploring()  # Start exploring interactively\nCONFIG.debug()  # See everything for troubleshooting\nCONFIG.production('logs/prod.log')  # Production mode\n</code></pre></p> Direct Control - Logging Only <p>For fine-grained control of logging without affecting other settings:</p> <p>Methods:     - <code>enable_console(level='INFO', colored=True, stream=None)</code>     - <code>enable_file(level='INFO', path='flixopt.log', max_bytes=10MB, backup_count=5)</code>     - <code>disable()</code> - Remove all handlers     - <code>set_colors(log_colors)</code> - Customize level colors</p> <p>Log Levels:     Standard levels plus custom SUCCESS level (between INFO and WARNING):     - DEBUG (10): Detailed debugging information     - INFO (20): General informational messages     - SUCCESS (25): Success messages (custom level)     - WARNING (30): Warning messages     - ERROR (40): Error messages     - CRITICAL (50): Critical error messages</p> <p>Examples:     <pre><code>import logging\nfrom flixopt.config import CONFIG, SUCCESS_LEVEL\n\n# Console and file logging\nCONFIG.Logging.enable_console('INFO')\nCONFIG.Logging.enable_file('DEBUG', 'debug.log')\n\n# Use SUCCESS level with logger.log()\nlogger = logging.getLogger('flixopt')\nCONFIG.Logging.enable_console('SUCCESS')  # Shows SUCCESS, WARNING, ERROR, CRITICAL\nlogger.log(SUCCESS_LEVEL, 'Operation completed successfully!')\n\n# Or use numeric level directly\nlogger.log(25, 'Also works with numeric level')\n\n# Customize colors\nCONFIG.Logging.set_colors(\n    {\n        'INFO': 'bold_white',\n        'SUCCESS': 'bold_green,bg_black',\n        'CRITICAL': 'bold_white,bg_red',\n    }\n)\n\n# Non-colored output\nCONFIG.Logging.enable_console('INFO', colored=False)\n</code></pre></p> Advanced Customization <p>For full control, use Python's standard logging or create custom formatters:</p> <pre><code># Custom formatter\nfrom flixopt.config import ColoredMultilineFormatter\nimport colorlog, logging\n\nhandler = colorlog.StreamHandler()\nhandler.setFormatter(ColoredMultilineFormatter(...))\nlogging.getLogger('flixopt').addHandler(handler)\n\n# Or standard Python logging\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')\n</code></pre> Note <p>Default formatters (MultilineFormatter and ColoredMultilineFormatter) provide pretty output with box borders for multi-line messages.</p>"},{"location":"api-reference/config/#flixopt.config.CONFIG.Logging-functions","title":"Functions","text":"enable_console <code>classmethod</code> \u00b6 <pre><code>enable_console(level: str | int = 'INFO', colored: bool = True, stream: TextIO | None = None) -&gt; None\n</code></pre> <p>Enable colored console logging.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str | int</code> <p>Log level (DEBUG, INFO, SUCCESS, WARNING, ERROR, CRITICAL or numeric level)</p> <code>'INFO'</code> <code>colored</code> <code>bool</code> <p>Use colored output if colorlog is available (default: True)</p> <code>True</code> <code>stream</code> <code>TextIO | None</code> <p>Output stream (default: sys.stdout). Can be sys.stdout or sys.stderr.</p> <code>None</code> Note <p>For full control over formatting, use logging.basicConfig() instead.</p> <p>Examples:</p> <pre><code># Colored output to stdout (default)\nCONFIG.Logging.enable_console('INFO')\n\n# Plain text output\nCONFIG.Logging.enable_console('INFO', colored=False)\n\n# Log to stderr instead\nimport sys\n\nCONFIG.Logging.enable_console('INFO', stream=sys.stderr)\n\n# Using logging constants\nimport logging\n\nCONFIG.Logging.enable_console(logging.DEBUG)\n</code></pre> enable_file <code>classmethod</code> \u00b6 <pre><code>enable_file(level: str | int = 'INFO', path: str | Path = 'flixopt.log', max_bytes: int = 10 * 1024 * 1024, backup_count: int = 5, encoding: str = 'utf-8') -&gt; None\n</code></pre> <p>Enable file logging with rotation. Removes all existing file handlers!</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str | int</code> <p>Log level (DEBUG, INFO, SUCCESS, WARNING, ERROR, CRITICAL or numeric level)</p> <code>'INFO'</code> <code>path</code> <code>str | Path</code> <p>Path to log file (default: 'flixopt.log')</p> <code>'flixopt.log'</code> <code>max_bytes</code> <code>int</code> <p>Maximum file size before rotation in bytes (default: 10MB)</p> <code>10 * 1024 * 1024</code> <code>backup_count</code> <code>int</code> <p>Number of backup files to keep (default: 5)</p> <code>5</code> <code>encoding</code> <code>str</code> <p>File encoding (default: 'utf-8'). Use 'utf-8' for maximum compatibility.</p> <code>'utf-8'</code> Note <p>For full control over formatting and handlers, use logging module directly.</p> <p>Examples:</p> <pre><code># Basic file logging\nCONFIG.Logging.enable_file('INFO', 'app.log')\n\n# With custom rotation\nCONFIG.Logging.enable_file('DEBUG', 'debug.log', max_bytes=50 * 1024 * 1024, backup_count=10)\n\n# With explicit encoding\nCONFIG.Logging.enable_file('INFO', 'app.log', encoding='utf-8')\n</code></pre> disable <code>classmethod</code> \u00b6 <pre><code>disable() -&gt; None\n</code></pre> <p>Disable all flixopt logging.</p> <p>Examples:</p> <pre><code>CONFIG.Logging.disable()\n</code></pre> set_colors <code>classmethod</code> \u00b6 <pre><code>set_colors(log_colors: dict[str, str]) -&gt; None\n</code></pre> <p>Customize log level colors for console output.</p> <p>This updates the colors for the current console handler. If no console handler exists, this does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>log_colors</code> <code>dict[str, str]</code> <p>Dictionary mapping log levels to color names. Colors can be comma-separated for multiple attributes (e.g., 'bold_red,bg_white').</p> required Available colors <ul> <li>Basic: black, red, green, yellow, blue, purple, cyan, white</li> <li>Bold: bold_red, bold_green, bold_yellow, bold_blue, etc.</li> <li>Light: light_red, light_green, light_yellow, light_blue, etc.</li> <li>Backgrounds: bg_red, bg_green, bg_light_red, etc.</li> <li>Combined: 'bold_white,bg_red' for white text on red background</li> </ul> <p>Examples:</p> <pre><code># Enable console first\nCONFIG.Logging.enable_console('INFO')\n\n# Then customize colors\nCONFIG.Logging.set_colors(\n    {\n        'DEBUG': 'cyan',\n        'INFO': 'bold_white',\n        'SUCCESS': 'bold_green',\n        'WARNING': 'bold_yellow,bg_black',  # Yellow on black\n        'ERROR': 'bold_red',\n        'CRITICAL': 'bold_white,bg_red',  # White on red\n    }\n)\n</code></pre> Note <p>Requires colorlog to be installed. Has no effect on file handlers.</p>"},{"location":"api-reference/config/#flixopt.config.CONFIG.Modeling","title":"Modeling","text":"<p>Optimization modeling parameters.</p> <p>Attributes:</p> Name Type Description <code>big</code> <code>int</code> <p>Large number for big-M constraints.</p> <code>epsilon</code> <code>float</code> <p>Tolerance for numerical comparisons.</p> <code>big_binary_bound</code> <code>int</code> <p>Upper bound for binary constraints.</p>"},{"location":"api-reference/config/#flixopt.config.CONFIG.Solving","title":"Solving","text":"<p>Solver configuration and default parameters.</p> <p>Attributes:</p> Name Type Description <code>mip_gap</code> <code>float</code> <p>Default MIP gap tolerance for solver convergence.</p> <code>time_limit_seconds</code> <code>int</code> <p>Default time limit in seconds for solver runs.</p> <code>log_to_console</code> <code>bool</code> <p>Whether solver should output to console.</p> <code>log_main_results</code> <code>bool</code> <p>Whether to log main results after solving.</p> <code>compute_infeasibilities</code> <code>bool</code> <p>Whether to compute infeasibility analysis when the model is infeasible.</p> <p>Examples:</p> <pre><code># Set tighter convergence and longer timeout\nCONFIG.Solving.mip_gap = 0.001\nCONFIG.Solving.time_limit_seconds = 600\nCONFIG.Solving.log_to_console = False\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG.Plotting","title":"Plotting","text":"<p>Plotting configuration.</p> <p>Configure backends via environment variables: - Matplotlib: Set <code>MPLBACKEND</code> environment variable (e.g., 'Agg', 'TkAgg') - Plotly: Set <code>PLOTLY_RENDERER</code> or use <code>plotly.io.renderers.default</code></p> <p>Attributes:</p> Name Type Description <code>default_show</code> <code>bool</code> <p>Default value for the <code>show</code> parameter in plot methods.</p> <code>default_engine</code> <code>Literal['plotly', 'matplotlib']</code> <p>Default plotting engine.</p> <code>default_dpi</code> <code>int</code> <p>Default DPI for saved plots.</p> <code>default_facet_cols</code> <code>int</code> <p>Default number of columns for faceted plots.</p> <code>default_sequential_colorscale</code> <code>str</code> <p>Default colorscale for heatmaps and continuous data.</p> <code>default_qualitative_colorscale</code> <code>str</code> <p>Default colormap for categorical plots (bar/line/area charts).</p> <p>Examples:</p> <pre><code># Configure default export and color settings\nCONFIG.Plotting.default_dpi = 600\nCONFIG.Plotting.default_sequential_colorscale = 'plasma'\nCONFIG.Plotting.default_qualitative_colorscale = 'Dark24'\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG.Carriers","title":"Carriers","text":"<p>Default carrier definitions for common energy types.</p> <p>Provides convenient defaults for carriers. Colors are from D3/Plotly palettes.</p> <p>Predefined: electricity, heat, gas, hydrogen, fuel, biomass</p> <p>Examples:</p> <pre><code>import flixopt as fx\n\n# Access predefined carriers\nfx.CONFIG.Carriers.electricity  # Carrier with color '#FECB52'\nfx.CONFIG.Carriers.heat.color  # '#D62728'\n\n# Use with buses\nbus = fx.Bus('Grid', carrier='electricity')\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG.Carriers-classes","title":"Classes","text":""},{"location":"api-reference/config/#flixopt.config.CONFIG-functions","title":"Functions","text":""},{"location":"api-reference/config/#flixopt.config.CONFIG.reset","title":"reset  <code>classmethod</code>","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset all configuration values to defaults.</p> <p>This resets modeling, solving, and plotting settings to their default values, and disables all logging handlers (back to silent mode).</p> <p>Examples:</p> <pre><code>CONFIG.debug()  # Enable debug mode\n# ... do some work ...\nCONFIG.reset()  # Back to defaults (silent)\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG.to_dict","title":"to_dict  <code>classmethod</code>","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the configuration class into a dictionary for JSON serialization.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the current configuration.</p>"},{"location":"api-reference/config/#flixopt.config.CONFIG.silent","title":"silent  <code>classmethod</code>","text":"<pre><code>silent() -&gt; type[CONFIG]\n</code></pre> <p>Configure for silent operation.</p> <p>Disables all logging, solver output, and result logging for clean production runs. Does not show plots.</p> <p>Examples:</p> <pre><code>CONFIG.silent()\n# Now run optimizations with no output\nresult = optimization.solve()\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG.debug","title":"debug  <code>classmethod</code>","text":"<pre><code>debug() -&gt; type[CONFIG]\n</code></pre> <p>Configure for debug mode with verbose output.</p> <p>Enables console logging at DEBUG level and all solver output for troubleshooting.</p> <p>Examples:</p> <pre><code>CONFIG.debug()\n# See detailed DEBUG logs and full solver output\noptimization.solve()\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG.exploring","title":"exploring  <code>classmethod</code>","text":"<pre><code>exploring() -&gt; type[CONFIG]\n</code></pre> <p>Configure for exploring flixopt.</p> <p>Enables console logging at INFO level and all solver output. Also enables browser plotting for plotly with showing plots per default.</p> <p>Examples:</p> <pre><code>CONFIG.exploring()\n# Perfect for interactive sessions\noptimization.solve()  # Shows INFO logs and solver output\nresult.plot()  # Opens plots in browser\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG.production","title":"production  <code>classmethod</code>","text":"<pre><code>production(log_file: str | Path = 'flixopt.log') -&gt; type[CONFIG]\n</code></pre> <p>Configure for production use.</p> <p>Enables file logging only (no console output), disables plots, and disables solver console output for clean production runs.</p> <p>Parameters:</p> Name Type Description Default <code>log_file</code> <code>str | Path</code> <p>Path to log file (default: 'flixopt.log')</p> <code>'flixopt.log'</code> <p>Examples:</p> <pre><code>CONFIG.production('production.log')\n# Logs to file, no console output\noptimization.solve()\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG.browser_plotting","title":"browser_plotting  <code>classmethod</code>","text":"<pre><code>browser_plotting() -&gt; type[CONFIG]\n</code></pre> <p>Configure for interactive usage with plotly to open plots in browser.</p> <p>Sets plotly.io.renderers.default = 'browser'. Useful for running examples and viewing interactive plots. Does NOT modify CONFIG.Plotting settings.</p> <p>Respects FLIXOPT_CI environment variable if set.</p> <p>Examples:</p> <pre><code>CONFIG.browser_plotting()\nresult.plot()  # Opens in browser instead of inline\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG.use_theme","title":"use_theme  <code>classmethod</code>","text":"<pre><code>use_theme() -&gt; type[CONFIG]\n</code></pre> <p>Activate the flixopt plotly theme as the default template.</p> <p>Sets <code>plotly.io.templates.default = 'plotly_white+flixopt'</code>.</p> <p>The 'flixopt' template is registered automatically on import with colorscales from CONFIG.Plotting. Call this method to make it the default for all plots.</p> <p>Returns:</p> Type Description <code>type[CONFIG]</code> <p>The CONFIG class for method chaining.</p> <p>Examples:</p> <pre><code># Activate flixopt theme globally\nCONFIG.use_theme()\n\n# Or combine with other setup\nCONFIG.notebook()  # Already calls use_theme() internally\n\n# Per-figure usage (without setting global default)\nfig.update_layout(template='plotly_white+flixopt')\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG.notebook","title":"notebook  <code>classmethod</code>","text":"<pre><code>notebook() -&gt; type[CONFIG]\n</code></pre> <p>Configure for Jupyter notebook environments.</p> <p>Optimizes settings for notebook usage: - Sets plotly renderer to 'notebook' for inline display (unless PLOTLY_RENDERER env var is set) - Disables automatic plot.show() calls (notebooks display via repr_html) - Enables SUCCESS-level console logging - Disables solver console output for cleaner notebook cells</p> Note <p>The plotly renderer can be overridden by setting the PLOTLY_RENDERER environment variable (e.g., 'notebook_connected' for CDN-based rendering).</p> <p>Examples:</p> <pre><code># At the start of your notebook\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n\n# Now plots display inline automatically\nflow_system.statistics.plot.balance('Heat')  # Displays inline\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG.load_from_file","title":"load_from_file  <code>classmethod</code>","text":"<pre><code>load_from_file(config_file: str | Path) -&gt; type[CONFIG]\n</code></pre> <p>Load configuration from YAML file and apply it.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str | Path</code> <p>Path to the YAML configuration file.</p> required <p>Returns:</p> Type Description <code>type[CONFIG]</code> <p>The CONFIG class for method chaining.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the config file does not exist.</p> <p>Examples:</p> <pre><code>CONFIG.load_from_file('my_config.yaml')\n</code></pre> <p>Example YAML file: <pre><code>config_name: my_project\nmodeling:\n    big: 10000000\n    epsilon: 0.00001\nsolving:\n    mip_gap: 0.001\n    time_limit_seconds: 600\nplotting:\n    default_engine: matplotlib\n    default_dpi: 600\n</code></pre></p>"},{"location":"api-reference/core/","title":"Core","text":""},{"location":"api-reference/core/#flixopt.core","title":"flixopt.core","text":"<p>This module contains the core functionality of the flixopt framework. It provides Datatypes, logging functionality, and some functions to transform data structures.</p>"},{"location":"api-reference/core/#flixopt.core-attributes","title":"Attributes","text":""},{"location":"api-reference/core/#flixopt.core.FlowSystemDimensions","title":"FlowSystemDimensions  <code>module-attribute</code>","text":"<pre><code>FlowSystemDimensions = Literal['time', 'cluster', 'period', 'scenario']\n</code></pre> <p>Possible dimensions of a FlowSystem.</p>"},{"location":"api-reference/core/#flixopt.core-classes","title":"Classes","text":""},{"location":"api-reference/core/#flixopt.core.PlausibilityError","title":"PlausibilityError","text":"<p>               Bases: <code>Exception</code></p> <p>Error for a failing Plausibility check.</p>"},{"location":"api-reference/core/#flixopt.core.ConversionError","title":"ConversionError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for data conversion errors.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesData","title":"TimeSeriesData","text":"<pre><code>TimeSeriesData(*args: Any, clustering_group: str | None = None, clustering_weight: float | None = None, **kwargs: Any)\n</code></pre> <p>               Bases: <code>DataArray</code></p> <p>Minimal TimeSeriesData that inherits from xr.DataArray with clustering metadata.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments passed to DataArray</p> <code>()</code> <code>clustering_group</code> <code>str | None</code> <p>Clustering group name. Use this when multiple time series should share the same clustering weight (1/n where n is the number of series in the group). Mutually exclusive with clustering_weight.</p> <code>None</code> <code>clustering_weight</code> <code>float | None</code> <p>Clustering weight (0-1). Use this to assign a specific weight to a single time series. Mutually exclusive with clustering_group.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to DataArray</p> <code>{}</code>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesData-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.TimeSeriesData.fit_to_coords","title":"fit_to_coords","text":"<pre><code>fit_to_coords(coords: dict[str, Index], name: str | None = None) -&gt; TimeSeriesData\n</code></pre> <p>Fit the data to the given coordinates. Returns a new TimeSeriesData object if the current coords are different.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesData.from_dataarray","title":"from_dataarray  <code>classmethod</code>","text":"<pre><code>from_dataarray(da: DataArray, clustering_group: str | None = None, clustering_weight: float | None = None)\n</code></pre> <p>Create TimeSeriesData from DataArray, extracting metadata from attrs.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesData.is_timeseries_data","title":"is_timeseries_data  <code>classmethod</code>","text":"<pre><code>is_timeseries_data(obj) -&gt; bool\n</code></pre> <p>Check if an object is TimeSeriesData.</p>"},{"location":"api-reference/core/#flixopt.core.DataConverter","title":"DataConverter","text":"<p>Converts various data types into xarray.DataArray with specified target coordinates.</p> <p>This converter handles intelligent dimension matching and broadcasting to ensure the output DataArray always conforms to the specified coordinate structure.</p> <p>Supported input types: - Scalars: int, float, np.number (broadcast to all target dimensions) - 1D data: np.ndarray, pd.Series, single-column DataFrame (matched by length/index) - Multi-dimensional arrays: np.ndarray, DataFrame (matched by shape) - xr.DataArray: validated and potentially broadcast to target dimensions</p> <p>The converter uses smart matching strategies: - Series: matched by exact index comparison - 1D arrays: matched by length to target coordinates - Multi-dimensional arrays: matched by shape permutation analysis - DataArrays: validated for compatibility and broadcast as needed</p>"},{"location":"api-reference/core/#flixopt.core.DataConverter-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.DataConverter.to_dataarray","title":"to_dataarray  <code>classmethod</code>","text":"<pre><code>to_dataarray(data: NumericOrBool, coords: dict[str, Index] | None = None) -&gt; xr.DataArray\n</code></pre> <p>Convert various data types to xarray.DataArray with specified target coordinates.</p> <p>This is the main conversion method that intelligently handles different input types and ensures the result conforms to the specified coordinate structure through smart dimension matching and broadcasting.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NumericOrBool</code> <p>Input data to convert. Supported types: - Scalars: int, float, bool, np.integer, np.floating, np.bool_ - Arrays: np.ndarray (1D and multi-dimensional) - Pandas: pd.Series, pd.DataFrame - xarray: xr.DataArray</p> required <code>coords</code> <code>dict[str, Index] | None</code> <p>Target coordinate specification as {dimension_name: coordinate_index}.    All coordinate indices must be pandas.Index objects.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray conforming to the target coordinate specification,</p> <code>DataArray</code> <p>with input data appropriately matched and broadcast</p> <p>Raises:</p> Type Description <code>ConversionError</code> <p>If data type is unsupported, conversion fails,            or broadcasting to target coordinates is impossible</p> <p>Examples:</p>"},{"location":"api-reference/core/#flixopt.core.DataConverter.to_dataarray--scalar-broadcasting","title":"Scalar broadcasting","text":"<pre><code>&gt;&gt;&gt; coords = {'x': pd.Index([1, 2, 3]), 'y': pd.Index(['a', 'b'])}\n&gt;&gt;&gt; converter.to_dataarray(42, coords)\n# Returns: DataArray with shape (3, 2), all values = 42\n</code></pre>"},{"location":"api-reference/core/#flixopt.core.DataConverter.to_dataarray--series-index-matching","title":"Series index matching","text":"<pre><code>&gt;&gt;&gt; series = pd.Series([10, 20, 30], index=[1, 2, 3])\n&gt;&gt;&gt; converter.to_dataarray(series, coords)\n# Returns: DataArray matched to 'x' dimension, broadcast to 'y'\n</code></pre>"},{"location":"api-reference/core/#flixopt.core.DataConverter.to_dataarray--array-shape-matching","title":"Array shape matching","text":"<pre><code>&gt;&gt;&gt; array = np.array([[1, 2], [3, 4], [5, 6]])  # Shape (3, 2)\n&gt;&gt;&gt; converter.to_dataarray(array, coords)\n# Returns: DataArray with dimensions ('x', 'y') based on shape\n</code></pre>"},{"location":"api-reference/core/#flixopt.core-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.get_dataarray_stats","title":"get_dataarray_stats","text":"<pre><code>get_dataarray_stats(arr: DataArray) -&gt; dict\n</code></pre> <p>Generate statistical summary of a DataArray.</p>"},{"location":"api-reference/core/#flixopt.core.drop_constant_arrays","title":"drop_constant_arrays","text":"<pre><code>drop_constant_arrays(ds: Dataset, dim: str = 'time', drop_arrays_without_dim: bool = True, atol: float = 1e-10) -&gt; xr.Dataset\n</code></pre> <p>Drop variables with constant values along a dimension.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Input dataset to filter.</p> required <code>dim</code> <code>str</code> <p>Dimension along which to check for constant values.</p> <code>'time'</code> <code>drop_arrays_without_dim</code> <code>bool</code> <p>If True, also drop variables that don't have the specified dimension.</p> <code>True</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for considering values as constant (based on max - min).</p> <code>1e-10</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset with constant variables removed.</p>"},{"location":"api-reference/effects/","title":"Effects","text":""},{"location":"api-reference/effects/#flixopt.effects","title":"flixopt.effects","text":"<p>This module contains the effects of the flixopt framework. Furthermore, it contains the EffectCollection, which is used to collect all effects of a system. Different Datatypes are used to represent the effects with assigned values by the user, which are then transformed into the internal data structure.</p>"},{"location":"api-reference/effects/#flixopt.effects-attributes","title":"Attributes","text":""},{"location":"api-reference/effects/#flixopt.effects-classes","title":"Classes","text":""},{"location":"api-reference/effects/#flixopt.effects.Effect","title":"Effect","text":"<pre><code>Effect(label: str, unit: str, description: str = '', meta_data: dict | None = None, is_standard: bool = False, is_objective: bool = False, period_weights: Numeric_PS | None = None, share_from_temporal: Effect_TPS | Numeric_TPS | None = None, share_from_periodic: Effect_PS | Numeric_PS | None = None, minimum_temporal: Numeric_PS | None = None, maximum_temporal: Numeric_PS | None = None, minimum_periodic: Numeric_PS | None = None, maximum_periodic: Numeric_PS | None = None, minimum_per_hour: Numeric_TPS | None = None, maximum_per_hour: Numeric_TPS | None = None, minimum_total: Numeric_PS | None = None, maximum_total: Numeric_PS | None = None, minimum_over_periods: Numeric_S | None = None, maximum_over_periods: Numeric_S | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Represents system-wide impacts like costs, emissions, or resource consumption.</p> <p>Effects quantify impacts aggregating contributions from Elements across the FlowSystem. One Effect serves as the optimization objective, while others can be constrained or tracked. Supports operational and investment contributions, cross-effect relationships (e.g., carbon pricing), and flexible constraint formulation.</p> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/effects-and-dimensions/</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>unit</code> <code>str</code> <p>The unit of the effect (e.g., '\u20ac', 'kg_CO2', 'kWh_primary', 'm\u00b2'). This is informative only and does not affect optimization.</p> required <code>description</code> <code>str</code> <p>Descriptive name explaining what this effect represents.</p> <code>''</code> <code>is_standard</code> <code>bool</code> <p>If True, this is a standard effect allowing direct value input without effect dictionaries. Used for simplified effect specification (and less boilerplate code).</p> <code>False</code> <code>is_objective</code> <code>bool</code> <p>If True, this effect serves as the optimization objective function. Only one effect can be marked as objective per optimization.</p> <code>False</code> <code>period_weights</code> <code>Numeric_PS | None</code> <p>Optional custom weights for periods and scenarios (Numeric_PS). If provided, overrides the FlowSystem's default period weights for this effect. Useful for effect-specific weighting (e.g., discounting for costs vs equal weights for CO2). If None, uses FlowSystem's default weights.</p> <code>None</code> <code>share_from_temporal</code> <code>Effect_TPS | Numeric_TPS | None</code> <p>Temporal cross-effect contributions. Maps temporal contributions from other effects to this effect.</p> <code>None</code> <code>share_from_periodic</code> <code>Effect_PS | Numeric_PS | None</code> <p>Periodic cross-effect contributions. Maps periodic contributions from other effects to this effect.</p> <code>None</code> <code>minimum_temporal</code> <code>Numeric_PS | None</code> <p>Minimum allowed total contribution across all timesteps (per period).</p> <code>None</code> <code>maximum_temporal</code> <code>Numeric_PS | None</code> <p>Maximum allowed total contribution across all timesteps (per period).</p> <code>None</code> <code>minimum_per_hour</code> <code>Numeric_TPS | None</code> <p>Minimum allowed contribution per hour.</p> <code>None</code> <code>maximum_per_hour</code> <code>Numeric_TPS | None</code> <p>Maximum allowed contribution per hour.</p> <code>None</code> <code>minimum_periodic</code> <code>Numeric_PS | None</code> <p>Minimum allowed total periodic contribution (per period).</p> <code>None</code> <code>maximum_periodic</code> <code>Numeric_PS | None</code> <p>Maximum allowed total periodic contribution (per period).</p> <code>None</code> <code>minimum_total</code> <code>Numeric_PS | None</code> <p>Minimum allowed total effect (temporal + periodic combined) per period.</p> <code>None</code> <code>maximum_total</code> <code>Numeric_PS | None</code> <p>Maximum allowed total effect (temporal + periodic combined) per period.</p> <code>None</code> <code>minimum_over_periods</code> <code>Numeric_S | None</code> <p>Minimum allowed weighted sum of total effect across ALL periods. Weighted by effect-specific weights if defined, otherwise by FlowSystem period weights. Requires FlowSystem to have a 'period' dimension (i.e., periods must be defined).</p> <code>None</code> <code>maximum_over_periods</code> <code>Numeric_S | None</code> <p>Maximum allowed weighted sum of total effect across ALL periods. Weighted by effect-specific weights if defined, otherwise by FlowSystem period weights. Requires FlowSystem to have a 'period' dimension (i.e., periods must be defined).</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Deprecated Parameters (for backwards compatibility):     minimum_operation: Use <code>minimum_temporal</code> instead.     maximum_operation: Use <code>maximum_temporal</code> instead.     minimum_invest: Use <code>minimum_periodic</code> instead.     maximum_invest: Use <code>maximum_periodic</code> instead.     minimum_operation_per_hour: Use <code>minimum_per_hour</code> instead.     maximum_operation_per_hour: Use <code>maximum_per_hour</code> instead.</p> <p>Examples:</p> <p>Basic cost objective:</p> <pre><code>cost_effect = Effect(\n    label='system_costs',\n    unit='\u20ac',\n    description='Total system costs',\n    is_objective=True,\n)\n</code></pre> <p>CO2 emissions with per-period limit:</p> <pre><code>co2_effect = Effect(\n    label='CO2',\n    unit='kg_CO2',\n    description='Carbon dioxide emissions',\n    maximum_total=100_000,  # 100 t CO2 per period\n)\n</code></pre> <p>CO2 emissions with total limit across all periods:</p> <pre><code>co2_effect = Effect(\n    label='CO2',\n    unit='kg_CO2',\n    description='Carbon dioxide emissions',\n    maximum_over_periods=1_000_000,  # 1000 t CO2 total across all periods\n)\n</code></pre> <p>Land use constraint:</p> <pre><code>land_use = Effect(\n    label='land_usage',\n    unit='m\u00b2',\n    description='Land area requirement',\n    maximum_total=50_000,  # Maximum 5 hectares per period\n)\n</code></pre> <p>Primary energy tracking:</p> <pre><code>primary_energy = Effect(\n    label='primary_energy',\n    unit='kWh_primary',\n    description='Primary energy consumption',\n)\n</code></pre> <p>Cost objective with carbon and primary energy pricing:</p> <pre><code>```python\ncost_effect = Effect(\n    label='system_costs',\n    unit='\u20ac',\n    description='Total system costs',\n    is_objective=True,\n    share_from_temporal={\n        'primary_energy': 0.08,  # 0.08 \u20ac/kWh_primary\n        'CO2': 0.2,  # Carbon pricing: 0.2 \u20ac/kg_CO2 into costs if used on a cost effect\n    },\n)\n```\n\nWater consumption with tiered constraints:\n\n```python\nwater_usage = Effect(\n    label='water_consumption',\n    unit='m\u00b3',\n    description='Industrial water usage',\n    minimum_per_hour=10,  # Minimum 10 m\u00b3/h for process stability\n    maximum_per_hour=500,  # Maximum 500 m\u00b3/h capacity limit\n    maximum_over_periods=100_000,  # Annual permit limit: 100,000 m\u00b3\n)\n```\n</code></pre> Note <p>Effect bounds can be None to indicate no constraint in that direction.</p> <p>Cross-effect relationships enable sophisticated modeling like carbon pricing, resource valuation, or multi-criteria optimization with weighted objectives.</p> <p>The unit field is purely informational - ensure dimensional consistency across all contributions to each effect manually.</p> <p>Effects are accumulated as: - Total = \u03a3(temporal contributions) + \u03a3(periodic contributions)</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect-attributes","title":"Attributes","text":""},{"location":"api-reference/effects/#flixopt.effects.Effect.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.Effect.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Link this effect to a FlowSystem.</p> <p>Elements use their label_full as prefix by default, ignoring the passed prefix.</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectModel","title":"EffectModel","text":"<pre><code>EffectModel(model: FlowSystemModel, element: Effect)\n</code></pre> <p>               Bases: <code>ElementModel</code></p> <p>Mathematical model implementation for Effects.</p> <p>Creates optimization variables and constraints for effect aggregation, including periodic and temporal tracking, cross-effect contributions, and effect bounds.</p> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/effects-and-dimensions/</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectModel-attributes","title":"Attributes","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectModel.period_weights","title":"period_weights  <code>property</code>","text":"<pre><code>period_weights: DataArray\n</code></pre> <p>Get period weights for this effect.</p> <p>Returns effect-specific weights if defined, otherwise falls back to FlowSystem period weights. This allows different effects to have different weighting schemes over periods (e.g., discounting for costs, equal weights for CO2 emissions).</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>Weights with period dimensions (if applicable)</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectModel-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollection","title":"EffectCollection","text":"<pre><code>EffectCollection(*effects: Effect, truncate_repr: int | None = None)\n</code></pre> <p>               Bases: <code>ElementContainer[Effect]</code></p> <p>Handling all Effects</p> <p>Initialize the EffectCollection.</p> <p>Parameters:</p> Name Type Description Default <code>*effects</code> <code>Effect</code> <p>Effects to register in the collection.</p> <code>()</code> <code>truncate_repr</code> <code>int | None</code> <p>Maximum number of items to show in repr. If None, show all items. Default: None</p> <code>None</code>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollection-attributes","title":"Attributes","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectCollection.penalty_effect","title":"penalty_effect  <code>property</code>","text":"<pre><code>penalty_effect: Effect\n</code></pre> <p>The penalty effect (auto-created during modeling if not user-defined).</p> <p>Returns the Penalty effect whether user-defined or auto-created.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollection-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectCollection.create_effect_values_dict","title":"create_effect_values_dict","text":"<pre><code>create_effect_values_dict(effect_values_user: Numeric_TPS | Effect_TPS | None) -&gt; Effect_TPS | None\n</code></pre> <p>Converts effect values into a dictionary. If a scalar is provided, it is associated with a default effect type.</p> <p>Examples:</p> <pre><code>effect_values_user = 20                               -&gt; {'&lt;standard_effect_label&gt;': 20}\neffect_values_user = {None: 20}                       -&gt; {'&lt;standard_effect_label&gt;': 20}\neffect_values_user = None                             -&gt; None\neffect_values_user = {'effect1': 20, 'effect2': 0.3}  -&gt; {'effect1': 20, 'effect2': 0.3}\n</code></pre> <p>Returns:</p> Name Type Description <code>Effect_TPS | None</code> <p>A dictionary keyed by effect label, or None if input is None.</p> <code>Note</code> <code>Effect_TPS | None</code> <p>a standard effect must be defined when passing scalars or None labels.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollection.add","title":"add","text":"<pre><code>add(element: T) -&gt; None\n</code></pre> <p>Add an element to the container.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel","title":"EffectCollectionModel","text":"<pre><code>EffectCollectionModel(model: FlowSystemModel, effects: EffectCollection)\n</code></pre> <p>               Bases: <code>Submodel</code></p> <p>Handling all Effects</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel-attributes","title":"Attributes","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/effects/#flixopt.effects-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.calculate_all_conversion_paths","title":"calculate_all_conversion_paths","text":"<pre><code>calculate_all_conversion_paths(conversion_dict: dict[str, dict[str, Scalar | DataArray]]) -&gt; dict[tuple[str, str], xr.DataArray]\n</code></pre> <p>Calculates all possible direct and indirect conversion factors between units/domains. This function uses Breadth-First Search (BFS) to find all possible conversion paths between different units or domains in a conversion graph. It computes both direct conversions (explicitly provided in the input) and indirect conversions (derived through intermediate units). Args:     conversion_dict: A nested dictionary where:         - Outer keys represent origin units/domains         - Inner dictionaries map target units/domains to their conversion factors         - Conversion factors can be integers, floats, or numpy arrays Returns:     A dictionary mapping (origin, target) tuples to their respective conversion factors.     Each key is a tuple of strings representing the origin and target units/domains.     Each value is the conversion factor (int, float, or numpy array) from origin to target.</p>"},{"location":"api-reference/effects/#flixopt.effects.detect_cycles","title":"detect_cycles","text":"<pre><code>detect_cycles(graph: dict[str, list[str]]) -&gt; list[list[str]]\n</code></pre> <p>Detects cycles in a directed graph using DFS.</p> <p>Parameters:</p> Name Type Description Default <code>graph</code> <code>dict[str, list[str]]</code> <p>Adjacency list representation of the graph</p> required <p>Returns:</p> Type Description <code>list[list[str]]</code> <p>List of cycles found, where each cycle is a list of nodes</p>"},{"location":"api-reference/effects/#flixopt.effects.tuples_to_adjacency_list","title":"tuples_to_adjacency_list","text":"<pre><code>tuples_to_adjacency_list(edges: list[tuple[str, str]]) -&gt; dict[str, list[str]]\n</code></pre> <p>Converts a list of edge tuples (source, target) to an adjacency list representation.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>list[tuple[str, str]]</code> <p>List of (source, target) tuples representing directed edges</p> required <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>Dictionary mapping each source node to a list of its target nodes</p>"},{"location":"api-reference/elements/","title":"Elements","text":""},{"location":"api-reference/elements/#flixopt.elements","title":"flixopt.elements","text":"<p>This module contains the basic elements of the flixopt framework.</p>"},{"location":"api-reference/elements/#flixopt.elements-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements-classes","title":"Classes","text":""},{"location":"api-reference/elements/#flixopt.elements.Component","title":"Component","text":"<pre><code>Component(label: str, inputs: list[Flow] | dict[str, Flow] | None = None, outputs: list[Flow] | dict[str, Flow] | None = None, status_parameters: StatusParameters | None = None, prevent_simultaneous_flows: list[Flow] | None = None, meta_data: dict | None = None, color: str | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Base class for all system components that transform, convert, or process flows.</p> <p>Components are the active elements in energy systems that define how input and output Flows interact with each other. They represent equipment, processes, or logical operations that transform energy or materials between different states, carriers, or locations.</p> <p>Components serve as connection points between Buses through their associated Flows, enabling the modeling of complex energy system topologies and operational constraints.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow] | dict[str, Flow] | None</code> <p>list of input Flows feeding into the component. These represent energy/material consumption by the component.</p> <code>None</code> <code>outputs</code> <code>list[Flow] | dict[str, Flow] | None</code> <p>list of output Flows leaving the component. These represent energy/material production by the component.</p> <code>None</code> <code>status_parameters</code> <code>StatusParameters | None</code> <p>Defines binary operation constraints and costs when the component has discrete active/inactive states. Creates binary variables for all connected Flows. For better performance, prefer defining StatusParameters on individual Flows when possible.</p> <code>None</code> <code>prevent_simultaneous_flows</code> <code>list[Flow] | None</code> <p>list of Flows that cannot be active simultaneously. Creates binary variables to enforce mutual exclusivity. Use sparingly as it increases computational complexity.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> Note <p>Component operational state is determined by its connected Flows: - Component is \"active\" if ANY of its Flows is active (flow_rate &gt; 0) - Component is \"inactive\" only when ALL Flows are inactive (flow_rate = 0)</p> <p>Binary variables and constraints: - status_parameters creates binary variables for ALL connected Flows - prevent_simultaneous_flows creates binary variables for specified Flows - For better computational performance, prefer Flow-level StatusParameters</p> <p>Component is an abstract base class. In practice, use specialized subclasses: - LinearConverter: Linear input/output relationships - Storage: Temporal energy/material storage - Transmission: Transport between locations - Source/Sink: System boundaries</p>"},{"location":"api-reference/elements/#flixopt.elements.Component-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements.Component.flows","title":"flows  <code>cached</code> <code>property</code>","text":"<pre><code>flows: FlowContainer\n</code></pre> <p>All flows (inputs and outputs) as a FlowContainer.</p> Supports access by label_full or short label <p>component.flows['Boiler(Q_th)']  # Full label component.flows['Q_th']          # Short label</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/elements/#flixopt.elements.Component-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Component.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to nested Interface objects and flows.</p> <p>Elements use their label_full as prefix by default, ignoring the passed prefix.</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus","title":"Bus","text":"<pre><code>Bus(label: str, carrier: str | None = None, imbalance_penalty_per_flow_hour: Numeric_TPS | None = None, meta_data: dict | None = None, **kwargs)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Buses represent nodal balances between flow rates, serving as connection points.</p> <p>A Bus enforces energy or material balance constraints where the sum of all incoming flows must equal the sum of all outgoing flows at each time step. Buses represent physical or logical connection points for energy carriers (electricity, heat, gas) or material flows between different Components.</p> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/elements/Bus/</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>carrier</code> <code>str | None</code> <p>Name of the energy/material carrier type (e.g., 'electricity', 'heat', 'gas'). Carriers are registered via <code>flow_system.add_carrier()</code> or available as predefined defaults in CONFIG.Carriers. Used for automatic color assignment in plots.</p> <code>None</code> <code>imbalance_penalty_per_flow_hour</code> <code>Numeric_TPS | None</code> <p>Penalty costs for bus balance violations. When None (default), no imbalance is allowed (hard constraint). When set to a value &gt; 0, allows bus imbalances at penalty cost.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Using predefined carrier names:</p> <pre><code>electricity_bus = Bus(label='main_grid', carrier='electricity')\nheat_bus = Bus(label='district_heating', carrier='heat')\n</code></pre> <p>Registering custom carriers on FlowSystem:</p> <pre><code>import flixopt as fx\n\nfs = fx.FlowSystem(timesteps)\nfs.add_carrier(fx.Carrier('biogas', '#228B22', 'kW'))\nbiogas_bus = fx.Bus(label='biogas_network', carrier='biogas')\n</code></pre> <p>Heat network with penalty for imbalances:</p> <pre><code>heat_bus = Bus(\n    label='district_heating',\n    carrier='heat',\n    imbalance_penalty_per_flow_hour=1000,\n)\n</code></pre> Note <p>The bus balance equation enforced is: \u03a3(inflows) + virtual_supply = \u03a3(outflows) + virtual_demand</p> <p>When imbalance_penalty_per_flow_hour is None, virtual_supply and virtual_demand are forced to zero. When a penalty cost is specified, the optimization can choose to violate the balance if economically beneficial, paying the penalty. The penalty is added to the objective directly.</p> <p>Empty <code>inputs</code> and <code>outputs</code> lists are initialized and populated automatically by the FlowSystem during system setup.</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements.Bus.flows","title":"flows  <code>property</code>","text":"<pre><code>flows: FlowContainer\n</code></pre> <p>All flows (inputs and outputs) as a FlowContainer.</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Bus.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to nested flows.</p> <p>Elements use their label_full as prefix by default, ignoring the passed prefix.</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/elements/#flixopt.elements.Connection","title":"Connection","text":"<pre><code>Connection()\n</code></pre> <p>This class is not yet implemented!</p>"},{"location":"api-reference/elements/#flixopt.elements.Connection-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Flow","title":"Flow","text":"<pre><code>Flow(label: str, bus: str, size: Numeric_PS | InvestParameters | None = None, fixed_relative_profile: Numeric_TPS | None = None, relative_minimum: Numeric_TPS = 0, relative_maximum: Numeric_TPS = 1, effects_per_flow_hour: Effect_TPS | Numeric_TPS | None = None, status_parameters: StatusParameters | None = None, flow_hours_max: Numeric_PS | None = None, flow_hours_min: Numeric_PS | None = None, flow_hours_max_over_periods: Numeric_S | None = None, flow_hours_min_over_periods: Numeric_S | None = None, load_factor_min: Numeric_PS | None = None, load_factor_max: Numeric_PS | None = None, previous_flow_rate: Scalar | list[Scalar] | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Define a directed flow of energy or material between bus and component.</p> <p>A Flow represents the transfer of energy (electricity, heat, fuel) or material between a Bus and a Component in a specific direction. The flow rate is the primary optimization variable, with constraints and costs defined through various parameters. Flows can have fixed or variable sizes, operational constraints, and complex on/inactive behavior.</p> Key Concepts <p>Flow Rate: The instantaneous rate of energy/material transfer (optimization variable) [kW, m\u00b3/h, kg/h] Flow Hours: Amount of energy/material transferred per timestep. [kWh, m\u00b3, kg] Flow Size: The maximum capacity or nominal rating of the flow [kW, m\u00b3/h, kg/h] Relative Bounds: Flow rate limits expressed as fractions of flow size</p> Integration with Parameter Classes <ul> <li>InvestParameters: Used for <code>size</code> when flow Size is an investment decision</li> <li>StatusParameters: Used for <code>status_parameters</code> when flow has discrete states</li> </ul> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/elements/Flow/</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Unique flow identifier within its component.</p> required <code>bus</code> <code>str</code> <p>Bus label this flow connects to.</p> required <code>size</code> <code>Numeric_PS | InvestParameters | None</code> <p>Flow capacity. Scalar, InvestParameters, or None (unbounded).</p> <code>None</code> <code>relative_minimum</code> <code>Numeric_TPS</code> <p>Minimum flow rate as fraction of size (0-1). Default: 0.</p> <code>0</code> <code>relative_maximum</code> <code>Numeric_TPS</code> <p>Maximum flow rate as fraction of size. Default: 1.</p> <code>1</code> <code>load_factor_min</code> <code>Numeric_PS | None</code> <p>Minimum average utilization (0-1). Default: 0.</p> <code>None</code> <code>load_factor_max</code> <code>Numeric_PS | None</code> <p>Maximum average utilization (0-1). Default: 1.</p> <code>None</code> <code>effects_per_flow_hour</code> <code>Effect_TPS | Numeric_TPS | None</code> <p>Operational costs/impacts per flow-hour. Dict mapping effect names to values (e.g., {'cost': 45, 'CO2': 0.8}).</p> <code>None</code> <code>status_parameters</code> <code>StatusParameters | None</code> <p>Binary operation constraints (StatusParameters). Default: None.</p> <code>None</code> <code>flow_hours_max</code> <code>Numeric_PS | None</code> <p>Maximum cumulative flow-hours per period. Alternative to load_factor_max.</p> <code>None</code> <code>flow_hours_min</code> <code>Numeric_PS | None</code> <p>Minimum cumulative flow-hours per period. Alternative to load_factor_min.</p> <code>None</code> <code>flow_hours_max_over_periods</code> <code>Numeric_S | None</code> <p>Maximum weighted sum of flow-hours across ALL periods. Weighted by FlowSystem period weights.</p> <code>None</code> <code>flow_hours_min_over_periods</code> <code>Numeric_S | None</code> <p>Minimum weighted sum of flow-hours across ALL periods. Weighted by FlowSystem period weights.</p> <code>None</code> <code>fixed_relative_profile</code> <code>Numeric_TPS | None</code> <p>Predetermined pattern as fraction of size. Flow rate = size \u00d7 fixed_relative_profile(t).</p> <code>None</code> <code>previous_flow_rate</code> <code>Scalar | list[Scalar] | None</code> <p>Initial flow state for active/inactive status at model start. Default: None (inactive).</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Additional info stored in results. Python native types only.</p> <code>None</code> <p>Examples:</p> <p>Basic power flow with fixed capacity:</p> <pre><code>generator_output = Flow(\n    label='electricity_out',\n    bus='electricity_grid',\n    size=100,  # 100 MW capacity\n    relative_minimum=0.4,  # Cannot operate below 40 MW\n    effects_per_flow_hour={'fuel_cost': 45, 'co2_emissions': 0.8},\n)\n</code></pre> <p>Investment decision for battery capacity:</p> <pre><code>battery_flow = Flow(\n    label='electricity_storage',\n    bus='electricity_grid',\n    size=InvestParameters(\n        minimum_size=10,  # Minimum 10 MWh\n        maximum_size=100,  # Maximum 100 MWh\n        specific_effects={'cost': 150_000},  # \u20ac150k/MWh annualized\n    ),\n)\n</code></pre> <p>Heat pump with startup costs and minimum run times:</p> <pre><code>heat_pump = Flow(\n    label='heat_output',\n    bus='heating_network',\n    size=50,  # 50 kW thermal\n    relative_minimum=0.3,  # Minimum 15 kW output when active\n    effects_per_flow_hour={'electricity_cost': 25, 'maintenance': 2},\n    status_parameters=StatusParameters(\n        effects_per_startup={'startup_cost': 100, 'wear': 0.1},\n        min_uptime=2,  # Must run at least 2 hours\n        min_downtime=1,  # Must stay inactive at least 1 hour\n        startup_limit=200,  # Maximum 200 starts per period\n    ),\n)\n</code></pre> <p>Fixed renewable generation profile:</p> <pre><code>solar_generation = Flow(\n    label='solar_power',\n    bus='electricity_grid',\n    size=25,  # 25 MW installed capacity\n    fixed_relative_profile=np.array([0, 0.1, 0.4, 0.8, 0.9, 0.7, 0.3, 0.1, 0]),\n    effects_per_flow_hour={'maintenance_costs': 5},  # \u20ac5/MWh maintenance\n)\n</code></pre> <p>Industrial process with annual utilization limits:</p> <pre><code>production_line = Flow(\n    label='product_output',\n    bus='product_market',\n    size=1000,  # 1000 units/hour capacity\n    load_factor_min=0.6,  # Must achieve 60% annual utilization\n    load_factor_max=0.85,  # Cannot exceed 85% for maintenance\n    effects_per_flow_hour={'variable_cost': 12, 'quality_control': 0.5},\n)\n</code></pre> Design Considerations <p>Size vs Load Factors: Use <code>flow_hours_min/max</code> for absolute limits per period, <code>load_factor_min/max</code> for utilization-based constraints, or <code>flow_hours_min/max_over_periods</code> for limits across all periods.</p> <p>Relative Bounds: Set <code>relative_minimum &gt; 0</code> only when equipment cannot operate below that level. Use <code>status_parameters</code> for discrete active/inactive behavior.</p> <p>Fixed Profiles: Use <code>fixed_relative_profile</code> for known exact patterns, <code>relative_maximum</code> for upper bounds on optimization variables.</p> Notes <ul> <li>size=None means unbounded (no capacity constraint)</li> <li>size must be set when using status_parameters or fixed_relative_profile</li> <li>list inputs for previous_flow_rate are converted to NumPy arrays</li> <li>Flow direction is determined by component input/output designation</li> </ul> Deprecated <p>Passing Bus objects to <code>bus</code> parameter. Use bus label strings instead.</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements.Flow.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Flow.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to nested Interface objects.</p> <p>Elements use their label_full as prefix by default, ignoring the passed prefix.</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel","title":"FlowModel","text":"<pre><code>FlowModel(model: FlowSystemModel, element: Flow)\n</code></pre> <p>               Bases: <code>ElementModel</code></p> <p>Mathematical model implementation for Flow elements.</p> <p>Creates optimization variables and constraints for flow rate bounds, flow-hours tracking, and load factors.</p> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/elements/Flow/</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements.FlowModel.flow_rate","title":"flow_rate  <code>property</code>","text":"<pre><code>flow_rate: Variable\n</code></pre> <p>Main flow rate variable</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.total_flow_hours","title":"total_flow_hours  <code>property</code>","text":"<pre><code>total_flow_hours: Variable\n</code></pre> <p>Total flow hours variable</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.absolute_flow_rate_bounds","title":"absolute_flow_rate_bounds  <code>property</code>","text":"<pre><code>absolute_flow_rate_bounds: tuple[DataArray, DataArray]\n</code></pre> <p>Returns the absolute bounds the flow_rate can reach. Further constraining might be needed</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.status","title":"status  <code>property</code>","text":"<pre><code>status: StatusModel | None\n</code></pre> <p>Status feature</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.investment","title":"investment  <code>property</code>","text":"<pre><code>investment: InvestmentModel | None\n</code></pre> <p>Investment feature</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.previous_status","title":"previous_status  <code>property</code>","text":"<pre><code>previous_status: DataArray | None\n</code></pre> <p>Previous status of the flow rate</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.FlowModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/elements/#flixopt.elements.BusModel","title":"BusModel","text":"<pre><code>BusModel(model: FlowSystemModel, element: Bus)\n</code></pre> <p>               Bases: <code>ElementModel</code></p> <p>Mathematical model implementation for Bus elements.</p> <p>Creates optimization variables and constraints for nodal balance equations, and optional excess/deficit variables with penalty costs.</p> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/elements/Bus/</p>"},{"location":"api-reference/elements/#flixopt.elements.BusModel-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements.BusModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/elements/#flixopt.elements.BusModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.BusModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.BusModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.BusModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.BusModel-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.BusModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.BusModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/elements/#flixopt.elements.BusModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/elements/#flixopt.elements.BusModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.BusModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.BusModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel","title":"ComponentModel","text":"<pre><code>ComponentModel(model: FlowSystemModel, element: Component)\n</code></pre> <p>               Bases: <code>ElementModel</code></p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.previous_status","title":"previous_status  <code>property</code>","text":"<pre><code>previous_status: DataArray | None\n</code></pre> <p>Previous status of the component, derived from its flows</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/elements/#flixopt.elements-functions","title":"Functions","text":""},{"location":"api-reference/features/","title":"Features","text":""},{"location":"api-reference/features/#flixopt.features","title":"flixopt.features","text":"<p>This module contains the features of the flixopt framework. Features extend the functionality of Elements.</p>"},{"location":"api-reference/features/#flixopt.features-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features-classes","title":"Classes","text":""},{"location":"api-reference/features/#flixopt.features.InvestmentModel","title":"InvestmentModel","text":"<pre><code>InvestmentModel(model: FlowSystemModel, label_of_element: str, parameters: InvestParameters, label_of_model: str | None = None, size_category: VariableCategory = VariableCategory.SIZE)\n</code></pre> <p>               Bases: <code>Submodel</code></p> <p>Mathematical model implementation for investment decisions.</p> <p>Creates optimization variables and constraints for investment sizing decisions, supporting both binary and continuous sizing with comprehensive effect modeling.</p> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/features/InvestParameters/</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FlowSystemModel</code> <p>The optimization model instance</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>parameters</code> <code>InvestParameters</code> <p>The parameters of the feature model.</p> required <code>label_of_model</code> <code>str | None</code> <p>The label of the model. This is needed to construct the full label of the model.</p> <code>None</code> <code>size_category</code> <code>VariableCategory</code> <p>Category for the size variable (FLOW_SIZE, STORAGE_SIZE, or SIZE for generic).</p> <code>SIZE</code>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.InvestmentModel.size","title":"size  <code>property</code>","text":"<pre><code>size: Variable\n</code></pre> <p>Investment size variable</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.invested","title":"invested  <code>property</code>","text":"<pre><code>invested: Variable | None\n</code></pre> <p>Binary investment decision variable</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.InvestmentModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel","title":"StatusModel","text":"<pre><code>StatusModel(model: FlowSystemModel, label_of_element: str, parameters: StatusParameters, status: Variable, previous_status: DataArray | None, label_of_model: str | None = None)\n</code></pre> <p>               Bases: <code>Submodel</code></p> <p>Mathematical model implementation for binary status.</p> <p>Creates optimization variables and constraints for binary status modeling, state transitions, duration tracking, and operational effects.</p> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/features/StatusParameters/</p> <p>This feature model is used to model the status (active/inactive) state of flow_rate(s). It does not matter if the flow_rates are bounded by a size variable or by a hard bound. The used bound here is the absolute highest/lowest bound!</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FlowSystemModel</code> <p>The optimization model instance</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>parameters</code> <code>StatusParameters</code> <p>The parameters of the feature model.</p> required <code>status</code> <code>Variable</code> <p>The variable that determines the active state</p> required <code>previous_status</code> <code>DataArray | None</code> <p>The previous flow_rates</p> required <code>label_of_model</code> <code>str | None</code> <p>The label of the model. This is needed to construct the full label of the model.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.StatusModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.StatusModel.active_hours","title":"active_hours  <code>property</code>","text":"<pre><code>active_hours: Variable\n</code></pre> <p>Total active hours variable</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.inactive","title":"inactive  <code>property</code>","text":"<pre><code>inactive: Variable | None\n</code></pre> <p>Binary inactive state variable.</p> Note <p>Only created when downtime tracking is enabled (min_downtime or max_downtime set). For general use, prefer the expression <code>1 - status</code> instead of this variable.</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.startup","title":"startup  <code>property</code>","text":"<pre><code>startup: Variable | None\n</code></pre> <p>Startup variable</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.shutdown","title":"shutdown  <code>property</code>","text":"<pre><code>shutdown: Variable | None\n</code></pre> <p>Shutdown variable</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.startup_count","title":"startup_count  <code>property</code>","text":"<pre><code>startup_count: Variable | None\n</code></pre> <p>Number of startups variable</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.uptime","title":"uptime  <code>property</code>","text":"<pre><code>uptime: Variable | None\n</code></pre> <p>Consecutive active hours (uptime) variable</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.downtime","title":"downtime  <code>property</code>","text":"<pre><code>downtime: Variable | None\n</code></pre> <p>Consecutive inactive hours (downtime) variable</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.StatusModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/features/#flixopt.features.StatusModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel","title":"PieceModel","text":"<pre><code>PieceModel(model: FlowSystemModel, label_of_element: str, label_of_model: str, dims: Collection[FlowSystemDimensions] | None)\n</code></pre> <p>               Bases: <code>Submodel</code></p> <p>Class for modeling a linear piece of one or more variables in parallel</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.PieceModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.PieceModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel","title":"PiecewiseModel","text":"<pre><code>PiecewiseModel(model: FlowSystemModel, label_of_element: str, label_of_model: str, piecewise_variables: dict[str, Piecewise], zero_point: bool | Variable | None, dims: Collection[FlowSystemDimensions] | None)\n</code></pre> <p>               Bases: <code>Submodel</code></p> <p>Mathematical model implementation for piecewise linear approximations.</p> <p>Creates optimization variables and constraints for piecewise linear relationships, including lambda variables, piece activation binaries, and coupling constraints.</p> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/features/Piecewise/</p> <p>Modeling a Piecewise relation between miultiple variables. The relation is defined by a list of Pieces, which are assigned to the variables. Each Piece is a tuple of (start, end).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FlowSystemModel</code> <p>The FlowSystemModel that is used to create the model.</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>label_of_model</code> <code>str</code> <p>The label of the model. Used to construct the full label of the model.</p> required <code>piecewise_variables</code> <code>dict[str, Piecewise]</code> <p>The variables to which the Pieces are assigned.</p> required <code>zero_point</code> <code>bool | Variable | None</code> <p>A variable that can be used to define a zero point for the Piecewise relation. If None or False, no zero point is defined.</p> required <code>dims</code> <code>Collection[FlowSystemDimensions] | None</code> <p>The dimensions used for variable creation. If None, all dimensions are used.</p> required"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseEffectsModel","title":"PiecewiseEffectsModel","text":"<pre><code>PiecewiseEffectsModel(model: FlowSystemModel, label_of_element: str, label_of_model: str, piecewise_origin: tuple[str, Piecewise], piecewise_shares: dict[str, Piecewise], zero_point: bool | Variable | None)\n</code></pre> <p>               Bases: <code>Submodel</code></p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseEffectsModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.PiecewiseEffectsModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseEffectsModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseEffectsModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseEffectsModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseEffectsModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseEffectsModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.PiecewiseEffectsModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseEffectsModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseEffectsModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseEffectsModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseEffectsModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseEffectsModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel","title":"ShareAllocationModel","text":"<pre><code>ShareAllocationModel(model: FlowSystemModel, dims: list[FlowSystemDimensions], label_of_element: str | None = None, label_of_model: str | None = None, total_max: Numeric_PS | None = None, total_min: Numeric_PS | None = None, max_per_hour: Numeric_TPS | None = None, min_per_hour: Numeric_TPS | None = None)\n</code></pre> <p>               Bases: <code>Submodel</code></p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.add_share","title":"add_share","text":"<pre><code>add_share(name: str, expression: LinearExpression, dims: list[FlowSystemDimensions] | None = None)\n</code></pre> <p>Add a share to the share allocation model. If the share already exists, the expression is added to the existing share. The expression is added to the right hand side (rhs) of the constraint. The variable representing the total share is on the left hand side (lhs) of the constraint. var_total = sum(expressions)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the share.</p> required <code>expression</code> <code>LinearExpression</code> <p>The expression of the share. Added to the right hand side of the constraint.</p> required <code>dims</code> <code>list[FlowSystemDimensions] | None</code> <p>The dimensions of the share. Defaults to all dimensions. Dims are ordered automatically</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/flow_system/","title":"Flow system","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system","title":"flixopt.flow_system","text":"<p>This module contains the FlowSystem class, which is used to collect instances of many other classes by the end User.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system-attributes","title":"Attributes","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system-classes","title":"Classes","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem","title":"FlowSystem","text":"<pre><code>FlowSystem(timesteps: DatetimeIndex | RangeIndex, periods: Index | None = None, scenarios: Index | None = None, clusters: Index | None = None, hours_of_last_timestep: int | float | None = None, hours_of_previous_timesteps: int | float | ndarray | None = None, weight_of_last_period: int | float | None = None, scenario_weights: Numeric_S | None = None, cluster_weight: Numeric_TPS | None = None, scenario_independent_sizes: bool | list[str] = True, scenario_independent_flow_rates: bool | list[str] = False, name: str | None = None, timestep_duration: DataArray | None = None)\n</code></pre> <p>               Bases: <code>Interface</code>, <code>CompositeContainerMixin[Element]</code></p> <p>A FlowSystem organizes the high level Elements (Components, Buses, Effects &amp; Flows).</p> <p>This is the main container class that users work with to build and manage their energy or material flow system. FlowSystem provides both direct container access (via .components, .buses, .effects, .flows) and a unified dict-like interface for accessing any element by label across all container types.</p> <p>Parameters:</p> Name Type Description Default <code>timesteps</code> <code>DatetimeIndex | RangeIndex</code> <p>The timesteps of the model.</p> required <code>periods</code> <code>Index | None</code> <p>The periods of the model.</p> <code>None</code> <code>scenarios</code> <code>Index | None</code> <p>The scenarios of the model.</p> <code>None</code> <code>hours_of_last_timestep</code> <code>int | float | None</code> <p>Duration of the last timestep. If None, computed from the last time interval.</p> <code>None</code> <code>hours_of_previous_timesteps</code> <code>int | float | ndarray | None</code> <p>Duration of previous timesteps. If None, computed from the first time interval. Can be a scalar (all previous timesteps have same duration) or array (different durations). Used to calculate previous values (e.g., uptime and downtime).</p> <code>None</code> <code>weight_of_last_period</code> <code>int | float | None</code> <p>Weight/duration of the last period. If None, computed from the last period interval. Used for calculating sums over periods in multi-period models.</p> <code>None</code> <code>scenario_weights</code> <code>Numeric_S | None</code> <p>The weights of each scenario. If None, all scenarios have the same weight (normalized to 1). Period weights are always computed internally from the period index (like timestep_duration for time). The final <code>weights</code> array (accessible via <code>flow_system.model.objective_weights</code>) is computed as period_weights \u00d7 normalized_scenario_weights, with normalization applied to the scenario weights by default.</p> <code>None</code> <code>cluster_weight</code> <code>Numeric_TPS | None</code> <p>Weight for each cluster. If None (default), all clusters have weight 1.0. Used by cluster() to specify how many original timesteps each cluster represents. Multiply with timestep_duration for proper time aggregation in clustered models.</p> <code>None</code> <code>scenario_independent_sizes</code> <code>bool | list[str]</code> <p>Controls whether investment sizes are equalized across scenarios. - True: All sizes are shared/equalized across scenarios - False: All sizes are optimized separately per scenario - list[str]: Only specified components (by label_full) are equalized across scenarios</p> <code>True</code> <code>scenario_independent_flow_rates</code> <code>bool | list[str]</code> <p>Controls whether flow rates are equalized across scenarios. - True: All flow rates are shared/equalized across scenarios - False: All flow rates are optimized separately per scenario - list[str]: Only specified flows (by label_full) are equalized across scenarios</p> <code>False</code> <p>Examples:</p> <p>Creating a FlowSystem and accessing elements:</p> <pre><code>&gt;&gt;&gt; import flixopt as fx\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; timesteps = pd.date_range('2023-01-01', periods=24, freq='h')\n&gt;&gt;&gt; flow_system = fx.FlowSystem(timesteps)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Add elements to the system\n&gt;&gt;&gt; boiler = fx.Component('Boiler', inputs=[heat_flow], status_parameters=...)\n&gt;&gt;&gt; heat_bus = fx.Bus('Heat', imbalance_penalty_per_flow_hour=1e4)\n&gt;&gt;&gt; costs = fx.Effect('costs', is_objective=True, is_standard=True)\n&gt;&gt;&gt; flow_system.add_elements(boiler, heat_bus, costs)\n</code></pre> <p>Unified dict-like access (recommended for most cases):</p> <pre><code>&gt;&gt;&gt; # Access any element by label, regardless of type\n&gt;&gt;&gt; boiler = flow_system['Boiler']  # Returns Component\n&gt;&gt;&gt; heat_bus = flow_system['Heat']  # Returns Bus\n&gt;&gt;&gt; costs = flow_system['costs']  # Returns Effect\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Check if element exists\n&gt;&gt;&gt; if 'Boiler' in flow_system:\n...     print('Boiler found in system')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Iterate over all elements\n&gt;&gt;&gt; for label in flow_system.keys():\n...     element = flow_system[label]\n...     print(f'{label}: {type(element).__name__}')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Get all element labels and objects\n&gt;&gt;&gt; all_labels = list(flow_system.keys())\n&gt;&gt;&gt; all_elements = list(flow_system.values())\n&gt;&gt;&gt; for label, element in flow_system.items():\n...     print(f'{label}: {element}')\n</code></pre> <p>Direct container access for type-specific operations:</p> <pre><code>&gt;&gt;&gt; # Access specific container when you need type filtering\n&gt;&gt;&gt; for component in flow_system.components.values():\n...     print(f'{component.label}: {len(component.inputs)} inputs')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Access buses directly\n&gt;&gt;&gt; for bus in flow_system.buses.values():\n...     print(f'{bus.label}')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Flows are automatically collected from all components\n</code></pre> <p>Power user pattern - Efficient chaining without conversion overhead:</p> <pre><code>&gt;&gt;&gt; # Instead of chaining (causes multiple conversions):\n&gt;&gt;&gt; result = flow_system.sel(time='2020-01').resample('2h')  # Slow\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use dataset methods directly (single conversion):\n&gt;&gt;&gt; ds = flow_system.to_dataset()\n&gt;&gt;&gt; ds = FlowSystem._dataset_sel(ds, time='2020-01')\n&gt;&gt;&gt; ds = flow_system._dataset_resample(ds, freq='2h', method='mean')\n&gt;&gt;&gt; result = FlowSystem.from_dataset(ds)  # Fast!\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Available dataset methods:\n&gt;&gt;&gt; # - FlowSystem._dataset_sel(dataset, time=..., period=..., scenario=...)\n&gt;&gt;&gt; # - FlowSystem._dataset_isel(dataset, time=..., period=..., scenario=...)\n&gt;&gt;&gt; # - flow_system._dataset_resample(dataset, freq=..., method=..., **kwargs)\n&gt;&gt;&gt; for flow in flow_system.flows.values():\n...     print(f'{flow.label_full}: {flow.size}')\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Access effects\n&gt;&gt;&gt; for effect in flow_system.effects.values():\n...     print(f'{effect.label}')\n</code></pre> Notes <ul> <li>The dict-like interface (<code>flow_system['element']</code>) searches across all containers   (components, buses, effects, flows) to find the element with the matching label.</li> <li>Element labels must be unique across all container types. Attempting to add   elements with duplicate labels will raise an error, ensuring each label maps to exactly one element.</li> <li>Direct container access (<code>.components</code>, <code>.buses</code>, <code>.effects</code>, <code>.flows</code>) is useful   when you need type-specific filtering or operations.</li> <li>The <code>.flows</code> container is automatically populated from all component inputs and outputs.</li> <li>Creates an empty registry for components and buses, an empty EffectCollection, and a placeholder for a SystemModel.</li> <li>The instance starts disconnected (self._connected_and_transformed == False) and will be   connected_and_transformed automatically when trying to optimize.</li> </ul>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem-attributes","title":"Attributes","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.carriers","title":"carriers  <code>property</code>","text":"<pre><code>carriers: CarrierContainer\n</code></pre> <p>Carriers registered on this FlowSystem.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.flow_carriers","title":"flow_carriers  <code>property</code>","text":"<pre><code>flow_carriers: dict[str, str]\n</code></pre> <p>Cached mapping of flow labels to carrier names.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dict mapping flow label to carrier name (lowercase).</p> <code>dict[str, str]</code> <p>Flows without a carrier are not included.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If FlowSystem is not connected_and_transformed.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.solution","title":"solution  <code>property</code> <code>writable</code>","text":"<pre><code>solution: Dataset | None\n</code></pre> <p>Access the optimization solution as an xarray Dataset.</p> <p>The solution is indexed by <code>timesteps_extra</code> (the original timesteps plus one additional timestep at the end). Variables that do not have data for the extra timestep (most variables except storage charge states) will contain NaN values at the final timestep.</p> <p>Returns:</p> Type Description <code>Dataset | None</code> <p>xr.Dataset: The solution dataset with all optimization variable results, or None if the model hasn't been solved yet.</p> Example <p>flow_system.optimize(solver) flow_system.solution.isel(time=slice(None, -1))  # Exclude trailing NaN (and final charge states)</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.variable_categories","title":"variable_categories  <code>property</code>","text":"<pre><code>variable_categories: dict[str, VariableCategory]\n</code></pre> <p>Variable categories for filtering and segment expansion.</p> <p>Returns:</p> Type Description <code>dict[str, VariableCategory]</code> <p>Dict mapping variable names to their VariableCategory.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.is_locked","title":"is_locked  <code>property</code>","text":"<pre><code>is_locked: bool\n</code></pre> <p>Check if the FlowSystem is locked (has a solution).</p> <p>A locked FlowSystem cannot be modified. Use <code>reset()</code> to unlock it.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.optimize","title":"optimize  <code>property</code>","text":"<pre><code>optimize: OptimizeAccessor\n</code></pre> <p>Access optimization methods for this FlowSystem.</p> <p>This property returns an OptimizeAccessor that can be called directly for standard optimization, or used to access specialized optimization modes.</p> <p>Returns:</p> Type Description <code>OptimizeAccessor</code> <p>An OptimizeAccessor instance.</p> <p>Examples:</p> <p>Standard optimization (call directly):</p> <pre><code>&gt;&gt;&gt; flow_system.optimize(HighsSolver())\n&gt;&gt;&gt; print(flow_system.solution['Boiler(Q_th)|flow_rate'])\n</code></pre> <p>Access element solutions directly:</p> <pre><code>&gt;&gt;&gt; flow_system.optimize(solver)\n&gt;&gt;&gt; boiler = flow_system.components['Boiler']\n&gt;&gt;&gt; print(boiler.solution)\n</code></pre> <p>Future specialized modes:</p> <pre><code>&gt;&gt;&gt; flow_system.optimize.clustered(solver, aggregation=params)\n&gt;&gt;&gt; flow_system.optimize.mga(solver, alternatives=5)\n</code></pre>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.transform","title":"transform  <code>property</code>","text":"<pre><code>transform: TransformAccessor\n</code></pre> <p>Access transformation methods for this FlowSystem.</p> <p>This property returns a TransformAccessor that provides methods to create transformed versions of this FlowSystem (e.g., clustered for time aggregation).</p> <p>Returns:</p> Type Description <code>TransformAccessor</code> <p>A TransformAccessor instance.</p> <p>Examples:</p> <p>Clustered optimization:</p> <pre><code>&gt;&gt;&gt; params = ClusteringParameters(hours_per_period=24, nr_of_periods=8)\n&gt;&gt;&gt; clustered_fs = flow_system.transform.cluster(params)\n&gt;&gt;&gt; clustered_fs.optimize(solver)\n&gt;&gt;&gt; print(clustered_fs.solution)\n</code></pre>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.statistics","title":"statistics  <code>property</code>","text":"<pre><code>statistics: StatisticsAccessor\n</code></pre> <p>Access statistics and plotting methods for optimization results.</p> <p>This property returns a StatisticsAccessor that provides methods to analyze and visualize optimization results stored in this FlowSystem's solution.</p> Note <p>The FlowSystem must have a solution (from optimize() or solve()) before most statistics methods can be used.</p> <p>Returns:</p> Type Description <code>StatisticsAccessor</code> <p>A cached StatisticsAccessor instance.</p> <p>Examples:</p> <p>After optimization:</p> <pre><code>&gt;&gt;&gt; flow_system.optimize(solver)\n&gt;&gt;&gt; flow_system.statistics.plot.balance('ElectricityBus')\n&gt;&gt;&gt; flow_system.statistics.plot.heatmap('Boiler|on')\n&gt;&gt;&gt; ds = flow_system.statistics.flow_rates  # Get data for analysis\n</code></pre>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.topology","title":"topology  <code>property</code>","text":"<pre><code>topology: TopologyAccessor\n</code></pre> <p>Access network topology inspection and visualization methods.</p> <p>This property returns a cached TopologyAccessor that provides methods to inspect the network structure and visualize it. The accessor is invalidated when the FlowSystem structure changes (via reset() or invalidate()).</p> <p>Returns:</p> Type Description <code>TopologyAccessor</code> <p>A cached TopologyAccessor instance.</p> <p>Examples:</p> <p>Visualize the network:</p> <pre><code>&gt;&gt;&gt; flow_system.topology.plot()\n&gt;&gt;&gt; flow_system.topology.plot(path='my_network.html', show=True)\n</code></pre> <p>Interactive visualization:</p> <pre><code>&gt;&gt;&gt; flow_system.topology.start_app()\n&gt;&gt;&gt; # ... interact with the visualization ...\n&gt;&gt;&gt; flow_system.topology.stop_app()\n</code></pre> <p>Get network structure info:</p> <pre><code>&gt;&gt;&gt; nodes, edges = flow_system.topology.infos()\n</code></pre>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.storages","title":"storages  <code>property</code>","text":"<pre><code>storages: ElementContainer[Storage]\n</code></pre> <p>All storage components as an ElementContainer.</p> <p>Returns:</p> Type Description <code>ElementContainer[Storage]</code> <p>ElementContainer containing all Storage components in the FlowSystem,</p> <code>ElementContainer[Storage]</code> <p>sorted by label for reproducibility.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: list[str]\n</code></pre> <p>Active dimension names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of active dimension names in order.</p> Example <p>fs.dims ['time']  # simple case fs_clustered.dims ['cluster', 'time', 'period', 'scenario']  # full case</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.indexes","title":"indexes  <code>property</code>","text":"<pre><code>indexes: dict[str, Index]\n</code></pre> <p>Indexes for active dimensions.</p> <p>Returns:</p> Type Description <code>dict[str, Index]</code> <p>Dict mapping dimension names to pandas Index objects.</p> Example <p>fs.indexes['time'] DatetimeIndex(['2024-01-01', ...], dtype='datetime64[ns]', name='time')</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.temporal_dims","title":"temporal_dims  <code>property</code>","text":"<pre><code>temporal_dims: list[str]\n</code></pre> <p>Temporal dimensions for summing over time.</p> <p>Returns ['time', 'cluster'] for clustered systems, ['time'] otherwise.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.temporal_weight","title":"temporal_weight  <code>property</code>","text":"<pre><code>temporal_weight: DataArray\n</code></pre> <p>Combined temporal weight (timestep_duration \u00d7 cluster_weight).</p> <p>Use for converting rates to totals before summing. Note: cluster_weight is used even without a clusters dimension.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.coords","title":"coords  <code>property</code>","text":"<pre><code>coords: dict[FlowSystemDimensions, Index]\n</code></pre> <p>Active coordinates for variable creation.</p> <p>.. deprecated::     Use :attr:<code>indexes</code> instead.</p> <p>Returns a dict of dimension names to coordinate arrays. When clustered, includes 'cluster' dimension before 'time'.</p> <p>Returns:</p> Type Description <code>dict[FlowSystemDimensions, Index]</code> <p>Dict mapping dimension names to coordinate arrays.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.is_segmented","title":"is_segmented  <code>property</code>","text":"<pre><code>is_segmented: bool\n</code></pre> <p>Check if this FlowSystem uses segmented time (RangeIndex instead of DatetimeIndex).</p> <p>Segmented systems have variable timestep durations stored in timestep_duration, and use a RangeIndex for time coordinates instead of DatetimeIndex.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.n_timesteps","title":"n_timesteps  <code>property</code>","text":"<pre><code>n_timesteps: int\n</code></pre> <p>Number of timesteps (within each cluster if clustered).</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.scenario_weights","title":"scenario_weights  <code>property</code> <code>writable</code>","text":"<pre><code>scenario_weights: DataArray | None\n</code></pre> <p>Weights for each scenario.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>xr.DataArray: Scenario weights with 'scenario' dimension</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.weights","title":"weights  <code>property</code>","text":"<pre><code>weights: dict[str, DataArray]\n</code></pre> <p>Weights for active dimensions (unit weights if not explicitly set).</p> <p>Returns:</p> Type Description <code>dict[str, DataArray]</code> <p>Dict mapping dimension names to weight DataArrays.</p> <code>dict[str, DataArray]</code> <p>Keys match :attr:<code>dims</code> and :attr:<code>indexes</code>.</p> Example <p>fs.weights['time']  # timestep durations fs.weights['cluster']  # cluster weights (unit if not set)</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.is_clustered","title":"is_clustered  <code>property</code>","text":"<pre><code>is_clustered: bool\n</code></pre> <p>Check if this FlowSystem uses time series clustering.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the FlowSystem was created with transform.cluster(),</p> <code>bool</code> <p>False otherwise.</p> Example <p>fs_clustered = flow_system.transform.cluster(n_clusters=8, cluster_duration='1D') fs_clustered.is_clustered True flow_system.is_clustered False</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.scenario_independent_sizes","title":"scenario_independent_sizes  <code>property</code> <code>writable</code>","text":"<pre><code>scenario_independent_sizes: bool | list[str]\n</code></pre> <p>Controls whether investment sizes are equalized across scenarios.</p> <p>Returns:</p> Type Description <code>bool | list[str]</code> <p>bool or list[str]: Configuration for scenario-independent sizing</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.scenario_independent_flow_rates","title":"scenario_independent_flow_rates  <code>property</code> <code>writable</code>","text":"<pre><code>scenario_independent_flow_rates: bool | list[str]\n</code></pre> <p>Controls whether flow rates are equalized across scenarios.</p> <p>Returns:</p> Type Description <code>bool | list[str]</code> <p>bool or list[str]: Configuration for scenario-independent flow rates</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem-functions","title":"Functions","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.calculate_timestep_duration","title":"calculate_timestep_duration  <code>staticmethod</code>","text":"<pre><code>calculate_timestep_duration(timesteps_extra: DatetimeIndex | RangeIndex) -&gt; xr.DataArray | None\n</code></pre> <p>Calculate duration of each timestep in hours as a 1D DataArray.</p> <p>For RangeIndex (segmented systems), returns None since duration cannot be computed from the index. Use timestep_duration parameter instead.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.calculate_weight_per_period","title":"calculate_weight_per_period  <code>staticmethod</code>","text":"<pre><code>calculate_weight_per_period(periods_extra: Index) -&gt; xr.DataArray\n</code></pre> <p>Calculate weight of each period from period index differences.</p> <p>Parameters:</p> Name Type Description Default <code>periods_extra</code> <code>Index</code> <p>Period index with an extra period at the end</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with weights for each period (1D, 'period' dimension)</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset(include_solution: bool = True, include_original_data: bool = True) -&gt; xr.Dataset\n</code></pre> <p>Convert the FlowSystem to an xarray Dataset. Ensures FlowSystem is connected before serialization.</p> <p>Data is stored in minimal form (scalars stay scalar, 1D arrays stay 1D) without broadcasting to full model dimensions. This provides significant memory savings for multi-period and multi-scenario models.</p> <p>If a solution is present and <code>include_solution=True</code>, it will be included in the dataset with variable names prefixed by 'solution|' to avoid conflicts with FlowSystem configuration variables. Solution time coordinates are renamed to 'solution_time' to preserve them independently of the FlowSystem's time coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>include_solution</code> <code>bool</code> <p>Whether to include the optimization solution in the dataset. Defaults to True. Set to False to get only the FlowSystem structure without solution data (useful for copying or saving templates).</p> <code>True</code> <code>include_original_data</code> <code>bool</code> <p>Whether to include clustering.original_data in the dataset. Defaults to True. Set to False for smaller files (~38% reduction) when clustering.plot.compare() isn't needed after loading. The core workflow (optimize \u2192 expand) works without original_data.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with structure in attributes</p> See Also <p>from_dataset: Create FlowSystem from dataset to_netcdf: Save to NetCDF file</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; FlowSystem\n</code></pre> <p>Create a FlowSystem from an xarray Dataset.</p> <p>If the dataset contains solution data (variables prefixed with 'solution|'), the solution will be restored to the FlowSystem. Solution time coordinates are renamed back from 'solution_time' to 'time'.</p> <p>Supports clustered datasets with (cluster, time) dimensions. When detected, creates a synthetic DatetimeIndex for compatibility and stores the clustered data structure for later use.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the FlowSystem data</p> required <p>Returns:</p> Type Description <code>FlowSystem</code> <p>FlowSystem instance</p> See Also <p>to_dataset: Convert FlowSystem to dataset from_netcdf: Load from NetCDF file</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False, include_original_data: bool = True)\n</code></pre> <p>Save the FlowSystem to a NetCDF file. Ensures FlowSystem is connected before saving.</p> <p>The FlowSystem's name is automatically set from the filename (without extension) when saving.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the netCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>The compression level to use when saving the file (0-9).</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <code>include_original_data</code> <code>bool</code> <p>Whether to include clustering.original_data in the file. Defaults to True. Set to False for smaller files (~38% reduction) when clustering.plot.compare() isn't needed after loading.</p> <code>True</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; FlowSystem\n</code></pre> <p>Load a FlowSystem from a NetCDF file.</p> <p>The FlowSystem's name is automatically derived from the filename (without extension), overriding any name that may have been stored.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>FlowSystem</code> <p>FlowSystem instance with name set from filename</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.from_old_results","title":"from_old_results  <code>classmethod</code>","text":"<pre><code>from_old_results(folder: str | Path, name: str) -&gt; FlowSystem\n</code></pre> <p>Load a FlowSystem from old-format Results files (pre-v5 API).</p> <p>This method loads results saved with the deprecated Results API (which used multiple files: <code>*--flow_system.nc4</code>, <code>*--solution.nc4</code>) and converts them to a FlowSystem with the solution attached.</p> <p>The method performs the following:</p> <ul> <li>Loads the old multi-file format</li> <li>Renames deprecated parameters in the FlowSystem structure   (e.g., <code>on_off_parameters</code> \u2192 <code>status_parameters</code>)</li> <li>Attaches the solution data to the FlowSystem</li> </ul> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path</code> <p>Directory containing the saved result files</p> required <code>name</code> <code>str</code> <p>Base name of the saved files (without extensions)</p> required <p>Returns:</p> Type Description <code>FlowSystem</code> <p>FlowSystem instance with solution attached</p> Warning <p>This is a best-effort migration for accessing old results:</p> <ul> <li>Solution variable names are NOT renamed - only basic variables   work (flow rates, sizes, charge states, effect totals)</li> <li>Advanced variable access may require using the original names</li> <li>Summary metadata (solver info, timing) is not loaded</li> </ul> <p>For full compatibility, re-run optimizations with the new API.</p> <p>Examples:</p> <pre><code># Load old results\nfs = FlowSystem.from_old_results('results_folder', 'my_optimization')\n\n# Access basic solution data\nfs.solution['Boiler(Q_th)|flow_rate'].plot()\n\n# Save in new single-file format\nfs.to_netcdf('my_optimization.nc')\n</code></pre> Deprecated <p>This method will be removed in v6.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.from_old_dataset","title":"from_old_dataset  <code>classmethod</code>","text":"<pre><code>from_old_dataset(path: str | Path) -&gt; FlowSystem\n</code></pre> <p>Load a FlowSystem from an old-format dataset file (pre-v5 API).</p> <p>This method loads a FlowSystem saved with older versions of flixopt (the <code>*--flow_system.nc4</code> file) and converts parameter names to the current API. Unlike :meth:<code>from_old_results</code>, this does not require a solution file and returns a FlowSystem without solution data.</p> <p>The method performs the following:</p> <ul> <li>Loads the old netCDF format</li> <li>Renames deprecated parameters in the FlowSystem structure   (e.g., <code>on_off_parameters</code> \u2192 <code>status_parameters</code>)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the old-format FlowSystem file (typically <code>*--flow_system.nc4</code>)</p> required <p>Returns:</p> Type Description <code>FlowSystem</code> <p>FlowSystem instance without solution</p> Warning <p>This is a best-effort migration for loading old FlowSystem definitions. For full compatibility, consider re-saving with the new API after loading.</p> <p>Examples:</p> <pre><code># Load old FlowSystem file\nfs = FlowSystem.from_old_dataset('results/my_run--flow_system.nc4')\n\n# Modify and optimize with current API\nfs.optimize(solver)\n\n# Save in new single-file format\nfs.to_netcdf('my_run.nc')\n</code></pre> Deprecated <p>This method will be removed in v6.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.copy","title":"copy","text":"<pre><code>copy() -&gt; FlowSystem\n</code></pre> <p>Create a copy of the FlowSystem without optimization state.</p> <p>Creates a new FlowSystem with copies of all elements, but without: - The solution dataset - The optimization model - Element submodels and variable/constraint names</p> <p>This is useful for creating variations of a FlowSystem for different optimization scenarios without affecting the original.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>A new FlowSystem instance that can be modified and optimized independently.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; original = FlowSystem(timesteps)\n&gt;&gt;&gt; original.add_elements(boiler, bus)\n&gt;&gt;&gt; original.optimize(solver)  # Original now has solution\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create a copy to try different parameters\n&gt;&gt;&gt; variant = original.copy()  # No solution, can be modified\n&gt;&gt;&gt; variant.add_elements(new_component)\n&gt;&gt;&gt; variant.optimize(solver)\n</code></pre>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get FlowSystem structure. Ensures FlowSystem is connected before getting structure.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the flow system to a JSON file. Ensures FlowSystem is connected before saving.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.fit_to_model_coords","title":"fit_to_model_coords","text":"<pre><code>fit_to_model_coords(name: str, data: NumericOrBool | None, dims: Collection[FlowSystemDimensions] | None = None) -&gt; xr.DataArray | None\n</code></pre> <p>Fit data to model coordinate system (currently time, but extensible).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the data</p> required <code>data</code> <code>NumericOrBool | None</code> <p>Data to fit to model coordinates (accepts any dimensionality including scalars)</p> required <code>dims</code> <code>Collection[FlowSystemDimensions] | None</code> <p>Collection of dimension names to use for fitting. If None, all dimensions are used.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>xr.DataArray aligned to model coordinate system. If data is None, returns None.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.fit_effects_to_model_coords","title":"fit_effects_to_model_coords","text":"<pre><code>fit_effects_to_model_coords(label_prefix: str | None, effect_values: Effect_TPS | Numeric_TPS | None, label_suffix: str | None = None, dims: Collection[FlowSystemDimensions] | None = None, delimiter: str = '|') -&gt; Effect_TPS | None\n</code></pre> <p>Transform EffectValues from the user to Internal Datatypes aligned with model coordinates.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.connect_and_transform","title":"connect_and_transform","text":"<pre><code>connect_and_transform()\n</code></pre> <p>Connect the network and transform all element data to model coordinates.</p> <p>This method performs the following steps:</p> <ol> <li>Connects flows to buses (establishing the network topology)</li> <li>Registers any missing carriers from CONFIG defaults</li> <li>Assigns colors to elements without explicit colors</li> <li>Transforms all element data to xarray DataArrays aligned with    FlowSystem coordinates (time, period, scenario)</li> <li>Validates system integrity</li> </ol> <p>This is called automatically by :meth:<code>build_model</code> and :meth:<code>optimize</code>.</p> Warning <p>After this method runs, element attributes (e.g., <code>flow.size</code>, <code>flow.relative_minimum</code>) contain transformed xarray DataArrays, not the original input values. If you modify element attributes after transformation, call :meth:<code>invalidate</code> to ensure the changes take effect on the next optimization.</p> Note <p>This method is idempotent within a single model lifecycle - calling it multiple times has no effect once <code>connected_and_transformed</code> is True. Use :meth:<code>invalidate</code> to reset this flag.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.add_elements","title":"add_elements","text":"<pre><code>add_elements(*elements: Element) -&gt; None\n</code></pre> <p>Add Components(Storages, Boilers, Heatpumps, ...), Buses or Effects to the FlowSystem</p> <p>Parameters:</p> Name Type Description Default <code>*elements</code> <code>Element</code> <p>childs of  Element like Boiler, HeatPump, Bus,... modeling Elements</p> <code>()</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the FlowSystem is locked (has a solution). Call <code>reset()</code> to unlock it first.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.add_carriers","title":"add_carriers","text":"<pre><code>add_carriers(*carriers: Carrier) -&gt; None\n</code></pre> <p>Register a custom carrier for this FlowSystem.</p> <p>Custom carriers registered on the FlowSystem take precedence over CONFIG.Carriers defaults when resolving colors and units for buses.</p> <p>Parameters:</p> Name Type Description Default <code>carriers</code> <code>Carrier</code> <p>Carrier objects defining the carrier properties.</p> <code>()</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the FlowSystem is locked (has a solution). Call <code>reset()</code> to unlock it first.</p> <p>Examples:</p> <pre><code>import flixopt as fx\n\nfs = fx.FlowSystem(timesteps)\n\n# Define and register custom carriers\nbiogas = fx.Carrier('biogas', '#228B22', 'kW', 'Biogas fuel')\nfs.add_carriers(biogas)\n\n# Now buses can reference this carrier by name\nbus = fx.Bus('BioGasNetwork', carrier='biogas')\nfs.add_elements(bus)\n\n# The carrier color will be used in plots automatically\n</code></pre>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.get_carrier","title":"get_carrier","text":"<pre><code>get_carrier(label: str) -&gt; Carrier | None\n</code></pre> <p>Get the carrier for a bus or flow.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Bus label (e.g., 'Fernw\u00e4rme') or flow label (e.g., 'Boiler(Q_th)').</p> required <p>Returns:</p> Type Description <code>Carrier | None</code> <p>Carrier or None if not found.</p> Note <p>To access a carrier directly by name, use <code>flow_system.carriers['electricity']</code>.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If FlowSystem is not connected_and_transformed.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.create_model","title":"create_model","text":"<pre><code>create_model(normalize_weights: bool | None = None) -&gt; FlowSystemModel\n</code></pre> <p>Create a linopy model from the FlowSystem.</p> <p>Parameters:</p> Name Type Description Default <code>normalize_weights</code> <code>bool | None</code> <p>Deprecated. Scenario weights are now always normalized in FlowSystem.</p> <code>None</code>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.build_model","title":"build_model","text":"<pre><code>build_model(normalize_weights: bool | None = None) -&gt; FlowSystem\n</code></pre> <p>Build the optimization model for this FlowSystem.</p> <p>This method prepares the FlowSystem for optimization by: 1. Connecting and transforming all elements (if not already done) 2. Creating the FlowSystemModel with all variables and constraints 3. Adding clustering constraints (if this is a clustered FlowSystem) 4. Adding typical periods modeling (if this is a reduced FlowSystem)</p> <p>After calling this method, <code>self.model</code> will be available for inspection before solving.</p> <p>Parameters:</p> Name Type Description Default <code>normalize_weights</code> <code>bool | None</code> <p>Deprecated. Scenario weights are now always normalized in FlowSystem.</p> <code>None</code> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>Self, for method chaining.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.build_model()\n&gt;&gt;&gt; print(flow_system.model.variables)  # Inspect variables before solving\n&gt;&gt;&gt; flow_system.solve(solver)\n</code></pre>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.solve","title":"solve","text":"<pre><code>solve(solver: _Solver) -&gt; FlowSystem\n</code></pre> <p>Solve the optimization model and populate the solution.</p> <p>This method solves the previously built model using the specified solver. After solving, <code>self.solution</code> will contain the optimization results, and each element's <code>.solution</code> property will provide access to its specific variables.</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>_Solver</code> <p>The solver to use (e.g., HighsSolver, GurobiSolver).</p> required <p>Returns:</p> Type Description <code>FlowSystem</code> <p>Self, for method chaining.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the model has not been built yet (call build_model first).</p> <code>RuntimeError</code> <p>If the model is infeasible.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.build_model()\n&gt;&gt;&gt; flow_system.solve(HighsSolver())\n&gt;&gt;&gt; print(flow_system.solution)\n</code></pre>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.get_variables_by_category","title":"get_variables_by_category","text":"<pre><code>get_variables_by_category(*categories: VariableCategory, from_solution: bool = True) -&gt; list[str]\n</code></pre> <p>Get variable names matching any of the specified categories.</p> <p>Parameters:</p> Name Type Description Default <code>*categories</code> <code>VariableCategory</code> <p>One or more VariableCategory values to filter by.</p> <code>()</code> <code>from_solution</code> <code>bool</code> <p>If True, only return variables present in solution. If False, return all registered variables matching categories.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of variable names matching any of the specified categories.</p> Example <p>fs.get_variables_by_category(VariableCategory.FLOW_RATE) ['Boiler(Q_th)|flow_rate', 'CHP(Q_th)|flow_rate', ...] fs.get_variables_by_category(VariableCategory.SIZE, VariableCategory.INVESTED) ['Boiler(Q_th)|size', 'Boiler(Q_th)|invested', ...]</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.reset","title":"reset","text":"<pre><code>reset() -&gt; FlowSystem\n</code></pre> <p>Clear optimization state to allow modifications.</p> <p>This method unlocks the FlowSystem by clearing: - The solution dataset - The optimization model - All element submodels and variable/constraint names - The connected_and_transformed flag</p> <p>After calling reset(), the FlowSystem can be modified again (e.g., adding elements or carriers).</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>Self, for method chaining.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.optimize(solver)  # FlowSystem is now locked\n&gt;&gt;&gt; flow_system.add_elements(new_bus)  # Raises RuntimeError\n&gt;&gt;&gt; flow_system.reset()  # Unlock the FlowSystem\n&gt;&gt;&gt; flow_system.add_elements(new_bus)  # Now works\n</code></pre>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.invalidate","title":"invalidate","text":"<pre><code>invalidate() -&gt; FlowSystem\n</code></pre> <p>Invalidate the model to allow re-transformation after modifying elements.</p> <p>Call this after modifying existing element attributes (e.g., <code>flow.size</code>, <code>flow.relative_minimum</code>) to ensure changes take effect on the next optimization. The next call to :meth:<code>optimize</code> or :meth:<code>build_model</code> will re-run :meth:<code>connect_and_transform</code>.</p> Note <p>Adding new elements via :meth:<code>add_elements</code> automatically invalidates the model. This method is only needed when modifying attributes of elements that are already part of the FlowSystem.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>Self, for method chaining.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the FlowSystem has a solution. Call :meth:<code>reset</code> first to clear the solution.</p> <p>Examples:</p> <p>Modify a flow's size and re-optimize:</p> <pre><code>&gt;&gt;&gt; flow_system.optimize(solver)\n&gt;&gt;&gt; flow_system.reset()  # Clear solution first\n&gt;&gt;&gt; flow_system.components['Boiler'].inputs[0].size = 200\n&gt;&gt;&gt; flow_system.invalidate()\n&gt;&gt;&gt; flow_system.optimize(solver)  # Re-runs connect_and_transform\n</code></pre> <p>Modify before first optimization:</p> <pre><code>&gt;&gt;&gt; flow_system.connect_and_transform()\n&gt;&gt;&gt; # Oops, need to change something\n&gt;&gt;&gt; flow_system.components['Boiler'].inputs[0].size = 200\n&gt;&gt;&gt; flow_system.invalidate()\n&gt;&gt;&gt; flow_system.optimize(solver)  # Changes take effect\n</code></pre>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.plot_network","title":"plot_network","text":"<pre><code>plot_network(path: bool | str | Path = 'flow_system.html', controls: bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']] = True, show: bool | None = None) -&gt; pyvis.network.Network | None\n</code></pre> <p>Deprecated: Use <code>flow_system.topology.plot()</code> instead.</p> <p>Visualizes the network structure of a FlowSystem using PyVis.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.start_network_app","title":"start_network_app","text":"<pre><code>start_network_app() -&gt; None\n</code></pre> <p>Deprecated: Use <code>flow_system.topology.start_app()</code> instead.</p> <p>Visualizes the network structure using Dash and Cytoscape.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.stop_network_app","title":"stop_network_app","text":"<pre><code>stop_network_app() -&gt; None\n</code></pre> <p>Deprecated: Use <code>flow_system.topology.stop_app()</code> instead.</p> <p>Stop the network visualization server.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.network_infos","title":"network_infos","text":"<pre><code>network_infos() -&gt; tuple[dict[str, dict[str, str]], dict[str, dict[str, str]]]\n</code></pre> <p>Deprecated: Use <code>flow_system.topology.infos()</code> instead.</p> <p>Get network topology information as dictionaries.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.sum_temporal","title":"sum_temporal","text":"<pre><code>sum_temporal(data: DataArray) -&gt; xr.DataArray\n</code></pre> <p>Sum data over temporal dimensions with full temporal weighting.</p> <p>Applies both timestep_duration and cluster_weight, then sums over temporal dimensions. Use this to convert rates to totals (e.g., flow_rate \u2192 total_energy).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataArray</code> <p>Data with time dimension (and optionally cluster).   Typically a rate (e.g., flow_rate in MW, status as 0/1).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>Data summed over temporal dims with full temporal weighting applied.</p> Example <p>total_energy = fs.sum_temporal(flow_rate)  # MW \u2192 MWh total active_hours = fs.sum_temporal(status)  # count \u2192 hours</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.sel","title":"sel","text":"<pre><code>sel(time: str | slice | list[str] | Timestamp | DatetimeIndex | None = None, period: int | slice | list[int] | Index | None = None, scenario: str | slice | list[str] | Index | None = None) -&gt; FlowSystem\n</code></pre> <p>Select a subset of the flowsystem by label.</p> <p>.. deprecated::     Use <code>flow_system.transform.sel()</code> instead. Will be removed in v6.0.0.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>str | slice | list[str] | Timestamp | DatetimeIndex | None</code> <p>Time selection (e.g., slice('2023-01-01', '2023-12-31'), '2023-06-15')</p> <code>None</code> <code>period</code> <code>int | slice | list[int] | Index | None</code> <p>Period selection (e.g., slice(2023, 2024), or list of periods)</p> <code>None</code> <code>scenario</code> <code>str | slice | list[str] | Index | None</code> <p>Scenario selection (e.g., 'scenario1', or list of scenarios)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>New FlowSystem with selected data (no solution).</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.isel","title":"isel","text":"<pre><code>isel(time: int | slice | list[int] | None = None, period: int | slice | list[int] | None = None, scenario: int | slice | list[int] | None = None) -&gt; FlowSystem\n</code></pre> <p>Select a subset of the flowsystem by integer indices.</p> <p>.. deprecated::     Use <code>flow_system.transform.isel()</code> instead. Will be removed in v6.0.0.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>int | slice | list[int] | None</code> <p>Time selection by integer index (e.g., slice(0, 100), 50, or [0, 5, 10])</p> <code>None</code> <code>period</code> <code>int | slice | list[int] | None</code> <p>Period selection by integer index</p> <code>None</code> <code>scenario</code> <code>int | slice | list[int] | None</code> <p>Scenario selection by integer index</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>New FlowSystem with selected data (no solution).</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.resample","title":"resample","text":"<pre><code>resample(time: str, method: Literal['mean', 'sum', 'max', 'min', 'first', 'last', 'std', 'var', 'median', 'count'] = 'mean', hours_of_last_timestep: int | float | None = None, hours_of_previous_timesteps: int | float | ndarray | None = None, **kwargs: Any) -&gt; FlowSystem\n</code></pre> <p>Create a resampled FlowSystem by resampling data along the time dimension.</p> <p>.. deprecated::     Use <code>flow_system.transform.resample()</code> instead. Will be removed in v6.0.0.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>str</code> <p>Resampling frequency (e.g., '3h', '2D', '1M')</p> required <code>method</code> <code>Literal['mean', 'sum', 'max', 'min', 'first', 'last', 'std', 'var', 'median', 'count']</code> <p>Resampling method. Recommended: 'mean', 'first', 'last', 'max', 'min'</p> <code>'mean'</code> <code>hours_of_last_timestep</code> <code>int | float | None</code> <p>Duration of the last timestep after resampling.</p> <code>None</code> <code>hours_of_previous_timesteps</code> <code>int | float | ndarray | None</code> <p>Duration of previous timesteps after resampling.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to xarray.resample()</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>New resampled FlowSystem (no solution).</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.keys","title":"keys","text":"<pre><code>keys() -&gt; list[str]\n</code></pre> <p>Return all element labels across all containers.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.values","title":"values","text":"<pre><code>values() -&gt; list[T_element]\n</code></pre> <p>Return all element objects across all containers.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.items","title":"items","text":"<pre><code>items() -&gt; list[tuple[str, T_element]]\n</code></pre> <p>Return (label, element) pairs for all elements.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.transform_data","title":"transform_data","text":"<pre><code>transform_data() -&gt; None\n</code></pre> <p>Transform the data of the interface to match the FlowSystem's dimensions.</p> <p>Uses <code>self._prefix</code> (set during <code>link_to_flow_system()</code>) to name transformed data.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Note <p>The FlowSystem reference is available via self._flow_system (for Interface objects) or self.flow_system property (for Element objects). Elements must be registered to a FlowSystem before calling this method.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system: FlowSystem, prefix: str = '') -&gt; None\n</code></pre> <p>Link this interface and all nested interfaces to a FlowSystem.</p> <p>This method is called automatically during element registration to enable elements to access FlowSystem properties without passing the reference through every method call. It also sets the prefix used for naming transformed data.</p> <p>Subclasses with nested Interface objects should override this method to propagate the link to their nested interfaces by calling <code>super().link_to_flow_system(flow_system, prefix)</code> first, then linking nested objects with appropriate prefixes.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to link to</p> required <code>prefix</code> <code>str</code> <p>The prefix for naming transformed data (e.g., 'Boiler(Q_th)')</p> <code>''</code> <p>Examples:</p> <p>Override in a subclass with nested interfaces:</p> <pre><code>def link_to_flow_system(self, flow_system, prefix: str = '') -&gt; None:\n    super().link_to_flow_system(flow_system, prefix)\n    if self.nested_interface is not None:\n        self.nested_interface.link_to_flow_system(flow_system, f'{prefix}|nested' if prefix else 'nested')\n</code></pre> <p>Creating an Interface dynamically during modeling:</p> <pre><code># In a Model class\nif flow.status_parameters is None:\n    flow.status_parameters = StatusParameters()\n    flow.status_parameters.link_to_flow_system(self._model.flow_system, f'{flow.label_full}')\n</code></pre>"},{"location":"api-reference/interface/","title":"Interface","text":""},{"location":"api-reference/interface/#flixopt.interface","title":"flixopt.interface","text":"<p>This module contains classes to collect Parameters for the Investment and Status decisions. These are tightly connected to features.py</p>"},{"location":"api-reference/interface/#flixopt.interface-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixopt.interface-classes","title":"Classes","text":""},{"location":"api-reference/interface/#flixopt.interface.Piece","title":"Piece","text":"<pre><code>Piece(start: Numeric_TPS, end: Numeric_TPS)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a single linear segment with specified domain boundaries.</p> <p>This class represents one linear segment that will be combined with other pieces to form complete piecewise linear functions. Each piece defines a domain interval [start, end] where a linear relationship applies.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Numeric_TPS</code> <p>Lower bound of the domain interval for this linear segment. Can be scalar values or time series arrays for time-varying boundaries.</p> required <code>end</code> <code>Numeric_TPS</code> <p>Upper bound of the domain interval for this linear segment. Can be scalar values or time series arrays for time-varying boundaries.</p> required <p>Examples:</p> <p>Basic piece for equipment efficiency curve:</p> <pre><code># Single segment from 40% to 80% load\nefficiency_segment = Piece(start=40, end=80)\n</code></pre> <p>Piece with time-varying boundaries:</p> <pre><code># Capacity limits that change seasonally\nseasonal_piece = Piece(\n    start=np.array([10, 20, 30, 25]),  # Minimum capacity by season\n    end=np.array([80, 100, 90, 70]),  # Maximum capacity by season\n)\n</code></pre> <p>Fixed operating point (start equals end):</p> <pre><code># Equipment that operates at exactly 50 MW\nfixed_output = Piece(start=50, end=50)\n</code></pre> Note <p>Individual pieces are building blocks that gain meaning when combined into Piecewise functions. See the Piecewise class for information about how pieces interact and relate to each other.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixopt.interface.Piece.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.Piece.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system: FlowSystem, prefix: str = '') -&gt; None\n</code></pre> <p>Link this interface and all nested interfaces to a FlowSystem.</p> <p>This method is called automatically during element registration to enable elements to access FlowSystem properties without passing the reference through every method call. It also sets the prefix used for naming transformed data.</p> <p>Subclasses with nested Interface objects should override this method to propagate the link to their nested interfaces by calling <code>super().link_to_flow_system(flow_system, prefix)</code> first, then linking nested objects with appropriate prefixes.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to link to</p> required <code>prefix</code> <code>str</code> <p>The prefix for naming transformed data (e.g., 'Boiler(Q_th)')</p> <code>''</code> <p>Examples:</p> <p>Override in a subclass with nested interfaces:</p> <pre><code>def link_to_flow_system(self, flow_system, prefix: str = '') -&gt; None:\n    super().link_to_flow_system(flow_system, prefix)\n    if self.nested_interface is not None:\n        self.nested_interface.link_to_flow_system(flow_system, f'{prefix}|nested' if prefix else 'nested')\n</code></pre> <p>Creating an Interface dynamically during modeling:</p> <pre><code># In a Model class\nif flow.status_parameters is None:\n    flow.status_parameters = StatusParameters()\n    flow.status_parameters.link_to_flow_system(self._model.flow_system, f'{flow.label_full}')\n</code></pre>"},{"location":"api-reference/interface/#flixopt.interface.Piece.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise","title":"Piecewise","text":"<pre><code>Piecewise(pieces: list[Piece])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define piecewise linear approximations for modeling non-linear relationships.</p> <p>Enables modeling of non-linear relationships through piecewise linear segments while maintaining problem linearity. Consists of a collection of Pieces that define valid ranges for variables.</p> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/features/Piecewise/</p> <p>Parameters:</p> Name Type Description Default <code>pieces</code> <code>list[Piece]</code> <p>list of Piece objects defining the linear segments. The arrangement and relationships between pieces determine the function behavior: - Touching pieces (end of one = start of next) ensure continuity - Gaps between pieces create forbidden regions - Overlapping pieces provide an extra choice for the optimizer</p> required Piece Relationship Patterns <p>Touching Pieces (Continuous Function): Pieces that share boundary points create smooth, continuous functions without gaps or overlaps.</p> <p>Gaps Between Pieces (Forbidden Regions): Non-contiguous pieces with gaps represent forbidden regions. For example minimum load requirements or safety zones.</p> <p>Overlapping Pieces (Flexible Operation): Pieces with overlapping domains provide optimization flexibility, allowing the solver to choose which segment to operate in.</p> <p>Examples:</p> <p>Continuous efficiency curve (touching pieces):</p> <pre><code>efficiency_curve = Piecewise(\n    [\n        Piece(start=0, end=25),  # Low load: 0-25 MW\n        Piece(start=25, end=75),  # Medium load: 25-75 MW (touches at 25)\n        Piece(start=75, end=100),  # High load: 75-100 MW (touches at 75)\n    ]\n)\n</code></pre> <p>Equipment with forbidden operating range (gap):</p> <pre><code>turbine_operation = Piecewise(\n    [\n        Piece(start=0, end=0),  # Off state (point operation)\n        Piece(start=40, end=100),  # Operating range (gap: 0-40 forbidden)\n    ]\n)\n</code></pre> <p>Flexible operation with overlapping options:</p> <pre><code>flexible_operation = Piecewise(\n    [\n        Piece(start=20, end=60),  # Standard efficiency mode\n        Piece(start=50, end=90),  # High efficiency mode (overlap: 50-60)\n    ]\n)\n</code></pre> <p>Tiered pricing structure:</p> <pre><code>electricity_pricing = Piecewise(\n    [\n        Piece(start=0, end=100),  # Tier 1: 0-100 kWh\n        Piece(start=100, end=500),  # Tier 2: 100-500 kWh\n        Piece(start=500, end=1000),  # Tier 3: 500-1000 kWh\n    ]\n)\n</code></pre> <p>Seasonal capacity variation:</p> <pre><code>seasonal_capacity = Piecewise(\n    [\n        Piece(start=[10, 15, 20, 12], end=[80, 90, 85, 75]),  # Varies by time\n    ]\n)\n</code></pre> Container Operations <p>The Piecewise class supports standard Python container operations:</p> <pre><code>piecewise = Piecewise([piece1, piece2, piece3])\n\nlen(piecewise)  # Returns number of pieces (3)\npiecewise[0]  # Access first piece\nfor piece in piecewise:  # Iterate over all pieces\n    print(piece.start, piece.end)\n</code></pre> Validation Considerations <ul> <li>Pieces are typically ordered by their start values</li> <li>Check for unintended gaps that might create infeasible regions</li> <li>Consider whether overlaps provide desired flexibility or create ambiguity</li> <li>Ensure time-varying pieces have consistent dimensions</li> </ul> Common Use Cases <ul> <li>Power plants: Heat rate curves, efficiency vs load, emissions profiles</li> <li>HVAC systems: COP vs temperature, capacity vs conditions</li> <li>Industrial processes: Conversion rates vs throughput, quality vs speed</li> <li>Financial modeling: Tiered rates, progressive taxes, bulk discounts</li> <li>Transportation: Fuel efficiency curves, capacity vs speed</li> <li>Storage systems: Efficiency vs state of charge, power vs energy</li> <li>Renewable energy: Output vs weather conditions, curtailment strategies</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixopt.interface.Piecewise.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.Piecewise.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to nested Piece objects.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion","title":"PiecewiseConversion","text":"<pre><code>PiecewiseConversion(piecewises: dict[str, Piecewise])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define coordinated piecewise linear relationships between multiple flows.</p> <p>This class models conversion processes where multiple flows (inputs, outputs, auxiliaries) have synchronized piecewise relationships. All flows change together based on the same operating point, enabling accurate modeling of complex equipment with variable performance characteristics.</p> Multi-Flow Coordination <p>All piecewise functions must have matching piece structures (same number of pieces with compatible domains) to ensure synchronized operation. When the equipment operates at a given point, ALL flows scale proportionally within their respective pieces.</p> Mathematical Formulation <p>See the complete mathematical model in the documentation: Piecewise</p> <p>Parameters:</p> Name Type Description Default <code>piecewises</code> <code>dict[str, Piecewise]</code> <p>Dictionary mapping flow labels to their Piecewise functions. Keys are flow identifiers (e.g., 'electricity_in', 'heat_out', 'fuel_consumed'). Values are Piecewise objects that define each flow's behavior. Critical Requirement: All Piecewise objects must have the same number of pieces with compatible domains to ensure consistent operation.</p> required Operating Point Coordination <p>When equipment operates at any point within a piece, all flows scale proportionally within their corresponding pieces. This ensures realistic equipment behavior where efficiency, consumption, and production rates all change together.</p> <p>Examples:</p> <p>Heat pump with coordinated efficiency changes:</p> <pre><code>heat_pump_pc = PiecewiseConversion(\n    {\n        'electricity_in': Piecewise(\n            [\n                Piece(0, 10),  # Low load: 0-10 kW electricity\n                Piece(10, 25),  # High load: 10-25 kW electricity\n            ]\n        ),\n        'heat_out': Piecewise(\n            [\n                Piece(0, 35),  # Low load COP=3.5: 0-35 kW heat\n                Piece(35, 75),  # High load COP=3.0: 35-75 kW heat\n            ]\n        ),\n        'cooling_water': Piecewise(\n            [\n                Piece(0, 2.5),  # Low load: 0-2.5 m\u00b3/h cooling\n                Piece(2.5, 6),  # High load: 2.5-6 m\u00b3/h cooling\n            ]\n        ),\n    }\n)\n# At 15 kW electricity \u2192 52.5 kW heat + 3.75 m\u00b3/h cooling water\n</code></pre> <p>Combined cycle power plant with synchronized flows:</p> <pre><code>power_plant_pc = PiecewiseConversion(\n    {\n        'natural_gas': Piecewise(\n            [\n                Piece(150, 300),  # Part load: 150-300 MW_th fuel\n                Piece(300, 500),  # Full load: 300-500 MW_th fuel\n            ]\n        ),\n        'electricity': Piecewise(\n            [\n                Piece(60, 135),  # Part load: 60-135 MW_e (45% efficiency)\n                Piece(135, 250),  # Full load: 135-250 MW_e (50% efficiency)\n            ]\n        ),\n        'steam_export': Piecewise(\n            [\n                Piece(20, 35),  # Part load: 20-35 MW_th steam\n                Piece(35, 50),  # Full load: 35-50 MW_th steam\n            ]\n        ),\n        'co2_emissions': Piecewise(\n            [\n                Piece(30, 60),  # Part load: 30-60 t/h CO2\n                Piece(60, 100),  # Full load: 60-100 t/h CO2\n            ]\n        ),\n    }\n)\n</code></pre> <p>Chemical reactor with multiple products and waste:</p> <pre><code>reactor_pc = PiecewiseConversion(\n    {\n        'feedstock': Piecewise(\n            [\n                Piece(10, 50),  # Small batch: 10-50 kg/h\n                Piece(50, 200),  # Large batch: 50-200 kg/h\n            ]\n        ),\n        'product_A': Piecewise(\n            [\n                Piece(7, 35),  # Small batch: 70% yield\n                Piece(35, 140),  # Large batch: 70% yield\n            ]\n        ),\n        'product_B': Piecewise(\n            [\n                Piece(2, 10),  # Small batch: 20% yield\n                Piece(10, 45),  # Large batch: 22.5% yield (improved)\n            ]\n        ),\n        'waste_stream': Piecewise(\n            [\n                Piece(1, 5),  # Small batch: 10% waste\n                Piece(5, 15),  # Large batch: 7.5% waste (efficiency)\n            ]\n        ),\n    }\n)\n</code></pre> <p>Equipment with discrete operating modes:</p> <pre><code>compressor_pc = PiecewiseConversion(\n    {\n        'electricity': Piecewise(\n            [\n                Piece(0, 0),  # Off mode: no consumption\n                Piece(45, 45),  # Low mode: fixed 45 kW\n                Piece(85, 85),  # High mode: fixed 85 kW\n            ]\n        ),\n        'compressed_air': Piecewise(\n            [\n                Piece(0, 0),  # Off mode: no production\n                Piece(250, 250),  # Low mode: 250 Nm\u00b3/h\n                Piece(500, 500),  # High mode: 500 Nm\u00b3/h\n            ]\n        ),\n    }\n)\n</code></pre> <p>Equipment with forbidden operating range:</p> <pre><code>steam_turbine_pc = PiecewiseConversion(\n    {\n        'steam_in': Piecewise(\n            [\n                Piece(0, 100),  # Low pressure operation\n                Piece(200, 500),  # High pressure (gap: 100-200 forbidden)\n            ]\n        ),\n        'electricity_out': Piecewise(\n            [\n                Piece(0, 30),  # Low pressure: poor efficiency\n                Piece(80, 220),  # High pressure: good efficiency\n            ]\n        ),\n        'condensate_out': Piecewise(\n            [\n                Piece(0, 100),  # Low pressure condensate\n                Piece(200, 500),  # High pressure condensate\n            ]\n        ),\n    }\n)\n</code></pre> Design Patterns <p>Forbidden Ranges: Use gaps between pieces to model equipment that cannot operate in certain ranges (e.g., minimum loads, unstable regions).</p> <p>Discrete Modes: Use pieces with identical start/end values to model equipment with fixed operating points (e.g., on/inactive, discrete speeds).</p> <p>Efficiency Changes: Coordinate input and output pieces to reflect changing conversion efficiency across operating ranges.</p> Common Use Cases <ul> <li>Power generation: Multi-fuel plants, cogeneration systems, renewable hybrids</li> <li>HVAC systems: Heat pumps, chillers with variable COP and auxiliary loads</li> <li>Industrial processes: Multi-product reactors, separation units, heat exchangers</li> <li>Transportation: Multi-modal systems, hybrid vehicles, charging infrastructure</li> <li>Water treatment: Multi-stage processes with varying energy and chemical needs</li> <li>Energy storage: Systems with efficiency changes and auxiliary power requirements</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Return an iterator over (flow_label, Piecewise) pairs stored in this PiecewiseConversion.</p> <p>This is a thin convenience wrapper around the internal mapping and yields the same view as dict.items(), where each key is a flow label (str) and each value is a Piecewise.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to nested Piecewise objects.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.plot","title":"plot","text":"<pre><code>plot(x_flow: str | None = None, title: str = '', select: dict[str, Any] | None = None, colorscale: str | None = None, show: bool | None = None) -&gt; PlotResult\n</code></pre> <p>Plot multi-flow piecewise conversion with time variation visualization.</p> <p>Visualizes the piecewise linear relationships between flows. Each flow is shown in a separate subplot (faceted by flow). Pieces are distinguished by line dash style. If boundaries vary over time, color shows time progression.</p> Note <p>Requires FlowSystem to be connected and transformed (call flow_system.connect_and_transform() first).</p> <p>Parameters:</p> Name Type Description Default <code>x_flow</code> <code>str | None</code> <p>Flow label to use for X-axis. Defaults to first flow in dict.</p> <code>None</code> <code>title</code> <code>str</code> <p>Plot title.</p> <code>''</code> <code>select</code> <code>dict[str, Any] | None</code> <p>xarray-style selection dict to filter data, e.g. {'time': slice('2024-01-01', '2024-01-02')}.</p> <code>None</code> <code>colorscale</code> <code>str | None</code> <p>Colorscale name for time coloring (e.g., 'RdYlBu_r', 'viridis'). Defaults to CONFIG.Plotting.default_sequential_colorscale.</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure. Defaults to CONFIG.Plotting.default_show.</p> <code>None</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult containing the figure and underlying piecewise data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.connect_and_transform()\n&gt;&gt;&gt; chp.piecewise_conversion.plot(x_flow='Gas', title='CHP Curves')\n&gt;&gt;&gt; # Select specific time range\n&gt;&gt;&gt; chp.piecewise_conversion.plot(select={'time': slice(0, 12)})\n</code></pre>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects","title":"PiecewiseEffects","text":"<pre><code>PiecewiseEffects(piecewise_origin: Piecewise, piecewise_shares: dict[str, Piecewise])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define how a single decision variable contributes to system effects with piecewise rates.</p> <p>This class models situations where a decision variable (the origin) generates different types of system effects (costs, emissions, resource consumption) at rates that change non-linearly with the variable's operating level. Unlike PiecewiseConversion which coordinates multiple flows, PiecewiseEffects focuses on how one variable impacts multiple system-wide effects.</p> <p>Key Concept - Origin vs. Effects:     - Origin: The primary decision variable (e.g., production level, capacity, size)     - Shares: The amounts which this variable contributes to different system effects</p> Relationship to PiecewiseConversion <p>PiecewiseConversion: Models synchronized relationships between multiple flow variables (e.g., fuel_in, electricity_out, emissions_out all coordinated).</p> <p>PiecewiseEffects: Models how one variable contributes to system-wide effects at variable rates (e.g., production_level \u2192 costs, emissions, resources).</p> <p>Parameters:</p> Name Type Description Default <code>piecewise_origin</code> <code>Piecewise</code> <p>Piecewise function defining the behavior of the primary decision variable. This establishes the operating domain and ranges.</p> required <code>piecewise_shares</code> <code>dict[str, Piecewise]</code> <p>Dictionary mapping effect names to their rate functions. Keys are effect identifiers (e.g., 'cost_per_unit', 'CO2_intensity'). Values are Piecewise objects defining the contribution rate per unit of the origin variable at different operating levels.</p> required Mathematical Relationship <p>For each effect: Total_Effect = Origin_Variable \u00d7 Share_Rate(Origin_Level)</p> <p>This enables modeling of: - Economies of scale (decreasing unit costs with volume) - Learning curves (improving efficiency with experience) - Threshold effects (changing rates at different scales) - Progressive pricing (increasing rates with consumption)</p> <p>Examples:</p> <p>Manufacturing with economies of scale:</p> <pre><code>production_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(0, 1000),  # Small scale: 0-1000 units/month\n            Piece(1000, 5000),  # Medium scale: 1000-5000 units/month\n            Piece(5000, 10000),  # Large scale: 5000-10000 units/month\n        ]\n    ),\n    piecewise_shares={\n        'unit_cost': Piecewise(\n            [\n                Piece(50, 45),  # \u20ac50-45/unit (scale benefits)\n                Piece(45, 35),  # \u20ac45-35/unit (bulk materials)\n                Piece(35, 30),  # \u20ac35-30/unit (automation benefits)\n            ]\n        ),\n        'labor_hours': Piecewise(\n            [\n                Piece(2.5, 2.0),  # 2.5-2.0 hours/unit (learning curve)\n                Piece(2.0, 1.5),  # 2.0-1.5 hours/unit (efficiency gains)\n                Piece(1.5, 1.2),  # 1.5-1.2 hours/unit (specialization)\n            ]\n        ),\n        'CO2_intensity': Piecewise(\n            [\n                Piece(15, 12),  # 15-12 kg CO2/unit (process optimization)\n                Piece(12, 9),  # 12-9 kg CO2/unit (equipment efficiency)\n                Piece(9, 7),  # 9-7 kg CO2/unit (renewable energy)\n            ]\n        ),\n    },\n)\n</code></pre> <p>Power generation with load-dependent characteristics:</p> <pre><code>generator_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(50, 200),  # Part load operation: 50-200 MW\n            Piece(200, 350),  # Rated operation: 200-350 MW\n            Piece(350, 400),  # Overload operation: 350-400 MW\n        ]\n    ),\n    piecewise_shares={\n        'fuel_rate': Piecewise(\n            [\n                Piece(12.0, 10.5),  # Heat rate: 12.0-10.5 GJ/MWh (part load penalty)\n                Piece(10.5, 9.8),  # Heat rate: 10.5-9.8 GJ/MWh (optimal efficiency)\n                Piece(9.8, 11.2),  # Heat rate: 9.8-11.2 GJ/MWh (overload penalty)\n            ]\n        ),\n        'maintenance_factor': Piecewise(\n            [\n                Piece(0.8, 1.0),  # Low stress operation\n                Piece(1.0, 1.0),  # Design operation\n                Piece(1.0, 1.5),  # High stress operation\n            ]\n        ),\n        'NOx_rate': Piecewise(\n            [\n                Piece(0.20, 0.15),  # NOx: 0.20-0.15 kg/MWh\n                Piece(0.15, 0.12),  # NOx: 0.15-0.12 kg/MWh (optimal combustion)\n                Piece(0.12, 0.25),  # NOx: 0.12-0.25 kg/MWh (overload penalties)\n            ]\n        ),\n    },\n)\n</code></pre> <p>Progressive utility pricing structure:</p> <pre><code>electricity_billing = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(0, 200),  # Basic usage: 0-200 kWh/month\n            Piece(200, 800),  # Standard usage: 200-800 kWh/month\n            Piece(800, 2000),  # High usage: 800-2000 kWh/month\n        ]\n    ),\n    piecewise_shares={\n        'energy_rate': Piecewise(\n            [\n                Piece(0.12, 0.12),  # Basic rate: \u20ac0.12/kWh\n                Piece(0.18, 0.18),  # Standard rate: \u20ac0.18/kWh\n                Piece(0.28, 0.28),  # Premium rate: \u20ac0.28/kWh\n            ]\n        ),\n        'carbon_tax': Piecewise(\n            [\n                Piece(0.02, 0.02),  # Low carbon tax: \u20ac0.02/kWh\n                Piece(0.03, 0.03),  # Medium carbon tax: \u20ac0.03/kWh\n                Piece(0.05, 0.05),  # High carbon tax: \u20ac0.05/kWh\n            ]\n        ),\n    },\n)\n</code></pre> <p>Data center with capacity-dependent efficiency:</p> <pre><code>datacenter_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(100, 500),  # Low utilization: 100-500 servers\n            Piece(500, 2000),  # Medium utilization: 500-2000 servers\n            Piece(2000, 5000),  # High utilization: 2000-5000 servers\n        ]\n    ),\n    piecewise_shares={\n        'power_per_server': Piecewise(\n            [\n                Piece(0.8, 0.6),  # 0.8-0.6 kW/server (inefficient cooling)\n                Piece(0.6, 0.4),  # 0.6-0.4 kW/server (optimal efficiency)\n                Piece(0.4, 0.5),  # 0.4-0.5 kW/server (thermal limits)\n            ]\n        ),\n        'cooling_overhead': Piecewise(\n            [\n                Piece(0.4, 0.3),  # 40%-30% cooling overhead\n                Piece(0.3, 0.2),  # 30%-20% cooling overhead\n                Piece(0.2, 0.25),  # 20%-25% cooling overhead\n            ]\n        ),\n    },\n)\n</code></pre> Design Patterns <p>Economies of Scale: Decreasing unit costs/impacts with increased scale Learning Curves: Improving efficiency rates with experience/volume Threshold Effects: Step changes in rates at specific operating levels Progressive Pricing: Increasing rates for higher consumption levels Capacity Utilization: Optimal efficiency at design points, penalties at extremes</p> Common Use Cases <ul> <li>Manufacturing: Production scaling, learning effects, quality improvements</li> <li>Energy systems: Generator efficiency curves, renewable capacity factors</li> <li>Logistics: Transportation rates, warehouse utilization, delivery optimization</li> <li>Utilities: Progressive pricing, infrastructure cost allocation</li> <li>Financial services: Risk premiums, transaction fees, volume discounts</li> <li>Environmental modeling: Pollution intensity, resource consumption rates</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to nested Piecewise objects.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.plot","title":"plot","text":"<pre><code>plot(title: str = '', select: dict[str, Any] | None = None, colorscale: str | None = None, show: bool | None = None) -&gt; PlotResult\n</code></pre> <p>Plot origin vs effect shares with time variation visualization.</p> <p>Visualizes the piecewise linear relationships between the origin variable and its effect shares. Each effect is shown in a separate subplot (faceted by effect). Pieces are distinguished by line dash style.</p> Note <p>Requires FlowSystem to be connected and transformed (call flow_system.connect_and_transform() first).</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Plot title.</p> <code>''</code> <code>select</code> <code>dict[str, Any] | None</code> <p>xarray-style selection dict to filter data, e.g. {'time': slice('2024-01-01', '2024-01-02')}.</p> <code>None</code> <code>colorscale</code> <code>str | None</code> <p>Colorscale name for time coloring (e.g., 'RdYlBu_r', 'viridis'). Defaults to CONFIG.Plotting.default_sequential_colorscale.</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure. Defaults to CONFIG.Plotting.default_show.</p> <code>None</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult containing the figure and underlying piecewise data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.connect_and_transform()\n&gt;&gt;&gt; invest_params.piecewise_effects_of_investment.plot(title='Investment Effects')\n</code></pre>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters","title":"InvestParameters","text":"<pre><code>InvestParameters(fixed_size: Numeric_PS | None = None, minimum_size: Numeric_PS | None = None, maximum_size: Numeric_PS | None = None, mandatory: bool = False, effects_of_investment: Effect_PS | Numeric_PS | None = None, effects_of_investment_per_size: Effect_PS | Numeric_PS | None = None, effects_of_retirement: Effect_PS | Numeric_PS | None = None, piecewise_effects_of_investment: PiecewiseEffects | None = None, linked_periods: Numeric_PS | tuple[int, int] | None = None)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define investment decision parameters with flexible sizing and effect modeling.</p> <p>This class models investment decisions in optimization problems, supporting both binary (invest/don't invest) and continuous sizing choices with comprehensive cost structures. It enables realistic representation of investment economics including fixed costs, scale effects, and divestment penalties.</p> Investment Decision Types <p>Binary Investments: Fixed size investments creating yes/no decisions (e.g., install a specific generator, build a particular facility)</p> <p>Continuous Sizing: Variable size investments with minimum/maximum bounds (e.g., battery capacity from 10-1000 kWh, pipeline diameter optimization)</p> Cost Modeling Approaches <ul> <li>Fixed Effects: One-time costs independent of size (permits, connections)</li> <li>Specific Effects: Linear costs proportional to size (\u20ac/kW, \u20ac/m\u00b2)</li> <li>Piecewise Effects: Non-linear relationships (bulk discounts, learning curves)</li> <li>Divestment Effects: Penalties for not investing (demolition, opportunity costs)</li> </ul> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/features/InvestParameters/</p> <p>Parameters:</p> Name Type Description Default <code>fixed_size</code> <code>Numeric_PS | None</code> <p>Creates binary decision at this exact size. None allows continuous sizing.</p> <code>None</code> <code>minimum_size</code> <code>Numeric_PS | None</code> <p>Lower bound for continuous sizing. Default: CONFIG.Modeling.epsilon. Ignored if fixed_size is specified.</p> <code>None</code> <code>maximum_size</code> <code>Numeric_PS | None</code> <p>Upper bound for continuous sizing. Required if fixed_size is not set. Ignored if fixed_size is specified.</p> <code>None</code> <code>mandatory</code> <code>bool</code> <p>Controls whether investment is required. When True, forces investment to occur (useful for mandatory upgrades or replacement decisions). When False (default), optimization can choose not to invest. With multiple periods, at least one period has to have an investment.</p> <code>False</code> <code>effects_of_investment</code> <code>Effect_PS | Numeric_PS | None</code> <p>Fixed costs if investment is made, regardless of size. Dict: {'effect_name': value} (e.g., {'cost': 10000}).</p> <code>None</code> <code>effects_of_investment_per_size</code> <code>Effect_PS | Numeric_PS | None</code> <p>Variable costs proportional to size (per-unit costs). Dict: {'effect_name': value/unit} (e.g., {'cost': 1200}).</p> <code>None</code> <code>piecewise_effects_of_investment</code> <code>PiecewiseEffects | None</code> <p>Non-linear costs using PiecewiseEffects. Combinable with effects_of_investment and effects_of_investment_per_size.</p> <code>None</code> <code>effects_of_retirement</code> <code>Effect_PS | Numeric_PS | None</code> <p>Costs incurred if NOT investing (demolition, penalties). Dict: {'effect_name': value}.</p> <code>None</code> <code>linked_periods</code> <code>Numeric_PS | tuple[int, int] | None</code> <p>Describes which periods are linked. 1 means linked, 0 means size=0. None means no linked periods. For convenience, pass a tuple containing the first and last period (2025, 2039), linking them and those in between</p> <code>None</code> Cost Annualization Requirements <p>All cost values must be properly weighted to match the optimization model's time horizon. For long-term investments, the cost values should be annualized to the corresponding operation time (annuity).</p> <ul> <li>Use equivalent annual cost (capital cost / equipment lifetime)</li> <li>Apply appropriate discount rates for present value optimizations</li> <li>Account for inflation, escalation, and financing costs</li> </ul> <p>Example: \u20ac1M equipment with 20-year life \u2192 \u20ac50k/year fixed cost</p> <p>Examples:</p> <p>Simple binary investment (solar panels):</p> <pre><code>solar_investment = InvestParameters(\n    fixed_size=100,  # 100 kW system (binary decision)\n    mandatory=False,  # Investment is optional\n    effects_of_investment={\n        'cost': 25000,  # Installation and permitting costs\n        'CO2': -50000,  # Avoided emissions over lifetime\n    },\n    effects_of_investment_per_size={\n        'cost': 1200,  # \u20ac1200/kW for panels (annualized)\n        'CO2': -800,  # kg CO2 avoided per kW annually\n    },\n)\n</code></pre> <p>Flexible sizing with economies of scale:</p> <pre><code>battery_investment = InvestParameters(\n    minimum_size=10,  # Minimum viable system size (kWh)\n    maximum_size=1000,  # Maximum installable capacity\n    mandatory=False,  # Investment is optional\n    effects_of_investment={\n        'cost': 5000,  # Grid connection and control system\n        'installation_time': 2,  # Days for fixed components\n    },\n    piecewise_effects_of_investment=PiecewiseEffects(\n        piecewise_origin=Piecewise(\n            [\n                Piece(0, 100),  # Small systems\n                Piece(100, 500),  # Medium systems\n                Piece(500, 1000),  # Large systems\n            ]\n        ),\n        piecewise_shares={\n            'cost': Piecewise(\n                [\n                    Piece(800, 750),  # High cost/kWh for small systems\n                    Piece(750, 600),  # Medium cost/kWh\n                    Piece(600, 500),  # Bulk discount for large systems\n                ]\n            )\n        },\n    ),\n)\n</code></pre> <p>Mandatory replacement with retirement costs:</p> <pre><code>boiler_replacement = InvestParameters(\n    minimum_size=50,\n    maximum_size=200,\n    mandatory=False,  # Can choose not to replace\n    effects_of_investment={\n        'cost': 15000,  # Installation costs\n        'disruption': 3,  # Days of downtime\n    },\n    effects_of_investment_per_size={\n        'cost': 400,  # \u20ac400/kW capacity\n        'maintenance': 25,  # Annual maintenance per kW\n    },\n    effects_of_retirement={\n        'cost': 8000,  # Demolition if not replaced\n        'environmental': 100,  # Disposal fees\n    },\n)\n</code></pre> <p>Multi-technology comparison:</p> <pre><code># Gas turbine option\ngas_turbine = InvestParameters(\n    fixed_size=50,  # MW\n    effects_of_investment={'cost': 2500000, 'CO2': 1250000},\n    effects_of_investment_per_size={'fuel_cost': 45, 'maintenance': 12},\n)\n\n# Wind farm option\nwind_farm = InvestParameters(\n    minimum_size=20,\n    maximum_size=100,\n    effects_of_investment={'cost': 1000000, 'CO2': -5000000},\n    effects_of_investment_per_size={'cost': 1800000, 'land_use': 0.5},\n)\n</code></pre> <p>Technology learning curve:</p> <pre><code>hydrogen_electrolyzer = InvestParameters(\n    minimum_size=1,\n    maximum_size=50,  # MW\n    piecewise_effects_of_investment=PiecewiseEffects(\n        piecewise_origin=Piecewise(\n            [\n                Piece(0, 5),  # Small scale: early adoption\n                Piece(5, 20),  # Medium scale: cost reduction\n                Piece(20, 50),  # Large scale: mature technology\n            ]\n        ),\n        piecewise_shares={\n            'capex': Piecewise(\n                [\n                    Piece(2000, 1800),  # Learning reduces costs\n                    Piece(1800, 1400),  # Continued cost reduction\n                    Piece(1400, 1200),  # Technology maturity\n                ]\n            ),\n            'efficiency': Piecewise(\n                [\n                    Piece(65, 68),  # Improving efficiency\n                    Piece(68, 72),  # with scale and experience\n                    Piece(72, 75),  # Best efficiency at scale\n                ]\n            ),\n        },\n    ),\n)\n</code></pre> Common Use Cases <ul> <li>Power generation: Plant sizing, technology selection, retrofit decisions</li> <li>Industrial equipment: Capacity expansion, efficiency upgrades, replacements</li> <li>Infrastructure: Network expansion, facility construction, system upgrades</li> <li>Energy storage: Battery sizing, pumped hydro, compressed air systems</li> <li>Transportation: Fleet expansion, charging infrastructure, modal shifts</li> <li>Buildings: HVAC systems, insulation upgrades, renewable integration</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to nested PiecewiseEffects object if present.</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.format_for_repr","title":"format_for_repr","text":"<pre><code>format_for_repr() -&gt; str\n</code></pre> <p>Format InvestParameters for display in repr methods.</p> <p>Returns:</p> Type Description <code>str</code> <p>Formatted string showing size information</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/interface/#flixopt.interface.StatusParameters","title":"StatusParameters","text":"<pre><code>StatusParameters(effects_per_startup: Effect_TPS | Numeric_TPS | None = None, effects_per_active_hour: Effect_TPS | Numeric_TPS | None = None, active_hours_min: Numeric_PS | None = None, active_hours_max: Numeric_PS | None = None, min_uptime: Numeric_TPS | None = None, max_uptime: Numeric_TPS | None = None, min_downtime: Numeric_TPS | None = None, max_downtime: Numeric_TPS | None = None, startup_limit: Numeric_PS | None = None, force_startup_tracking: bool = False, cluster_mode: Literal['relaxed', 'cyclic'] = 'relaxed')\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define operational constraints and effects for binary status equipment behavior.</p> <p>This class models equipment that operates in discrete states (active/inactive) rather than continuous operation, capturing realistic operational constraints and associated costs. It handles complex equipment behavior including startup costs, minimum run times, cycling limitations, and maintenance scheduling requirements.</p> Key Modeling Capabilities <p>Startup Costs: One-time costs for starting equipment (fuel, wear, labor) Runtime Constraints: Minimum and maximum continuous operation periods (uptime/downtime) Cycling Limits: Maximum number of startups to prevent excessive wear Operating Hours: Total active hours limits and requirements over time horizon</p> Typical Equipment Applications <ul> <li>Power Plants: Combined cycle units, steam turbines with startup costs</li> <li>Industrial Processes: Batch reactors, furnaces with thermal cycling</li> <li>HVAC Systems: Chillers, boilers with minimum run times</li> <li>Backup Equipment: Emergency generators, standby systems</li> <li>Process Equipment: Compressors, pumps with operational constraints</li> </ul> Mathematical Formulation <p>See https://flixopt.github.io/flixopt/latest/user-guide/mathematical-notation/features/StatusParameters/</p> <p>Parameters:</p> Name Type Description Default <code>effects_per_startup</code> <code>Effect_TPS | Numeric_TPS | None</code> <p>Costs or impacts incurred for each transition from inactive state (status=0) to active state (status=1). Represents startup costs, wear and tear, or other switching impacts. Dictionary mapping effect names to values (e.g., {'cost': 500, 'maintenance_hours': 2}).</p> <code>None</code> <code>effects_per_active_hour</code> <code>Effect_TPS | Numeric_TPS | None</code> <p>Ongoing costs or impacts while equipment operates in the active state. Includes fuel costs, labor, consumables, or emissions. Dictionary mapping effect names to hourly values (e.g., {'fuel_cost': 45}).</p> <code>None</code> <code>active_hours_min</code> <code>Numeric_PS | None</code> <p>Minimum total active hours across the entire time horizon per period. Ensures equipment meets minimum utilization requirements or contractual obligations (e.g., power purchase agreements, maintenance schedules).</p> <code>None</code> <code>active_hours_max</code> <code>Numeric_PS | None</code> <p>Maximum total active hours across the entire time horizon per period. Limits equipment usage due to maintenance schedules, fuel availability, environmental permits, or equipment lifetime constraints.</p> <code>None</code> <code>min_uptime</code> <code>Numeric_TPS | None</code> <p>Minimum continuous operating duration once started (unit commitment term). Models minimum run times due to thermal constraints, process stability, or efficiency considerations. Can be time-varying to reflect different constraints across the planning horizon.</p> <code>None</code> <code>max_uptime</code> <code>Numeric_TPS | None</code> <p>Maximum continuous operating duration in one campaign (unit commitment term). Models mandatory maintenance intervals, process batch sizes, or equipment thermal limits requiring periodic shutdowns.</p> <code>None</code> <code>min_downtime</code> <code>Numeric_TPS | None</code> <p>Minimum continuous shutdown duration between operations (unit commitment term). Models cooling periods, maintenance requirements, or process constraints that prevent immediate restart after shutdown.</p> <code>None</code> <code>max_downtime</code> <code>Numeric_TPS | None</code> <p>Maximum continuous shutdown duration before mandatory restart. Models equipment preservation, process stability, or contractual requirements for minimum activity levels.</p> <code>None</code> <code>startup_limit</code> <code>Numeric_PS | None</code> <p>Maximum number of startup operations across the time horizon per period.. Limits equipment cycling to reduce wear, maintenance costs, or comply with operational constraints (e.g., grid stability requirements).</p> <code>None</code> <code>force_startup_tracking</code> <code>bool</code> <p>When True, creates startup variables even without explicit startup_limit constraint. Useful for tracking or reporting startup events without enforcing limits.</p> <code>False</code> <code>cluster_mode</code> <code>Literal['relaxed', 'cyclic']</code> <p>How inter-timestep constraints are handled at cluster boundaries. Only relevant when using <code>transform.cluster()</code>. Options:</p> <ul> <li><code>'relaxed'</code>: No constraint at cluster boundaries. Startups at the first   timestep of each cluster are not forced - the optimizer is free to choose.   This prevents clustering from inducing \"phantom\" startups. (default)</li> <li><code>'cyclic'</code>: Each cluster's final status equals its initial status.   Ensures consistent behavior within each representative period.</li> </ul> <code>'relaxed'</code> Note <p>Time Series Boundary Handling: The final time period constraints for min_uptime/max_uptime and min_downtime/max_downtime are not enforced, allowing the optimization to end with ongoing campaigns that may be shorter than the specified minimums or longer than maximums.</p> <p>Examples:</p> <p>Combined cycle power plant with startup costs and minimum run time:</p> <pre><code>power_plant_operation = StatusParameters(\n    effects_per_startup={\n        'startup_cost': 25000,  # \u20ac25,000 per startup\n        'startup_fuel': 150,  # GJ natural gas for startup\n        'startup_time': 4,  # Hours to reach full output\n        'maintenance_impact': 0.1,  # Fractional life consumption\n    },\n    effects_per_active_hour={\n        'fixed_om': 125,  # Fixed O&amp;M costs while active\n        'auxiliary_power': 2.5,  # MW parasitic loads\n    },\n    min_uptime=8,  # Minimum 8-hour run once started\n    min_downtime=4,  # Minimum 4-hour cooling period\n    active_hours_max=6000,  # Annual operating limit\n)\n</code></pre> <p>Industrial batch process with cycling limits:</p> <pre><code>batch_reactor = StatusParameters(\n    effects_per_startup={\n        'setup_cost': 1500,  # Labor and materials for startup\n        'catalyst_consumption': 5,  # kg catalyst per batch\n        'cleaning_chemicals': 200,  # L cleaning solution\n    },\n    effects_per_active_hour={\n        'steam': 2.5,  # t/h process steam\n        'electricity': 150,  # kWh electrical load\n        'cooling_water': 50,  # m\u00b3/h cooling water\n    },\n    min_uptime=12,  # Minimum batch size (12 hours)\n    max_uptime=24,  # Maximum batch size (24 hours)\n    min_downtime=6,  # Cleaning and setup time\n    startup_limit=200,  # Maximum 200 batches per period\n    active_hours_max=4000,  # Maximum production time\n)\n</code></pre> <p>HVAC system with thermostat control and maintenance:</p> <pre><code>hvac_operation = StatusParameters(\n    effects_per_startup={\n        'compressor_wear': 0.5,  # Hours of compressor life per start\n        'inrush_current': 15,  # kW peak demand on startup\n    },\n    effects_per_active_hour={\n        'electricity': 25,  # kW electrical consumption\n        'maintenance': 0.12,  # \u20ac/hour maintenance reserve\n    },\n    min_uptime=1,  # Minimum 1-hour run to avoid cycling\n    min_downtime=0.5,  # 30-minute minimum inactive time\n    startup_limit=2000,  # Limit cycling for compressor life\n    active_hours_min=2000,  # Minimum operation for humidity control\n    active_hours_max=5000,  # Maximum operation for energy budget\n)\n</code></pre> <p>Backup generator with testing and maintenance requirements:</p> <pre><code>backup_generator = StatusParameters(\n    effects_per_startup={\n        'fuel_priming': 50,  # L diesel for system priming\n        'wear_factor': 1.0,  # Start cycles impact on maintenance\n        'testing_labor': 2,  # Hours technician time per test\n    },\n    effects_per_active_hour={\n        'fuel_consumption': 180,  # L/h diesel consumption\n        'emissions_permit': 15,  # \u20ac emissions allowance cost\n        'noise_penalty': 25,  # \u20ac noise compliance cost\n    },\n    min_uptime=0.5,  # Minimum test duration (30 min)\n    max_downtime=720,  # Maximum 30 days between tests\n    startup_limit=52,  # Weekly testing limit\n    active_hours_min=26,  # Minimum annual testing (0.5h \u00d7 52)\n    active_hours_max=200,  # Maximum runtime (emergencies + tests)\n)\n</code></pre> <p>Peak shaving battery with cycling degradation:</p> <pre><code>battery_cycling = StatusParameters(\n    effects_per_startup={\n        'cycle_degradation': 0.01,  # % capacity loss per cycle\n        'inverter_startup': 0.5,  # kWh losses during startup\n    },\n    effects_per_active_hour={\n        'standby_losses': 2,  # kW standby consumption\n        'cooling': 5,  # kW thermal management\n        'inverter_losses': 8,  # kW conversion losses\n    },\n    min_uptime=1,  # Minimum discharge duration\n    max_uptime=4,  # Maximum continuous discharge\n    min_downtime=1,  # Minimum rest between cycles\n    startup_limit=365,  # Daily cycling limit\n    force_startup_tracking=True,  # Track all cycling events\n)\n</code></pre> Common Use Cases <ul> <li>Power generation: Thermal plant cycling, renewable curtailment, grid services</li> <li>Industrial processes: Batch production, maintenance scheduling, equipment rotation</li> <li>Buildings: HVAC control, lighting systems, elevator operations</li> <li>Transportation: Fleet management, charging infrastructure, maintenance windows</li> <li>Storage systems: Battery cycling, pumped hydro, compressed air systems</li> <li>Emergency equipment: Backup generators, safety systems, emergency lighting</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.StatusParameters-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixopt.interface.StatusParameters.use_uptime_tracking","title":"use_uptime_tracking  <code>property</code>","text":"<pre><code>use_uptime_tracking: bool\n</code></pre> <p>Determines whether a Variable for uptime (consecutive active hours) is needed or not</p>"},{"location":"api-reference/interface/#flixopt.interface.StatusParameters.use_downtime_tracking","title":"use_downtime_tracking  <code>property</code>","text":"<pre><code>use_downtime_tracking: bool\n</code></pre> <p>Determines whether a Variable for downtime (consecutive inactive hours) is needed or not</p>"},{"location":"api-reference/interface/#flixopt.interface.StatusParameters.use_startup_tracking","title":"use_startup_tracking  <code>property</code>","text":"<pre><code>use_startup_tracking: bool\n</code></pre> <p>Determines whether a variable for startup is needed or not</p>"},{"location":"api-reference/interface/#flixopt.interface.StatusParameters.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/interface/#flixopt.interface.StatusParameters.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/interface/#flixopt.interface.StatusParameters-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.StatusParameters.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system: FlowSystem, prefix: str = '') -&gt; None\n</code></pre> <p>Link this interface and all nested interfaces to a FlowSystem.</p> <p>This method is called automatically during element registration to enable elements to access FlowSystem properties without passing the reference through every method call. It also sets the prefix used for naming transformed data.</p> <p>Subclasses with nested Interface objects should override this method to propagate the link to their nested interfaces by calling <code>super().link_to_flow_system(flow_system, prefix)</code> first, then linking nested objects with appropriate prefixes.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to link to</p> required <code>prefix</code> <code>str</code> <p>The prefix for naming transformed data (e.g., 'Boiler(Q_th)')</p> <code>''</code> <p>Examples:</p> <p>Override in a subclass with nested interfaces:</p> <pre><code>def link_to_flow_system(self, flow_system, prefix: str = '') -&gt; None:\n    super().link_to_flow_system(flow_system, prefix)\n    if self.nested_interface is not None:\n        self.nested_interface.link_to_flow_system(flow_system, f'{prefix}|nested' if prefix else 'nested')\n</code></pre> <p>Creating an Interface dynamically during modeling:</p> <pre><code># In a Model class\nif flow.status_parameters is None:\n    flow.status_parameters = StatusParameters()\n    flow.status_parameters.link_to_flow_system(self._model.flow_system, f'{flow.label_full}')\n</code></pre>"},{"location":"api-reference/interface/#flixopt.interface.StatusParameters.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/interface/#flixopt.interface.StatusParameters.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.StatusParameters.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/interface/#flixopt.interface.StatusParameters.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/interface/#flixopt.interface.StatusParameters.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/interface/#flixopt.interface.StatusParameters.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/interface/#flixopt.interface.StatusParameters.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/interface/#flixopt.interface-functions","title":"Functions","text":""},{"location":"api-reference/io/","title":"Io","text":""},{"location":"api-reference/io/#flixopt.io","title":"flixopt.io","text":""},{"location":"api-reference/io/#flixopt.io-attributes","title":"Attributes","text":""},{"location":"api-reference/io/#flixopt.io-classes","title":"Classes","text":""},{"location":"api-reference/io/#flixopt.io.ResultsPaths","title":"ResultsPaths  <code>dataclass</code>","text":"<pre><code>ResultsPaths(folder: Path, name: str)\n</code></pre> <p>Container for all paths related to saving Results.</p>"},{"location":"api-reference/io/#flixopt.io.ResultsPaths-functions","title":"Functions","text":""},{"location":"api-reference/io/#flixopt.io.ResultsPaths.all_paths","title":"all_paths","text":"<pre><code>all_paths() -&gt; dict[str, pathlib.Path]\n</code></pre> <p>Return a dictionary of all paths.</p>"},{"location":"api-reference/io/#flixopt.io.ResultsPaths.create_folders","title":"create_folders","text":"<pre><code>create_folders(parents: bool = False, exist_ok: bool = True) -&gt; None\n</code></pre> <p>Ensure the folder exists.</p> <p>Parameters:</p> Name Type Description Default <code>parents</code> <code>bool</code> <p>If True, create parent directories as needed. If False, parent must exist.</p> <code>False</code> <code>exist_ok</code> <code>bool</code> <p>If True, do not raise error if folder already exists. If False, raise FileExistsError.</p> <code>True</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If parents=False and parent directory doesn't exist.</p> <code>FileExistsError</code> <p>If exist_ok=False and folder already exists.</p>"},{"location":"api-reference/io/#flixopt.io.ResultsPaths.update","title":"update","text":"<pre><code>update(new_name: str | None = None, new_folder: Path | None = None) -&gt; None\n</code></pre> <p>Update name and/or folder and refresh all paths.</p>"},{"location":"api-reference/io/#flixopt.io.FlowSystemDatasetIO","title":"FlowSystemDatasetIO","text":"<p>Unified I/O handler for FlowSystem dataset serialization and deserialization.</p> <p>This class provides optimized methods for converting FlowSystem objects to/from xarray Datasets. It uses shared constants for variable prefixes and implements fast DataArray construction to avoid xarray's slow _construct_dataarray method.</p> Constants <p>SOLUTION_PREFIX: Prefix for solution variables ('solution|') CLUSTERING_PREFIX: Prefix for clustering variables ('clustering|')</p> Example"},{"location":"api-reference/io/#flixopt.io.FlowSystemDatasetIO--serialization-flowsystem-dataset","title":"Serialization (FlowSystem -&gt; Dataset)","text":"<p>ds = FlowSystemDatasetIO.to_dataset(flow_system, base_ds)</p>"},{"location":"api-reference/io/#flixopt.io.FlowSystemDatasetIO--deserialization-dataset-flowsystem","title":"Deserialization (Dataset -&gt; FlowSystem)","text":"<p>fs = FlowSystemDatasetIO.from_dataset(ds)</p>"},{"location":"api-reference/io/#flixopt.io.FlowSystemDatasetIO-functions","title":"Functions","text":""},{"location":"api-reference/io/#flixopt.io.FlowSystemDatasetIO.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; FlowSystem\n</code></pre> <p>Create FlowSystem from dataset.</p> <p>This is the main entry point for dataset restoration. Called by FlowSystem.from_dataset().</p> <p>If the dataset contains solution data (variables prefixed with 'solution|'), the solution will be restored to the FlowSystem. Solution time coordinates are renamed back from 'solution_time' to 'time'.</p> <p>Supports clustered datasets with (cluster, time) dimensions. When detected, creates a synthetic DatetimeIndex for compatibility and stores the clustered data structure for later use.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the FlowSystem data</p> required <p>Returns:</p> Type Description <code>FlowSystem</code> <p>FlowSystem instance with all components, buses, effects, and solution restored</p>"},{"location":"api-reference/io/#flixopt.io.FlowSystemDatasetIO.to_dataset","title":"to_dataset  <code>classmethod</code>","text":"<pre><code>to_dataset(flow_system: FlowSystem, base_dataset: Dataset, include_solution: bool = True, include_original_data: bool = True) -&gt; xr.Dataset\n</code></pre> <p>Convert FlowSystem-specific data to dataset.</p> <p>This function adds FlowSystem-specific data (solution, clustering, metadata) to a base dataset created by the parent class's to_dataset() method.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to serialize</p> required <code>base_dataset</code> <code>Dataset</code> <p>Dataset from parent class with basic structure</p> required <code>include_solution</code> <code>bool</code> <p>Whether to include optimization solution</p> <code>True</code> <code>include_original_data</code> <code>bool</code> <p>Whether to include clustering.original_data</p> <code>True</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Complete dataset with all FlowSystem data</p>"},{"location":"api-reference/io/#flixopt.io-functions","title":"Functions","text":""},{"location":"api-reference/io/#flixopt.io.remove_none_and_empty","title":"remove_none_and_empty","text":"<pre><code>remove_none_and_empty(obj)\n</code></pre> <p>Recursively removes None and empty dicts and lists values from a dictionary or list.</p>"},{"location":"api-reference/io/#flixopt.io.round_nested_floats","title":"round_nested_floats","text":"<pre><code>round_nested_floats(obj: dict | list | float | int | Any, decimals: int = 2) -&gt; dict | list | float | int | Any\n</code></pre> <p>Recursively round floating point numbers in nested data structures and convert it to python native types.</p> <p>This function traverses nested data structures (dictionaries, lists) and rounds any floating point numbers to the specified number of decimal places. It handles various data types including NumPy arrays and xarray DataArrays by converting them to lists with rounded values.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>dict | list | float | int | Any</code> <p>The object to process. Can be a dict, list, float, int, numpy.ndarray, xarray.DataArray, or any other type.</p> required <code>decimals</code> <code>int</code> <p>Number of decimal places to round to. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Type Description <code>dict | list | float | int | Any</code> <p>The processed object with the same structure as the input, but with all floating point numbers rounded to the specified precision. NumPy arrays and xarray DataArrays are converted to lists.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = {'a': 3.14159, 'b': [1.234, 2.678]}\n&gt;&gt;&gt; round_nested_floats(data, decimals=2)\n{'a': 3.14, 'b': [1.23, 2.68]}\n</code></pre> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; arr = np.array([1.234, 5.678])\n&gt;&gt;&gt; round_nested_floats(arr, decimals=1)\n[1.2, 5.7]\n</code></pre>"},{"location":"api-reference/io/#flixopt.io.load_json","title":"load_json","text":"<pre><code>load_json(path: str | Path) -&gt; dict | list\n</code></pre> <p>Load data from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the JSON file.</p> required <p>Returns:</p> Type Description <code>dict | list</code> <p>Loaded data (typically dict or list).</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>JSONDecodeError</code> <p>If the file is not valid JSON.</p>"},{"location":"api-reference/io/#flixopt.io.save_json","title":"save_json","text":"<pre><code>save_json(data: dict | list, path: str | Path, indent: int = 4, ensure_ascii: bool = False, **kwargs: Any) -&gt; None\n</code></pre> <p>Save data to a JSON file with consistent formatting.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | list</code> <p>Data to save (dict or list).</p> required <code>path</code> <code>str | Path</code> <p>Path to save the JSON file.</p> required <code>indent</code> <code>int</code> <p>Number of spaces for indentation (default: 4).</p> <code>4</code> <code>ensure_ascii</code> <code>bool</code> <p>If False, allow Unicode characters (default: False).</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to json.dump().</p> <code>{}</code>"},{"location":"api-reference/io/#flixopt.io.load_yaml","title":"load_yaml","text":"<pre><code>load_yaml(path: str | Path) -&gt; dict | list\n</code></pre> <p>Load data from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the YAML file.</p> required <p>Returns:</p> Type Description <code>dict | list</code> <p>Loaded data (typically dict or list), or empty dict if file is empty.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>YAMLError</code> <p>If the file is not valid YAML.</p> <code>Note</code> <p>Returns {} for empty YAML files instead of None.</p>"},{"location":"api-reference/io/#flixopt.io.save_yaml","title":"save_yaml","text":"<pre><code>save_yaml(data: dict | list, path: str | Path, indent: int = 4, width: int = 1000, allow_unicode: bool = True, sort_keys: bool = False, compact_numeric_lists: bool = False, **kwargs: Any) -&gt; None\n</code></pre> <p>Save data to a YAML file with consistent formatting.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | list</code> <p>Data to save (dict or list).</p> required <code>path</code> <code>str | Path</code> <p>Path to save the YAML file.</p> required <code>indent</code> <code>int</code> <p>Number of spaces for indentation (default: 4).</p> <code>4</code> <code>width</code> <code>int</code> <p>Maximum line width (default: 1000).</p> <code>1000</code> <code>allow_unicode</code> <code>bool</code> <p>If True, allow Unicode characters (default: True).</p> <code>True</code> <code>sort_keys</code> <code>bool</code> <p>If True, sort dictionary keys (default: False).</p> <code>False</code> <code>compact_numeric_lists</code> <code>bool</code> <p>If True, format numeric lists inline for better readability (default: False).</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to yaml.dump().</p> <code>{}</code>"},{"location":"api-reference/io/#flixopt.io.format_yaml_string","title":"format_yaml_string","text":"<pre><code>format_yaml_string(data: dict | list, indent: int = 4, width: int = 1000, allow_unicode: bool = True, sort_keys: bool = False, compact_numeric_lists: bool = False, **kwargs: Any) -&gt; str\n</code></pre> <p>Format data as a YAML string with consistent formatting.</p> <p>This function provides the same formatting as save_yaml() but returns a string instead of writing to a file. Useful for logging or displaying YAML data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict | list</code> <p>Data to format (dict or list).</p> required <code>indent</code> <code>int</code> <p>Number of spaces for indentation (default: 4).</p> <code>4</code> <code>width</code> <code>int</code> <p>Maximum line width (default: 1000).</p> <code>1000</code> <code>allow_unicode</code> <code>bool</code> <p>If True, allow Unicode characters (default: True).</p> <code>True</code> <code>sort_keys</code> <code>bool</code> <p>If True, sort dictionary keys (default: False).</p> <code>False</code> <code>compact_numeric_lists</code> <code>bool</code> <p>If True, format numeric lists inline for better readability (default: False).</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to yaml.dump().</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted YAML string.</p>"},{"location":"api-reference/io/#flixopt.io.load_config_file","title":"load_config_file","text":"<pre><code>load_config_file(path: str | Path) -&gt; dict\n</code></pre> <p>Load a configuration file, automatically detecting JSON or YAML format.</p> <p>This function intelligently tries to load the file based on its extension, with fallback support if the primary format fails.</p> <p>Supported extensions: - .json: Tries JSON first, falls back to YAML - .yaml, .yml: Tries YAML first, falls back to JSON - Others: Tries YAML, then JSON</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the configuration file.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Loaded configuration as a dictionary.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>ValueError</code> <p>If neither JSON nor YAML parsing succeeds.</p>"},{"location":"api-reference/io/#flixopt.io.document_linopy_model","title":"document_linopy_model","text":"<pre><code>document_linopy_model(model: Model, path: Path | None = None) -&gt; dict[str, str]\n</code></pre> <p>Convert all model variables and constraints to a structured string representation. This can take multiple seconds for large models. The output can be saved to a yaml file with readable formating applied.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to save the document. Defaults to None.</p> <code>None</code>"},{"location":"api-reference/io/#flixopt.io.save_dataset_to_netcdf","title":"save_dataset_to_netcdf","text":"<pre><code>save_dataset_to_netcdf(ds: Dataset, path: str | Path, compression: int = 0, stack_vars: bool = True) -&gt; None\n</code></pre> <p>Save a dataset to a netcdf file. Store all attrs as JSON strings in 'attrs' attributes.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset to save.</p> required <code>path</code> <code>str | Path</code> <p>Path to save the dataset to.</p> required <code>compression</code> <code>int</code> <p>Compression level for the dataset (0-9). 0 means no compression. 5 is a good default.</p> <code>0</code> <code>stack_vars</code> <code>bool</code> <p>If True (default), stack variables with equal dims for faster I/O. Variables are automatically unstacked when loading with load_dataset_from_netcdf.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path has an invalid file extension.</p>"},{"location":"api-reference/io/#flixopt.io.load_dataset_from_netcdf","title":"load_dataset_from_netcdf","text":"<pre><code>load_dataset_from_netcdf(path: str | Path) -&gt; xr.Dataset\n</code></pre> <p>Load a dataset from a netcdf file. Load all attrs from 'attrs' attributes.</p> <p>Automatically unstacks variables that were stacked during saving with save_dataset_to_netcdf(stack_vars=True).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to load the dataset from.</p> required <p>Returns:</p> Name Type Description <code>Dataset</code> <code>Dataset</code> <p>Loaded dataset with restored attrs and unstacked variables.</p>"},{"location":"api-reference/io/#flixopt.io.convert_old_dataset","title":"convert_old_dataset","text":"<pre><code>convert_old_dataset(ds: Dataset, key_renames: dict[str, str] | None = None, value_renames: dict[str, dict] | None = None, reduce_constants: bool = True) -&gt; xr.Dataset\n</code></pre> <p>Convert an old FlowSystem dataset to the current format.</p> <p>This function performs two conversions: 1. Renames parameters in the reference structure to current naming conventions 2. Reduces constant arrays to minimal dimensions (e.g., broadcasted scalars back to scalars)</p> <p>This is useful for loading FlowSystem files saved with older versions of flixopt.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>The dataset to convert</p> required <code>key_renames</code> <code>dict[str, str] | None</code> <p>Custom key renames to apply. If None, uses PARAMETER_RENAMES.</p> <code>None</code> <code>value_renames</code> <code>dict[str, dict] | None</code> <p>Custom value renames to apply. If None, uses VALUE_RENAMES.</p> <code>None</code> <code>reduce_constants</code> <code>bool</code> <p>If True (default), reduce constant arrays to minimal dimensions. Old files may have scalars broadcasted to full (time, period, scenario) shape.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>The converted dataset</p> <p>Examples:</p> <p>Convert an old netCDF file to new format:</p> <pre><code>from flixopt import io\n\n# Load old file\nds = io.load_dataset_from_netcdf('old_flow_system.nc4')\n\n# Convert to current format\nds = io.convert_old_dataset(ds)\n\n# Now load as FlowSystem\nfrom flixopt import FlowSystem\n\nfs = FlowSystem.from_dataset(ds)\n</code></pre>"},{"location":"api-reference/io/#flixopt.io.convert_old_netcdf","title":"convert_old_netcdf","text":"<pre><code>convert_old_netcdf(input_path: str | Path, output_path: str | Path | None = None, compression: int = 0) -&gt; xr.Dataset\n</code></pre> <p>Load an old FlowSystem netCDF file and convert to new parameter names.</p> <p>This is a convenience function that combines loading, conversion, and optionally saving the converted dataset.</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>str | Path</code> <p>Path to the old netCDF file</p> required <code>output_path</code> <code>str | Path | None</code> <p>If provided, save the converted dataset to this path. If None, only returns the converted dataset without saving.</p> <code>None</code> <code>compression</code> <code>int</code> <p>Compression level (0-9) for saving. Only used if output_path is provided.</p> <code>0</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>The converted dataset</p> <p>Examples:</p> <p>Convert and save to new file:</p> <pre><code>from flixopt import io\n\n# Convert old file to new format\nds = io.convert_old_netcdf('old_system.nc4', 'new_system.nc')\n</code></pre> <p>Convert and load as FlowSystem:</p> <pre><code>from flixopt import FlowSystem, io\n\nds = io.convert_old_netcdf('old_system.nc4')\nfs = FlowSystem.from_dataset(ds)\n</code></pre>"},{"location":"api-reference/io/#flixopt.io.numeric_to_str_for_repr","title":"numeric_to_str_for_repr","text":"<pre><code>numeric_to_str_for_repr(value: Numeric_TPS, precision: int = 1, atol: float = 1e-10) -&gt; str\n</code></pre> <p>Format value for display in repr methods.</p> <p>For single values or uniform arrays, returns the formatted value. For arrays with variation, returns a range showing min-max.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Numeric_TPS</code> <p>Numeric value or container (DataArray, array, Series, DataFrame)</p> required <code>precision</code> <code>int</code> <p>Number of decimal places (default: 1)</p> <code>1</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for considering values equal (default: 1e-10)</p> <code>1e-10</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted string representation:</p> <code>str</code> <ul> <li>Single/uniform values: \"100.0\"</li> </ul> <code>str</code> <ul> <li>Nearly uniform values: \"~100.0\" (values differ slightly but display similarly)</li> </ul> <code>str</code> <ul> <li>Varying values: \"50.0-150.0\" (shows range from min to max)</li> </ul> <p>Raises:</p> Type Description <code>TypeError</code> <p>If value cannot be converted to numeric format</p>"},{"location":"api-reference/io/#flixopt.io.build_repr_from_init","title":"build_repr_from_init","text":"<pre><code>build_repr_from_init(obj: object, excluded_params: set[str] | None = None, label_as_positional: bool = True, skip_default_size: bool = False) -&gt; str\n</code></pre> <p>Build a repr string from init signature, showing non-default parameter values.</p> <p>This utility function extracts common repr logic used across flixopt classes. It introspects the init method to build a constructor-style repr showing only parameters that differ from their defaults.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object to create repr for</p> required <code>excluded_params</code> <code>set[str] | None</code> <p>Set of parameter names to exclude (e.g., {'self', 'inputs', 'outputs'})             Default excludes 'self', 'label', and 'kwargs'</p> <code>None</code> <code>label_as_positional</code> <code>bool</code> <p>If True and 'label' param exists, show it as first positional arg</p> <code>True</code> <code>skip_default_size</code> <code>bool</code> <p>Deprecated. Previously skipped size=CONFIG.Modeling.big, now size=None is default.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted repr string like: ClassName(\"label\", param=value)</p>"},{"location":"api-reference/io/#flixopt.io.format_flow_details","title":"format_flow_details","text":"<pre><code>format_flow_details(obj: Any, has_inputs: bool = True, has_outputs: bool = True) -&gt; str\n</code></pre> <p>Format inputs and outputs as indented bullet list.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Object with 'inputs' and/or 'outputs' attributes</p> required <code>has_inputs</code> <code>bool</code> <p>Whether to check for inputs</p> <code>True</code> <code>has_outputs</code> <code>bool</code> <p>Whether to check for outputs</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted string with flow details (including leading newline), or empty string if no flows</p>"},{"location":"api-reference/io/#flixopt.io.format_title_with_underline","title":"format_title_with_underline","text":"<pre><code>format_title_with_underline(title: str, underline_char: str = '-') -&gt; str\n</code></pre> <p>Format a title with underline of matching length.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title text</p> required <code>underline_char</code> <code>str</code> <p>Character to use for underline (default: '-')</p> <code>'-'</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted string: \"Title\\n-----\\n\"</p>"},{"location":"api-reference/io/#flixopt.io.format_sections_with_headers","title":"format_sections_with_headers","text":"<pre><code>format_sections_with_headers(sections: dict[str, str], underline_char: str = '-') -&gt; list[str]\n</code></pre> <p>Format sections with underlined headers.</p> <p>Parameters:</p> Name Type Description Default <code>sections</code> <code>dict[str, str]</code> <p>Dict mapping section headers to content</p> required <code>underline_char</code> <code>str</code> <p>Character for underlining headers</p> <code>'-'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of formatted section strings</p>"},{"location":"api-reference/io/#flixopt.io.build_metadata_info","title":"build_metadata_info","text":"<pre><code>build_metadata_info(parts: list[str], prefix: str = ' | ') -&gt; str\n</code></pre> <p>Build metadata info string from parts.</p> <p>Parameters:</p> Name Type Description Default <code>parts</code> <code>list[str]</code> <p>List of metadata strings (empty strings are filtered out)</p> required <code>prefix</code> <code>str</code> <p>Prefix to add if parts is non-empty</p> <code>' | '</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted info string or empty string</p>"},{"location":"api-reference/io/#flixopt.io.suppress_output","title":"suppress_output","text":"<pre><code>suppress_output()\n</code></pre> <p>Suppress all console output including C-level output from solvers.</p> <p>WARNING: Not thread-safe. Modifies global file descriptors. Use only with sequential execution or multiprocessing.</p>"},{"location":"api-reference/io/#flixopt.io.restore_flow_system_from_dataset","title":"restore_flow_system_from_dataset","text":"<pre><code>restore_flow_system_from_dataset(ds: Dataset) -&gt; FlowSystem\n</code></pre> <p>Create FlowSystem from dataset.</p> <p>This is the main entry point for dataset restoration. Called by FlowSystem.from_dataset().</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the FlowSystem data</p> required <p>Returns:</p> Type Description <code>FlowSystem</code> <p>FlowSystem instance with all components, buses, effects, and solution restored</p> See Also <p>FlowSystemDatasetIO: Class containing the implementation</p>"},{"location":"api-reference/io/#flixopt.io.flow_system_to_dataset","title":"flow_system_to_dataset","text":"<pre><code>flow_system_to_dataset(flow_system: FlowSystem, base_dataset: Dataset, include_solution: bool = True, include_original_data: bool = True) -&gt; xr.Dataset\n</code></pre> <p>Convert FlowSystem-specific data to dataset.</p> <p>This function adds FlowSystem-specific data (solution, clustering, metadata) to a base dataset created by the parent class's to_dataset() method.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to serialize</p> required <code>base_dataset</code> <code>Dataset</code> <p>Dataset from parent class with basic structure</p> required <code>include_solution</code> <code>bool</code> <p>Whether to include optimization solution</p> <code>True</code> <code>include_original_data</code> <code>bool</code> <p>Whether to include clustering.original_data</p> <code>True</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Complete dataset with all FlowSystem data</p> See Also <p>FlowSystemDatasetIO: Class containing the implementation</p>"},{"location":"api-reference/linear_converters/","title":"Linear converters","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters","title":"flixopt.linear_converters","text":"<p>This Module contains high-level classes to easily model a FlowSystem.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters-attributes","title":"Attributes","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters-classes","title":"Classes","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler","title":"Boiler","text":"<pre><code>Boiler(label: str, thermal_efficiency: Numeric_TPS | None = None, fuel_flow: Flow | None = None, thermal_flow: Flow | None = None, status_parameters: StatusParameters | None = None, meta_data: dict | None = None, color: str | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing a fuel-fired boiler for thermal energy generation.</p> <p>Boilers convert fuel input into thermal energy with a specified efficiency factor. This is a simplified wrapper around LinearConverter with predefined conversion relationships for thermal generation applications.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>thermal_efficiency</code> <code>Numeric_TPS | None</code> <p>Thermal efficiency factor (0-1 range). Defines the ratio of thermal output to fuel input energy content.</p> <code>None</code> <code>fuel_flow</code> <code>Flow | None</code> <p>Fuel input-flow representing fuel consumption.</p> <code>None</code> <code>thermal_flow</code> <code>Flow | None</code> <p>Thermal output-flow representing heat generation.</p> <code>None</code> <code>status_parameters</code> <code>StatusParameters | None</code> <p>Parameters defining status, startup and shutdown constraints and effects</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Natural gas boiler:</p> <pre><code>gas_boiler = Boiler(\n    label='natural_gas_boiler',\n    thermal_efficiency=0.85,  # 85% thermal efficiency\n    fuel_flow=natural_gas_flow,\n    thermal_flow=hot_water_flow,\n)\n</code></pre> <p>Biomass boiler with seasonal efficiency variation:</p> <pre><code>biomass_boiler = Boiler(\n    label='wood_chip_boiler',\n    thermal_efficiency=seasonal_efficiency_profile,  # Time-varying efficiency\n    fuel_flow=biomass_flow,\n    thermal_flow=district_heat_flow,\n    status_parameters=StatusParameters(\n        min_uptime=4,  # Minimum 4-hour operation\n        effects_per_startup={'startup_fuel': 50},  # Startup fuel penalty\n    ),\n)\n</code></pre> Note <p>The conversion relationship is: thermal_flow = fuel_flow \u00d7 thermal_efficiency</p> <p>Efficiency should be between 0 and 1, where 1 represents perfect conversion (100% of fuel energy converted to useful thermal output).</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler-attributes","title":"Attributes","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.flows","title":"flows  <code>cached</code> <code>property</code>","text":"<pre><code>flows: FlowContainer\n</code></pre> <p>All flows (inputs and outputs) as a FlowContainer.</p> Supports access by label_full or short label <p>component.flows['Boiler(Q_th)']  # Full label component.flows['Q_th']          # Short label</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to parent Component and piecewise_conversion.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat","title":"Power2Heat","text":"<pre><code>Power2Heat(label: str, thermal_efficiency: Numeric_TPS | None = None, electrical_flow: Flow | None = None, thermal_flow: Flow | None = None, status_parameters: StatusParameters | None = None, meta_data: dict | None = None, color: str | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing electric resistance heating or power-to-heat conversion.</p> <p>Power2Heat components convert electrical energy directly into thermal energy through resistance heating elements, electrode boilers, or other direct electric heating technologies. This is a simplified wrapper around LinearConverter with predefined conversion relationships for electric heating applications.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>thermal_efficiency</code> <code>Numeric_TPS | None</code> <p>Thermal efficiency factor (0-1 range). For resistance heating this is typically close to 1.0 (nearly 100% efficiency), but may be lower for electrode boilers or systems with distribution losses.</p> <code>None</code> <code>electrical_flow</code> <code>Flow | None</code> <p>Electrical input-flow representing electricity consumption.</p> <code>None</code> <code>thermal_flow</code> <code>Flow | None</code> <p>Thermal output-flow representing heat generation.</p> <code>None</code> <code>status_parameters</code> <code>StatusParameters | None</code> <p>Parameters defining status, startup and shutdown constraints and effects</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Electric resistance heater:</p> <pre><code>electric_heater = Power2Heat(\n    label='resistance_heater',\n    thermal_efficiency=0.98,  # 98% efficiency (small losses)\n    electrical_flow=electricity_flow,\n    thermal_flow=space_heating_flow,\n)\n</code></pre> <p>Electrode boiler for industrial steam:</p> <pre><code>electrode_boiler = Power2Heat(\n    label='electrode_steam_boiler',\n    thermal_efficiency=0.95,  # 95% efficiency including boiler losses\n    electrical_flow=industrial_electricity,\n    thermal_flow=process_steam_flow,\n    status_parameters=StatusParameters(\n        min_uptime=1,  # Minimum 1-hour operation\n        effects_per_startup={'startup_cost': 100},\n    ),\n)\n</code></pre> Note <p>The conversion relationship is: thermal_flow = electrical_flow \u00d7 thermal_efficiency</p> <p>Unlike heat pumps, Power2Heat systems cannot exceed 100% efficiency (thermal_efficiency \u2264 1.0) as they only convert electrical energy without extracting additional energy from the environment. However, they provide fast response times and precise temperature control.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat-attributes","title":"Attributes","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.flows","title":"flows  <code>cached</code> <code>property</code>","text":"<pre><code>flows: FlowContainer\n</code></pre> <p>All flows (inputs and outputs) as a FlowContainer.</p> Supports access by label_full or short label <p>component.flows['Boiler(Q_th)']  # Full label component.flows['Q_th']          # Short label</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to parent Component and piecewise_conversion.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump","title":"HeatPump","text":"<pre><code>HeatPump(label: str, cop: Numeric_TPS | None = None, electrical_flow: Flow | None = None, thermal_flow: Flow | None = None, status_parameters: StatusParameters | None = None, meta_data: dict | None = None, color: str | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing an electric heat pump for thermal energy generation.</p> <p>Heat pumps convert electrical energy into thermal energy with a Coefficient of Performance (COP) greater than 1, making them more efficient than direct electric heating. This is a simplified wrapper around LinearConverter with predefined conversion relationships for heat pump applications.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>cop</code> <code>Numeric_TPS | None</code> <p>Coefficient of Performance (typically 1-20 range). Defines the ratio of thermal output to electrical input. COP &gt; 1 indicates the heat pump extracts additional energy from the environment.</p> <code>None</code> <code>electrical_flow</code> <code>Flow | None</code> <p>Electrical input-flow representing electricity consumption.</p> <code>None</code> <code>thermal_flow</code> <code>Flow | None</code> <p>Thermal output-flow representing heat generation.</p> <code>None</code> <code>status_parameters</code> <code>StatusParameters | None</code> <p>Parameters defining status, startup and shutdown constraints and effects</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Air-source heat pump with constant COP:</p> <pre><code>air_hp = HeatPump(\n    label='air_source_heat_pump',\n    cop=3.5,  # COP of 3.5 (350% efficiency)\n    electrical_flow=electricity_flow,\n    thermal_flow=heating_flow,\n)\n</code></pre> <p>Ground-source heat pump with temperature-dependent COP:</p> <pre><code>ground_hp = HeatPump(\n    label='geothermal_heat_pump',\n    cop=temperature_dependent_cop,  # Time-varying COP based on ground temp\n    electrical_flow=electricity_flow,\n    thermal_flow=radiant_heating_flow,\n    status_parameters=StatusParameters(\n        min_uptime=2,  # Avoid frequent cycling\n        effects_per_active_hour={'maintenance': 0.5},\n    ),\n)\n</code></pre> Note <p>The conversion relationship is: thermal_flow = electrical_flow \u00d7 COP</p> <p>COP should be greater than 1 for realistic heat pump operation, with typical values ranging from 2-6 depending on technology and operating conditions. Higher COP values indicate more efficient heat extraction from the environment.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump-attributes","title":"Attributes","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.flows","title":"flows  <code>cached</code> <code>property</code>","text":"<pre><code>flows: FlowContainer\n</code></pre> <p>All flows (inputs and outputs) as a FlowContainer.</p> Supports access by label_full or short label <p>component.flows['Boiler(Q_th)']  # Full label component.flows['Q_th']          # Short label</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to parent Component and piecewise_conversion.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower","title":"CoolingTower","text":"<pre><code>CoolingTower(label: str, specific_electricity_demand: Numeric_TPS, electrical_flow: Flow | None = None, thermal_flow: Flow | None = None, status_parameters: StatusParameters | None = None, meta_data: dict | None = None, color: str | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing a cooling tower for waste heat rejection.</p> <p>Cooling towers consume electrical energy (for fans, pumps) to reject thermal energy to the environment through evaporation and heat transfer. The electricity demand is typically a small fraction of the thermal load being rejected. This component has no thermal outputs as the heat is rejected to the environment.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>specific_electricity_demand</code> <code>Numeric_TPS</code> <p>Auxiliary electricity demand per unit of cooling power (dimensionless, typically 0.01-0.05 range). Represents the fraction of thermal power that must be supplied as electricity for fans and pumps.</p> required <code>electrical_flow</code> <code>Flow | None</code> <p>Electrical input-flow representing electricity consumption for fans/pumps.</p> <code>None</code> <code>thermal_flow</code> <code>Flow | None</code> <p>Thermal input-flow representing waste heat to be rejected to environment.</p> <code>None</code> <code>status_parameters</code> <code>StatusParameters | None</code> <p>Parameters defining status, startup and shutdown constraints and effects</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Industrial cooling tower:</p> <pre><code>cooling_tower = CoolingTower(\n    label='process_cooling_tower',\n    specific_electricity_demand=0.025,  # 2.5% auxiliary power\n    electrical_flow=cooling_electricity,\n    thermal_flow=waste_heat_flow,\n)\n</code></pre> <p>Power plant condenser cooling:</p> <pre><code>condenser_cooling = CoolingTower(\n    label='power_plant_cooling',\n    specific_electricity_demand=0.015,  # 1.5% auxiliary power\n    electrical_flow=auxiliary_electricity,\n    thermal_flow=condenser_waste_heat,\n    status_parameters=StatusParameters(\n        min_uptime=4,  # Minimum operation time\n        effects_per_active_hour={'water_consumption': 2.5},  # m\u00b3/h\n    ),\n)\n</code></pre> Note <p>The conversion relationship is: electrical_flow = thermal_flow \u00d7 specific_electricity_demand</p> <p>The cooling tower consumes electrical power proportional to the thermal load. No thermal energy is produced - all thermal input is rejected to the environment.</p> <p>Typical specific electricity demands range from 1-5% of the thermal cooling load, depending on tower design, climate conditions, and operational requirements.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower-attributes","title":"Attributes","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.flows","title":"flows  <code>cached</code> <code>property</code>","text":"<pre><code>flows: FlowContainer\n</code></pre> <p>All flows (inputs and outputs) as a FlowContainer.</p> Supports access by label_full or short label <p>component.flows['Boiler(Q_th)']  # Full label component.flows['Q_th']          # Short label</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to parent Component and piecewise_conversion.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP","title":"CHP","text":"<pre><code>CHP(label: str, thermal_efficiency: Numeric_TPS | None = None, electrical_efficiency: Numeric_TPS | None = None, fuel_flow: Flow | None = None, electrical_flow: Flow | None = None, thermal_flow: Flow | None = None, status_parameters: StatusParameters | None = None, meta_data: dict | None = None, color: str | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing a Combined Heat and Power (CHP) unit.</p> <p>CHP units simultaneously generate both electrical and thermal energy from a single fuel input, providing higher overall efficiency than separate generation. This is a wrapper around LinearConverter with predefined conversion relationships for cogeneration applications.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>thermal_efficiency</code> <code>Numeric_TPS | None</code> <p>Thermal efficiency factor (0-1 range). Defines the fraction of fuel energy converted to useful thermal output.</p> <code>None</code> <code>electrical_efficiency</code> <code>Numeric_TPS | None</code> <p>Electrical efficiency factor (0-1 range). Defines the fraction of fuel energy converted to electrical output.</p> <code>None</code> <code>fuel_flow</code> <code>Flow | None</code> <p>Fuel input-flow representing fuel consumption.</p> <code>None</code> <code>electrical_flow</code> <code>Flow | None</code> <p>Electrical output-flow representing electricity generation.</p> <code>None</code> <code>thermal_flow</code> <code>Flow | None</code> <p>Thermal output-flow representing heat generation.</p> <code>None</code> <code>status_parameters</code> <code>StatusParameters | None</code> <p>Parameters defining status, startup and shutdown constraints and effects</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Natural gas CHP unit:</p> <pre><code>gas_chp = CHP(\n    label='natural_gas_chp',\n    thermal_efficiency=0.45,  # 45% thermal efficiency\n    electrical_efficiency=0.35,  # 35% electrical efficiency (80% total)\n    fuel_flow=natural_gas_flow,\n    electrical_flow=electricity_flow,\n    thermal_flow=district_heat_flow,\n)\n</code></pre> <p>Industrial CHP with operational constraints:</p> <pre><code>industrial_chp = CHP(\n    label='industrial_chp',\n    thermal_efficiency=0.40,\n    electrical_efficiency=0.38,\n    fuel_flow=fuel_gas_flow,\n    electrical_flow=plant_electricity,\n    thermal_flow=process_steam,\n    status_parameters=StatusParameters(\n        min_uptime=8,  # Minimum 8-hour operation\n        effects_per_startup={'startup_cost': 5000},\n        active_hours_max=6000,  # Annual operating limit\n    ),\n)\n</code></pre> Note <p>The conversion relationships are: - thermal_flow = fuel_flow \u00d7 thermal_efficiency (thermal output) - electrical_flow = fuel_flow \u00d7 electrical_efficiency (electrical output)</p> <p>Total efficiency (thermal_efficiency + electrical_efficiency) should be \u2264 1.0, with typical combined efficiencies of 80-90% for modern CHP units. This provides significant efficiency gains compared to separate heat and power generation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP-attributes","title":"Attributes","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.flows","title":"flows  <code>cached</code> <code>property</code>","text":"<pre><code>flows: FlowContainer\n</code></pre> <p>All flows (inputs and outputs) as a FlowContainer.</p> Supports access by label_full or short label <p>component.flows['Boiler(Q_th)']  # Full label component.flows['Q_th']          # Short label</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to parent Component and piecewise_conversion.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource","title":"HeatPumpWithSource","text":"<pre><code>HeatPumpWithSource(label: str, cop: Numeric_TPS | None = None, electrical_flow: Flow | None = None, heat_source_flow: Flow | None = None, thermal_flow: Flow | None = None, status_parameters: StatusParameters | None = None, meta_data: dict | None = None, color: str | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing a heat pump with explicit heat source modeling.</p> <p>This component models a heat pump that extracts thermal energy from a heat source (ground, air, water) and upgrades it using electrical energy to provide higher-grade thermal output. Unlike the simple HeatPump class, this explicitly models both the heat source extraction and electrical consumption with their interdependent relationships.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>cop</code> <code>Numeric_TPS | None</code> <p>Coefficient of Performance (typically 1-20 range). Defines the ratio of thermal output to electrical input. The heat source extraction is automatically calculated as heat_source_flow = thermal_flow \u00d7 (COP-1)/COP.</p> <code>None</code> <code>electrical_flow</code> <code>Flow | None</code> <p>Electrical input-flow representing electricity consumption for compressor.</p> <code>None</code> <code>heat_source_flow</code> <code>Flow | None</code> <p>Heat source input-flow representing thermal energy extracted from environment (ground, air, water source).</p> <code>None</code> <code>thermal_flow</code> <code>Flow | None</code> <p>Thermal output-flow representing useful heat delivered to the application.</p> <code>None</code> <code>status_parameters</code> <code>StatusParameters | None</code> <p>Parameters defining status, startup and shutdown constraints and effects</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Ground-source heat pump with explicit ground coupling:</p> <pre><code>ground_source_hp = HeatPumpWithSource(\n    label='geothermal_heat_pump',\n    cop=4.5,  # High COP due to stable ground temperature\n    electrical_flow=electricity_flow,\n    heat_source_flow=ground_heat_extraction,  # Heat extracted from ground loop\n    thermal_flow=building_heating_flow,\n)\n</code></pre> <p>Air-source heat pump with temperature-dependent performance:</p> <pre><code>waste_heat_pump = HeatPumpWithSource(\n    label='waste_heat_pump',\n    cop=temperature_dependent_cop,  # Varies with temperature of heat source\n    electrical_flow=electricity_consumption,\n    heat_source_flow=industrial_heat_extraction,  # Heat extracted from a industrial process or waste water\n    thermal_flow=heat_supply,\n    status_parameters=StatusParameters(\n        min_uptime=0.5,  # 30-minute minimum runtime\n        effects_per_startup={'costs': 1000},\n    ),\n)\n</code></pre> Note <p>The conversion relationships are: - thermal_flow = electrical_flow \u00d7 COP (thermal output from electrical input) - heat_source_flow = thermal_flow \u00d7 (COP-1)/COP (heat source extraction) - Energy balance: thermal_flow = electrical_flow + heat_source_flow</p> <p>This formulation explicitly tracks the heat source, which is important for systems where the source capacity or temperature is limited, or where the impact of heat extraction must be considered.</p> <p>COP should be &gt; 1 for thermodynamically valid operation, with typical values of 2-6 depending on source and sink temperatures.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource-attributes","title":"Attributes","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.flows","title":"flows  <code>cached</code> <code>property</code>","text":"<pre><code>flows: FlowContainer\n</code></pre> <p>All flows (inputs and outputs) as a FlowContainer.</p> Supports access by label_full or short label <p>component.flows['Boiler(Q_th)']  # Full label component.flows['Q_th']          # Short label</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system, prefix: str = '') -&gt; None\n</code></pre> <p>Propagate flow_system reference to parent Component and piecewise_conversion.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.check_bounds","title":"check_bounds","text":"<pre><code>check_bounds(value: Numeric_TPS, parameter_label: str, element_label: str, lower_bound: Numeric_TPS, upper_bound: Numeric_TPS) -&gt; None\n</code></pre> <p>Check if the value is within the bounds. The bounds are exclusive. If not, log a warning. Args:     value: The value to check.     parameter_label: The label of the value.     element_label: The label of the element.     lower_bound: The lower bound.     upper_bound: The upper bound.</p>"},{"location":"api-reference/modeling/","title":"Modeling","text":""},{"location":"api-reference/modeling/#flixopt.modeling","title":"flixopt.modeling","text":""},{"location":"api-reference/modeling/#flixopt.modeling-classes","title":"Classes","text":""},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilitiesAbstract","title":"ModelingUtilitiesAbstract","text":"<p>Utility functions for modeling - leveraging xarray for temporal data</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilitiesAbstract-functions","title":"Functions","text":""},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilitiesAbstract.to_binary","title":"to_binary  <code>staticmethod</code>","text":"<pre><code>to_binary(values: DataArray, epsilon: float | None = None, dims: str | list[str] | None = None) -&gt; xr.DataArray\n</code></pre> <p>Converts a DataArray to binary {0, 1} values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>DataArray</code> <p>Input DataArray to convert to binary</p> required <code>epsilon</code> <code>float | None</code> <p>Tolerance for zero detection (uses CONFIG.Modeling.epsilon if None)</p> <code>None</code> <code>dims</code> <code>str | list[str] | None</code> <p>Dims to keep. Other dimensions are collapsed using .any() -&gt; If any value is 1, all are 1.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>Binary DataArray with same shape (or collapsed if collapse_non_time=True)</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilitiesAbstract.count_consecutive_states","title":"count_consecutive_states  <code>staticmethod</code>","text":"<pre><code>count_consecutive_states(binary_values: DataArray | ndarray | list[int, float], dim: str = 'time', epsilon: float | None = None) -&gt; float\n</code></pre> <p>Count consecutive steps in the final active state of a binary time series.</p> <p>This function counts how many consecutive time steps the series remains \"on\" (non-zero) at the end of the time series. If the final state is \"inactive\", returns 0.</p> <p>Parameters:</p> Name Type Description Default <code>binary_values</code> <code>DataArray | ndarray | list[int, float]</code> <p>Binary DataArray with values close to 0 (inactive) or 1 (active).</p> required <code>dim</code> <code>str</code> <p>Dimension along which to count consecutive states.</p> <code>'time'</code> <code>epsilon</code> <code>float | None</code> <p>Tolerance for zero detection. Uses CONFIG.Modeling.epsilon if None.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Sum of values in the final consecutive \"active\" period. Returns 0.0 if the</p> <code>float</code> <p>final state is \"inactive\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; arr = xr.DataArray([0, 0, 1, 1, 1, 0, 1, 1], dims=['time'])\n&gt;&gt;&gt; ModelingUtilitiesAbstract.count_consecutive_states(arr)\n2.0\n</code></pre> <pre><code>&gt;&gt;&gt; arr = [0, 0, 1, 0, 1, 1, 1, 1]\n&gt;&gt;&gt; ModelingUtilitiesAbstract.count_consecutive_states(arr)\n4.0\n</code></pre>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilities","title":"ModelingUtilities","text":""},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilities-functions","title":"Functions","text":""},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilities.compute_consecutive_hours_in_state","title":"compute_consecutive_hours_in_state  <code>staticmethod</code>","text":"<pre><code>compute_consecutive_hours_in_state(binary_values: DataArray, hours_per_timestep: int | float, epsilon: float = None) -&gt; float\n</code></pre> <p>Computes the final consecutive duration in state 'active' (=1) in hours.</p> <p>Parameters:</p> Name Type Description Default <code>binary_values</code> <code>DataArray</code> <p>Binary DataArray with 'time' dim, or scalar/array</p> required <code>hours_per_timestep</code> <code>int | float</code> <p>Duration of each timestep in hours</p> required <code>epsilon</code> <code>float</code> <p>Tolerance for zero detection (uses CONFIG.Modeling.epsilon if None)</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>The duration of the final consecutive 'active' period in hours</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilities.compute_previous_off_duration","title":"compute_previous_off_duration  <code>staticmethod</code>","text":"<pre><code>compute_previous_off_duration(previous_values: DataArray, hours_per_step: DataArray | float | int) -&gt; float\n</code></pre> <p>Compute previous consecutive 'inactive' duration.</p> <p>Parameters:</p> Name Type Description Default <code>previous_values</code> <code>DataArray</code> <p>DataArray with 'time' dimension</p> required <code>hours_per_step</code> <code>DataArray | float | int</code> <p>Duration of each timestep in hours</p> required <p>Returns:</p> Type Description <code>float</code> <p>Previous consecutive inactive duration in hours</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingUtilities.get_most_recent_state","title":"get_most_recent_state  <code>staticmethod</code>","text":"<pre><code>get_most_recent_state(previous_values: DataArray | None) -&gt; int\n</code></pre> <p>Get the most recent binary state from previous values.</p> <p>Parameters:</p> Name Type Description Default <code>previous_values</code> <code>DataArray | None</code> <p>DataArray with 'time' dimension</p> required <p>Returns:</p> Type Description <code>int</code> <p>Most recent binary state (0 or 1)</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingPrimitives","title":"ModelingPrimitives","text":"<p>Mathematical modeling primitives returning (variables, constraints) tuples</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingPrimitives-functions","title":"Functions","text":""},{"location":"api-reference/modeling/#flixopt.modeling.ModelingPrimitives.expression_tracking_variable","title":"expression_tracking_variable  <code>staticmethod</code>","text":"<pre><code>expression_tracking_variable(model: Submodel, tracked_expression: LinearExpression | Variable, name: str = None, short_name: str = None, bounds: tuple[DataArray, DataArray] = None, coords: str | list[str] | None = None, category: VariableCategory = None) -&gt; tuple[linopy.Variable, linopy.Constraint]\n</code></pre> <p>Creates a variable constrained to equal a given expression.</p> Mathematical formulation <p>tracker = expression lower \u2264 tracker \u2264 upper  (if bounds provided)</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The submodel to add variables and constraints to</p> required <code>tracked_expression</code> <code>LinearExpression | Variable</code> <p>Expression that the tracker variable must equal</p> required <code>name</code> <code>str</code> <p>Full name for the variable and constraint</p> <code>None</code> <code>short_name</code> <code>str</code> <p>Short name for display purposes</p> <code>None</code> <code>bounds</code> <code>tuple[DataArray, DataArray]</code> <p>Optional (lower_bound, upper_bound) tuple for the tracker variable</p> <code>None</code> <code>coords</code> <code>str | list[str] | None</code> <p>Coordinate dimensions for the variable (None uses all model coords)</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Variable, Constraint]</code> <p>Tuple of (tracker_variable, tracking_constraint)</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingPrimitives.consecutive_duration_tracking","title":"consecutive_duration_tracking  <code>staticmethod</code>","text":"<pre><code>consecutive_duration_tracking(model: Submodel, state: Variable, name: str = None, short_name: str = None, minimum_duration: DataArray | None = None, maximum_duration: DataArray | None = None, duration_dim: str = 'time', duration_per_step: int | float | DataArray = None, previous_duration: DataArray | float | int | None = None) -&gt; tuple[dict[str, linopy.Variable], dict[str, linopy.Constraint]]\n</code></pre> <p>Creates consecutive duration tracking for a binary state variable.</p> <p>Tracks how long a binary state has been continuously active (=1). Duration resets to 0 when state becomes inactive (=0).</p> Mathematical formulation <p>duration[t] \u2264 state[t] \u00b7 M  \u2200t duration[t+1] \u2264 duration[t] + duration_per_step[t]  \u2200t duration[t+1] \u2265 duration[t] + duration_per_step[t] + (state[t+1] - 1) \u00b7 M  \u2200t duration[0] = (duration_per_step[0] + previous_duration) \u00b7 state[0]</p> <p>If minimum_duration provided:     duration[t] \u2265 (state[t-1] - state[t]) \u00b7 minimum_duration[t-1]  \u2200t &gt; 0</p> <p>Where M is a big-M value (sum of all duration_per_step + previous_duration).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The submodel to add variables and constraints to</p> required <code>state</code> <code>Variable</code> <p>Binary state variable (1=active, 0=inactive) to track duration for</p> required <code>name</code> <code>str</code> <p>Full name for the duration variable</p> <code>None</code> <code>short_name</code> <code>str</code> <p>Short name for display purposes</p> <code>None</code> <code>minimum_duration</code> <code>DataArray | None</code> <p>Optional minimum consecutive duration (enforced at state transitions)</p> <code>None</code> <code>maximum_duration</code> <code>DataArray | None</code> <p>Optional maximum consecutive duration (upper bound on duration variable)</p> <code>None</code> <code>duration_dim</code> <code>str</code> <p>Dimension name to track duration along (default 'time')</p> <code>'time'</code> <code>duration_per_step</code> <code>int | float | DataArray</code> <p>Time increment per step in duration_dim</p> <code>None</code> <code>previous_duration</code> <code>DataArray | float | int | None</code> <p>Initial duration value before first timestep. If None (default), no initial constraint is added (relaxed initial state).</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Variable]</code> <p>Tuple of (variables_dict, constraints_dict).</p> <code>dict[str, Constraint]</code> <p>variables_dict contains: 'duration'.</p> <code>tuple[dict[str, Variable], dict[str, Constraint]]</code> <p>constraints_dict always contains: 'ub', 'forward', 'backward'.</p> <code>tuple[dict[str, Variable], dict[str, Constraint]]</code> <p>When previous_duration is not None, also contains: 'initial'.</p> <code>tuple[dict[str, Variable], dict[str, Constraint]]</code> <p>When minimum_duration is provided, also contains: 'lb'.</p> <code>tuple[dict[str, Variable], dict[str, Constraint]]</code> <p>When minimum_duration is provided and previous_duration is not None and</p> <code>tuple[dict[str, Variable], dict[str, Constraint]]</code> <p>0 &lt; previous_duration &lt; minimum_duration[0], also contains: 'initial_lb'.</p>"},{"location":"api-reference/modeling/#flixopt.modeling.ModelingPrimitives.mutual_exclusivity_constraint","title":"mutual_exclusivity_constraint  <code>staticmethod</code>","text":"<pre><code>mutual_exclusivity_constraint(model: Submodel, binary_variables: list[Variable], tolerance: float = 1, short_name: str = 'mutual_exclusivity') -&gt; linopy.Constraint\n</code></pre> <p>Creates mutual exclusivity constraint for binary variables.</p> <p>Ensures at most one binary variable can be active (=1) at any time.</p> Mathematical formulation <p>\u03a3\u1d62 binary_vars[i] \u2264 tolerance  \u2200t</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The submodel to add the constraint to</p> required <code>binary_variables</code> <code>list[Variable]</code> <p>List of binary variables that should be mutually exclusive</p> required <code>tolerance</code> <code>float</code> <p>Upper bound on the sum (default 1, allows slight numerical tolerance)</p> <code>1</code> <code>short_name</code> <code>str</code> <p>Short name for the constraint</p> <code>'mutual_exclusivity'</code> <p>Returns:</p> Type Description <code>Constraint</code> <p>Mutual exclusivity constraint</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If fewer than 2 variables provided or variables aren't binary</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns","title":"BoundingPatterns","text":"<p>High-level patterns that compose primitives and return (variables, constraints) tuples</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns-functions","title":"Functions","text":""},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns.basic_bounds","title":"basic_bounds  <code>staticmethod</code>","text":"<pre><code>basic_bounds(model: Submodel, variable: Variable, bounds: tuple[DataArray, DataArray], name: str = None) -&gt; list[linopy.constraints.Constraint]\n</code></pre> <p>Creates simple lower and upper bounds for a variable.</p> Mathematical formulation <p>lower_bound \u2264 variable \u2264 upper_bound</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The submodel to add constraints to</p> required <code>variable</code> <code>Variable</code> <p>Variable to be bounded</p> required <code>bounds</code> <code>tuple[DataArray, DataArray]</code> <p>Tuple of (lower_bound, upper_bound) absolute bounds</p> required <code>name</code> <code>str</code> <p>Optional name prefix for constraints</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Constraint]</code> <p>List of [lower_constraint, upper_constraint]</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns.bounds_with_state","title":"bounds_with_state  <code>staticmethod</code>","text":"<pre><code>bounds_with_state(model: Submodel, variable: Variable, bounds: tuple[DataArray, DataArray], state: Variable, name: str = None) -&gt; list[linopy.Constraint]\n</code></pre> <p>Creates bounds controlled by a binary state variable.</p> <p>Variable is forced to 0 when state=0, bounded when state=1.</p> Mathematical formulation <p>state \u00b7 max(\u03b5, lower_bound) \u2264 variable \u2264 state \u00b7 upper_bound</p> <p>Where \u03b5 is a small positive number (CONFIG.Modeling.epsilon) ensuring numerical stability when lower_bound is 0.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The submodel to add constraints to</p> required <code>variable</code> <code>Variable</code> <p>Variable to be bounded</p> required <code>bounds</code> <code>tuple[DataArray, DataArray]</code> <p>Tuple of (lower_bound, upper_bound) absolute bounds when state=1</p> required <code>state</code> <code>Variable</code> <p>Binary variable (0=force variable to 0, 1=allow bounds)</p> required <code>name</code> <code>str</code> <p>Optional name prefix for constraints</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Constraint]</code> <p>List of [lower_constraint, upper_constraint] (or [fix_constraint] if lower=upper)</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns.scaled_bounds","title":"scaled_bounds  <code>staticmethod</code>","text":"<pre><code>scaled_bounds(model: Submodel, variable: Variable, scaling_variable: Variable, relative_bounds: tuple[DataArray, DataArray], name: str = None) -&gt; list[linopy.Constraint]\n</code></pre> <p>Creates bounds scaled by another variable.</p> <p>Variable is bounded relative to a scaling variable (e.g., flow rate relative to size).</p> Mathematical formulation <p>scaling_variable \u00b7 lower_factor \u2264 variable \u2264 scaling_variable \u00b7 upper_factor</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The submodel to add constraints to</p> required <code>variable</code> <code>Variable</code> <p>Variable to be bounded</p> required <code>scaling_variable</code> <code>Variable</code> <p>Variable that scales the bound factors (e.g., equipment size)</p> required <code>relative_bounds</code> <code>tuple[DataArray, DataArray]</code> <p>Tuple of (lower_factor, upper_factor) relative to scaling_variable</p> required <code>name</code> <code>str</code> <p>Optional name prefix for constraints</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Constraint]</code> <p>List of [lower_constraint, upper_constraint] (or [fix_constraint] if lower=upper)</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns.scaled_bounds_with_state","title":"scaled_bounds_with_state  <code>staticmethod</code>","text":"<pre><code>scaled_bounds_with_state(model: Submodel, variable: Variable, scaling_variable: Variable, relative_bounds: tuple[DataArray, DataArray], scaling_bounds: tuple[DataArray, DataArray], state: Variable, name: str = None) -&gt; list[linopy.Constraint]\n</code></pre> <p>Creates bounds scaled by a variable and controlled by a binary state.</p> <p>Variable is forced to 0 when state=0, bounded relative to scaling_variable when state=1.</p> <p>Mathematical formulation (Big-M):     (state - 1) \u00b7 M_misc + scaling_variable \u00b7 rel_lower \u2264 variable \u2264 scaling_variable \u00b7 rel_upper     state \u00b7 big_m_lower \u2264 variable \u2264 state \u00b7 big_m_upper</p> Where <p>M_misc = scaling_max \u00b7 rel_lower big_m_upper = scaling_max \u00b7 rel_upper big_m_lower = max(\u03b5, scaling_min \u00b7 rel_lower)</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The submodel to add constraints to</p> required <code>variable</code> <code>Variable</code> <p>Variable to be bounded</p> required <code>scaling_variable</code> <code>Variable</code> <p>Variable that scales the bound factors (e.g., equipment size)</p> required <code>relative_bounds</code> <code>tuple[DataArray, DataArray]</code> <p>Tuple of (lower_factor, upper_factor) relative to scaling_variable</p> required <code>scaling_bounds</code> <code>tuple[DataArray, DataArray]</code> <p>Tuple of (scaling_min, scaling_max) bounds of the scaling_variable</p> required <code>state</code> <code>Variable</code> <p>Binary variable (0=force variable to 0, 1=allow scaled bounds)</p> required <code>name</code> <code>str</code> <p>Optional name prefix for constraints</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Constraint]</code> <p>List of [scaling_lower, scaling_upper, binary_lower, binary_upper] constraints</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns.state_transition_bounds","title":"state_transition_bounds  <code>staticmethod</code>","text":"<pre><code>state_transition_bounds(model: Submodel, state: Variable, activate: Variable, deactivate: Variable, name: str, previous_state: float | DataArray | None = 0, coord: str = 'time') -&gt; tuple[linopy.Constraint, linopy.Constraint | None, linopy.Constraint]\n</code></pre> <p>Creates state transition constraints for binary state variables.</p> <p>Tracks transitions between active (1) and inactive (0) states using separate binary variables for activation and deactivation events.</p> Mathematical formulation <p>activate[t] - deactivate[t] = state[t] - state[t-1]  \u2200t &gt; 0 activate[0] - deactivate[0] = state[0] - previous_state activate[t] + deactivate[t] \u2264 1  \u2200t activate[t], deactivate[t] \u2208 {0, 1}</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The submodel to add constraints to</p> required <code>state</code> <code>Variable</code> <p>Binary state variable (0=inactive, 1=active)</p> required <code>activate</code> <code>Variable</code> <p>Binary variable for transitions from inactive to active (0\u21921)</p> required <code>deactivate</code> <code>Variable</code> <p>Binary variable for transitions from active to inactive (1\u21920)</p> required <code>name</code> <code>str</code> <p>Base name for constraints</p> required <code>previous_state</code> <code>float | DataArray | None</code> <p>State value before first timestep (default 0). If None, no initial constraint is added (relaxed initial state).</p> <code>0</code> <code>coord</code> <code>str</code> <p>Time dimension name (default 'time')</p> <code>'time'</code> <p>Returns:</p> Type Description <code>Constraint</code> <p>Tuple of (transition_constraint, initial_constraint, mutex_constraint).</p> <code>Constraint | None</code> <p>initial_constraint is None when previous_state is None.</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns.continuous_transition_bounds","title":"continuous_transition_bounds  <code>staticmethod</code>","text":"<pre><code>continuous_transition_bounds(model: Submodel, continuous_variable: Variable, activate: Variable, deactivate: Variable, name: str, max_change: float | DataArray, previous_value: float | DataArray = 0.0, coord: str = 'time') -&gt; tuple[linopy.Constraint, linopy.Constraint, linopy.Constraint, linopy.Constraint]\n</code></pre> <p>Constrains a continuous variable to only change during state transitions.</p> <p>Ensures a continuous variable remains constant unless a transition event occurs. Uses Big-M formulation to enforce change bounds.</p> Mathematical formulation <p>-max_change \u00b7 (activate[t] + deactivate[t]) \u2264 continuous[t] - continuous[t-1] \u2264 max_change \u00b7 (activate[t] + deactivate[t])  \u2200t &gt; 0 -max_change \u00b7 (activate[0] + deactivate[0]) \u2264 continuous[0] - previous_value \u2264 max_change \u00b7 (activate[0] + deactivate[0]) activate[t], deactivate[t] \u2208 {0, 1}</p> Behavior <ul> <li>When activate=0 and deactivate=0: variable must stay constant</li> <li>When activate=1 or deactivate=1: variable can change within \u00b1max_change</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The submodel to add constraints to</p> required <code>continuous_variable</code> <code>Variable</code> <p>Continuous variable to constrain</p> required <code>activate</code> <code>Variable</code> <p>Binary variable for transitions from inactive to active (0\u21921)</p> required <code>deactivate</code> <code>Variable</code> <p>Binary variable for transitions from active to inactive (1\u21920)</p> required <code>name</code> <code>str</code> <p>Base name for constraints</p> required <code>max_change</code> <code>float | DataArray</code> <p>Maximum allowed change (Big-M value, should be \u2265 actual max change)</p> required <code>previous_value</code> <code>float | DataArray</code> <p>Initial value before first timestep (default 0.0)</p> <code>0.0</code> <code>coord</code> <code>str</code> <p>Time dimension name (default 'time')</p> <code>'time'</code> <p>Returns:</p> Type Description <code>tuple[Constraint, Constraint, Constraint, Constraint]</code> <p>Tuple of (transition_upper, transition_lower, initial_upper, initial_lower) constraints</p>"},{"location":"api-reference/modeling/#flixopt.modeling.BoundingPatterns.link_changes_to_level_with_binaries","title":"link_changes_to_level_with_binaries  <code>staticmethod</code>","text":"<pre><code>link_changes_to_level_with_binaries(model: Submodel, level_variable: Variable, increase_variable: Variable, decrease_variable: Variable, increase_binary: Variable, decrease_binary: Variable, name: str, max_change: float | DataArray, initial_level: float | DataArray = 0.0, coord: str = 'period') -&gt; tuple[linopy.Constraint, linopy.Constraint, linopy.Constraint, linopy.Constraint, linopy.Constraint]\n</code></pre> <p>Link changes to level evolution with binary control and mutual exclusivity.</p> <p>Creates the complete constraint system for ALL time periods: 1. level[0] = initial_level + increase[0] - decrease[0] 2. level[t] = level[t-1] + increase[t] - decrease[t]  \u2200t &gt; 0 3. increase[t] &lt;= max_change * increase_binary[t]  \u2200t 4. decrease[t] &lt;= max_change * decrease_binary[t]  \u2200t 5. increase_binary[t] + decrease_binary[t] &lt;= 1  \u2200t</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Submodel</code> <p>The submodel to add constraints to</p> required <code>increase_variable</code> <code>Variable</code> <p>Incremental additions for ALL periods (&gt;= 0)</p> required <code>decrease_variable</code> <code>Variable</code> <p>Incremental reductions for ALL periods (&gt;= 0)</p> required <code>increase_binary</code> <code>Variable</code> <p>Binary indicators for increases for ALL periods</p> required <code>decrease_binary</code> <code>Variable</code> <p>Binary indicators for decreases for ALL periods</p> required <code>level_variable</code> <code>Variable</code> <p>Level variable for ALL periods</p> required <code>name</code> <code>str</code> <p>Base name for constraints</p> required <code>max_change</code> <code>float | DataArray</code> <p>Maximum change per period</p> required <code>initial_level</code> <code>float | DataArray</code> <p>Starting level before first period</p> <code>0.0</code> <code>coord</code> <code>str</code> <p>Time coordinate name</p> <code>'period'</code> <p>Returns:</p> Type Description <code>tuple[Constraint, Constraint, Constraint, Constraint, Constraint]</code> <p>Tuple of (initial_constraint, transition_constraints, increase_bounds, decrease_bounds, mutual_exclusion)</p>"},{"location":"api-reference/network_app/","title":"Network app","text":""},{"location":"api-reference/network_app/#flixopt.network_app","title":"flixopt.network_app","text":""},{"location":"api-reference/network_app/#flixopt.network_app-classes","title":"Classes","text":""},{"location":"api-reference/network_app/#flixopt.network_app.VisualizationConfig","title":"VisualizationConfig","text":"<p>Configuration constants for the visualization</p>"},{"location":"api-reference/network_app/#flixopt.network_app-functions","title":"Functions","text":""},{"location":"api-reference/network_app/#flixopt.network_app.flow_graph","title":"flow_graph","text":"<pre><code>flow_graph(flow_system: FlowSystem) -&gt; nx.DiGraph\n</code></pre> <p>Convert FlowSystem to NetworkX graph - simplified and more robust</p>"},{"location":"api-reference/network_app/#flixopt.network_app.make_cytoscape_elements","title":"make_cytoscape_elements","text":"<pre><code>make_cytoscape_elements(graph: DiGraph) -&gt; list[dict[str, Any]]\n</code></pre> <p>Convert NetworkX graph to Cytoscape elements</p>"},{"location":"api-reference/network_app/#flixopt.network_app.create_color_picker_input","title":"create_color_picker_input","text":"<pre><code>create_color_picker_input(label: str, input_id: str, default_color: str)\n</code></pre> <p>Create a compact color picker with DAQ ColorPicker</p>"},{"location":"api-reference/network_app/#flixopt.network_app.create_style_section","title":"create_style_section","text":"<pre><code>create_style_section(title: str, children: list)\n</code></pre> <p>Create a collapsible section for organizing controls</p>"},{"location":"api-reference/network_app/#flixopt.network_app.create_sidebar","title":"create_sidebar","text":"<pre><code>create_sidebar()\n</code></pre> <p>Create the main sidebar with improved organization</p>"},{"location":"api-reference/network_app/#flixopt.network_app.shownetwork","title":"shownetwork","text":"<pre><code>shownetwork(graph: DiGraph)\n</code></pre> <p>Main function to create and run the network visualization</p>"},{"location":"api-reference/optimization/","title":"Optimization","text":""},{"location":"api-reference/optimization/#flixopt.optimization","title":"flixopt.optimization","text":"<p>This module contains the Optimization functionality for the flixopt framework. It is used to optimize a FlowSystemModel for a given FlowSystem through a solver.</p> There are two Optimization types <ol> <li>Optimization: Optimizes the FlowSystemModel for the full FlowSystem</li> <li>SegmentedOptimization: Solves a FlowSystemModel for each individual Segment of the FlowSystem.</li> </ol> <p>For time series aggregation (clustering), use FlowSystem.transform.cluster() instead.</p>"},{"location":"api-reference/optimization/#flixopt.optimization-classes","title":"Classes","text":""},{"location":"api-reference/optimization/#flixopt.optimization.OptimizationProtocol","title":"OptimizationProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol defining the interface that all optimization types should implement.</p> <p>This protocol ensures type consistency across different optimization approaches without forcing them into an artificial inheritance hierarchy.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the optimization</p> <code>flow_system</code> <code>FlowSystem</code> <p>FlowSystem being optimized</p> <code>folder</code> <code>Path</code> <p>Directory where results are saved</p> <code>results</code> <code>Results | SegmentedResults | None</code> <p>Results object after solving</p> <code>durations</code> <code>dict[str, float]</code> <p>Dictionary tracking time spent in different phases</p>"},{"location":"api-reference/optimization/#flixopt.optimization.OptimizationProtocol-attributes","title":"Attributes","text":""},{"location":"api-reference/optimization/#flixopt.optimization.OptimizationProtocol.modeled","title":"modeled  <code>property</code>","text":"<pre><code>modeled: bool\n</code></pre> <p>Returns True if the optimization has been modeled.</p>"},{"location":"api-reference/optimization/#flixopt.optimization.OptimizationProtocol.main_results","title":"main_results  <code>property</code>","text":"<pre><code>main_results: dict[str, int | float | dict]\n</code></pre> <p>Returns main results including objective, effects, and investment decisions.</p>"},{"location":"api-reference/optimization/#flixopt.optimization.OptimizationProtocol.summary","title":"summary  <code>property</code>","text":"<pre><code>summary: dict\n</code></pre> <p>Returns summary information about the optimization.</p>"},{"location":"api-reference/optimization/#flixopt.optimization.Optimization","title":"Optimization","text":"<pre><code>Optimization(name: str, flow_system: FlowSystem, folder: Path | None = None, normalize_weights: bool = True)\n</code></pre> <p>Standard optimization that solves the complete problem using all time steps.</p> <p>This is the default optimization approach that considers every time step, providing the most accurate but computationally intensive solution.</p> <p>For large problems, consider using FlowSystem.transform.cluster() (time aggregation) or SegmentedOptimization (temporal decomposition) instead.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of optimization</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be optimized</p> required <code>folder</code> <code>Path | None</code> <p>folder where results should be saved. If None, then the current working directory is used.</p> <code>None</code> <code>normalize_weights</code> <code>bool</code> <p>Deprecated. Scenario weights are now always normalized in FlowSystem.</p> <code>True</code> <p>Examples:</p> <p>Basic usage: <pre><code>from flixopt import Optimization\n\nopt = Optimization(name='my_optimization', flow_system=energy_system, folder=Path('results'))\nopt.do_modeling()\nopt.solve(solver=gurobi)\nresults = opt.results\n</code></pre></p>"},{"location":"api-reference/optimization/#flixopt.optimization.Optimization-functions","title":"Functions","text":""},{"location":"api-reference/optimization/#flixopt.optimization.Optimization.fix_sizes","title":"fix_sizes","text":"<pre><code>fix_sizes(ds: Dataset | None = None, decimal_rounding: int | None = 5) -&gt; Optimization\n</code></pre> <p>Fix the sizes of the optimizations to specified values.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset | None</code> <p>The dataset that contains the variable names mapped to their sizes. If None, the dataset is loaded from the results.</p> <code>None</code> <code>decimal_rounding</code> <code>int | None</code> <p>The number of decimal places to round the sizes to. If no rounding is applied, numerical errors might lead to infeasibility.</p> <code>5</code>"},{"location":"api-reference/optimization/#flixopt.optimization.SegmentedOptimization","title":"SegmentedOptimization","text":"<pre><code>SegmentedOptimization(name: str, flow_system: FlowSystem, timesteps_per_segment: int, overlap_timesteps: int, nr_of_previous_values: int = 1, folder: Path | None = None)\n</code></pre> <p>Solve large optimization problems by dividing time horizon into (overlapping) segments.</p> <p>This class addresses memory and computational limitations of large-scale optimization problems by decomposing the time horizon into smaller overlapping segments that are solved sequentially. Each segment uses final values from the previous segment as initial conditions, ensuring dynamic continuity across the solution.</p> Key Concepts <p>Temporal Decomposition: Divides long time horizons into manageable segments Overlapping Windows: Segments share timesteps to improve storage dynamics Value Transfer: Final states of one segment become initial states of the next Sequential Solving: Each segment solved independently but with coupling</p> Limitations and Constraints <p>Investment Parameters: InvestParameters are not supported in segmented optimizations as investment decisions must be made for the entire time horizon, not per segment.</p> <p>Global Constraints: Time-horizon-wide constraints (flow_hours_total_min/max, load_factor_min/max) may produce suboptimal results as they cannot be enforced globally across segments.</p> <p>Storage Dynamics: While overlap helps, storage optimization may be suboptimal compared to full-horizon solutions due to limited foresight in each segment.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the calculation, used in result files and logging.</p> required <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to optimize, containing all components, flows, and buses.</p> required <code>timesteps_per_segment</code> <code>int</code> <p>Number of timesteps in each segment (excluding overlap). Must be &gt; 2 to avoid internal side effects. Larger values provide better optimization at the cost of memory and computation time.</p> required <code>overlap_timesteps</code> <code>int</code> <p>Number of additional timesteps added to each segment. Improves storage optimization by providing lookahead. Higher values improve solution quality but increase computational cost.</p> required <code>nr_of_previous_values</code> <code>int</code> <p>Number of previous timestep values to transfer between segments for initialization. Typically 1 is sufficient.</p> <code>1</code> <code>folder</code> <code>Path | None</code> <p>Directory for saving results. Defaults to current working directory + 'results'.</p> <code>None</code> <p>Examples:</p> <p>Annual optimization with monthly segments:</p> <pre><code># 8760 hours annual data with monthly segments (730 hours) and 48-hour overlap\nsegmented_calc = SegmentedOptimization(\n    name='annual_energy_system',\n    flow_system=energy_system,\n    timesteps_per_segment=730,  # ~1 month\n    overlap_timesteps=48,  # 2 days overlap\n    folder=Path('results/segmented'),\n)\nsegmented_calc.do_modeling_and_solve(solver='gurobi')\n</code></pre> <p>Weekly optimization with daily overlap:</p> <pre><code># Weekly segments for detailed operational planning\nweekly_calc = SegmentedOptimization(\n    name='weekly_operations',\n    flow_system=industrial_system,\n    timesteps_per_segment=168,  # 1 week (hourly data)\n    overlap_timesteps=24,  # 1 day overlap\n    nr_of_previous_values=1,\n)\n</code></pre> <p>Large-scale system with minimal overlap:</p> <pre><code># Large system with minimal overlap for computational efficiency\nlarge_calc = SegmentedOptimization(\n    name='large_scale_grid',\n    flow_system=grid_system,\n    timesteps_per_segment=100,  # Shorter segments\n    overlap_timesteps=5,  # Minimal overlap\n)\n</code></pre> Design Considerations <p>Segment Size: Balance between solution quality and computational efficiency. Larger segments provide better optimization but require more memory and time.</p> <p>Overlap Duration: More overlap improves storage dynamics and reduces end-effects but increases computational cost. Typically 5-10% of segment length.</p> <p>Storage Systems: Systems with large storage components benefit from longer overlaps to capture charge/discharge cycles effectively.</p> <p>Investment Decisions: Use Optimization for problems requiring investment optimization, as SegmentedOptimization cannot handle investment parameters.</p> Common Use Cases <ul> <li>Annual Planning: Long-term planning with seasonal variations</li> <li>Large Networks: Spatially or temporally large energy systems</li> <li>Memory-Limited Systems: When full optimization exceeds available memory</li> <li>Operational Planning: Detailed short-term optimization with limited foresight</li> <li>Sensitivity Analysis: Quick approximate solutions for parameter studies</li> </ul> Performance Tips <ul> <li>Start with Optimization and use this class if memory issues occur</li> <li>Use longer overlaps for systems with significant storage</li> <li>Monitor solution quality at segment boundaries for discontinuities</li> </ul> Warning <p>The evaluation of the solution is a bit more complex than Optimization due to the overlapping individual solutions.</p>"},{"location":"api-reference/optimization/#flixopt.optimization.SegmentedOptimization-attributes","title":"Attributes","text":""},{"location":"api-reference/optimization/#flixopt.optimization.SegmentedOptimization.start_values_of_segments","title":"start_values_of_segments  <code>property</code>","text":"<pre><code>start_values_of_segments: list[dict[str, Any]]\n</code></pre> <p>Gives an overview of the start values of all Segments</p>"},{"location":"api-reference/optimization/#flixopt.optimization.SegmentedOptimization.modeled","title":"modeled  <code>property</code>","text":"<pre><code>modeled: bool\n</code></pre> <p>Returns True if all segments have been modeled.</p>"},{"location":"api-reference/optimization/#flixopt.optimization.SegmentedOptimization.main_results","title":"main_results  <code>property</code>","text":"<pre><code>main_results: dict[str, int | float | dict]\n</code></pre> <p>Aggregated main results from all segments.</p> Note <p>For SegmentedOptimization, results are aggregated from SegmentedResults which handles the overlapping segments properly. Individual segment results should not be summed directly as they contain overlapping timesteps.</p> <p>The objective value shown is the sum of all segment objectives and includes double-counting from overlapping regions. It does not represent a true full-horizon objective value.</p>"},{"location":"api-reference/optimization/#flixopt.optimization.SegmentedOptimization.summary","title":"summary  <code>property</code>","text":"<pre><code>summary\n</code></pre> <p>Summary of the segmented optimization with aggregated information from all segments.</p>"},{"location":"api-reference/optimization/#flixopt.optimization.SegmentedOptimization-functions","title":"Functions","text":""},{"location":"api-reference/optimization/#flixopt.optimization.SegmentedOptimization.do_modeling_and_solve","title":"do_modeling_and_solve","text":"<pre><code>do_modeling_and_solve(solver: _Solver, log_file: Path | None = None, log_main_results: bool = False, show_individual_solves: bool = False) -&gt; SegmentedOptimization\n</code></pre> <p>Model and solve all segments of the segmented optimization.</p> <p>This method creates sub-optimizations for each time segment, then iteratively models and solves each segment. It supports two output modes: a progress bar for compact output, or detailed individual solve information.</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>_Solver</code> <p>The solver instance to use for optimization (e.g., Gurobi, HiGHS).</p> required <code>log_file</code> <code>Path | None</code> <p>Optional path to the solver log file. If None, defaults to folder/name.log.</p> <code>None</code> <code>log_main_results</code> <code>bool</code> <p>Whether to log main results (objective, effects, etc.) after each segment solve. Defaults to False.</p> <code>False</code> <code>show_individual_solves</code> <code>bool</code> <p>If True, shows detailed output for each segment solve with logger messages. If False (default), shows a compact progress bar with suppressed solver output for cleaner display.</p> <code>False</code> <p>Returns:</p> Type Description <code>SegmentedOptimization</code> <p>Self, for method chaining.</p> Note <p>The method automatically transfers all start values between segments to ensure continuity of storage states and flow rates across segment boundaries.</p>"},{"location":"api-reference/optimize_accessor/","title":"Optimize accessor","text":""},{"location":"api-reference/optimize_accessor/#flixopt.optimize_accessor","title":"flixopt.optimize_accessor","text":"<p>Optimization accessor for FlowSystem.</p> <p>This module provides the OptimizeAccessor class that enables the <code>flow_system.optimize(...)</code> pattern with extensible optimization methods.</p>"},{"location":"api-reference/optimize_accessor/#flixopt.optimize_accessor-classes","title":"Classes","text":""},{"location":"api-reference/optimize_accessor/#flixopt.optimize_accessor.OptimizeAccessor","title":"OptimizeAccessor","text":"<pre><code>OptimizeAccessor(flow_system: FlowSystem)\n</code></pre> <p>Accessor for optimization methods on FlowSystem.</p> <p>This class provides the optimization API for FlowSystem, accessible via <code>flow_system.optimize</code>. It supports both direct calling (standard optimization) and method access for specialized optimization modes.</p> <p>Examples:</p> <p>Standard optimization (via call):</p> <pre><code>&gt;&gt;&gt; flow_system.optimize(solver)\n&gt;&gt;&gt; print(flow_system.solution)\n</code></pre> <p>Rolling horizon optimization:</p> <pre><code>&gt;&gt;&gt; segments = flow_system.optimize.rolling_horizon(solver, horizon=168)\n&gt;&gt;&gt; print(flow_system.solution)  # Combined result\n</code></pre> <p>Initialize the accessor with a reference to the FlowSystem.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to optimize.</p> required"},{"location":"api-reference/optimize_accessor/#flixopt.optimize_accessor.OptimizeAccessor-functions","title":"Functions","text":""},{"location":"api-reference/optimize_accessor/#flixopt.optimize_accessor.OptimizeAccessor.rolling_horizon","title":"rolling_horizon","text":"<pre><code>rolling_horizon(solver: _Solver, horizon: int = 100, overlap: int = 0, nr_of_previous_values: int = 1) -&gt; list[FlowSystem]\n</code></pre> <p>Solve the optimization using a rolling horizon approach.</p> <p>Divides the time horizon into overlapping segments that are solved sequentially. Each segment uses final values from the previous segment as initial conditions, ensuring dynamic continuity across the solution. The combined solution is stored on the original FlowSystem.</p> <p>This approach is useful for: - Large-scale problems that exceed memory limits - Annual planning with seasonal variations - Operational planning with limited foresight</p> <p>Parameters:</p> Name Type Description Default <code>solver</code> <code>_Solver</code> <p>The solver to use (e.g., HighsSolver, GurobiSolver).</p> required <code>horizon</code> <code>int</code> <p>Number of timesteps in each segment (excluding overlap). Must be &gt; 2. Larger values provide better optimization at the cost of memory and computation time. Default: 100.</p> <code>100</code> <code>overlap</code> <code>int</code> <p>Number of additional timesteps added to each segment for lookahead. Improves storage optimization by providing foresight. Higher values improve solution quality but increase computational cost. Default: 0.</p> <code>0</code> <code>nr_of_previous_values</code> <code>int</code> <p>Number of previous timestep values to transfer between segments for initialization (e.g., for uptime/downtime tracking). Default: 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>list[FlowSystem]</code> <p>List of segment FlowSystems, each with their individual solution.</p> <code>list[FlowSystem]</code> <p>The combined solution (with overlaps trimmed) is stored on the original FlowSystem.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If horizon &lt;= 2 or overlap &lt; 0.</p> <code>ValueError</code> <p>If horizon + overlap &gt; total timesteps.</p> <code>ValueError</code> <p>If InvestParameters are used (not supported in rolling horizon).</p> <p>Examples:</p> <p>Basic rolling horizon optimization:</p> <pre><code>&gt;&gt;&gt; segments = flow_system.optimize.rolling_horizon(\n...     solver,\n...     horizon=168,  # Weekly segments\n...     overlap=24,  # 1-day lookahead\n... )\n&gt;&gt;&gt; print(flow_system.solution)  # Combined result\n</code></pre> <p>Inspect individual segments:</p> <pre><code>&gt;&gt;&gt; for i, seg in enumerate(segments):\n...     print(f'Segment {i}: {seg.solution[\"costs\"].item():.2f}')\n</code></pre> Note <ul> <li>InvestParameters are not supported as investment decisions require   full-horizon optimization.</li> <li>Global constraints (flow_hours_max, etc.) may produce suboptimal results   as they cannot be enforced globally across segments.</li> <li>Storage optimization may be suboptimal compared to full-horizon solutions   due to limited foresight in each segment.</li> </ul>"},{"location":"api-reference/optimize_accessor/#flixopt.optimize_accessor-functions","title":"Functions","text":""},{"location":"api-reference/plot_result/","title":"Plot result","text":""},{"location":"api-reference/plot_result/#flixopt.plot_result","title":"flixopt.plot_result","text":"<p>Plot result container for unified plotting API.</p> <p>This module provides the PlotResult class that wraps plotting outputs across the entire flixopt package, ensuring a consistent interface.</p>"},{"location":"api-reference/plot_result/#flixopt.plot_result-classes","title":"Classes","text":""},{"location":"api-reference/plot_result/#flixopt.plot_result.PlotResult","title":"PlotResult  <code>dataclass</code>","text":"<pre><code>PlotResult(data: Dataset, figure: Figure)\n</code></pre> <p>Container returned by all plot methods. Holds both data and figure.</p> <p>This class provides a unified interface for all plotting methods across the flixopt package, enabling consistent method chaining and export options.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Dataset</code> <p>Prepared xarray Dataset used for the plot.</p> <code>figure</code> <code>Figure</code> <p>Plotly figure object.</p> <p>Examples:</p> <p>Basic usage with chaining:</p> <pre><code>&gt;&gt;&gt; result = flow_system.statistics.plot.balance('Bus')\n&gt;&gt;&gt; result.show().to_html('plot.html')\n</code></pre> <p>Accessing underlying data:</p> <pre><code>&gt;&gt;&gt; result = flow_system.statistics.plot.flows()\n&gt;&gt;&gt; df = result.data.to_dataframe()\n&gt;&gt;&gt; result.to_csv('data.csv')\n</code></pre> <p>Customizing the figure:</p> <pre><code>&gt;&gt;&gt; result = clustering.plot.compare()\n&gt;&gt;&gt; result.update(title='My Custom Title').show()\n</code></pre>"},{"location":"api-reference/plot_result/#flixopt.plot_result.PlotResult-functions","title":"Functions","text":""},{"location":"api-reference/plot_result/#flixopt.plot_result.PlotResult.show","title":"show","text":"<pre><code>show() -&gt; PlotResult\n</code></pre> <p>Display the figure. Returns self for chaining.</p>"},{"location":"api-reference/plot_result/#flixopt.plot_result.PlotResult.update","title":"update","text":"<pre><code>update(**layout_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Update figure layout. Returns self for chaining.</p> <p>Parameters:</p> Name Type Description Default <code>**layout_kwargs</code> <code>Any</code> <p>Arguments passed to plotly's update_layout().</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>Self for method chaining.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; result.update(title='New Title', height=600)\n</code></pre>"},{"location":"api-reference/plot_result/#flixopt.plot_result.PlotResult.update_traces","title":"update_traces","text":"<pre><code>update_traces(**trace_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Update figure traces. Returns self for chaining.</p> <p>Parameters:</p> Name Type Description Default <code>**trace_kwargs</code> <code>Any</code> <p>Arguments passed to plotly's update_traces().</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>Self for method chaining.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; result.update_traces(line_width=2, marker_size=8)\n</code></pre>"},{"location":"api-reference/plot_result/#flixopt.plot_result.PlotResult.to_html","title":"to_html","text":"<pre><code>to_html(path: str | Path) -&gt; PlotResult\n</code></pre> <p>Save figure as interactive HTML. Returns self for chaining.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>File path for the HTML output.</p> required <p>Returns:</p> Type Description <code>PlotResult</code> <p>Self for method chaining.</p>"},{"location":"api-reference/plot_result/#flixopt.plot_result.PlotResult.to_image","title":"to_image","text":"<pre><code>to_image(path: str | Path, **kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Save figure as static image. Returns self for chaining.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>File path for the image (format inferred from extension).</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to write_image().</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>Self for method chaining.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; result.to_image('plot.png', scale=2)\n&gt;&gt;&gt; result.to_image('plot.svg')\n</code></pre>"},{"location":"api-reference/plot_result/#flixopt.plot_result.PlotResult.to_csv","title":"to_csv","text":"<pre><code>to_csv(path: str | Path, **kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Export the underlying data to CSV. Returns self for chaining.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>File path for the CSV output.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to to_csv().</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>Self for method chaining.</p>"},{"location":"api-reference/plot_result/#flixopt.plot_result.PlotResult.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, **kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Export the underlying data to netCDF. Returns self for chaining.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>File path for the netCDF output.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to to_netcdf().</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>Self for method chaining.</p>"},{"location":"api-reference/plotting/","title":"Plotting","text":""},{"location":"api-reference/plotting/#flixopt.plotting","title":"flixopt.plotting","text":"<p>Comprehensive visualization toolkit for flixopt optimization results and data analysis.</p> <p>This module provides a unified plotting interface supporting both Plotly (interactive) and Matplotlib (static) backends for visualizing energy system optimization results. It offers specialized plotting functions for time series, heatmaps, network diagrams, and statistical analyses commonly needed in energy system modeling.</p> Key Features <p>Dual Backend Support: Seamless switching between Plotly and Matplotlib Energy System Focus: Specialized plots for power flows, storage states, emissions Color Management: Intelligent color processing and palette management Export Capabilities: High-quality export for reports and publications Integration Ready: Designed for use with CalculationResults and standalone analysis</p> Main Plot Types <ul> <li>Time Series: Flow rates, power profiles, storage states over time</li> <li>Heatmaps: High-resolution temporal data visualization with customizable aggregation</li> <li>Network Diagrams: System topology with flow visualization</li> <li>Statistical Plots: Distribution analysis, correlation studies, performance metrics</li> <li>Comparative Analysis: Multi-scenario and sensitivity study visualizations</li> </ul> <p>The module integrates seamlessly with flixopt's result classes while remaining accessible for standalone data visualization tasks.</p>"},{"location":"api-reference/plotting/#flixopt.plotting-attributes","title":"Attributes","text":""},{"location":"api-reference/plotting/#flixopt.plotting.PlottingEngine","title":"PlottingEngine  <code>module-attribute</code>","text":"<pre><code>PlottingEngine = Literal['plotly', 'matplotlib']\n</code></pre> <p>Identifier for the plotting engine to use.</p>"},{"location":"api-reference/plotting/#flixopt.plotting-classes","title":"Classes","text":""},{"location":"api-reference/plotting/#flixopt.plotting-functions","title":"Functions","text":""},{"location":"api-reference/plotting/#flixopt.plotting.with_plotly","title":"with_plotly","text":"<pre><code>with_plotly(data: Dataset | DataFrame | Series, mode: Literal['stacked_bar', 'line', 'area', 'grouped_bar'] = 'stacked_bar', colors: ColorType | None = None, title: str = '', ylabel: str = '', xlabel: str = '', facet_by: str | list[str] | None = None, animate_by: str | None = None, facet_cols: int | None = None, shared_yaxes: bool = True, shared_xaxes: bool = True, **px_kwargs: Any) -&gt; go.Figure\n</code></pre> <p>Plot data with Plotly using facets (subplots) and/or animation for multidimensional data.</p> <p>Uses Plotly Express for convenient faceting and animation with automatic styling.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dataset | DataFrame | Series</code> <p>An xarray Dataset, pandas DataFrame, or pandas Series to plot.</p> required <code>mode</code> <code>Literal['stacked_bar', 'line', 'area', 'grouped_bar']</code> <p>The plotting mode. Use 'stacked_bar' for stacked bar charts, 'line' for lines,   'area' for stacked area charts, or 'grouped_bar' for grouped bar charts.</p> <code>'stacked_bar'</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale, list, or dict mapping labels to colors).</p> <code>None</code> <code>title</code> <code>str</code> <p>The main title of the plot.</p> <code>''</code> <code>ylabel</code> <code>str</code> <p>The label for the y-axis.</p> <code>''</code> <code>xlabel</code> <code>str</code> <p>The label for the x-axis.</p> <code>''</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) to create facets for. Creates a subplot grid.   Can be a single dimension name or list of dimensions (max 2 for facet_row and facet_col).   If the dimension doesn't exist in the data, it will be silently ignored.</p> <code>None</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over. Creates animation frames.   If the dimension doesn't exist in the data, it will be silently ignored.</p> <code>None</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid (used when facet_by is single dimension).</p> <code>None</code> <code>shared_yaxes</code> <code>bool</code> <p>Whether subplots share y-axes.</p> <code>True</code> <code>shared_xaxes</code> <code>bool</code> <p>Whether subplots share x-axes.</p> <code>True</code> <code>**px_kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to the underlying Plotly Express function         (px.bar, px.line, px.area). These override default arguments if provided.         Examples: range_x=[0, 100], range_y=[0, 50], category_orders={...}, line_shape='linear'</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A Plotly figure object containing the faceted/animated plot. You can further customize</p> <code>Figure</code> <p>the returned figure using Plotly's methods (e.g., fig.update_traces(), fig.update_layout()).</p> <p>Examples:</p> <p>Simple plot:</p> <pre><code>fig = with_plotly(dataset, mode='area', title='Energy Mix')\n</code></pre> <p>Facet by scenario:</p> <pre><code>fig = with_plotly(dataset, facet_by='scenario', facet_cols=2)\n</code></pre> <p>Animate by period:</p> <pre><code>fig = with_plotly(dataset, animate_by='period')\n</code></pre> <p>Facet and animate:</p> <pre><code>fig = with_plotly(dataset, facet_by='scenario', animate_by='period')\n</code></pre> <p>Customize with Plotly Express kwargs:</p> <pre><code>fig = with_plotly(dataset, range_y=[0, 100], line_shape='linear')\n</code></pre> <p>Further customize the returned figure:</p> <pre><code>fig = with_plotly(dataset, mode='line')\nfig.update_traces(line={'width': 5, 'dash': 'dot'})\nfig.update_layout(template='plotly_dark', width=1200, height=600)\n</code></pre>"},{"location":"api-reference/plotting/#flixopt.plotting.with_matplotlib","title":"with_matplotlib","text":"<pre><code>with_matplotlib(data: Dataset | DataFrame | Series, mode: Literal['stacked_bar', 'line'] = 'stacked_bar', colors: ColorType | None = None, title: str = '', ylabel: str = '', xlabel: str = 'Time in h', figsize: tuple[int, int] = (12, 6), plot_kwargs: dict[str, Any] | None = None) -&gt; tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plot data with Matplotlib using stacked bars or stepped lines.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dataset | DataFrame | Series</code> <p>An xarray Dataset, pandas DataFrame, or pandas Series to plot. After conversion to DataFrame,   the index represents time and each column represents a separate data series (variables).</p> required <code>mode</code> <code>Literal['stacked_bar', 'line']</code> <p>Plotting mode. Use 'stacked_bar' for stacked bar charts or 'line' for stepped lines.</p> <code>'stacked_bar'</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification. Can be: - A colorscale name (e.g., 'turbo', 'plasma') - A list of color strings (e.g., ['#ff0000', '#00ff00']) - A dict mapping column names to colors (e.g., {'Column1': '#ff0000'})</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the plot.</p> <code>''</code> <code>ylabel</code> <code>str</code> <p>The ylabel of the plot.</p> <code>''</code> <code>xlabel</code> <code>str</code> <p>The xlabel of the plot.</p> <code>'Time in h'</code> <code>figsize</code> <code>tuple[int, int]</code> <p>Specify the size of the figure (width, height) in inches.</p> <code>(12, 6)</code> <code>plot_kwargs</code> <code>dict[str, Any] | None</code> <p>Optional dict of parameters to pass to ax.bar() or ax.step() plotting calls.         Use this to customize plot properties (e.g., linewidth, alpha, edgecolor).</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Figure, Axes]</code> <p>A tuple containing the Matplotlib figure and axes objects used for the plot.</p> Notes <ul> <li>If <code>mode</code> is 'stacked_bar', bars are stacked for both positive and negative values.   Negative values are stacked separately without extra labels in the legend.</li> <li>If <code>mode</code> is 'line', stepped lines are drawn for each data series.</li> </ul>"},{"location":"api-reference/plotting/#flixopt.plotting.reshape_data_for_heatmap","title":"reshape_data_for_heatmap","text":"<pre><code>reshape_data_for_heatmap(data: DataArray, reshape_time: tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None = 'auto', facet_by: str | list[str] | None = None, animate_by: str | None = None, fill: Literal['ffill', 'bfill'] | None = 'ffill') -&gt; xr.DataArray\n</code></pre> <p>Reshape data for heatmap visualization, handling time dimension intelligently.</p> <p>This function decides whether to reshape the 'time' dimension based on the reshape_time parameter: - 'auto': Automatically reshapes if only 'time' dimension would remain for heatmap - Tuple: Explicitly reshapes time with specified parameters - None: No reshaping (returns data as-is)</p> <p>All non-time dimensions are preserved during reshaping.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataArray</code> <p>DataArray to reshape for heatmap visualization.</p> required <code>reshape_time</code> <code>tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None</code> <p>Reshaping configuration:          - 'auto' (default): Auto-reshape if needed based on facet_by/animate_by          - Tuple (timeframes, timesteps_per_frame): Explicit time reshaping          - None: No reshaping</p> <code>'auto'</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) used for faceting (used in 'auto' decision).</p> <code>None</code> <code>animate_by</code> <code>str | None</code> <p>Dimension used for animation (used in 'auto' decision).</p> <code>None</code> <code>fill</code> <code>Literal['ffill', 'bfill'] | None</code> <p>Method to fill missing values: 'ffill' or 'bfill'. Default is 'ffill'.</p> <code>'ffill'</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>Reshaped DataArray. If time reshaping is applied, 'time' dimension is replaced</p> <code>DataArray</code> <p>by 'timestep' and 'timeframe'. All other dimensions are preserved.</p> <p>Examples:</p> <p>Auto-reshaping:</p> <pre><code># Will auto-reshape because only 'time' remains after faceting/animation\ndata = reshape_data_for_heatmap(data, reshape_time='auto', facet_by='scenario', animate_by='period')\n</code></pre> <p>Explicit reshaping:</p> <pre><code># Explicitly reshape to daily pattern\ndata = reshape_data_for_heatmap(data, reshape_time=('D', 'h'))\n</code></pre> <p>No reshaping:</p> <pre><code># Keep data as-is\ndata = reshape_data_for_heatmap(data, reshape_time=None)\n</code></pre>"},{"location":"api-reference/plotting/#flixopt.plotting.plot_network","title":"plot_network","text":"<pre><code>plot_network(node_infos: dict, edge_infos: dict, path: str | Path | None = None, controls: bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']] = True, show: bool = False) -&gt; pyvis.network.Network | None\n</code></pre> <p>Visualizes the network structure of a FlowSystem using PyVis, using info-dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path | None</code> <p>Path to save the HTML visualization. <code>False</code>: Visualization is created but not saved. <code>str</code> or <code>Path</code>: Specifies file path (default: 'results/network.html').</p> <code>None</code> <code>controls</code> <code>bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]</code> <p>UI controls to add to the visualization. <code>True</code>: Enables all available controls. <code>list</code>: Specify controls, e.g., ['nodes', 'layout']. Options: 'nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer'. You can play with these and generate a Dictionary from it that can be applied to the network returned by this function. network.set_options() https://pyvis.readthedocs.io/en/latest/tutorial.html</p> <code>True</code> <code>show</code> <code>bool</code> <p>Whether to open the visualization in the web browser. The calculation must be saved to show it. If no path is given, it defaults to 'network.html'.</p> <code>False</code> <p>Returns:     The <code>Network</code> instance representing the visualization, or <code>None</code> if <code>pyvis</code> is not installed.</p> <p>Notes: - This function requires <code>pyvis</code>. If not installed, the function prints a warning and returns <code>None</code>. - Nodes are styled based on type (e.g., circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.preprocess_data_for_pie","title":"preprocess_data_for_pie","text":"<pre><code>preprocess_data_for_pie(data: Dataset | DataFrame | Series, lower_percentage_threshold: float = 5.0) -&gt; pd.Series\n</code></pre> <p>Preprocess data for pie chart display.</p> <p>Groups items that are individually below the threshold percentage into an \"Other\" category. Converts various input types to a pandas Series for uniform handling.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dataset | DataFrame | Series</code> <p>Input data (xarray Dataset, DataFrame, or Series)</p> required <code>lower_percentage_threshold</code> <code>float</code> <p>Percentage threshold - items below this are grouped into \"Other\"</p> <code>5.0</code> <p>Returns:</p> Type Description <code>Series</code> <p>Processed pandas Series with small items grouped into \"Other\"</p>"},{"location":"api-reference/plotting/#flixopt.plotting.dual_pie_with_plotly","title":"dual_pie_with_plotly","text":"<pre><code>dual_pie_with_plotly(data_left: Dataset | DataFrame | Series, data_right: Dataset | DataFrame | Series, colors: ColorType | None = None, title: str = '', subtitles: tuple[str, str] = ('Left Chart', 'Right Chart'), legend_title: str = '', hole: float = 0.2, lower_percentage_group: float = 5.0, text_info: str = 'percent+label', text_position: str = 'inside', hover_template: str = '%{label}: %{value} (%{percent})') -&gt; go.Figure\n</code></pre> <p>Create two pie charts side by side with Plotly.</p> <p>Parameters:</p> Name Type Description Default <code>data_left</code> <code>Dataset | DataFrame | Series</code> <p>Data for the left pie chart. Variables are summed across all dimensions.</p> required <code>data_right</code> <code>Dataset | DataFrame | Series</code> <p>Data for the right pie chart. Variables are summed across all dimensions.</p> required <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, list of colors, or dict mapping)</p> <code>None</code> <code>title</code> <code>str</code> <p>The main title of the plot.</p> <code>''</code> <code>subtitles</code> <code>tuple[str, str]</code> <p>Tuple containing the subtitles for (left, right) charts.</p> <code>('Left Chart', 'Right Chart')</code> <code>legend_title</code> <code>str</code> <p>The title for the legend.</p> <code>''</code> <code>hole</code> <code>float</code> <p>Size of the hole in the center for creating donut charts (0.0 to 1.0).</p> <code>0.2</code> <code>lower_percentage_group</code> <code>float</code> <p>Group segments whose cumulative share is below this percentage (0\u2013100) into \"Other\".</p> <code>5.0</code> <code>hover_template</code> <code>str</code> <p>Template for hover text. Use %{label}, %{value}, %{percent}.</p> <code>'%{label}: %{value} (%{percent})'</code> <code>text_info</code> <code>str</code> <p>What to show on pie segments: 'label', 'percent', 'value', 'label+percent',       'label+value', 'percent+value', 'label+percent+value', or 'none'.</p> <code>'percent+label'</code> <code>text_position</code> <code>str</code> <p>Position of text: 'inside', 'outside', 'auto', or 'none'.</p> <code>'inside'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly Figure object</p>"},{"location":"api-reference/plotting/#flixopt.plotting.dual_pie_with_matplotlib","title":"dual_pie_with_matplotlib","text":"<pre><code>dual_pie_with_matplotlib(data_left: Dataset | DataFrame | Series, data_right: Dataset | DataFrame | Series, colors: ColorType | None = None, title: str = '', subtitles: tuple[str, str] = ('Left Chart', 'Right Chart'), legend_title: str = '', hole: float = 0.2, lower_percentage_group: float = 5.0, figsize: tuple[int, int] = (14, 7)) -&gt; tuple[plt.Figure, list[plt.Axes]]\n</code></pre> <p>Create two pie charts side by side with Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>data_left</code> <code>Dataset | DataFrame | Series</code> <p>Data for the left pie chart.</p> required <code>data_right</code> <code>Dataset | DataFrame | Series</code> <p>Data for the right pie chart.</p> required <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, list of colors, or dict mapping)</p> <code>None</code> <code>title</code> <code>str</code> <p>The main title of the plot.</p> <code>''</code> <code>subtitles</code> <code>tuple[str, str]</code> <p>Tuple containing the subtitles for (left, right) charts.</p> <code>('Left Chart', 'Right Chart')</code> <code>legend_title</code> <code>str</code> <p>The title for the legend.</p> <code>''</code> <code>hole</code> <code>float</code> <p>Size of the hole in the center for creating donut charts (0.0 to 1.0).</p> <code>0.2</code> <code>lower_percentage_group</code> <code>float</code> <p>Whether to group small segments (below percentage) into an \"Other\" category.</p> <code>5.0</code> <code>figsize</code> <code>tuple[int, int]</code> <p>The size of the figure (width, height) in inches.</p> <code>(14, 7)</code> <p>Returns:</p> Type Description <code>tuple[Figure, list[Axes]]</code> <p>Tuple of (Figure, list of Axes)</p>"},{"location":"api-reference/plotting/#flixopt.plotting.heatmap_with_plotly_v2","title":"heatmap_with_plotly_v2","text":"<pre><code>heatmap_with_plotly_v2(data: DataArray, colors: ColorType | None = None, title: str = '', facet_col: str | None = None, animation_frame: str | None = None, facet_col_wrap: int | None = None, **imshow_kwargs: Any) -&gt; go.Figure\n</code></pre> <p>Plot a heatmap using Plotly's imshow.</p> <p>Data should be prepared with dims in order: (y_axis, x_axis, [facet_col], [animation_frame]). Use reshape_data_for_heatmap() to prepare time-series data before calling this.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataArray</code> <p>DataArray with 2-4 dimensions. First two are heatmap axes.</p> required <code>colors</code> <code>ColorType | None</code> <p>Colorscale name ('viridis', 'plasma', etc.).</p> <code>None</code> <code>title</code> <code>str</code> <p>Plot title.</p> <code>''</code> <code>facet_col</code> <code>str | None</code> <p>Dimension name for subplot columns (3<sup>rd</sup> dim).</p> <code>None</code> <code>animation_frame</code> <code>str | None</code> <p>Dimension name for animation (4<sup>th</sup> dim).</p> <code>None</code> <code>facet_col_wrap</code> <code>int | None</code> <p>Max columns before wrapping (only if &lt; n_facets).</p> <code>None</code> <code>**imshow_kwargs</code> <code>Any</code> <p>Additional args for px.imshow.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Plotly Figure object.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.heatmap_with_plotly","title":"heatmap_with_plotly","text":"<pre><code>heatmap_with_plotly(data: DataArray, colors: ColorType | None = None, title: str = '', facet_by: str | list[str] | None = None, animate_by: str | None = None, facet_cols: int | None = None, reshape_time: tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None = 'auto', fill: Literal['ffill', 'bfill'] | None = 'ffill', **imshow_kwargs: Any) -&gt; go.Figure\n</code></pre> <p>Plot a heatmap visualization using Plotly's imshow with faceting and animation support.</p> <p>This function creates heatmap visualizations from xarray DataArrays, supporting multi-dimensional data through faceting (subplots) and animation. It automatically handles dimension reduction and data reshaping for optimal heatmap display.</p> Automatic Time Reshaping <p>If only the 'time' dimension remains after faceting/animation (making the data 1D), the function automatically reshapes time into a 2D format using default values (timeframes='D', timesteps_per_frame='h'). This creates a daily pattern heatmap showing hours vs days.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataArray</code> <p>An xarray DataArray containing the data to visualize. Should have at least   2 dimensions, or a 'time' dimension that can be reshaped into 2D.</p> required <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, list, or dict). Common options:     'turbo', 'plasma', 'RdBu', 'portland'.</p> <code>None</code> <code>title</code> <code>str</code> <p>The main title of the heatmap.</p> <code>''</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension to create facets for. Creates a subplot grid.       Can be a single dimension name or list (only first dimension used).       Note: px.imshow only supports single-dimension faceting.       If the dimension doesn't exist in the data, it will be silently ignored.</p> <code>None</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over. Creates animation frames.         If the dimension doesn't exist in the data, it will be silently ignored.</p> <code>None</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid (used with facet_by).</p> <code>None</code> <code>reshape_time</code> <code>tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None</code> <p>Time reshaping configuration:          - 'auto' (default): Automatically applies ('D', 'h') if only 'time' dimension remains          - Tuple like ('D', 'h'): Explicit time reshaping (days vs hours)          - None: Disable time reshaping (will error if only 1D time data)</p> <code>'auto'</code> <code>fill</code> <code>Literal['ffill', 'bfill'] | None</code> <p>Method to fill missing values when reshaping time: 'ffill' or 'bfill'. Default is 'ffill'.</p> <code>'ffill'</code> <code>**imshow_kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to plotly.express.imshow.             Common options include:             - aspect: 'auto', 'equal', or a number for aspect ratio             - zmin, zmax: Minimum and maximum values for color scale             - labels: Dict to customize axis labels</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A Plotly figure object containing the heatmap visualization.</p> <p>Examples:</p> <p>Simple heatmap:</p> <pre><code>fig = heatmap_with_plotly(data_array, colors='RdBu', title='Temperature Map')\n</code></pre> <p>Facet by scenario:</p> <pre><code>fig = heatmap_with_plotly(data_array, facet_by='scenario', facet_cols=2)\n</code></pre> <p>Animate by period:</p> <pre><code>fig = heatmap_with_plotly(data_array, animate_by='period')\n</code></pre> <p>Automatic time reshaping (when only time dimension remains):</p> <pre><code># Data with dims ['time', 'period','scenario']\n# After faceting and animation, only 'time' remains -&gt; auto-reshapes to (timestep, timeframe)\nfig = heatmap_with_plotly(data_array, facet_by='scenario', animate_by='period')\n</code></pre> <p>Explicit time reshaping:</p> <pre><code>fig = heatmap_with_plotly(data_array, facet_by='scenario', animate_by='period', reshape_time=('W', 'D'))\n</code></pre>"},{"location":"api-reference/plotting/#flixopt.plotting.heatmap_with_matplotlib","title":"heatmap_with_matplotlib","text":"<pre><code>heatmap_with_matplotlib(data: DataArray, colors: ColorType | None = None, title: str = '', figsize: tuple[float, float] = (12, 6), reshape_time: tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None = 'auto', fill: Literal['ffill', 'bfill'] | None = 'ffill', vmin: float | None = None, vmax: float | None = None, imshow_kwargs: dict[str, Any] | None = None, cbar_kwargs: dict[str, Any] | None = None, **kwargs: Any) -&gt; tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plot a heatmap visualization using Matplotlib's imshow.</p> <p>This function creates a basic 2D heatmap from an xarray DataArray using matplotlib's imshow function. For multi-dimensional data, only the first two dimensions are used.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataArray</code> <p>An xarray DataArray containing the data to visualize. Should have at least   2 dimensions. If more than 2 dimensions exist, additional dimensions will   be reduced by taking the first slice.</p> required <code>colors</code> <code>ColorType | None</code> <p>Color specification. Should be a colorscale name (e.g., 'turbo', 'RdBu').</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the heatmap.</p> <code>''</code> <code>figsize</code> <code>tuple[float, float]</code> <p>The size of the figure (width, height) in inches.</p> <code>(12, 6)</code> <code>reshape_time</code> <code>tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None</code> <p>Time reshaping configuration:          - 'auto' (default): Automatically applies ('D', 'h') if only 'time' dimension          - Tuple like ('D', 'h'): Explicit time reshaping (days vs hours)          - None: Disable time reshaping</p> <code>'auto'</code> <code>fill</code> <code>Literal['ffill', 'bfill'] | None</code> <p>Method to fill missing values when reshaping time: 'ffill' or 'bfill'. Default is 'ffill'.</p> <code>'ffill'</code> <code>vmin</code> <code>float | None</code> <p>Minimum value for color scale. If None, uses data minimum.</p> <code>None</code> <code>vmax</code> <code>float | None</code> <p>Maximum value for color scale. If None, uses data maximum.</p> <code>None</code> <code>imshow_kwargs</code> <code>dict[str, Any] | None</code> <p>Optional dict of parameters to pass to ax.imshow().           Use this to customize image properties (e.g., interpolation, aspect).</p> <code>None</code> <code>cbar_kwargs</code> <code>dict[str, Any] | None</code> <p>Optional dict of parameters to pass to plt.colorbar().         Use this to customize colorbar properties (e.g., orientation, label).</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to ax.imshow().      Common options include:      - interpolation: 'nearest', 'bilinear', 'bicubic', etc.      - alpha: Transparency level (0-1)      - extent: [left, right, bottom, top] for axis limits</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[Figure, Axes]</code> <p>A tuple containing the Matplotlib figure and axes objects used for the plot.</p> Notes <ul> <li>Matplotlib backend doesn't support faceting or animation. Use plotly engine for those features.</li> <li>The y-axis is automatically inverted to display data with origin at top-left.</li> <li>A colorbar is added to show the value scale.</li> </ul> <p>Examples:</p> <pre><code>fig, ax = heatmap_with_matplotlib(data_array, colors='RdBu', title='Temperature')\nplt.savefig('heatmap.png')\n</code></pre> <p>Time reshaping:</p> <pre><code>fig, ax = heatmap_with_matplotlib(data_array, reshape_time=('D', 'h'))\n</code></pre>"},{"location":"api-reference/plotting/#flixopt.plotting.export_figure","title":"export_figure","text":"<pre><code>export_figure(figure_like: Figure | tuple[Figure, Axes], default_path: Path, default_filetype: str | None = None, user_path: Path | None = None, show: bool | None = None, save: bool = False, dpi: int | None = None) -&gt; go.Figure | tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Export a figure to a file and or show it.</p> <p>Parameters:</p> Name Type Description Default <code>figure_like</code> <code>Figure | tuple[Figure, Axes]</code> <p>The figure to export. Can be a Plotly figure or a tuple of Matplotlib figure and axes.</p> required <code>default_path</code> <code>Path</code> <p>The default file path if no user filename is provided.</p> required <code>default_filetype</code> <code>str | None</code> <p>The default filetype if the path doesnt end with a filetype.</p> <code>None</code> <code>user_path</code> <code>Path | None</code> <p>An optional user-specified file path.</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure. If None, uses CONFIG.Plotting.default_show (default: None).</p> <code>None</code> <code>save</code> <code>bool</code> <p>Whether to save the figure (default: False).</p> <code>False</code> <code>dpi</code> <code>int | None</code> <p>DPI (dots per inch) for saving Matplotlib figures. If None, uses CONFIG.Plotting.default_dpi.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no default filetype is provided and the path doesn't specify a filetype.</p> <code>TypeError</code> <p>If the figure type is not supported.</p>"},{"location":"api-reference/results/","title":"Results","text":""},{"location":"api-reference/results/#flixopt.results","title":"flixopt.results","text":""},{"location":"api-reference/results/#flixopt.results-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results-classes","title":"Classes","text":""},{"location":"api-reference/results/#flixopt.results.Results","title":"Results","text":"<pre><code>Results(solution: Dataset, flow_system_data: Dataset, name: str, summary: dict, folder: Path | None = None, model: Model | None = None)\n</code></pre> <p>               Bases: <code>CompositeContainerMixin['ComponentResults | BusResults | EffectResults | FlowResults']</code></p> <p>Comprehensive container for optimization results and analysis tools.</p> <p>This class provides unified access to all optimization results including flow rates, component states, bus balances, and system effects. It offers powerful analysis capabilities through filtering, plotting, and export functionality, making it the primary interface for post-processing optimization results.</p> Key Features <p>Unified Access: Single interface to all solution variables and constraints Element Results: Direct access to component, bus, and effect-specific results Visualization: Built-in plotting methods for heatmaps, time series, and networks Persistence: Save/load functionality with compression for large datasets Analysis Tools: Filtering, aggregation, and statistical analysis methods</p> Result Organization <ul> <li>Components: Equipment-specific results (flows, states, constraints)</li> <li>Buses: Network node balances and energy flows</li> <li>Effects: System-wide impacts (costs, emissions, resource consumption)</li> <li>Solution: Raw optimization variables and their values</li> <li>Metadata: Optimization parameters, timing, and system configuration</li> </ul> <p>Attributes:</p> Name Type Description <code>solution</code> <p>Dataset containing all optimization variable solutions</p> <code>flow_system_data</code> <p>Dataset with complete system configuration and parameters. Restore the used FlowSystem for further analysis.</p> <code>summary</code> <p>Optimization metadata including solver status, timing, and statistics</p> <code>name</code> <p>Unique identifier for this optimization</p> <code>model</code> <code>Model | None</code> <p>Original linopy optimization model (if available)</p> <code>folder</code> <p>Directory path for result storage and loading</p> <code>components</code> <p>Dictionary mapping component labels to ComponentResults objects</p> <code>buses</code> <p>Dictionary mapping bus labels to BusResults objects</p> <code>effects</code> <p>Dictionary mapping effect names to EffectResults objects</p> <code>timesteps_extra</code> <p>Extended time index including boundary conditions</p> <code>timestep_duration</code> <p>Duration of each timestep in hours for proper energy calculations</p> <p>Examples:</p> <p>Load and analyze saved results:</p> <pre><code># Load results from file\nresults = Results.from_file('results', 'annual_optimization')\n\n# Access specific component results\nboiler_results = results['Boiler_01']\nheat_pump_results = results['HeatPump_02']\n\n# Plot component flow rates\nresults.plot_heatmap('Boiler_01(Natural_Gas)|flow_rate')\nresults['Boiler_01'].plot_node_balance()\n\n# Access raw solution dataarrays\nelectricity_flows = results.solution[['Generator_01(Grid)|flow_rate', 'HeatPump_02(Grid)|flow_rate']]\n\n# Filter and analyze results\npeak_demand_hours = results.filter_solution(variable_dims='time')\ncosts_solution = results.effects['cost'].solution\n</code></pre> <p>Advanced filtering and aggregation:</p> <pre><code># Filter by variable type\nscalar_results = results.filter_solution(variable_dims='scalar')\ntime_series = results.filter_solution(variable_dims='time')\n\n# Custom data analysis leveraging xarray\npeak_power = results.solution['Generator_01(Grid)|flow_rate'].max()\navg_efficiency = (\n    results.solution['HeatPump(Heat)|flow_rate'] / results.solution['HeatPump(Electricity)|flow_rate']\n).mean()\n</code></pre> <p>Configure automatic color management for plots:</p> <pre><code># Dict-based configuration:\nresults.setup_colors({'Solar*': 'Oranges', 'Wind*': 'Blues', 'Battery': 'green'})\n\n# All plots automatically use configured colors (colors=None is the default)\nresults['ElectricityBus'].plot_node_balance()\nresults['Battery'].plot_charge_state()\n\n# Override when needed\nresults['ElectricityBus'].plot_node_balance(colors='turbo')  # Ignores setup\n</code></pre> Design Patterns <p>Factory Methods: Use <code>from_file()</code> and <code>from_optimization()</code> for creation or access directly from <code>Optimization.results</code> Dictionary Access: Use <code>results[element_label]</code> for element-specific results Lazy Loading: Results objects created on-demand for memory efficiency Unified Interface: Consistent API across different result types</p> <p>Initialize Results with optimization data. Usually, this class is instantiated by an Optimization object via <code>Results.from_optimization()</code> or by loading from file using <code>Results.from_file()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>Dataset</code> <p>Optimization solution dataset.</p> required <code>flow_system_data</code> <code>Dataset</code> <p>Flow system configuration dataset.</p> required <code>name</code> <code>str</code> <p>Optimization name.</p> required <code>summary</code> <code>dict</code> <p>Optimization metadata.</p> required <code>folder</code> <code>Path | None</code> <p>Results storage folder.</p> <code>None</code> <code>model</code> <code>Model | None</code> <p>Linopy optimization model.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.Results-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.Results.storages","title":"storages  <code>property</code>","text":"<pre><code>storages: list[ComponentResults]\n</code></pre> <p>Get all storage components in the results.</p>"},{"location":"api-reference/results/#flixopt.results.Results.objective","title":"objective  <code>property</code>","text":"<pre><code>objective: float\n</code></pre> <p>Get optimization objective value.</p>"},{"location":"api-reference/results/#flixopt.results.Results.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>Get optimization variables (requires linopy model).</p>"},{"location":"api-reference/results/#flixopt.results.Results.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>Get optimization constraints (requires linopy model).</p>"},{"location":"api-reference/results/#flixopt.results.Results.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>The restored flow_system that was used to create the optimization. Contains all input parameters.</p>"},{"location":"api-reference/results/#flixopt.results.Results.effects_per_component","title":"effects_per_component  <code>property</code>","text":"<pre><code>effects_per_component: Dataset\n</code></pre> <p>Returns a dataset containing effect results for each mode, aggregated by Component</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>An xarray Dataset with an additional component dimension and effects as variables.</p>"},{"location":"api-reference/results/#flixopt.results.Results-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.Results.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(folder: str | Path, name: str) -&gt; Results\n</code></pre> <p>Load Results from saved files.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path</code> <p>Directory containing saved files.</p> required <code>name</code> <code>str</code> <p>Base name of saved files (without extensions).</p> required <p>Returns:</p> Name Type Description <code>Results</code> <code>Results</code> <p>Loaded instance.</p>"},{"location":"api-reference/results/#flixopt.results.Results.from_optimization","title":"from_optimization  <code>classmethod</code>","text":"<pre><code>from_optimization(optimization: Optimization) -&gt; Results\n</code></pre> <p>Create Results from an Optimization instance.</p> <p>Parameters:</p> Name Type Description Default <code>optimization</code> <code>Optimization</code> <p>The Optimization instance to extract results from.</p> required <p>Returns:</p> Name Type Description <code>Results</code> <code>Results</code> <p>New instance containing the optimization results.</p>"},{"location":"api-reference/results/#flixopt.results.Results.setup_colors","title":"setup_colors","text":"<pre><code>setup_colors(config: dict[str, str | list[str]] | str | Path | None = None, default_colorscale: str | None = None) -&gt; dict[str, str]\n</code></pre> <p>Setup colors for all variables across all elements. Overwrites existing ones.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, str | list[str]] | str | Path | None</code> <p>Configuration for color assignment. Can be: - dict: Maps components to colors/colorscales:     * 'component1': 'red'  # Single component to single color     * 'component1': '#FF0000'  # Single component to hex color     - OR maps colorscales to multiple components:     * 'colorscale_name': ['component1', 'component2']  # Colorscale across components - str: Path to a JSON/YAML config file or a colorscale name to apply to all - Path: Path to a JSON/YAML config file - None: Use default_colorscale for all components</p> <code>None</code> <code>default_colorscale</code> <code>str | None</code> <p>Default colorscale for unconfigured components (default: 'turbo')</p> <code>None</code> <p>Examples:</p> <p>setup_colors({     # Direct component-to-color mappings     'Boiler1': '#FF0000',     'CHP': 'darkred',     # Colorscale for multiple components     'Oranges': ['Solar1', 'Solar2'],     'Blues': ['Wind1', 'Wind2'],     'Greens': ['Battery1', 'Battery2', 'Battery3'], })</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Complete variable-to-color mapping dictionary</p>"},{"location":"api-reference/results/#flixopt.results.Results.filter_solution","title":"filter_solution","text":"<pre><code>filter_solution(variable_dims: Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None = None, element: str | None = None, timesteps: DatetimeIndex | None = None, scenarios: Index | None = None, contains: str | list[str] | None = None, startswith: str | list[str] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter solution by variable dimension and/or element.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None</code> <p>The dimension of which to get variables from. - 'scalar': Get scalar variables (without dimensions) - 'time': Get time-dependent variables (with a time dimension) - 'scenario': Get scenario-dependent variables (with ONLY a scenario dimension) - 'timeonly': Get time-dependent variables (with ONLY a time dimension) - 'scenarioonly': Get scenario-dependent variables (with ONLY a scenario dimension)</p> <code>None</code> <code>element</code> <code>str | None</code> <p>The element to filter for.</p> <code>None</code> <code>timesteps</code> <code>DatetimeIndex | None</code> <p>Optional time indexes to select. Can be: - pd.DatetimeIndex: Multiple timesteps - str/pd.Timestamp: Single timestep Defaults to all available timesteps.</p> <code>None</code> <code>scenarios</code> <code>Index | None</code> <p>Optional scenario indexes to select. Can be: - pd.Index: Multiple scenarios - str/int: Single scenario (int is treated as a label, not an index position) Defaults to all available scenarios.</p> <code>None</code> <code>contains</code> <code>str | list[str] | None</code> <p>Filter variables that contain this string or strings. If a list is provided, variables must contain ALL strings in the list.</p> <code>None</code> <code>startswith</code> <code>str | list[str] | None</code> <p>Filter variables that start with this string or strings. If a list is provided, variables must start with ANY of the strings in the list.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.Results.flow_rates","title":"flow_rates","text":"<pre><code>flow_rates(start: str | list[str] | None = None, end: str | list[str] | None = None, component: str | list[str] | None = None) -&gt; xr.DataArray\n</code></pre> <p>Returns a DataArray containing the flow rates of each Flow.</p> <p>.. deprecated::     Use <code>results.plot.all_flow_rates</code> (Dataset) or     <code>results.flows['FlowLabel'].flow_rate</code> (DataArray) instead.</p> <pre><code>**Note**: The new API differs from this method:\n\n- Returns ``xr.Dataset`` (not ``DataArray``) with flow labels as variable names\n- No ``'flow'`` dimension - each flow is a separate variable\n- No filtering parameters - filter using these alternatives::\n\n    # Select specific flows by label\n    ds = results.plot.all_flow_rates\n    ds[['Boiler(Q_th)', 'CHP(Q_th)']]\n\n    # Filter by substring in label\n    ds[[v for v in ds.data_vars if 'Boiler' in v]]\n\n    # Filter by bus (start/end) - get flows connected to a bus\n    results['Fernw\u00e4rme'].inputs  # list of input flow labels\n    results['Fernw\u00e4rme'].outputs  # list of output flow labels\n    ds[results['Fernw\u00e4rme'].inputs]  # Dataset with only inputs to bus\n\n    # Filter by component - get flows of a component\n    results['Boiler'].inputs  # list of input flow labels\n    results['Boiler'].outputs  # list of output flow labels\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.Results.flow_hours","title":"flow_hours","text":"<pre><code>flow_hours(start: str | list[str] | None = None, end: str | list[str] | None = None, component: str | list[str] | None = None) -&gt; xr.DataArray\n</code></pre> <p>Returns a DataArray containing the flow hours of each Flow.</p> <p>.. deprecated::     Use <code>results.plot.all_flow_hours</code> (Dataset) or     <code>results.flows['FlowLabel'].flow_rate * results.timestep_duration</code> instead.</p> <pre><code>**Note**: The new API differs from this method:\n\n- Returns ``xr.Dataset`` (not ``DataArray``) with flow labels as variable names\n- No ``'flow'`` dimension - each flow is a separate variable\n- No filtering parameters - filter using these alternatives::\n\n    # Select specific flows by label\n    ds = results.plot.all_flow_hours\n    ds[['Boiler(Q_th)', 'CHP(Q_th)']]\n\n    # Filter by substring in label\n    ds[[v for v in ds.data_vars if 'Boiler' in v]]\n\n    # Filter by bus (start/end) - get flows connected to a bus\n    results['Fernw\u00e4rme'].inputs  # list of input flow labels\n    results['Fernw\u00e4rme'].outputs  # list of output flow labels\n    ds[results['Fernw\u00e4rme'].inputs]  # Dataset with only inputs to bus\n\n    # Filter by component - get flows of a component\n    results['Boiler'].inputs  # list of input flow labels\n    results['Boiler'].outputs  # list of output flow labels\n</code></pre> <p>Flow hours represent the total energy/material transferred over time, calculated by multiplying flow rates by the duration of each timestep.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | list[str] | None</code> <p>Optional source node(s) to filter by. Can be a single node name or a list of names.</p> <code>None</code> <code>end</code> <code>str | list[str] | None</code> <p>Optional destination node(s) to filter by. Can be a single node name or a list of names.</p> <code>None</code> <code>component</code> <code>str | list[str] | None</code> <p>Optional component(s) to filter by. Can be a single component name or a list of names.</p> <code>None</code> Further usage <p>Convert the dataarray to a dataframe:</p> <p>results.flow_hours().to_pandas() Sum up the flow hours over time: results.flow_hours().sum('time') Sum up the flow hours of flows with the same start and end: results.flow_hours(end='Fernw\u00e4rme').groupby('start').sum(dim='flow') To recombine filtered dataarrays, use <code>xr.concat</code> with dim 'flow': xr.concat([results.flow_hours(start='Fernw\u00e4rme'), results.flow_hours(end='Fernw\u00e4rme')], dim='flow')</p>"},{"location":"api-reference/results/#flixopt.results.Results.sizes","title":"sizes","text":"<pre><code>sizes(start: str | list[str] | None = None, end: str | list[str] | None = None, component: str | list[str] | None = None) -&gt; xr.DataArray\n</code></pre> <p>Returns a dataset with the sizes of the Flows.</p> <p>.. deprecated::     Use <code>results.plot.all_sizes</code> (Dataset) or     <code>results.flows['FlowLabel'].size</code> (DataArray) instead.</p> <pre><code>**Note**: The new API differs from this method:\n\n- Returns ``xr.Dataset`` (not ``DataArray``) with flow labels as variable names\n- No ``'flow'`` dimension - each flow is a separate variable\n- No filtering parameters - filter using these alternatives::\n\n    # Select specific flows by label\n    ds = results.plot.all_sizes\n    ds[['Boiler(Q_th)', 'CHP(Q_th)']]\n\n    # Filter by substring in label\n    ds[[v for v in ds.data_vars if 'Boiler' in v]]\n\n    # Filter by bus (start/end) - get flows connected to a bus\n    results['Fernw\u00e4rme'].inputs  # list of input flow labels\n    results['Fernw\u00e4rme'].outputs  # list of output flow labels\n    ds[results['Fernw\u00e4rme'].inputs]  # Dataset with only inputs to bus\n\n    # Filter by component - get flows of a component\n    results['Boiler'].inputs  # list of input flow labels\n    results['Boiler'].outputs  # list of output flow labels\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.Results.get_effect_shares","title":"get_effect_shares","text":"<pre><code>get_effect_shares(element: str, effect: str, mode: Literal['temporal', 'periodic'] | None = None, include_flows: bool = False) -&gt; xr.Dataset\n</code></pre> <p>Retrieves individual effect shares for a specific element and effect. Either for temporal, investment, or both modes combined. Only includes the direct shares.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>The element identifier for which to retrieve effect shares.</p> required <code>effect</code> <code>str</code> <p>The effect identifier for which to retrieve shares.</p> required <code>mode</code> <code>Literal['temporal', 'periodic'] | None</code> <p>Optional. The mode to retrieve shares for. Can be 'temporal', 'periodic', or None to retrieve both. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>An xarray Dataset containing the requested effect shares. If mode is None,</p> <code>Dataset</code> <p>returns a merged Dataset containing both temporal and investment shares.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified effect is not available or if mode is invalid.</p>"},{"location":"api-reference/results/#flixopt.results.Results.plot_heatmap","title":"plot_heatmap","text":"<pre><code>plot_heatmap(variable_name: str | list[str], save: bool | Path = False, show: bool | None = None, colors: ColorType | None = None, engine: PlottingEngine = 'plotly', select: dict[FlowSystemDimensions, Any] | None = None, facet_by: str | list[str] | None = 'scenario', animate_by: str | None = 'period', facet_cols: int | None = None, reshape_time: tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None = 'auto', fill: Literal['ffill', 'bfill'] | None = 'ffill', **plot_kwargs: Any) -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plots a heatmap visualization of a variable using imshow or time-based reshaping.</p> <p>Supports multiple visualization features that can be combined: - Multi-variable: Plot multiple variables on a single heatmap (creates 'variable' dimension) - Time reshaping: Converts 'time' dimension into 2D (e.g., hours vs days) - Faceting: Creates subplots for different dimension values - Animation: Animates through dimension values (Plotly only)</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str | list[str]</code> <p>The name of the variable to plot, or a list of variable names. When a list is provided, variables are combined into a single DataArray with a new 'variable' dimension.</p> required <code>save</code> <code>bool | Path</code> <p>Whether to save the plot or not. If a path is provided, the plot will be saved at that location.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to show the plot or not.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color scheme for the heatmap. See <code>flixopt.plotting.ColorType</code> for options.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>The engine to use for plotting. Can be either 'plotly' or 'matplotlib'.</p> <code>'plotly'</code> <code>select</code> <code>dict[FlowSystemDimensions, Any] | None</code> <p>Optional data selection dict. Supports single values, lists, slices, and index arrays. Applied BEFORE faceting/animation/reshaping.</p> <code>None</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) to create facets (subplots) for. Can be a single dimension name (str) or list of dimensions. Each unique value combination creates a subplot. Ignored if not found.</p> <code>'scenario'</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over (Plotly only). Creates animation frames that cycle through dimension values. Only one dimension can be animated. Ignored if not found.</p> <code>'period'</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid layout (default: 3).</p> <code>None</code> <code>reshape_time</code> <code>tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None</code> <p>Time reshaping configuration (default: 'auto'): - 'auto': Automatically applies ('D', 'h') when only 'time' dimension remains - Tuple: Explicit reshaping, e.g. ('D', 'h') for days vs hours,          ('MS', 'D') for months vs days, ('W', 'h') for weeks vs hours - None: Disable auto-reshaping (will error if only 1D time data) Supported timeframes: 'YS', 'MS', 'W', 'D', 'h', '15min', 'min'</p> <code>'auto'</code> <code>fill</code> <code>Literal['ffill', 'bfill'] | None</code> <p>Method to fill missing values after reshape: 'ffill' (forward fill) or 'bfill' (backward fill). Default is 'ffill'.</p> <code>'ffill'</code> <code>**plot_kwargs</code> <code>Any</code> <p>Additional plotting customization options. Common options:</p> <ul> <li>dpi (int): Export resolution for saved plots. Default: 300.</li> </ul> <p>For heatmaps specifically:</p> <ul> <li>vmin (float): Minimum value for color scale (both engines).</li> <li>vmax (float): Maximum value for color scale (both engines).</li> </ul> <p>For Matplotlib heatmaps:</p> <ul> <li>imshow_kwargs (dict): Additional kwargs for matplotlib's imshow (e.g., interpolation, aspect).</li> <li>cbar_kwargs (dict): Additional kwargs for colorbar customization.</li> </ul> <code>{}</code> <p>Examples:</p> <p>Direct imshow mode (default):</p> <pre><code>&gt;&gt;&gt; results.plot_heatmap('Battery|charge_state', select={'scenario': 'base'})\n</code></pre> <p>Facet by scenario:</p> <pre><code>&gt;&gt;&gt; results.plot_heatmap('Boiler(Qth)|flow_rate', facet_by='scenario', facet_cols=2)\n</code></pre> <p>Animate by period:</p> <pre><code>&gt;&gt;&gt; results.plot_heatmap('Boiler(Qth)|flow_rate', select={'scenario': 'base'}, animate_by='period')\n</code></pre> <p>Time reshape mode - daily patterns:</p> <pre><code>&gt;&gt;&gt; results.plot_heatmap('Boiler(Qth)|flow_rate', select={'scenario': 'base'}, reshape_time=('D', 'h'))\n</code></pre> <p>Combined: time reshaping with faceting and animation:</p> <pre><code>&gt;&gt;&gt; results.plot_heatmap(\n...     'Boiler(Qth)|flow_rate', facet_by='scenario', animate_by='period', reshape_time=('D', 'h')\n... )\n</code></pre> <p>Multi-variable heatmap (variables as one axis):</p> <pre><code>&gt;&gt;&gt; results.plot_heatmap(\n...     ['Boiler(Q_th)|flow_rate', 'CHP(Q_th)|flow_rate', 'HeatStorage|charge_state'],\n...     select={'scenario': 'base', 'period': 1},\n...     reshape_time=None,\n... )\n</code></pre> <p>Multi-variable with time reshaping:</p> <pre><code>&gt;&gt;&gt; results.plot_heatmap(\n...     ['Boiler(Q_th)|flow_rate', 'CHP(Q_th)|flow_rate'],\n...     facet_by='scenario',\n...     animate_by='period',\n...     reshape_time=('D', 'h'),\n... )\n</code></pre> <p>High-resolution export with custom color range:</p> <pre><code>&gt;&gt;&gt; results.plot_heatmap('Battery|charge_state', save=True, dpi=600, vmin=0, vmax=100)\n</code></pre> <p>Matplotlib heatmap with custom imshow settings:</p> <pre><code>&gt;&gt;&gt; results.plot_heatmap(\n...     'Boiler(Q_th)|flow_rate',\n...     engine='matplotlib',\n...     imshow_kwargs={'interpolation': 'bilinear', 'aspect': 'auto'},\n... )\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.Results.plot_network","title":"plot_network","text":"<pre><code>plot_network(controls: bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']] = True, path: Path | None = None, show: bool | None = None) -&gt; pyvis.network.Network | None\n</code></pre> <p>Plot interactive network visualization of the system.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]</code> <p>Enable/disable interactive controls.</p> <code>True</code> <code>path</code> <code>Path | None</code> <p>Save path for network HTML.</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the plot. If None, uses CONFIG.Plotting.default_show.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.Results.to_flow_system","title":"to_flow_system","text":"<pre><code>to_flow_system() -&gt; FlowSystem\n</code></pre> <p>Convert Results to a FlowSystem with solution attached.</p> <p>This method migrates results from the deprecated Results format to the new FlowSystem-based format, enabling use of the modern API.</p> Note <p>For loading old results files directly, consider using <code>FlowSystem.from_old_results(folder, name)</code> instead.</p> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>A FlowSystem instance with the solution data attached.</p> Caveats <ul> <li>The linopy model is NOT attached (only the solution data)</li> <li>Element submodels are NOT recreated (no re-optimization without   calling build_model() first)</li> <li>Variable/constraint names on elements are NOT restored</li> </ul> <p>Examples:</p> <p>Convert loaded Results to FlowSystem:</p> <pre><code># Load old results\nresults = Results.from_file('results', 'my_optimization')\n\n# Convert to FlowSystem\nflow_system = results.to_flow_system()\n\n# Use new API\nflow_system.plot.heatmap()\nflow_system.solution.to_netcdf('solution.nc')\n\n# Save in new single-file format\nflow_system.to_netcdf('my_optimization.nc')\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.Results.to_file","title":"to_file","text":"<pre><code>to_file(folder: str | Path | None = None, name: str | None = None, compression: int = 5, document_model: bool = True, save_linopy_model: bool = False, overwrite: bool = False)\n</code></pre> <p>Save results to files.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path | None</code> <p>Save folder (defaults to optimization folder).</p> <code>None</code> <code>name</code> <code>str | None</code> <p>File name (defaults to optimization name).</p> <code>None</code> <code>compression</code> <code>int</code> <p>Compression level 0-9.</p> <code>5</code> <code>document_model</code> <code>bool</code> <p>Whether to document model formulations as yaml.</p> <code>True</code> <code>save_linopy_model</code> <code>bool</code> <p>Whether to save linopy model file.</p> <code>False</code> <code>overwrite</code> <code>bool</code> <p>If False, raise error if results files already exist. If True, overwrite existing files.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and result files already exist.</p>"},{"location":"api-reference/results/#flixopt.results.Results.keys","title":"keys","text":"<pre><code>keys() -&gt; list[str]\n</code></pre> <p>Return all element labels across all containers.</p>"},{"location":"api-reference/results/#flixopt.results.Results.values","title":"values","text":"<pre><code>values() -&gt; list[T_element]\n</code></pre> <p>Return all element objects across all containers.</p>"},{"location":"api-reference/results/#flixopt.results.Results.items","title":"items","text":"<pre><code>items() -&gt; list[tuple[str, T_element]]\n</code></pre> <p>Return (label, element) pairs for all elements.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults","title":"BusResults","text":"<pre><code>BusResults(results: Results, label: str, variables: list[str], constraints: list[str], inputs: list[str], outputs: list[str], flows: list[str])\n</code></pre> <p>               Bases: <code>_NodeResults</code></p> <p>Results container for energy/material balance nodes in the system.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.BusResults.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>Get element variables (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>Get element constraints (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.BusResults.filter_solution","title":"filter_solution","text":"<pre><code>filter_solution(variable_dims: Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None = None, timesteps: DatetimeIndex | None = None, scenarios: Index | None = None, contains: str | list[str] | None = None, startswith: str | list[str] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter the solution to a specific variable dimension and element. If no element is specified, all elements are included.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None</code> <p>The dimension of which to get variables from. - 'scalar': Get scalar variables (without dimensions) - 'time': Get time-dependent variables (with a time dimension) - 'scenario': Get scenario-dependent variables (with ONLY a scenario dimension) - 'timeonly': Get time-dependent variables (with ONLY a time dimension) - 'scenarioonly': Get scenario-dependent variables (with ONLY a scenario dimension)</p> <code>None</code> <code>timesteps</code> <code>DatetimeIndex | None</code> <p>Optional time indexes to select. Can be: - pd.DatetimeIndex: Multiple timesteps - str/pd.Timestamp: Single timestep Defaults to all available timesteps.</p> <code>None</code> <code>scenarios</code> <code>Index | None</code> <p>Optional scenario indexes to select. Can be: - pd.Index: Multiple scenarios - str/int: Single scenario (int is treated as a label, not an index position) Defaults to all available scenarios.</p> <code>None</code> <code>contains</code> <code>str | list[str] | None</code> <p>Filter variables that contain this string or strings. If a list is provided, variables must contain ALL strings in the list.</p> <code>None</code> <code>startswith</code> <code>str | list[str] | None</code> <p>Filter variables that start with this string or strings. If a list is provided, variables must start with ANY of the strings in the list.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.BusResults.plot_node_balance","title":"plot_node_balance","text":"<pre><code>plot_node_balance(save: bool | Path = False, show: bool | None = None, colors: ColorType | None = None, engine: PlottingEngine = 'plotly', select: dict[FlowSystemDimensions, Any] | None = None, unit_type: Literal['flow_rate', 'flow_hours'] = 'flow_rate', mode: Literal['area', 'stacked_bar', 'line'] = 'stacked_bar', drop_suffix: bool = True, facet_by: str | list[str] | None = 'scenario', animate_by: str | None = 'period', facet_cols: int | None = None, **plot_kwargs: Any) -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plots the node balance of the Component or Bus with optional faceting and animation.</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool | Path</code> <p>Whether to save the plot or not. If a path is provided, the plot will be saved at that location.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to show the plot or not.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>The colors to use for the plot. See <code>flixopt.plotting.ColorType</code> for options.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>The engine to use for plotting. Can be either 'plotly' or 'matplotlib'.</p> <code>'plotly'</code> <code>select</code> <code>dict[FlowSystemDimensions, Any] | None</code> <p>Optional data selection dict. Supports: - Single values: {'scenario': 'base', 'period': 2024} - Multiple values: {'scenario': ['base', 'high', 'renewable']} - Slices: {'time': slice('2024-01', '2024-06')} - Index arrays: {'time': time_array} Note: Applied BEFORE faceting/animation.</p> <code>None</code> <code>unit_type</code> <code>Literal['flow_rate', 'flow_hours']</code> <p>The unit type to use for the dataset. Can be 'flow_rate' or 'flow_hours'. - 'flow_rate': Returns the flow_rates of the Node. - 'flow_hours': Returns the flow_hours of the Node. [flow_hours(t) = flow_rate(t) * dt(t)]. Renames suffixes to |flow_hours.</p> <code>'flow_rate'</code> <code>mode</code> <code>Literal['area', 'stacked_bar', 'line']</code> <p>The plotting mode. Use 'stacked_bar' for stacked bar charts, 'line' for stepped lines, or 'area' for stacked area charts.</p> <code>'stacked_bar'</code> <code>drop_suffix</code> <code>bool</code> <p>Whether to drop the suffix from the variable names.</p> <code>True</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) to create facets (subplots) for. Can be a single dimension name (str) or list of dimensions. Each unique value combination creates a subplot. Ignored if not found. Example: 'scenario' creates one subplot per scenario. Example: ['period', 'scenario'] creates a grid of subplots for each scenario-period combination.</p> <code>'scenario'</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over (Plotly only). Creates animation frames that cycle through dimension values. Only one dimension can be animated. Ignored if not found.</p> <code>'period'</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid layout (default: 3).</p> <code>None</code> <code>**plot_kwargs</code> <code>Any</code> <p>Additional plotting customization options passed to underlying plotting functions.</p> <p>Common options:</p> <ul> <li>dpi (int): Export resolution in dots per inch. Default: 300.</li> </ul> <p>For Plotly engine (<code>engine='plotly'</code>):</p> <ul> <li>Any Plotly Express parameter for px.bar()/px.line()/px.area()   Example: <code>range_y=[0, 100]</code>, <code>line_shape='linear'</code></li> </ul> <p>For Matplotlib engine (<code>engine='matplotlib'</code>):</p> <ul> <li>plot_kwargs (dict): Customize plot via <code>ax.bar()</code> or <code>ax.step()</code>.   Example: <code>plot_kwargs={'linewidth': 3, 'alpha': 0.7, 'edgecolor': 'black'}</code></li> </ul> <p>See :func:<code>flixopt.plotting.with_plotly</code> and :func:<code>flixopt.plotting.with_matplotlib</code> for complete parameter reference.</p> <p>Note: For Plotly, you can further customize the returned figure using <code>fig.update_traces()</code> and <code>fig.update_layout()</code> after calling this method.</p> <code>{}</code> <p>Examples:</p> <p>Basic plot (current behavior):</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance()\n</code></pre> <p>Facet by scenario:</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(facet_by='scenario', facet_cols=2)\n</code></pre> <p>Animate by period:</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(animate_by='period')\n</code></pre> <p>Facet by scenario AND animate by period:</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(facet_by='scenario', animate_by='period')\n</code></pre> <p>Select single scenario, then facet by period:</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(select={'scenario': 'base'}, facet_by='period')\n</code></pre> <p>Select multiple scenarios and facet by them:</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(\n...     select={'scenario': ['base', 'high', 'renewable']}, facet_by='scenario'\n... )\n</code></pre> <p>Time range selection (summer months only):</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(select={'time': slice('2024-06', '2024-08')}, facet_by='scenario')\n</code></pre> <p>High-resolution export for publication:</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(engine='matplotlib', save='figure.png', dpi=600)\n</code></pre> <p>Plotly Express customization (e.g., set y-axis range):</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(range_y=[0, 100])\n</code></pre> <p>Custom matplotlib appearance:</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(engine='matplotlib', plot_kwargs={'linewidth': 3, 'alpha': 0.7})\n</code></pre> <p>Further customize Plotly figure after creation:</p> <pre><code>&gt;&gt;&gt; fig = results['Boiler'].plot_node_balance(mode='line', show=False)\n&gt;&gt;&gt; fig.update_traces(line={'width': 5, 'dash': 'dot'})\n&gt;&gt;&gt; fig.update_layout(template='plotly_dark', width=1200, height=600)\n&gt;&gt;&gt; fig.show()\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.BusResults.plot_node_balance_pie","title":"plot_node_balance_pie","text":"<pre><code>plot_node_balance_pie(lower_percentage_group: float = 5, colors: ColorType | None = None, text_info: str = 'percent+label+value', save: bool | Path = False, show: bool | None = None, engine: PlottingEngine = 'plotly', select: dict[FlowSystemDimensions, Any] | None = None, **plot_kwargs: Any) -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, list[plt.Axes]]\n</code></pre> <p>Plot pie chart of flow hours distribution.</p> Note <p>Pie charts require scalar data (no extra dimensions beyond time). If your data has dimensions like 'scenario' or 'period', either:</p> <ul> <li>Use <code>select</code> to choose specific values: <code>select={'scenario': 'base', 'period': 2024}</code></li> <li>Let auto-selection choose the first value (a warning will be logged)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>lower_percentage_group</code> <code>float</code> <p>Percentage threshold for \"Others\" grouping.</p> <code>5</code> <code>colors</code> <code>ColorType | None</code> <p>Color scheme. Also see plotly.</p> <code>None</code> <code>text_info</code> <code>str</code> <p>Information to display on pie slices.</p> <code>'percent+label+value'</code> <code>save</code> <code>bool | Path</code> <p>Whether to save plot.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to display plot.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine ('plotly' or 'matplotlib').</p> <code>'plotly'</code> <code>select</code> <code>dict[FlowSystemDimensions, Any] | None</code> <p>Optional data selection dict. Supports single values, lists, slices, and index arrays. Use this to select specific scenario/period before creating the pie chart.</p> <code>None</code> <code>**plot_kwargs</code> <code>Any</code> <p>Additional plotting customization options.</p> <p>Common options:</p> <ul> <li>dpi (int): Export resolution in dots per inch. Default: 300.</li> <li>hover_template (str): Hover text template (Plotly only).   Example: <code>hover_template='%{label}: %{value} (%{percent})'</code></li> <li>text_position (str): Text position ('inside', 'outside', 'auto').</li> <li>hole (float): Size of donut hole (0.0 to 1.0).</li> </ul> <p>See :func:<code>flixopt.plotting.dual_pie_with_plotly</code> for complete reference.</p> <code>{}</code> <p>Examples:</p> <p>Basic usage (auto-selects first scenario/period if present):</p> <pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie()\n</code></pre> <p>Explicitly select a scenario and period:</p> <pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie(select={'scenario': 'high_demand', 'period': 2030})\n</code></pre> <p>Create a donut chart with custom hover text:</p> <pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie(hole=0.4, hover_template='%{label}: %{value:.2f} (%{percent})')\n</code></pre> <p>High-resolution export:</p> <pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie(save='figure.png', dpi=600)\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.BusResults.node_balance","title":"node_balance","text":"<pre><code>node_balance(negate_inputs: bool = True, negate_outputs: bool = False, threshold: float | None = 1e-05, with_last_timestep: bool = False, unit_type: Literal['flow_rate', 'flow_hours'] = 'flow_rate', drop_suffix: bool = False, select: dict[FlowSystemDimensions, Any] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Returns a dataset with the node balance of the Component or Bus. Args:     negate_inputs: Whether to negate the input flow_rates of the Node.     negate_outputs: Whether to negate the output flow_rates of the Node.     threshold: The threshold for small values. Variables with all values below the threshold are dropped.     with_last_timestep: Whether to include the last timestep in the dataset.     unit_type: The unit type to use for the dataset. Can be 'flow_rate' or 'flow_hours'.         - 'flow_rate': Returns the flow_rates of the Node.         - 'flow_hours': Returns the flow_hours of the Node. [flow_hours(t) = flow_rate(t) * dt(t)]. Renames suffixes to |flow_hours.     drop_suffix: Whether to drop the suffix from the variable names.     select: Optional data selection dict. Supports single values, lists, slices, and index arrays.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults","title":"ComponentResults","text":"<pre><code>ComponentResults(results: Results, label: str, variables: list[str], constraints: list[str], inputs: list[str], outputs: list[str], flows: list[str])\n</code></pre> <p>               Bases: <code>_NodeResults</code></p> <p>Results container for individual system components with specialized analysis tools.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.ComponentResults.charge_state","title":"charge_state  <code>property</code>","text":"<pre><code>charge_state: DataArray\n</code></pre> <p>Get storage charge state solution.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>Get element variables (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>Get element constraints (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.ComponentResults.plot_charge_state","title":"plot_charge_state","text":"<pre><code>plot_charge_state(save: bool | Path = False, show: bool | None = None, colors: ColorType | None = None, engine: PlottingEngine = 'plotly', mode: Literal['area', 'stacked_bar', 'line'] = 'area', select: dict[FlowSystemDimensions, Any] | None = None, facet_by: str | list[str] | None = 'scenario', animate_by: str | None = 'period', facet_cols: int | None = None, **plot_kwargs: Any) -&gt; plotly.graph_objs.Figure\n</code></pre> <p>Plot storage charge state over time, combined with the node balance with optional faceting and animation.</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool | Path</code> <p>Whether to save the plot or not. If a path is provided, the plot will be saved at that location.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to show the plot or not.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color scheme. Also see plotly.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine to use. Only 'plotly' is implemented atm.</p> <code>'plotly'</code> <code>mode</code> <code>Literal['area', 'stacked_bar', 'line']</code> <p>The plotting mode. Use 'stacked_bar' for stacked bar charts, 'line' for stepped lines, or 'area' for stacked area charts.</p> <code>'area'</code> <code>select</code> <code>dict[FlowSystemDimensions, Any] | None</code> <p>Optional data selection dict. Supports single values, lists, slices, and index arrays. Applied BEFORE faceting/animation.</p> <code>None</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) to create facets (subplots) for. Can be a single dimension name (str) or list of dimensions. Each unique value combination creates a subplot. Ignored if not found.</p> <code>'scenario'</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over (Plotly only). Creates animation frames that cycle through dimension values. Only one dimension can be animated. Ignored if not found.</p> <code>'period'</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid layout (default: 3).</p> <code>None</code> <code>**plot_kwargs</code> <code>Any</code> <p>Additional plotting customization options passed to underlying plotting functions.</p> <p>Common options:</p> <ul> <li>dpi (int): Export resolution in dots per inch. Default: 300.</li> </ul> <p>For Plotly engine:</p> <ul> <li>Any Plotly Express parameter for px.bar()/px.line()/px.area()   Example: <code>range_y=[0, 100]</code>, <code>line_shape='linear'</code></li> </ul> <p>For Matplotlib engine:</p> <ul> <li>plot_kwargs (dict): Customize plot via <code>ax.bar()</code> or <code>ax.step()</code>.</li> </ul> <p>See :func:<code>flixopt.plotting.with_plotly</code> and :func:<code>flixopt.plotting.with_matplotlib</code> for complete parameter reference.</p> <p>Note: For Plotly, you can further customize the returned figure using <code>fig.update_traces()</code> and <code>fig.update_layout()</code> after calling this method.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If component is not a storage.</p> <p>Examples:</p> <p>Basic plot:</p> <pre><code>&gt;&gt;&gt; results['Storage'].plot_charge_state()\n</code></pre> <p>Facet by scenario:</p> <pre><code>&gt;&gt;&gt; results['Storage'].plot_charge_state(facet_by='scenario', facet_cols=2)\n</code></pre> <p>Animate by period:</p> <pre><code>&gt;&gt;&gt; results['Storage'].plot_charge_state(animate_by='period')\n</code></pre> <p>Facet by scenario AND animate by period:</p> <pre><code>&gt;&gt;&gt; results['Storage'].plot_charge_state(facet_by='scenario', animate_by='period')\n</code></pre> <p>Custom layout after creation:</p> <pre><code>&gt;&gt;&gt; fig = results['Storage'].plot_charge_state(show=False)\n&gt;&gt;&gt; fig.update_layout(template='plotly_dark', height=800)\n&gt;&gt;&gt; fig.show()\n</code></pre> <p>High-resolution export:</p> <pre><code>&gt;&gt;&gt; results['Storage'].plot_charge_state(save='storage.png', dpi=600)\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.node_balance_with_charge_state","title":"node_balance_with_charge_state","text":"<pre><code>node_balance_with_charge_state(negate_inputs: bool = True, negate_outputs: bool = False, threshold: float | None = 1e-05) -&gt; xr.Dataset\n</code></pre> <p>Get storage node balance including charge state.</p> <p>Parameters:</p> Name Type Description Default <code>negate_inputs</code> <code>bool</code> <p>Whether to negate input flows.</p> <code>True</code> <code>negate_outputs</code> <code>bool</code> <p>Whether to negate output flows.</p> <code>False</code> <code>threshold</code> <code>float | None</code> <p>Threshold for small values.</p> <code>1e-05</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Node balance with charge state.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If component is not a storage.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.filter_solution","title":"filter_solution","text":"<pre><code>filter_solution(variable_dims: Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None = None, timesteps: DatetimeIndex | None = None, scenarios: Index | None = None, contains: str | list[str] | None = None, startswith: str | list[str] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter the solution to a specific variable dimension and element. If no element is specified, all elements are included.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None</code> <p>The dimension of which to get variables from. - 'scalar': Get scalar variables (without dimensions) - 'time': Get time-dependent variables (with a time dimension) - 'scenario': Get scenario-dependent variables (with ONLY a scenario dimension) - 'timeonly': Get time-dependent variables (with ONLY a time dimension) - 'scenarioonly': Get scenario-dependent variables (with ONLY a scenario dimension)</p> <code>None</code> <code>timesteps</code> <code>DatetimeIndex | None</code> <p>Optional time indexes to select. Can be: - pd.DatetimeIndex: Multiple timesteps - str/pd.Timestamp: Single timestep Defaults to all available timesteps.</p> <code>None</code> <code>scenarios</code> <code>Index | None</code> <p>Optional scenario indexes to select. Can be: - pd.Index: Multiple scenarios - str/int: Single scenario (int is treated as a label, not an index position) Defaults to all available scenarios.</p> <code>None</code> <code>contains</code> <code>str | list[str] | None</code> <p>Filter variables that contain this string or strings. If a list is provided, variables must contain ALL strings in the list.</p> <code>None</code> <code>startswith</code> <code>str | list[str] | None</code> <p>Filter variables that start with this string or strings. If a list is provided, variables must start with ANY of the strings in the list.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.plot_node_balance","title":"plot_node_balance","text":"<pre><code>plot_node_balance(save: bool | Path = False, show: bool | None = None, colors: ColorType | None = None, engine: PlottingEngine = 'plotly', select: dict[FlowSystemDimensions, Any] | None = None, unit_type: Literal['flow_rate', 'flow_hours'] = 'flow_rate', mode: Literal['area', 'stacked_bar', 'line'] = 'stacked_bar', drop_suffix: bool = True, facet_by: str | list[str] | None = 'scenario', animate_by: str | None = 'period', facet_cols: int | None = None, **plot_kwargs: Any) -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plots the node balance of the Component or Bus with optional faceting and animation.</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool | Path</code> <p>Whether to save the plot or not. If a path is provided, the plot will be saved at that location.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to show the plot or not.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>The colors to use for the plot. See <code>flixopt.plotting.ColorType</code> for options.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>The engine to use for plotting. Can be either 'plotly' or 'matplotlib'.</p> <code>'plotly'</code> <code>select</code> <code>dict[FlowSystemDimensions, Any] | None</code> <p>Optional data selection dict. Supports: - Single values: {'scenario': 'base', 'period': 2024} - Multiple values: {'scenario': ['base', 'high', 'renewable']} - Slices: {'time': slice('2024-01', '2024-06')} - Index arrays: {'time': time_array} Note: Applied BEFORE faceting/animation.</p> <code>None</code> <code>unit_type</code> <code>Literal['flow_rate', 'flow_hours']</code> <p>The unit type to use for the dataset. Can be 'flow_rate' or 'flow_hours'. - 'flow_rate': Returns the flow_rates of the Node. - 'flow_hours': Returns the flow_hours of the Node. [flow_hours(t) = flow_rate(t) * dt(t)]. Renames suffixes to |flow_hours.</p> <code>'flow_rate'</code> <code>mode</code> <code>Literal['area', 'stacked_bar', 'line']</code> <p>The plotting mode. Use 'stacked_bar' for stacked bar charts, 'line' for stepped lines, or 'area' for stacked area charts.</p> <code>'stacked_bar'</code> <code>drop_suffix</code> <code>bool</code> <p>Whether to drop the suffix from the variable names.</p> <code>True</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) to create facets (subplots) for. Can be a single dimension name (str) or list of dimensions. Each unique value combination creates a subplot. Ignored if not found. Example: 'scenario' creates one subplot per scenario. Example: ['period', 'scenario'] creates a grid of subplots for each scenario-period combination.</p> <code>'scenario'</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over (Plotly only). Creates animation frames that cycle through dimension values. Only one dimension can be animated. Ignored if not found.</p> <code>'period'</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid layout (default: 3).</p> <code>None</code> <code>**plot_kwargs</code> <code>Any</code> <p>Additional plotting customization options passed to underlying plotting functions.</p> <p>Common options:</p> <ul> <li>dpi (int): Export resolution in dots per inch. Default: 300.</li> </ul> <p>For Plotly engine (<code>engine='plotly'</code>):</p> <ul> <li>Any Plotly Express parameter for px.bar()/px.line()/px.area()   Example: <code>range_y=[0, 100]</code>, <code>line_shape='linear'</code></li> </ul> <p>For Matplotlib engine (<code>engine='matplotlib'</code>):</p> <ul> <li>plot_kwargs (dict): Customize plot via <code>ax.bar()</code> or <code>ax.step()</code>.   Example: <code>plot_kwargs={'linewidth': 3, 'alpha': 0.7, 'edgecolor': 'black'}</code></li> </ul> <p>See :func:<code>flixopt.plotting.with_plotly</code> and :func:<code>flixopt.plotting.with_matplotlib</code> for complete parameter reference.</p> <p>Note: For Plotly, you can further customize the returned figure using <code>fig.update_traces()</code> and <code>fig.update_layout()</code> after calling this method.</p> <code>{}</code> <p>Examples:</p> <p>Basic plot (current behavior):</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance()\n</code></pre> <p>Facet by scenario:</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(facet_by='scenario', facet_cols=2)\n</code></pre> <p>Animate by period:</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(animate_by='period')\n</code></pre> <p>Facet by scenario AND animate by period:</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(facet_by='scenario', animate_by='period')\n</code></pre> <p>Select single scenario, then facet by period:</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(select={'scenario': 'base'}, facet_by='period')\n</code></pre> <p>Select multiple scenarios and facet by them:</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(\n...     select={'scenario': ['base', 'high', 'renewable']}, facet_by='scenario'\n... )\n</code></pre> <p>Time range selection (summer months only):</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(select={'time': slice('2024-06', '2024-08')}, facet_by='scenario')\n</code></pre> <p>High-resolution export for publication:</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(engine='matplotlib', save='figure.png', dpi=600)\n</code></pre> <p>Plotly Express customization (e.g., set y-axis range):</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(range_y=[0, 100])\n</code></pre> <p>Custom matplotlib appearance:</p> <pre><code>&gt;&gt;&gt; results['Boiler'].plot_node_balance(engine='matplotlib', plot_kwargs={'linewidth': 3, 'alpha': 0.7})\n</code></pre> <p>Further customize Plotly figure after creation:</p> <pre><code>&gt;&gt;&gt; fig = results['Boiler'].plot_node_balance(mode='line', show=False)\n&gt;&gt;&gt; fig.update_traces(line={'width': 5, 'dash': 'dot'})\n&gt;&gt;&gt; fig.update_layout(template='plotly_dark', width=1200, height=600)\n&gt;&gt;&gt; fig.show()\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.plot_node_balance_pie","title":"plot_node_balance_pie","text":"<pre><code>plot_node_balance_pie(lower_percentage_group: float = 5, colors: ColorType | None = None, text_info: str = 'percent+label+value', save: bool | Path = False, show: bool | None = None, engine: PlottingEngine = 'plotly', select: dict[FlowSystemDimensions, Any] | None = None, **plot_kwargs: Any) -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, list[plt.Axes]]\n</code></pre> <p>Plot pie chart of flow hours distribution.</p> Note <p>Pie charts require scalar data (no extra dimensions beyond time). If your data has dimensions like 'scenario' or 'period', either:</p> <ul> <li>Use <code>select</code> to choose specific values: <code>select={'scenario': 'base', 'period': 2024}</code></li> <li>Let auto-selection choose the first value (a warning will be logged)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>lower_percentage_group</code> <code>float</code> <p>Percentage threshold for \"Others\" grouping.</p> <code>5</code> <code>colors</code> <code>ColorType | None</code> <p>Color scheme. Also see plotly.</p> <code>None</code> <code>text_info</code> <code>str</code> <p>Information to display on pie slices.</p> <code>'percent+label+value'</code> <code>save</code> <code>bool | Path</code> <p>Whether to save plot.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to display plot.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine ('plotly' or 'matplotlib').</p> <code>'plotly'</code> <code>select</code> <code>dict[FlowSystemDimensions, Any] | None</code> <p>Optional data selection dict. Supports single values, lists, slices, and index arrays. Use this to select specific scenario/period before creating the pie chart.</p> <code>None</code> <code>**plot_kwargs</code> <code>Any</code> <p>Additional plotting customization options.</p> <p>Common options:</p> <ul> <li>dpi (int): Export resolution in dots per inch. Default: 300.</li> <li>hover_template (str): Hover text template (Plotly only).   Example: <code>hover_template='%{label}: %{value} (%{percent})'</code></li> <li>text_position (str): Text position ('inside', 'outside', 'auto').</li> <li>hole (float): Size of donut hole (0.0 to 1.0).</li> </ul> <p>See :func:<code>flixopt.plotting.dual_pie_with_plotly</code> for complete reference.</p> <code>{}</code> <p>Examples:</p> <p>Basic usage (auto-selects first scenario/period if present):</p> <pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie()\n</code></pre> <p>Explicitly select a scenario and period:</p> <pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie(select={'scenario': 'high_demand', 'period': 2030})\n</code></pre> <p>Create a donut chart with custom hover text:</p> <pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie(hole=0.4, hover_template='%{label}: %{value:.2f} (%{percent})')\n</code></pre> <p>High-resolution export:</p> <pre><code>&gt;&gt;&gt; results['Bus'].plot_node_balance_pie(save='figure.png', dpi=600)\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.node_balance","title":"node_balance","text":"<pre><code>node_balance(negate_inputs: bool = True, negate_outputs: bool = False, threshold: float | None = 1e-05, with_last_timestep: bool = False, unit_type: Literal['flow_rate', 'flow_hours'] = 'flow_rate', drop_suffix: bool = False, select: dict[FlowSystemDimensions, Any] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Returns a dataset with the node balance of the Component or Bus. Args:     negate_inputs: Whether to negate the input flow_rates of the Node.     negate_outputs: Whether to negate the output flow_rates of the Node.     threshold: The threshold for small values. Variables with all values below the threshold are dropped.     with_last_timestep: Whether to include the last timestep in the dataset.     unit_type: The unit type to use for the dataset. Can be 'flow_rate' or 'flow_hours'.         - 'flow_rate': Returns the flow_rates of the Node.         - 'flow_hours': Returns the flow_hours of the Node. [flow_hours(t) = flow_rate(t) * dt(t)]. Renames suffixes to |flow_hours.     drop_suffix: Whether to drop the suffix from the variable names.     select: Optional data selection dict. Supports single values, lists, slices, and index arrays.</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults","title":"EffectResults","text":"<pre><code>EffectResults(results: Results, label: str, variables: list[str], constraints: list[str])\n</code></pre> <p>               Bases: <code>_ElementResults</code></p> <p>Results for an Effect</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.EffectResults.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>Get element variables (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>Get element constraints (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.EffectResults.get_shares_from","title":"get_shares_from","text":"<pre><code>get_shares_from(element: str) -&gt; xr.Dataset\n</code></pre> <p>Get effect shares from specific element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>Element label to get shares from.</p> required <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Element shares to this effect.</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults.filter_solution","title":"filter_solution","text":"<pre><code>filter_solution(variable_dims: Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None = None, timesteps: DatetimeIndex | None = None, scenarios: Index | None = None, contains: str | list[str] | None = None, startswith: str | list[str] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter the solution to a specific variable dimension and element. If no element is specified, all elements are included.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None</code> <p>The dimension of which to get variables from. - 'scalar': Get scalar variables (without dimensions) - 'time': Get time-dependent variables (with a time dimension) - 'scenario': Get scenario-dependent variables (with ONLY a scenario dimension) - 'timeonly': Get time-dependent variables (with ONLY a time dimension) - 'scenarioonly': Get scenario-dependent variables (with ONLY a scenario dimension)</p> <code>None</code> <code>timesteps</code> <code>DatetimeIndex | None</code> <p>Optional time indexes to select. Can be: - pd.DatetimeIndex: Multiple timesteps - str/pd.Timestamp: Single timestep Defaults to all available timesteps.</p> <code>None</code> <code>scenarios</code> <code>Index | None</code> <p>Optional scenario indexes to select. Can be: - pd.Index: Multiple scenarios - str/int: Single scenario (int is treated as a label, not an index position) Defaults to all available scenarios.</p> <code>None</code> <code>contains</code> <code>str | list[str] | None</code> <p>Filter variables that contain this string or strings. If a list is provided, variables must contain ALL strings in the list.</p> <code>None</code> <code>startswith</code> <code>str | list[str] | None</code> <p>Filter variables that start with this string or strings. If a list is provided, variables must start with ANY of the strings in the list.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.SegmentedResults","title":"SegmentedResults","text":"<pre><code>SegmentedResults(segment_results: list[Results], all_timesteps: DatetimeIndex, timesteps_per_segment: int, overlap_timesteps: int, name: str, folder: Path | None = None)\n</code></pre> <p>Results container for segmented optimization optimizations with temporal decomposition.</p> <p>This class manages results from SegmentedOptimization runs where large optimization problems are solved by dividing the time horizon into smaller, overlapping segments. It provides unified access to results across all segments while maintaining the ability to analyze individual segment behavior.</p> Key Features <p>Unified Time Series: Automatically assembles results from all segments into continuous time series, removing overlaps and boundary effects Segment Analysis: Access individual segment results for debugging and validation Consistency Checks: Verify solution continuity at segment boundaries Memory Efficiency: Handles large datasets that exceed single-segment memory limits</p> Temporal Handling <p>The class manages the complex task of combining overlapping segment solutions into coherent time series, ensuring proper treatment of: - Storage state continuity between segments - Flow rate transitions at segment boundaries - Aggregated results over the full time horizon</p> <p>Examples:</p> <p>Load and analyze segmented results:</p> <pre><code># Load segmented optimization results\nresults = SegmentedResults.from_file('results', 'annual_segmented')\n\n# Access unified results across all segments\nfull_timeline = results.all_timesteps\ntotal_segments = len(results.segment_results)\n\n# Analyze individual segments\nfor i, segment in enumerate(results.segment_results):\n    print(f'Segment {i + 1}: {len(segment.solution.time)} timesteps')\n    segment_costs = segment.effects['cost'].total_value\n\n# Check solution continuity at boundaries\nsegment_boundaries = results.get_boundary_analysis()\nmax_discontinuity = segment_boundaries['max_storage_jump']\n</code></pre> <p>Create from segmented optimization:</p> <pre><code># After running segmented optimization\nsegmented_opt = SegmentedOptimization(\n    name='annual_system',\n    flow_system=system,\n    timesteps_per_segment=730,  # Monthly segments\n    overlap_timesteps=48,  # 2-day overlap\n)\nsegmented_opt.do_modeling_and_solve(solver='gurobi')\n\n# Extract unified results\nresults = SegmentedResults.from_optimization(segmented_opt)\n\n# Save combined results\nresults.to_file(compression=5)\n</code></pre> <p>Performance analysis across segments:</p> <pre><code># Compare segment solve times\nsolve_times = [seg.summary['durations']['solving'] for seg in results.segment_results]\navg_solve_time = sum(solve_times) / len(solve_times)\n\n# Verify solution quality consistency\nsegment_objectives = [seg.summary['objective_value'] for seg in results.segment_results]\n\n# Storage continuity analysis\nif 'Battery' in results.segment_results[0].components:\n    storage_continuity = results.check_storage_continuity('Battery')\n</code></pre> Design Considerations <p>Boundary Effects: Monitor solution quality at segment interfaces where foresight is limited compared to full-horizon optimization.</p> <p>Memory Management: Individual segment results are maintained for detailed analysis while providing unified access for system-wide metrics.</p> <p>Validation Tools: Built-in methods to verify temporal consistency and identify potential issues from segmentation approach.</p> Common Use Cases <ul> <li>Large-Scale Analysis: Annual or multi-period optimization results</li> <li>Memory-Constrained Systems: Results from systems exceeding hardware limits</li> <li>Segment Validation: Verifying segmentation approach effectiveness</li> <li>Performance Monitoring: Comparing segmented vs. full-horizon solutions</li> <li>Debugging: Identifying issues specific to temporal decomposition</li> </ul>"},{"location":"api-reference/results/#flixopt.results.SegmentedResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.SegmentedResults.from_optimization","title":"from_optimization  <code>classmethod</code>","text":"<pre><code>from_optimization(optimization: SegmentedOptimization) -&gt; SegmentedResults\n</code></pre> <p>Create SegmentedResults from a SegmentedOptimization instance.</p> <p>Parameters:</p> Name Type Description Default <code>optimization</code> <code>SegmentedOptimization</code> <p>The SegmentedOptimization instance to extract results from.</p> required <p>Returns:</p> Name Type Description <code>SegmentedResults</code> <code>SegmentedResults</code> <p>New instance containing the optimization results.</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedResults.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(folder: str | Path, name: str) -&gt; SegmentedResults\n</code></pre> <p>Load SegmentedResults from saved files.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path</code> <p>Directory containing saved files.</p> required <code>name</code> <code>str</code> <p>Base name of saved files.</p> required <p>Returns:</p> Name Type Description <code>SegmentedResults</code> <code>SegmentedResults</code> <p>Loaded instance.</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedResults.setup_colors","title":"setup_colors","text":"<pre><code>setup_colors(config: dict[str, str | list[str]] | str | Path | None = None, default_colorscale: str | None = None) -&gt; dict[str, str]\n</code></pre> <p>Setup colors for all variables across all segment results.</p> <p>This method applies the same color configuration to all segments, ensuring consistent visualization across the entire segmented optimization. The color mapping is propagated to each segment's Results instance.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, str | list[str]] | str | Path | None</code> <p>Configuration for color assignment. Can be: - dict: Maps components to colors/colorscales:     * 'component1': 'red'  # Single component to single color     * 'component1': '#FF0000'  # Single component to hex color     - OR maps colorscales to multiple components:     * 'colorscale_name': ['component1', 'component2']  # Colorscale across components - str: Path to a JSON/YAML config file or a colorscale name to apply to all - Path: Path to a JSON/YAML config file - None: Use default_colorscale for all components</p> <code>None</code> <code>default_colorscale</code> <code>str | None</code> <p>Default colorscale for unconfigured components (default: 'turbo')</p> <code>None</code> <p>Examples:</p> <pre><code># Apply colors to all segments\nsegmented_results.setup_colors(\n    {\n        'CHP': 'red',\n        'Blues': ['Storage1', 'Storage2'],\n        'Oranges': ['Solar1', 'Solar2'],\n    }\n)\n\n# Use a single colorscale for all components in all segments\nsegmented_results.setup_colors('portland')\n</code></pre> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Complete variable-to-color mapping dictionary from the first segment</p> <code>dict[str, str]</code> <p>(all segments will have the same mapping)</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedResults.solution_without_overlap","title":"solution_without_overlap","text":"<pre><code>solution_without_overlap(variable_name: str) -&gt; xr.DataArray\n</code></pre> <p>Get variable solution removing segment overlaps.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>Name of variable to extract.</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xr.DataArray: Continuous solution without overlaps.</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedResults.plot_heatmap","title":"plot_heatmap","text":"<pre><code>plot_heatmap(variable_name: str, reshape_time: tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None = 'auto', colors: ColorType | None = None, save: bool | Path = False, show: bool | None = None, engine: PlottingEngine = 'plotly', facet_by: str | list[str] | None = None, animate_by: str | None = None, facet_cols: int | None = None, fill: Literal['ffill', 'bfill'] | None = 'ffill', **plot_kwargs: Any) -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plot heatmap of variable solution across segments.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>Variable to plot.</p> required <code>reshape_time</code> <code>tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None</code> <p>Time reshaping configuration (default: 'auto'): - 'auto': Automatically applies ('D', 'h') when only 'time' dimension remains - Tuple like ('D', 'h'): Explicit reshaping (days vs hours) - None: Disable time reshaping</p> <code>'auto'</code> <code>colors</code> <code>ColorType | None</code> <p>Color scheme. See plotting.ColorType for options.</p> <code>None</code> <code>save</code> <code>bool | Path</code> <p>Whether to save plot.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to display plot.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine.</p> <code>'plotly'</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) to create facets (subplots) for.</p> <code>None</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over (Plotly only).</p> <code>None</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid layout.</p> <code>None</code> <code>fill</code> <code>Literal['ffill', 'bfill'] | None</code> <p>Method to fill missing values: 'ffill' or 'bfill'.</p> <code>'ffill'</code> <code>**plot_kwargs</code> <code>Any</code> <p>Additional plotting customization options. Common options:</p> <ul> <li>dpi (int): Export resolution for saved plots. Default: 300.</li> <li>vmin (float): Minimum value for color scale.</li> <li>vmax (float): Maximum value for color scale.</li> </ul> <p>For Matplotlib heatmaps:</p> <ul> <li>imshow_kwargs (dict): Additional kwargs for matplotlib's imshow.</li> <li>cbar_kwargs (dict): Additional kwargs for colorbar customization.</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>Figure | tuple[Figure, Axes]</code> <p>Figure object.</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedResults.to_file","title":"to_file","text":"<pre><code>to_file(folder: str | Path | None = None, name: str | None = None, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save segmented results to files.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path | None</code> <p>Save folder (defaults to instance folder).</p> <code>None</code> <code>name</code> <code>str | None</code> <p>File name (defaults to instance name).</p> <code>None</code> <code>compression</code> <code>int</code> <p>Compression level 0-9.</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If False, raise error if results files already exist. If True, overwrite existing files.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and result files already exist.</p>"},{"location":"api-reference/results/#flixopt.results-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.load_mapping_from_file","title":"load_mapping_from_file","text":"<pre><code>load_mapping_from_file(path: Path) -&gt; dict[str, str | list[str]]\n</code></pre> <p>Load color mapping from JSON or YAML file.</p> <p>Tries loader based on file suffix first, with fallback to the other format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to config file (.json or .yaml/.yml)</p> required <p>Returns:</p> Type Description <code>dict[str, str | list[str]]</code> <p>Dictionary mapping components to colors or colorscales to component lists</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If file cannot be loaded as JSON or YAML</p>"},{"location":"api-reference/results/#flixopt.results.plot_heatmap","title":"plot_heatmap","text":"<pre><code>plot_heatmap(data: DataArray | Dataset, name: str | None = None, folder: Path | None = None, colors: ColorType | None = None, save: bool | Path = False, show: bool | None = None, engine: PlottingEngine = 'plotly', select: dict[str, Any] | None = None, facet_by: str | list[str] | None = None, animate_by: str | None = None, facet_cols: int | None = None, reshape_time: tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None = 'auto', fill: Literal['ffill', 'bfill'] | None = 'ffill', **plot_kwargs: Any)\n</code></pre> <p>Plot heatmap visualization with support for multi-variable, faceting, and animation.</p> <p>This function provides a standalone interface to the heatmap plotting capabilities, supporting the same modern features as Results.plot_heatmap().</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataArray | Dataset</code> <p>Data to plot. Can be a single DataArray or an xarray Dataset. When a Dataset is provided, all data variables are combined along a new 'variable' dimension.</p> required <code>name</code> <code>str | None</code> <p>Optional name for the title. If not provided, uses the DataArray name or generates a default title for Datasets.</p> <code>None</code> <code>folder</code> <code>Path | None</code> <p>Save folder for the plot. Defaults to current directory if not provided.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color scheme for the heatmap. See <code>flixopt.plotting.ColorType</code> for options.</p> <code>None</code> <code>save</code> <code>bool | Path</code> <p>Whether to save the plot or not. If a path is provided, the plot will be saved at that location.</p> <code>False</code> <code>show</code> <code>bool | None</code> <p>Whether to show the plot or not.</p> <code>None</code> <code>engine</code> <code>PlottingEngine</code> <p>The engine to use for plotting. Can be either 'plotly' or 'matplotlib'.</p> <code>'plotly'</code> <code>select</code> <code>dict[str, Any] | None</code> <p>Optional data selection dict. Supports single values, lists, slices, and index arrays.</p> <code>None</code> <code>facet_by</code> <code>str | list[str] | None</code> <p>Dimension(s) to create facets (subplots) for. Can be a single dimension name (str) or list of dimensions. Each unique value combination creates a subplot.</p> <code>None</code> <code>animate_by</code> <code>str | None</code> <p>Dimension to animate over (Plotly only). Creates animation frames.</p> <code>None</code> <code>facet_cols</code> <code>int | None</code> <p>Number of columns in the facet grid layout (default: 3).</p> <code>None</code> <code>reshape_time</code> <code>tuple[Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], Literal['W', 'D', 'h', '15min', 'min']] | Literal['auto'] | None</code> <p>Time reshaping configuration (default: 'auto'): - 'auto': Automatically applies ('D', 'h') when only 'time' dimension remains - Tuple: Explicit reshaping, e.g. ('D', 'h') for days vs hours - None: Disable auto-reshaping</p> <code>'auto'</code> <code>fill</code> <code>Literal['ffill', 'bfill'] | None</code> <p>Method to fill missing values after reshape: 'ffill' (forward fill) or 'bfill' (backward fill). Default is 'ffill'.</p> <code>'ffill'</code> <p>Examples:</p> <p>Single DataArray with time reshaping:</p> <pre><code>&gt;&gt;&gt; plot_heatmap(data, name='Temperature', folder=Path('.'), reshape_time=('D', 'h'))\n</code></pre> <p>Dataset with multiple variables (facet by variable):</p> <pre><code>&gt;&gt;&gt; dataset = xr.Dataset({'Boiler': data1, 'CHP': data2, 'Storage': data3})\n&gt;&gt;&gt; plot_heatmap(\n...     dataset,\n...     folder=Path('.'),\n...     facet_by='variable',\n...     reshape_time=('D', 'h'),\n... )\n</code></pre> <p>Dataset with animation by variable:</p> <pre><code>&gt;&gt;&gt; plot_heatmap(dataset, animate_by='variable', reshape_time=('D', 'h'))\n</code></pre>"},{"location":"api-reference/results/#flixopt.results.sanitize_dataset","title":"sanitize_dataset","text":"<pre><code>sanitize_dataset(ds: Dataset, timesteps: DatetimeIndex | None = None, threshold: float | None = 1e-05, negate: list[str] | None = None, drop_small_vars: bool = True, zero_small_values: bool = False, drop_suffix: str | None = None) -&gt; xr.Dataset\n</code></pre> <p>Clean dataset by handling small values and reindexing time.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset to sanitize.</p> required <code>timesteps</code> <code>DatetimeIndex | None</code> <p>Time index for reindexing (optional).</p> <code>None</code> <code>threshold</code> <code>float | None</code> <p>Threshold for small values processing.</p> <code>1e-05</code> <code>negate</code> <code>list[str] | None</code> <p>Variables to negate.</p> <code>None</code> <code>drop_small_vars</code> <code>bool</code> <p>Whether to drop variables below threshold.</p> <code>True</code> <code>zero_small_values</code> <code>bool</code> <p>Whether to zero values below threshold.</p> <code>False</code> <code>drop_suffix</code> <code>str | None</code> <p>Drop suffix of data var names. Split by the provided str.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.filter_dataset","title":"filter_dataset","text":"<pre><code>filter_dataset(ds: Dataset, variable_dims: Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None = None, timesteps: DatetimeIndex | str | Timestamp | None = None, scenarios: Index | str | int | None = None, contains: str | list[str] | None = None, startswith: str | list[str] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter dataset by variable dimensions, indexes, and with string filters for variable names.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>The dataset to filter.</p> required <code>variable_dims</code> <code>Literal['scalar', 'time', 'scenario', 'timeonly', 'scenarioonly'] | None</code> <p>The dimension of which to get variables from. - 'scalar': Get scalar variables (without dimensions) - 'time': Get time-dependent variables (with a time dimension) - 'scenario': Get scenario-dependent variables (with ONLY a scenario dimension) - 'timeonly': Get time-dependent variables (with ONLY a time dimension) - 'scenarioonly': Get scenario-dependent variables (with ONLY a scenario dimension)</p> <code>None</code> <code>timesteps</code> <code>DatetimeIndex | str | Timestamp | None</code> <p>Optional time indexes to select. Can be: - pd.DatetimeIndex: Multiple timesteps - str/pd.Timestamp: Single timestep Defaults to all available timesteps.</p> <code>None</code> <code>scenarios</code> <code>Index | str | int | None</code> <p>Optional scenario indexes to select. Can be: - pd.Index: Multiple scenarios - str/int: Single scenario (int is treated as a label, not an index position) Defaults to all available scenarios.</p> <code>None</code> <code>contains</code> <code>str | list[str] | None</code> <p>Filter variables that contain this string or strings. If a list is provided, variables must contain ALL strings in the list.</p> <code>None</code> <code>startswith</code> <code>str | list[str] | None</code> <p>Filter variables that start with this string or strings. If a list is provided, variables must start with ANY of the strings in the list.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.filter_dataarray_by_coord","title":"filter_dataarray_by_coord","text":"<pre><code>filter_dataarray_by_coord(da: DataArray, **kwargs: str | list[str] | None) -&gt; xr.DataArray\n</code></pre> <p>Filter flows by node and component attributes.</p> <p>Filters are applied in the order they are specified. All filters must match for an edge to be included.</p> <p>To recombine filtered dataarrays, use <code>xr.concat</code>.</p> <p>xr.concat([res.sizes(start='Fernw\u00e4rme'), res.sizes(end='Fernw\u00e4rme')], dim='flow')</p> <p>Parameters:</p> Name Type Description Default <code>da</code> <code>DataArray</code> <p>Flow DataArray with network metadata coordinates.</p> required <code>**kwargs</code> <code>str | list[str] | None</code> <p>Coord filters as name=value pairs.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>Filtered DataArray with matching edges.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If required coordinates are missing.</p> <code>ValueError</code> <p>If specified nodes don't exist or no matches found.</p>"},{"location":"api-reference/solvers/","title":"Solvers","text":""},{"location":"api-reference/solvers/#flixopt.solvers","title":"flixopt.solvers","text":"<p>This module contains the solvers of the flixopt framework, making them available to the end user in a compact way.</p>"},{"location":"api-reference/solvers/#flixopt.solvers-classes","title":"Classes","text":""},{"location":"api-reference/solvers/#flixopt.solvers.GurobiSolver","title":"GurobiSolver  <code>dataclass</code>","text":"<pre><code>GurobiSolver(mip_gap: float = (lambda: CONFIG.Solving.mip_gap)(), time_limit_seconds: int = (lambda: CONFIG.Solving.time_limit_seconds)(), log_to_console: bool = (lambda: CONFIG.Solving.log_to_console)(), extra_options: dict[str, Any] = dict())\n</code></pre> <p>               Bases: <code>_Solver</code></p> <p>Gurobi solver configuration.</p> <p>Parameters:</p> Name Type Description Default <code>mip_gap</code> <code>float</code> <p>Acceptable relative optimality gap in [0.0, 1.0]; mapped to Gurobi <code>MIPGap</code>.</p> <code>(lambda: mip_gap)()</code> <code>time_limit_seconds</code> <code>int</code> <p>Time limit in seconds; mapped to Gurobi <code>TimeLimit</code>.</p> <code>(lambda: time_limit_seconds)()</code> <code>log_to_console</code> <code>bool</code> <p>If False, no output to console.</p> <code>(lambda: log_to_console)()</code> <code>extra_options</code> <code>dict[str, Any]</code> <p>Additional solver options merged into <code>options</code>.</p> <code>dict()</code>"},{"location":"api-reference/solvers/#flixopt.solvers.GurobiSolver-attributes","title":"Attributes","text":""},{"location":"api-reference/solvers/#flixopt.solvers.GurobiSolver.options","title":"options  <code>property</code>","text":"<pre><code>options: dict[str, Any]\n</code></pre> <p>Return a dictionary of solver options.</p>"},{"location":"api-reference/solvers/#flixopt.solvers.HighsSolver","title":"HighsSolver  <code>dataclass</code>","text":"<pre><code>HighsSolver(mip_gap: float = (lambda: CONFIG.Solving.mip_gap)(), time_limit_seconds: int = (lambda: CONFIG.Solving.time_limit_seconds)(), log_to_console: bool = (lambda: CONFIG.Solving.log_to_console)(), extra_options: dict[str, Any] = dict())\n</code></pre> <p>               Bases: <code>_Solver</code></p> <p>HiGHS solver configuration.</p> <p>Attributes:</p> Name Type Description <code>mip_gap</code> <code>float</code> <p>Acceptable relative optimality gap in [0.0, 1.0]; mapped to HiGHS <code>mip_rel_gap</code>.</p> <code>time_limit_seconds</code> <code>int</code> <p>Time limit in seconds; mapped to HiGHS <code>time_limit</code>.</p> <code>log_to_console</code> <code>bool</code> <p>If False, no output to console.</p> <code>extra_options</code> <code>dict[str, Any]</code> <p>Additional solver options merged into <code>options</code>.</p> <code>threads</code> <code>int | None</code> <p>Number of threads to use. If None, HiGHS chooses.</p>"},{"location":"api-reference/solvers/#flixopt.solvers.HighsSolver-attributes","title":"Attributes","text":""},{"location":"api-reference/solvers/#flixopt.solvers.HighsSolver.options","title":"options  <code>property</code>","text":"<pre><code>options: dict[str, Any]\n</code></pre> <p>Return a dictionary of solver options.</p>"},{"location":"api-reference/statistics_accessor/","title":"Statistics accessor","text":""},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor","title":"flixopt.statistics_accessor","text":"<p>Statistics accessor for FlowSystem.</p> <p>This module provides a user-friendly API for analyzing optimization results directly from a FlowSystem.</p> Structure <ul> <li><code>.statistics</code> - Data/metrics access (cached xarray Datasets)</li> <li><code>.statistics.plot</code> - Plotting methods using the statistics data</li> </ul> Example <p>flow_system.optimize(solver)</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor--data-access","title":"Data access","text":"<p>flow_system.statistics.flow_rates flow_system.statistics.flow_hours</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor--plotting","title":"Plotting","text":"<p>flow_system.statistics.plot.balance('ElectricityBus') flow_system.statistics.plot.heatmap('Boiler|on')</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor-attributes","title":"Attributes","text":""},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.SelectType","title":"SelectType  <code>module-attribute</code>","text":"<pre><code>SelectType = dict[str, Any]\n</code></pre> <p>xarray-style selection dict: {'time': slice(...), 'scenario': 'base'}</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.FilterType","title":"FilterType  <code>module-attribute</code>","text":"<pre><code>FilterType = str | list[str]\n</code></pre> <p>For include/exclude filtering: exact label(s) to match, e.g., 'Boiler(Q_th)' or ['Boiler(Q_th)', 'CHP(Q_th)']</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.FlowSankeySelect","title":"FlowSankeySelect  <code>module-attribute</code>","text":"<pre><code>FlowSankeySelect = dict[Literal['flow', 'bus', 'component', 'carrier', 'time', 'period', 'scenario'], Any]\n</code></pre> <p>Select options for flow-based sankey: flow, bus, component, carrier, time, period, scenario.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.EffectsSankeySelect","title":"EffectsSankeySelect  <code>module-attribute</code>","text":"<pre><code>EffectsSankeySelect = dict[Literal['effect', 'component', 'contributor', 'period', 'scenario'], Any]\n</code></pre> <p>Select options for effects sankey: effect, component, contributor, period, scenario.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor-classes","title":"Classes","text":""},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor","title":"StatisticsAccessor","text":"<pre><code>StatisticsAccessor(flow_system: FlowSystem)\n</code></pre> <p>Statistics accessor for FlowSystem. Access via <code>flow_system.statistics</code>.</p> <p>This accessor provides cached data properties for optimization results. Use <code>.plot</code> for visualization methods.</p> Data Properties <p><code>flow_rates</code> : xr.Dataset     Flow rates for all flows. <code>flow_hours</code> : xr.Dataset     Flow hours (energy) for all flows. <code>sizes</code> : xr.Dataset     Sizes for all flows. <code>charge_states</code> : xr.Dataset     Charge states for all storage components. <code>temporal_effects</code> : xr.Dataset     Temporal effects per contributor per timestep. <code>periodic_effects</code> : xr.Dataset     Periodic (investment) effects per contributor. <code>total_effects</code> : xr.Dataset     Total effects (temporal + periodic) per contributor. <code>effect_share_factors</code> : dict     Conversion factors between effects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.optimize(solver)\n&gt;&gt;&gt; flow_system.statistics.flow_rates  # Get data\n&gt;&gt;&gt; flow_system.statistics.plot.balance('Bus')  # Plot\n</code></pre>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor-attributes","title":"Attributes","text":""},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.carrier_colors","title":"carrier_colors  <code>property</code>","text":"<pre><code>carrier_colors: dict[str, str]\n</code></pre> <p>Cached mapping of carrier name to color.</p> <p>Delegates to topology accessor for centralized color caching.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dict mapping carrier names (lowercase) to hex color strings.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.component_colors","title":"component_colors  <code>property</code>","text":"<pre><code>component_colors: dict[str, str]\n</code></pre> <p>Cached mapping of component label to color.</p> <p>Delegates to topology accessor for centralized color caching.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dict mapping component labels to hex color strings.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.bus_colors","title":"bus_colors  <code>property</code>","text":"<pre><code>bus_colors: dict[str, str]\n</code></pre> <p>Cached mapping of bus label to color (from carrier).</p> <p>Delegates to topology accessor for centralized color caching.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dict mapping bus labels to hex color strings.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.carrier_units","title":"carrier_units  <code>property</code>","text":"<pre><code>carrier_units: dict[str, str]\n</code></pre> <p>Cached mapping of carrier name to unit string.</p> <p>Delegates to topology accessor for centralized unit caching.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dict mapping carrier names (lowercase) to unit strings.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.effect_units","title":"effect_units  <code>property</code>","text":"<pre><code>effect_units: dict[str, str]\n</code></pre> <p>Cached mapping of effect label to unit string.</p> <p>Delegates to topology accessor for centralized unit caching.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dict mapping effect labels to unit strings.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.plot","title":"plot  <code>property</code>","text":"<pre><code>plot: StatisticsPlotAccessor\n</code></pre> <p>Access plotting methods for statistics.</p> <p>Returns:</p> Type Description <code>StatisticsPlotAccessor</code> <p>A StatisticsPlotAccessor instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.statistics.plot.balance('ElectricityBus')\n&gt;&gt;&gt; flow_system.statistics.plot.heatmap('Boiler|on')\n</code></pre>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.flow_rates","title":"flow_rates  <code>property</code>","text":"<pre><code>flow_rates: Dataset\n</code></pre> <p>All flow rates as a Dataset with flow labels as variable names.</p> Each variable has attributes <ul> <li>'carrier': carrier type (e.g., 'heat', 'electricity', 'gas')</li> <li>'unit': carrier unit (e.g., 'kW')</li> </ul>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.flow_hours","title":"flow_hours  <code>property</code>","text":"<pre><code>flow_hours: Dataset\n</code></pre> <p>All flow hours (energy) as a Dataset with flow labels as variable names.</p> Each variable has attributes <ul> <li>'carrier': carrier type (e.g., 'heat', 'electricity', 'gas')</li> <li>'unit': energy unit (e.g., 'kWh', 'm3/s*h')</li> </ul>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.flow_sizes","title":"flow_sizes  <code>property</code>","text":"<pre><code>flow_sizes: Dataset\n</code></pre> <p>Flow sizes as a Dataset with flow labels as variable names.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.storage_sizes","title":"storage_sizes  <code>property</code>","text":"<pre><code>storage_sizes: Dataset\n</code></pre> <p>Storage capacity sizes as a Dataset with storage labels as variable names.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.sizes","title":"sizes  <code>property</code>","text":"<pre><code>sizes: Dataset\n</code></pre> <p>All investment sizes (flows and storage capacities) as a Dataset.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.charge_states","title":"charge_states  <code>property</code>","text":"<pre><code>charge_states: Dataset\n</code></pre> <p>All storage charge states as a Dataset with storage labels as variable names.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.effect_share_factors","title":"effect_share_factors  <code>property</code>","text":"<pre><code>effect_share_factors: dict[str, dict]\n</code></pre> <p>Effect share factors for temporal and periodic modes.</p> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>Dict with 'temporal' and 'periodic' keys, each containing</p> <code>dict[str, dict]</code> <p>conversion factors between effects.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.temporal_effects","title":"temporal_effects  <code>property</code>","text":"<pre><code>temporal_effects: Dataset\n</code></pre> <p>Temporal effects per contributor per timestep.</p> <p>Returns a Dataset where each effect is a data variable with dimensions [time, contributor] (plus period/scenario if present).</p> Coordinates <ul> <li>contributor: Individual contributor labels</li> <li>component: Parent component label for groupby operations</li> <li>component_type: Component type (e.g., 'Boiler', 'Source', 'Sink')</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Get costs per contributor per timestep\n&gt;&gt;&gt; statistics.temporal_effects['costs']\n&gt;&gt;&gt; # Sum over all contributors to get total costs per timestep\n&gt;&gt;&gt; statistics.temporal_effects['costs'].sum('contributor')\n&gt;&gt;&gt; # Group by component\n&gt;&gt;&gt; statistics.temporal_effects['costs'].groupby('component').sum()\n</code></pre> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset with effects as variables and contributor dimension.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.periodic_effects","title":"periodic_effects  <code>property</code>","text":"<pre><code>periodic_effects: Dataset\n</code></pre> <p>Periodic (investment) effects per contributor.</p> <p>Returns a Dataset where each effect is a data variable with dimensions [contributor] (plus period/scenario if present).</p> Coordinates <ul> <li>contributor: Individual contributor labels</li> <li>component: Parent component label for groupby operations</li> <li>component_type: Component type (e.g., 'Boiler', 'Source', 'Sink')</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Get investment costs per contributor\n&gt;&gt;&gt; statistics.periodic_effects['costs']\n&gt;&gt;&gt; # Sum over all contributors to get total investment costs\n&gt;&gt;&gt; statistics.periodic_effects['costs'].sum('contributor')\n&gt;&gt;&gt; # Group by component\n&gt;&gt;&gt; statistics.periodic_effects['costs'].groupby('component').sum()\n</code></pre> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset with effects as variables and contributor dimension.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.total_effects","title":"total_effects  <code>property</code>","text":"<pre><code>total_effects: Dataset\n</code></pre> <p>Total effects (temporal + periodic) per contributor.</p> <p>Returns a Dataset where each effect is a data variable with dimensions [contributor] (plus period/scenario if present).</p> Coordinates <ul> <li>contributor: Individual contributor labels</li> <li>component: Parent component label for groupby operations</li> <li>component_type: Component type (e.g., 'Boiler', 'Source', 'Sink')</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Get total costs per contributor\n&gt;&gt;&gt; statistics.total_effects['costs']\n&gt;&gt;&gt; # Sum over all contributors to get total system costs\n&gt;&gt;&gt; statistics.total_effects['costs'].sum('contributor')\n&gt;&gt;&gt; # Group by component\n&gt;&gt;&gt; statistics.total_effects['costs'].groupby('component').sum()\n&gt;&gt;&gt; # Group by component type\n&gt;&gt;&gt; statistics.total_effects['costs'].groupby('component_type').sum()\n</code></pre> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset with effects as variables and contributor dimension.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor-functions","title":"Functions","text":""},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsAccessor.get_effect_shares","title":"get_effect_shares","text":"<pre><code>get_effect_shares(element: str, effect: str, mode: Literal['temporal', 'periodic'] | None = None, include_flows: bool = False) -&gt; xr.Dataset\n</code></pre> <p>Retrieve individual effect shares for a specific element and effect.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>The element identifier (component or flow label).</p> required <code>effect</code> <code>str</code> <p>The effect identifier.</p> required <code>mode</code> <code>Literal['temporal', 'periodic'] | None</code> <p>'temporal', 'periodic', or None for both.</p> <code>None</code> <code>include_flows</code> <code>bool</code> <p>Whether to include effects from flows connected to this element.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset containing the requested effect shares.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the effect is not available or mode is invalid.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.SankeyPlotAccessor","title":"SankeyPlotAccessor","text":"<pre><code>SankeyPlotAccessor(plot_accessor: StatisticsPlotAccessor)\n</code></pre> <p>Sankey diagram accessor. Access via <code>flow_system.statistics.plot.sankey</code>.</p> <p>Provides typed methods for different sankey diagram types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fs.statistics.plot.sankey.flows(select={'bus': 'HeatBus'})\n&gt;&gt;&gt; fs.statistics.plot.sankey.effects(select={'effect': 'costs'})\n&gt;&gt;&gt; fs.statistics.plot.sankey.sizes(select={'component': 'Boiler'})\n</code></pre>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.SankeyPlotAccessor-functions","title":"Functions","text":""},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.SankeyPlotAccessor.flows","title":"flows","text":"<pre><code>flows(*, aggregate: Literal['sum', 'mean'] = 'sum', select: FlowSankeySelect | None = None, colors: ColorType | None = None, show: bool | None = None, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot Sankey diagram of energy/material flow amounts.</p> <p>Parameters:</p> Name Type Description Default <code>aggregate</code> <code>Literal['sum', 'mean']</code> <p>How to aggregate over time ('sum' or 'mean').</p> <code>'sum'</code> <code>select</code> <code>FlowSankeySelect | None</code> <p>Filter options: - flow: filter by flow label (e.g., 'Boiler|Q_th') - bus: filter by bus label (e.g., 'HeatBus') - component: filter by component label (e.g., 'Boiler') - time: select specific time (e.g., 100 or '2023-01-01') - period, scenario: xarray dimension selection</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification for nodes.</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure.</p> <code>None</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to Plotly layout.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with Sankey flow data and figure.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.SankeyPlotAccessor.sizes","title":"sizes","text":"<pre><code>sizes(*, select: FlowSankeySelect | None = None, max_size: float | None = None, colors: ColorType | None = None, show: bool | None = None, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot Sankey diagram of investment sizes/capacities.</p> <p>Parameters:</p> Name Type Description Default <code>select</code> <code>FlowSankeySelect | None</code> <p>Filter options: - flow: filter by flow label (e.g., 'Boiler|Q_th') - bus: filter by bus label (e.g., 'HeatBus') - component: filter by component label (e.g., 'Boiler') - period, scenario: xarray dimension selection</p> <code>None</code> <code>max_size</code> <code>float | None</code> <p>Filter flows with sizes exceeding this value.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification for nodes.</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure.</p> <code>None</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to Plotly layout.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with Sankey size data and figure.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.SankeyPlotAccessor.peak_flow","title":"peak_flow","text":"<pre><code>peak_flow(*, select: FlowSankeySelect | None = None, colors: ColorType | None = None, show: bool | None = None, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot Sankey diagram of peak (maximum) flow rates.</p> <p>Parameters:</p> Name Type Description Default <code>select</code> <code>FlowSankeySelect | None</code> <p>Filter options: - flow: filter by flow label (e.g., 'Boiler|Q_th') - bus: filter by bus label (e.g., 'HeatBus') - component: filter by component label (e.g., 'Boiler') - time, period, scenario: xarray dimension selection</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification for nodes.</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure.</p> <code>None</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to Plotly layout.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with Sankey peak flow data and figure.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.SankeyPlotAccessor.effects","title":"effects","text":"<pre><code>effects(*, select: EffectsSankeySelect | None = None, colors: ColorType | None = None, show: bool | None = None, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot Sankey diagram of component contributions to effects.</p> <p>Shows how each component contributes to costs, CO2, and other effects.</p> <p>Parameters:</p> Name Type Description Default <code>select</code> <code>EffectsSankeySelect | None</code> <p>Filter options: - effect: filter which effects are shown (e.g., 'costs', ['costs', 'CO2']) - component: filter by component label (e.g., 'Boiler') - contributor: filter by contributor label (e.g., 'Boiler|Q_th') - period, scenario: xarray dimension selection</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification for nodes.</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure.</p> <code>None</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to Plotly layout.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with Sankey effects data and figure.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsPlotAccessor","title":"StatisticsPlotAccessor","text":"<pre><code>StatisticsPlotAccessor(statistics: StatisticsAccessor)\n</code></pre> <p>Plot accessor for statistics. Access via <code>flow_system.statistics.plot</code>.</p> <p>All methods return PlotResult with both data and figure.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsPlotAccessor-attributes","title":"Attributes","text":""},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsPlotAccessor.sankey","title":"sankey  <code>property</code>","text":"<pre><code>sankey: SankeyPlotAccessor\n</code></pre> <p>Access sankey diagram methods with typed select options.</p> <p>Returns:</p> Type Description <code>SankeyPlotAccessor</code> <p>SankeyPlotAccessor with methods: flows(), sizes(), peak_flow(), effects()</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fs.statistics.plot.sankey.flows(select={'bus': 'HeatBus'})\n&gt;&gt;&gt; fs.statistics.plot.sankey.effects(select={'effect': 'costs'})\n</code></pre>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsPlotAccessor-functions","title":"Functions","text":""},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsPlotAccessor.balance","title":"balance","text":"<pre><code>balance(node: str, *, select: SelectType | None = None, include: FilterType | None = None, exclude: FilterType | None = None, unit: Literal['flow_rate', 'flow_hours'] = 'flow_rate', colors: ColorType | None = None, round_decimals: int | None = 6, show: bool | None = None, data_only: bool = False, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot node balance (inputs vs outputs) for a Bus or Component.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>Label of the Bus or Component to plot.</p> required <code>select</code> <code>SelectType | None</code> <p>xarray-style selection dict.</p> <code>None</code> <code>include</code> <code>FilterType | None</code> <p>Only include flows with these exact labels.</p> <code>None</code> <code>exclude</code> <code>FilterType | None</code> <p>Exclude flows with these exact labels.</p> <code>None</code> <code>unit</code> <code>Literal['flow_rate', 'flow_hours']</code> <p>'flow_rate' (power) or 'flow_hours' (energy).</p> <code>'flow_rate'</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, color list, or label-to-color dict).</p> <code>None</code> <code>round_decimals</code> <code>int | None</code> <p>Round values to this many decimal places to avoid numerical noise (e.g., tiny negative values from solver precision). Set to None to disable.</p> <code>6</code> <code>show</code> <code>bool | None</code> <p>Whether to display the plot.</p> <code>None</code> <code>data_only</code> <code>bool</code> <p>If True, skip figure creation and return only data (for performance).</p> <code>False</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to the plotly accessor (e.g., facet_col, facet_row, animation_frame).</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with .data and .figure.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsPlotAccessor.carrier_balance","title":"carrier_balance","text":"<pre><code>carrier_balance(carrier: str, *, select: SelectType | None = None, include: FilterType | None = None, exclude: FilterType | None = None, unit: Literal['flow_rate', 'flow_hours'] = 'flow_rate', colors: ColorType | None = None, round_decimals: int | None = 6, show: bool | None = None, data_only: bool = False, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot carrier-level balance showing all flows of a carrier type.</p> <p>Shows production (positive) and consumption (negative) of a carrier across all buses of that carrier type in the system.</p> <p>Parameters:</p> Name Type Description Default <code>carrier</code> <code>str</code> <p>Carrier name (e.g., 'heat', 'electricity', 'gas').</p> required <code>select</code> <code>SelectType | None</code> <p>xarray-style selection dict.</p> <code>None</code> <code>include</code> <code>FilterType | None</code> <p>Only include flows with these exact labels.</p> <code>None</code> <code>exclude</code> <code>FilterType | None</code> <p>Exclude flows with these exact labels.</p> <code>None</code> <code>unit</code> <code>Literal['flow_rate', 'flow_hours']</code> <p>'flow_rate' (power) or 'flow_hours' (energy).</p> <code>'flow_rate'</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, color list, or label-to-color dict).</p> <code>None</code> <code>round_decimals</code> <code>int | None</code> <p>Round values to this many decimal places to avoid numerical noise (e.g., tiny negative values from solver precision). Set to None to disable.</p> <code>6</code> <code>show</code> <code>bool | None</code> <p>Whether to display the plot.</p> <code>None</code> <code>data_only</code> <code>bool</code> <p>If True, skip figure creation and return only data (for performance).</p> <code>False</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to the plotly accessor (e.g., facet_col, facet_row, animation_frame).</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with .data and .figure.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fs.statistics.plot.carrier_balance('heat')\n&gt;&gt;&gt; fs.statistics.plot.carrier_balance('electricity', unit='flow_hours')\n</code></pre> Notes <ul> <li>Inputs to carrier buses (from sources/converters) are shown as positive</li> <li>Outputs from carrier buses (to sinks/converters) are shown as negative</li> <li>Internal transfers between buses of the same carrier appear on both sides</li> </ul>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsPlotAccessor.heatmap","title":"heatmap","text":"<pre><code>heatmap(variables: str | list[str], *, select: SelectType | None = None, reshape: tuple[str, str] | Literal['auto'] | None = ('D', 'h'), colors: str | list[str] | None = None, show: bool | None = None, data_only: bool = False, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot heatmap of time series data.</p> <p>By default, time is reshaped into days \u00d7 hours for clear daily pattern visualization. For clustered data, the natural (cluster, time) shape is used instead.</p> <p>Multiple variables are shown as facets. If no time dimension exists, reshaping is skipped and data dimensions are used directly.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>str | list[str]</code> <p>Flow label(s) or variable name(s). Flow labels like 'Boiler(Q_th)' are automatically resolved to 'Boiler(Q_th)|flow_rate'. Full variable names like 'Storage|charge_state' are used as-is.</p> required <code>select</code> <code>SelectType | None</code> <p>xarray-style selection, e.g. {'scenario': 'Base Case'}.</p> <code>None</code> <code>reshape</code> <code>tuple[str, str] | Literal['auto'] | None</code> <p>Time reshape frequencies as (outer, inner). Default <code>('D', 'h')</code> reshapes into days \u00d7 hours. Use None to disable reshaping and use data dimensions directly.</p> <code>('D', 'h')</code> <code>colors</code> <code>str | list[str] | None</code> <p>Colorscale name (str) or list of colors for heatmap coloring. Dicts are not supported for heatmaps (use str or list[str]).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure.</p> <code>None</code> <code>data_only</code> <code>bool</code> <p>If True, skip figure creation and return only data (for performance).</p> <code>False</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to plotly accessor (e.g., facet_col, animation_frame).</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with processed data and figure.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsPlotAccessor.flows","title":"flows","text":"<pre><code>flows(*, start: str | list[str] | None = None, end: str | list[str] | None = None, component: str | list[str] | None = None, select: SelectType | None = None, unit: Literal['flow_rate', 'flow_hours'] = 'flow_rate', colors: ColorType | None = None, show: bool | None = None, data_only: bool = False, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot flow rates filtered by start/end nodes or component.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | list[str] | None</code> <p>Filter by source node(s).</p> <code>None</code> <code>end</code> <code>str | list[str] | None</code> <p>Filter by destination node(s).</p> <code>None</code> <code>component</code> <code>str | list[str] | None</code> <p>Filter by parent component(s).</p> <code>None</code> <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>unit</code> <code>Literal['flow_rate', 'flow_hours']</code> <p>'flow_rate' or 'flow_hours'.</p> <code>'flow_rate'</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, color list, or label-to-color dict).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display.</p> <code>None</code> <code>data_only</code> <code>bool</code> <p>If True, skip figure creation and return only data (for performance).</p> <code>False</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to the plotly accessor (e.g., facet_col, facet_row, animation_frame).</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with flow data.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsPlotAccessor.sizes","title":"sizes","text":"<pre><code>sizes(*, max_size: float | None = 1000000.0, select: SelectType | None = None, colors: ColorType | None = None, show: bool | None = None, data_only: bool = False, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot investment sizes (capacities) of flows.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>float | None</code> <p>Maximum size to include (filters defaults).</p> <code>1000000.0</code> <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, color list, or label-to-color dict).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display.</p> <code>None</code> <code>data_only</code> <code>bool</code> <p>If True, skip figure creation and return only data (for performance).</p> <code>False</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to the plotly accessor (e.g., facet_col, facet_row, animation_frame).</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with size data.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsPlotAccessor.duration_curve","title":"duration_curve","text":"<pre><code>duration_curve(variables: str | list[str], *, select: SelectType | None = None, normalize: bool = False, colors: ColorType | None = None, show: bool | None = None, data_only: bool = False, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot load duration curves (sorted time series).</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>str | list[str]</code> <p>Flow label(s) or variable name(s). Flow labels like 'Boiler(Q_th)' are looked up in flow_rates. Full variable names like 'Boiler(Q_th)|flow_rate' are stripped to their flow label. Other variables (e.g., 'Storage|charge_state') are looked up in the solution directly.</p> required <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>normalize</code> <code>bool</code> <p>If True, normalize x-axis to 0-100%.</p> <code>False</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, color list, or label-to-color dict).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display.</p> <code>None</code> <code>data_only</code> <code>bool</code> <p>If True, skip figure creation and return only data (for performance).</p> <code>False</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to the plotly accessor (e.g., facet_col, facet_row, animation_frame).</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with sorted duration curve data.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsPlotAccessor.effects","title":"effects","text":"<pre><code>effects(aspect: Literal['total', 'temporal', 'periodic'] = 'total', *, effect: str | None = None, by: Literal['component', 'contributor', 'time'] | None = None, select: SelectType | None = None, colors: ColorType | None = None, show: bool | None = None, data_only: bool = False, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot effect (cost, emissions, etc.) breakdown.</p> <p>Parameters:</p> Name Type Description Default <code>aspect</code> <code>Literal['total', 'temporal', 'periodic']</code> <p>Which aspect to plot - 'total', 'temporal', or 'periodic'.</p> <code>'total'</code> <code>effect</code> <code>str | None</code> <p>Specific effect name to plot (e.g., 'costs', 'CO2').     If None, plots all effects.</p> <code>None</code> <code>by</code> <code>Literal['component', 'contributor', 'time'] | None</code> <p>Group by 'component', 'contributor' (individual flows), 'time', or None to show aggregated totals per effect.</p> <code>None</code> <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, color list, or label-to-color dict).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display.</p> <code>None</code> <code>data_only</code> <code>bool</code> <p>If True, skip figure creation and return only data (for performance).</p> <code>False</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to the plotly accessor (e.g., facet_col, facet_row, animation_frame).</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with effect breakdown data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.statistics.plot.effects()  # Aggregated totals per effect\n&gt;&gt;&gt; flow_system.statistics.plot.effects(effect='costs')  # Just costs\n&gt;&gt;&gt; flow_system.statistics.plot.effects(by='component')  # Breakdown by component\n&gt;&gt;&gt; flow_system.statistics.plot.effects(by='contributor')  # By individual flows\n&gt;&gt;&gt; flow_system.statistics.plot.effects(aspect='temporal', by='time')  # Over time\n</code></pre>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsPlotAccessor.charge_states","title":"charge_states","text":"<pre><code>charge_states(storages: str | list[str] | None = None, *, select: SelectType | None = None, colors: ColorType | None = None, show: bool | None = None, data_only: bool = False, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot storage charge states over time.</p> <p>Parameters:</p> Name Type Description Default <code>storages</code> <code>str | list[str] | None</code> <p>Storage label(s) to plot. If None, plots all storages.</p> <code>None</code> <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, color list, or label-to-color dict).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display.</p> <code>None</code> <code>data_only</code> <code>bool</code> <p>If True, skip figure creation and return only data (for performance).</p> <code>False</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to the plotly accessor (e.g., facet_col, facet_row, animation_frame).</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with charge state data.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.StatisticsPlotAccessor.storage","title":"storage","text":"<pre><code>storage(storage: str, *, select: SelectType | None = None, unit: Literal['flow_rate', 'flow_hours'] = 'flow_rate', colors: ColorType | None = None, charge_state_color: str = 'black', round_decimals: int | None = 6, show: bool | None = None, data_only: bool = False, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot storage operation: balance and charge state in vertically stacked subplots.</p> <p>Creates two subplots sharing the x-axis: - Top: Charging/discharging flows as stacked bars (inputs negative, outputs positive) - Bottom: Charge state over time as a line</p> <p>Parameters:</p> Name Type Description Default <code>storage</code> <code>str</code> <p>Storage component label.</p> required <code>select</code> <code>SelectType | None</code> <p>xarray-style selection.</p> <code>None</code> <code>unit</code> <code>Literal['flow_rate', 'flow_hours']</code> <p>'flow_rate' (power) or 'flow_hours' (energy).</p> <code>'flow_rate'</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification for flow bars.</p> <code>None</code> <code>charge_state_color</code> <code>str</code> <p>Color for the charge state line overlay.</p> <code>'black'</code> <code>round_decimals</code> <code>int | None</code> <p>Round values to this many decimal places to avoid numerical noise (e.g., tiny negative values from solver precision). Set to None to disable.</p> <code>6</code> <code>show</code> <code>bool | None</code> <p>Whether to display.</p> <code>None</code> <code>data_only</code> <code>bool</code> <p>If True, skip figure creation and return only data (for performance).</p> <code>False</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to the plotly accessor (e.g., facet_col, facet_row, animation_frame).</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult with combined balance and charge state data.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If storage component not found.</p> <code>ValueError</code> <p>If component is not a storage.</p>"},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor-functions","title":"Functions","text":""},{"location":"api-reference/statistics_accessor/#flixopt.statistics_accessor.add_line_overlay","title":"add_line_overlay","text":"<pre><code>add_line_overlay(fig: Figure, da: DataArray, *, x: str | None = None, facet_col: str | None = None, facet_row: str | None = None, animation_frame: str | None = None, color: str | None = None, line_color: str = 'black', name: str | None = None, secondary_y: bool = False, y_title: str | None = None, showlegend: bool = True) -&gt; None\n</code></pre> <p>Add line traces on top of existing figure, optionally on secondary y-axis.</p> <p>This function creates line traces from a DataArray and adds them to an existing figure. When using secondary_y=True, it correctly handles faceted figures by creating matching secondary axes for each primary axis.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Plotly figure to add traces to.</p> required <code>da</code> <code>DataArray</code> <p>DataArray to plot as lines.</p> required <code>x</code> <code>str | None</code> <p>Dimension to use for x-axis. If None, auto-detects 'time' or first dim.</p> <code>None</code> <code>facet_col</code> <code>str | None</code> <p>Dimension for column facets (must match primary figure).</p> <code>None</code> <code>facet_row</code> <code>str | None</code> <p>Dimension for row facets (must match primary figure).</p> <code>None</code> <code>animation_frame</code> <code>str | None</code> <p>Dimension for animation slider (must match primary figure).</p> <code>None</code> <code>color</code> <code>str | None</code> <p>Dimension to color by (creates multiple lines).</p> <code>None</code> <code>line_color</code> <code>str</code> <p>Color for lines when color is None.</p> <code>'black'</code> <code>name</code> <code>str | None</code> <p>Legend name for the traces.</p> <code>None</code> <code>secondary_y</code> <code>bool</code> <p>If True, plot on secondary y-axis.</p> <code>False</code> <code>y_title</code> <code>str | None</code> <p>Title for the y-axis (secondary if secondary_y=True).</p> <code>None</code> <code>showlegend</code> <code>bool</code> <p>Whether to show legend entries.</p> <code>True</code>"},{"location":"api-reference/stats_accessor/","title":"Stats accessor","text":""},{"location":"api-reference/stats_accessor/#flixopt.stats_accessor","title":"flixopt.stats_accessor","text":"<p>Xarray accessor for statistics and transformations (<code>.fxstats</code>).</p>"},{"location":"api-reference/stats_accessor/#flixopt.stats_accessor-classes","title":"Classes","text":""},{"location":"api-reference/stats_accessor/#flixopt.stats_accessor.DatasetStatsAccessor","title":"DatasetStatsAccessor","text":"<pre><code>DatasetStatsAccessor(xarray_obj: Dataset)\n</code></pre> <p>Statistics/transformation accessor for any xr.Dataset. Access via <code>dataset.fxstats</code>.</p> <p>Provides data transformation methods that return new datasets. Chain with <code>.plotly</code> for visualization.</p> <p>Examples:</p> <p>Duration curve::</p> <pre><code>ds.fxstats.to_duration_curve().plotly.line()\n</code></pre>"},{"location":"api-reference/stats_accessor/#flixopt.stats_accessor.DatasetStatsAccessor-functions","title":"Functions","text":""},{"location":"api-reference/stats_accessor/#flixopt.stats_accessor.DatasetStatsAccessor.to_duration_curve","title":"to_duration_curve","text":"<pre><code>to_duration_curve(*, normalize: bool = True) -&gt; xr.Dataset\n</code></pre> <p>Transform dataset to duration curve format (sorted values).</p> <p>Values are sorted in descending order along the 'time' dimension. The time coordinate is replaced with duration (percentage or index).</p> <p>Parameters:</p> Name Type Description Default <code>normalize</code> <code>bool</code> <p>If True, x-axis shows percentage (0-100). If False, shows timestep index.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Transformed xr.Dataset with duration coordinate instead of time.</p> Example <p>ds.fxstats.to_duration_curve().plotly.line(title='Duration Curve')</p>"},{"location":"api-reference/structure/","title":"Structure","text":""},{"location":"api-reference/structure/#flixopt.structure","title":"flixopt.structure","text":"<p>This module contains the core structure of the flixopt framework. These classes are not directly used by the end user, but are used by other modules.</p>"},{"location":"api-reference/structure/#flixopt.structure-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.EXPAND_INTERPOLATE","title":"EXPAND_INTERPOLATE  <code>module-attribute</code>","text":"<pre><code>EXPAND_INTERPOLATE: set[VariableCategory] = {CHARGE_STATE}\n</code></pre> <p>State variables that should be interpolated between segment boundaries.</p>"},{"location":"api-reference/structure/#flixopt.structure.EXPAND_DIVIDE","title":"EXPAND_DIVIDE  <code>module-attribute</code>","text":"<pre><code>EXPAND_DIVIDE: set[VariableCategory] = {PER_TIMESTEP, SHARE}\n</code></pre> <p>Segment totals that should be divided by expansion factor to preserve sums.</p>"},{"location":"api-reference/structure/#flixopt.structure.EXPAND_FIRST_TIMESTEP","title":"EXPAND_FIRST_TIMESTEP  <code>module-attribute</code>","text":"<pre><code>EXPAND_FIRST_TIMESTEP: set[VariableCategory] = {STARTUP, SHUTDOWN}\n</code></pre> <p>Binary events that should appear only at the first timestep of the segment.</p>"},{"location":"api-reference/structure/#flixopt.structure-classes","title":"Classes","text":""},{"location":"api-reference/structure/#flixopt.structure.VariableCategory","title":"VariableCategory","text":"<p>               Bases: <code>Enum</code></p> <p>Fine-grained variable categories - names mirror variable names.</p> <p>Each variable type has its own category for precise handling during segment expansion and statistics calculation.</p>"},{"location":"api-reference/structure/#flixopt.structure.SubmodelsMixin","title":"SubmodelsMixin","text":"<p>Mixin that provides submodel functionality for both FlowSystemModel and Submodel.</p>"},{"location":"api-reference/structure/#flixopt.structure.SubmodelsMixin-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.SubmodelsMixin.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/structure/#flixopt.structure.SubmodelsMixin-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.SubmodelsMixin.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel","title":"FlowSystemModel","text":"<pre><code>FlowSystemModel(flow_system: FlowSystem)\n</code></pre> <p>               Bases: <code>Model</code>, <code>SubmodelsMixin</code></p> <p>The FlowSystemModel is the linopy Model that is used to create the mathematical model of the flow_system. It is used to create and store the variables and constraints for the flow_system.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The flow_system that is used to create the model.</p> required"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.solution","title":"solution  <code>property</code>","text":"<pre><code>solution\n</code></pre> <p>Build solution dataset, reindexing to timesteps_extra for consistency.</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.timestep_duration","title":"timestep_duration  <code>property</code>","text":"<pre><code>timestep_duration: DataArray\n</code></pre> <p>Duration of each timestep in hours.</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: list[str]\n</code></pre> <p>Active dimension names.</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.indexes","title":"indexes  <code>property</code>","text":"<pre><code>indexes: dict[str, Index]\n</code></pre> <p>Indexes for active dimensions.</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.weights","title":"weights  <code>property</code>","text":"<pre><code>weights: dict[str, DataArray]\n</code></pre> <p>Weights for active dimensions (unit weights if not set).</p> <p>Scenario weights are always normalized (handled by FlowSystem).</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.temporal_dims","title":"temporal_dims  <code>property</code>","text":"<pre><code>temporal_dims: list[str]\n</code></pre> <p>Temporal dimensions for summing over time.</p> <p>Returns ['time', 'cluster'] for clustered systems, ['time'] otherwise.</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.temporal_weight","title":"temporal_weight  <code>property</code>","text":"<pre><code>temporal_weight: DataArray\n</code></pre> <p>Combined temporal weight (timestep_duration \u00d7 cluster_weight).</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.scenario_weights","title":"scenario_weights  <code>property</code>","text":"<pre><code>scenario_weights: DataArray\n</code></pre> <p>Scenario weights of model.</p> <p>Returns:</p> Type Description <code>DataArray</code> <ul> <li>Scalar 1 if no scenarios defined</li> </ul> <code>DataArray</code> <ul> <li>Unit weights (all 1.0) if scenarios exist but no explicit weights set</li> </ul> <code>DataArray</code> <ul> <li>Normalized explicit weights if set via FlowSystem.scenario_weights</li> </ul>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.objective_weights","title":"objective_weights  <code>property</code>","text":"<pre><code>objective_weights: DataArray\n</code></pre> <p>Objective weights of model (period_weights \u00d7 scenario_weights).</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(lower: DataArray | float = -np.inf, upper: DataArray | float = np.inf, coords: Coordinates | None = None, **kwargs) -&gt; linopy.Variable\n</code></pre> <p>Override to ensure bounds are broadcasted to coords shape.</p> <p>Linopy uses the union of all DataArray dimensions to determine variable shape. This override ensures at least one bound has all target dimensions when coords is provided, allowing internal data to remain compact (scalars, 1D arrays).</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.sum_temporal","title":"sum_temporal","text":"<pre><code>sum_temporal(data: DataArray) -&gt; xr.DataArray\n</code></pre> <p>Sum data over temporal dimensions with full temporal weighting.</p> Example <p>total_energy = model.sum_temporal(flow_rate)</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.get_coords","title":"get_coords","text":"<pre><code>get_coords(dims: Collection[str] | None = None, extra_timestep: bool = False) -&gt; xr.Coordinates | None\n</code></pre> <p>Returns the coordinates of the model</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>Collection[str] | None</code> <p>The dimensions to include in the coordinates. If None, includes all dimensions</p> <code>None</code> <code>extra_timestep</code> <code>bool</code> <p>If True, uses extra timesteps instead of regular timesteps. For clustered FlowSystems, extends time by 1 (for charge_state boundaries).</p> <code>False</code> <p>Returns:</p> Type Description <code>Coordinates | None</code> <p>The coordinates of the model, or None if no coordinates are available</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If extra_timestep=True but 'time' is not in dims</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowSystemModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface","title":"Interface","text":"<p>Base class for all Elements and Models in flixopt that provides serialization capabilities.</p> <p>This class enables automatic serialization/deserialization of objects containing xarray DataArrays and nested Interface objects to/from xarray Datasets and NetCDF files. It uses introspection of constructor parameters to automatically handle most serialization scenarios.</p> Key Features <ul> <li>Automatic extraction and restoration of xarray DataArrays</li> <li>Support for nested Interface objects</li> <li>NetCDF and JSON export/import</li> <li>Recursive handling of complex nested structures</li> </ul> Subclasses must implement <p>transform_data(): Transform data to match FlowSystem dimensions</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.Interface.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Interface.transform_data","title":"transform_data","text":"<pre><code>transform_data() -&gt; None\n</code></pre> <p>Transform the data of the interface to match the FlowSystem's dimensions.</p> <p>Uses <code>self._prefix</code> (set during <code>link_to_flow_system()</code>) to name transformed data.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Note <p>The FlowSystem reference is available via self._flow_system (for Interface objects) or self.flow_system property (for Element objects). Elements must be registered to a FlowSystem before calling this method.</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system: FlowSystem, prefix: str = '') -&gt; None\n</code></pre> <p>Link this interface and all nested interfaces to a FlowSystem.</p> <p>This method is called automatically during element registration to enable elements to access FlowSystem properties without passing the reference through every method call. It also sets the prefix used for naming transformed data.</p> <p>Subclasses with nested Interface objects should override this method to propagate the link to their nested interfaces by calling <code>super().link_to_flow_system(flow_system, prefix)</code> first, then linking nested objects with appropriate prefixes.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to link to</p> required <code>prefix</code> <code>str</code> <p>The prefix for naming transformed data (e.g., 'Boiler(Q_th)')</p> <code>''</code> <p>Examples:</p> <p>Override in a subclass with nested interfaces:</p> <pre><code>def link_to_flow_system(self, flow_system, prefix: str = '') -&gt; None:\n    super().link_to_flow_system(flow_system, prefix)\n    if self.nested_interface is not None:\n        self.nested_interface.link_to_flow_system(flow_system, f'{prefix}|nested' if prefix else 'nested')\n</code></pre> <p>Creating an Interface dynamically during modeling:</p> <pre><code># In a Model class\nif flow.status_parameters is None:\n    flow.status_parameters = StatusParameters()\n    flow.status_parameters.link_to_flow_system(self._model.flow_system, f'{flow.label_full}')\n</code></pre>"},{"location":"api-reference/structure/#flixopt.structure.Interface.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/structure/#flixopt.structure.Element","title":"Element","text":"<pre><code>Element(label: str, meta_data: dict | None = None, color: str | None = None, _variable_names: list[str] | None = None, _constraint_names: list[str] | None = None)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>This class is the basic Element of flixopt. Every Element has a label</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the element</p> required <code>meta_data</code> <code>dict | None</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code> <code>color</code> <code>str | None</code> <p>Optional color for visualizations (e.g., '#FF6B6B'). If not provided, a color will be automatically assigned during FlowSystem.connect_and_transform().</p> <code>None</code> <code>_variable_names</code> <code>list[str] | None</code> <p>Internal. Variable names for this element (populated after modeling).</p> <code>None</code> <code>_constraint_names</code> <code>list[str] | None</code> <p>Internal. Constraint names for this element (populated after modeling).</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure.Element-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.Element.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Dataset\n</code></pre> <p>Solution data for this element's variables.</p> <p>Returns a view into FlowSystem.solution containing only this element's variables.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no solution is available (optimization not run or not solved).</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.prefix","title":"prefix  <code>property</code>","text":"<pre><code>prefix: str\n</code></pre> <p>The prefix used for naming transformed data (e.g., 'Boiler(Q_th)|status_parameters').</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.flow_system","title":"flow_system  <code>property</code>","text":"<pre><code>flow_system: FlowSystem\n</code></pre> <p>Access the FlowSystem this interface is linked to.</p> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>The FlowSystem instance this interface belongs to.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If interface has not been linked to a FlowSystem yet.</p> Note <p>For Elements, this is set during add_elements(). For parameter classes, this is set recursively when the parent Element is registered.</p>"},{"location":"api-reference/structure/#flixopt.structure.Element-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Element.transform_data","title":"transform_data","text":"<pre><code>transform_data() -&gt; None\n</code></pre> <p>Transform the data of the interface to match the FlowSystem's dimensions.</p> <p>Uses <code>self._prefix</code> (set during <code>link_to_flow_system()</code>) to name transformed data.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Must be implemented by subclasses</p> Note <p>The FlowSystem reference is available via self._flow_system (for Interface objects) or self.flow_system property (for Element objects). Elements must be registered to a FlowSystem before calling this method.</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.link_to_flow_system","title":"link_to_flow_system","text":"<pre><code>link_to_flow_system(flow_system: FlowSystem, prefix: str = '') -&gt; None\n</code></pre> <p>Link this interface and all nested interfaces to a FlowSystem.</p> <p>This method is called automatically during element registration to enable elements to access FlowSystem properties without passing the reference through every method call. It also sets the prefix used for naming transformed data.</p> <p>Subclasses with nested Interface objects should override this method to propagate the link to their nested interfaces by calling <code>super().link_to_flow_system(flow_system, prefix)</code> first, then linking nested objects with appropriate prefixes.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to link to</p> required <code>prefix</code> <code>str</code> <p>The prefix for naming transformed data (e.g., 'Boiler(Q_th)')</p> <code>''</code> <p>Examples:</p> <p>Override in a subclass with nested interfaces:</p> <pre><code>def link_to_flow_system(self, flow_system, prefix: str = '') -&gt; None:\n    super().link_to_flow_system(flow_system, prefix)\n    if self.nested_interface is not None:\n        self.nested_interface.link_to_flow_system(flow_system, f'{prefix}|nested' if prefix else 'nested')\n</code></pre> <p>Creating an Interface dynamically during modeling:</p> <pre><code># In a Model class\nif flow.status_parameters is None:\n    flow.status_parameters = StatusParameters()\n    flow.status_parameters.link_to_flow_system(self._model.flow_system, f'{flow.label_full}')\n</code></pre>"},{"location":"api-reference/structure/#flixopt.structure.Element.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset() -&gt; xr.Dataset\n</code></pre> <p>Convert the object to an xarray Dataset representation. All DataArrays become dataset variables, everything else goes to attrs.</p> <p>Its recommended to only call this method on Interfaces with all numeric data stored as xr.DataArrays. Interfaces inside a FlowSystem are automatically converted this form after connecting and transforming the FlowSystem.</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Dataset containing all DataArrays with basic objects only in attributes</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails due to naming conflicts or invalid data</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 5, overwrite: bool = False)\n</code></pre> <p>Save the object to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the NetCDF file. Parent directories are created if they don't exist.</p> required <code>compression</code> <code>int</code> <p>Compression level (0-9)</p> <code>5</code> <code>overwrite</code> <code>bool</code> <p>If True, overwrite existing file. If False, raise error if file exists.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If overwrite=False and file already exists.</p> <code>ValueError</code> <p>If serialization fails</p> <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.from_dataset","title":"from_dataset  <code>classmethod</code>","text":"<pre><code>from_dataset(ds: Dataset) -&gt; Interface\n</code></pre> <p>Create an instance from an xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset containing the object data</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dataset format is invalid or class mismatch</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path) -&gt; Interface\n</code></pre> <p>Load an instance from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the NetCDF file</p> required <p>Returns:</p> Type Description <code>Interface</code> <p>Interface instance</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be read</p> <code>ValueError</code> <p>If file format is invalid</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.get_structure","title":"get_structure","text":"<pre><code>get_structure(clean: bool = False, stats: bool = False) -&gt; dict\n</code></pre> <p>Get object structure as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, remove None and empty dicts and lists.</p> <code>False</code> <code>stats</code> <code>bool</code> <p>If True, replace DataArray references with statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the object structure</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Save the object to a JSON file. This is meant for documentation and comparison, not for reloading.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the JSON file.</p> required <p>Raises:</p> Type Description <code>IOError</code> <p>If file cannot be written</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.copy","title":"copy","text":"<pre><code>copy() -&gt; Interface\n</code></pre> <p>Create a copy of the Interface object.</p> <p>Uses the existing serialization infrastructure to ensure proper copying of all DataArrays and nested objects.</p> <p>Returns:</p> Type Description <code>Interface</code> <p>A new instance of the same class with copied data.</p>"},{"location":"api-reference/structure/#flixopt.structure.ContainerMixin","title":"ContainerMixin","text":"<pre><code>ContainerMixin(elements: list[T] | dict[str, T] | None = None, element_type_name: str = 'elements', truncate_repr: int | None = None, item_name: str | None = None)\n</code></pre> <p>               Bases: <code>dict[str, T]</code></p> <p>Mixin providing shared container functionality with nice repr and error messages.</p> <p>Subclasses must implement _get_label() to extract the label from elements.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>list[T] | dict[str, T] | None</code> <p>Initial elements to add (list or dict)</p> <code>None</code> <code>element_type_name</code> <code>str</code> <p>Name for display (e.g., 'components', 'buses')</p> <code>'elements'</code> <code>truncate_repr</code> <code>int | None</code> <p>Maximum number of items to show in repr. If None, show all items. Default: None</p> <code>None</code> <code>item_name</code> <code>str | None</code> <p>Singular name for error messages (e.g., 'Component', 'Carrier'). If None, inferred from first added item's class name.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure.ContainerMixin-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.ContainerMixin.add","title":"add","text":"<pre><code>add(element: T) -&gt; None\n</code></pre> <p>Add an element to the container.</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementContainer","title":"ElementContainer","text":"<pre><code>ElementContainer(elements: list[T] | dict[str, T] | None = None, element_type_name: str = 'elements', truncate_repr: int | None = None, item_name: str | None = None)\n</code></pre> <p>               Bases: <code>ContainerMixin[T]</code></p> <p>Container for Element objects (Component, Bus, Flow, Effect).</p> <p>Uses element.label_full for keying.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>list[T] | dict[str, T] | None</code> <p>Initial elements to add (list or dict)</p> <code>None</code> <code>element_type_name</code> <code>str</code> <p>Name for display (e.g., 'components', 'buses')</p> <code>'elements'</code> <code>truncate_repr</code> <code>int | None</code> <p>Maximum number of items to show in repr. If None, show all items. Default: None</p> <code>None</code> <code>item_name</code> <code>str | None</code> <p>Singular name for error messages (e.g., 'Component', 'Carrier'). If None, inferred from first added item's class name.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure.ElementContainer-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.ElementContainer.add","title":"add","text":"<pre><code>add(element: T) -&gt; None\n</code></pre> <p>Add an element to the container.</p>"},{"location":"api-reference/structure/#flixopt.structure.ResultsContainer","title":"ResultsContainer","text":"<pre><code>ResultsContainer(elements: list[T] | dict[str, T] | None = None, element_type_name: str = 'elements', truncate_repr: int | None = None, item_name: str | None = None)\n</code></pre> <p>               Bases: <code>ContainerMixin[T]</code></p> <p>Container for Results objects (ComponentResults, BusResults, etc).</p> <p>Uses element.label for keying.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>list[T] | dict[str, T] | None</code> <p>Initial elements to add (list or dict)</p> <code>None</code> <code>element_type_name</code> <code>str</code> <p>Name for display (e.g., 'components', 'buses')</p> <code>'elements'</code> <code>truncate_repr</code> <code>int | None</code> <p>Maximum number of items to show in repr. If None, show all items. Default: None</p> <code>None</code> <code>item_name</code> <code>str | None</code> <p>Singular name for error messages (e.g., 'Component', 'Carrier'). If None, inferred from first added item's class name.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure.ResultsContainer-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.ResultsContainer.add","title":"add","text":"<pre><code>add(element: T) -&gt; None\n</code></pre> <p>Add an element to the container.</p>"},{"location":"api-reference/structure/#flixopt.structure.FlowContainer","title":"FlowContainer","text":"<pre><code>FlowContainer(elements: list[T] | dict[str, T] | None = None, element_type_name: str = 'elements', truncate_repr: int | None = None, item_name: str | None = None)\n</code></pre> <p>               Bases: <code>ContainerMixin[T]</code></p> <p>Container for Flow objects with dual access: by index or by label_full.</p> Supports <ul> <li>container['Boiler(Q_th)']  # label_full-based access</li> <li>container['Q_th']          # short-label access (when all flows share same component)</li> <li>container[0]               # index-based access</li> <li>container.add(flow)</li> <li>for flow in container.values()</li> <li>container1 + container2    # concatenation</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; boiler = Boiler(label='Boiler', inputs=[Flow('Q_th', bus=heat_bus)])\n&gt;&gt;&gt; boiler.inputs[0]  # Index access\n&gt;&gt;&gt; boiler.inputs['Boiler(Q_th)']  # Full label access\n&gt;&gt;&gt; boiler.inputs['Q_th']  # Short label access (same component)\n&gt;&gt;&gt; for flow in boiler.inputs.values():\n...     print(flow.label_full)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>list[T] | dict[str, T] | None</code> <p>Initial elements to add (list or dict)</p> <code>None</code> <code>element_type_name</code> <code>str</code> <p>Name for display (e.g., 'components', 'buses')</p> <code>'elements'</code> <code>truncate_repr</code> <code>int | None</code> <p>Maximum number of items to show in repr. If None, show all items. Default: None</p> <code>None</code> <code>item_name</code> <code>str | None</code> <p>Singular name for error messages (e.g., 'Component', 'Carrier'). If None, inferred from first added item's class name.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure.FlowContainer-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.FlowContainer.add","title":"add","text":"<pre><code>add(element: T) -&gt; None\n</code></pre> <p>Add an element to the container.</p>"},{"location":"api-reference/structure/#flixopt.structure.CompositeContainerMixin","title":"CompositeContainerMixin","text":"<p>               Bases: <code>Generic[T_element]</code></p> <p>Mixin providing unified dict-like access across multiple typed containers.</p> <p>This mixin enables classes that manage multiple containers (e.g., components, buses, effects, flows) to provide a unified interface for accessing elements across all containers, as if they were a single collection.</p> Type Parameter <p>T_element: The type of elements stored in the containers. Can be a union type     for containers holding multiple types (e.g., 'ComponentResults | BusResults').</p> Key Features <ul> <li>Dict-like access: <code>obj['element_name']</code> searches all containers</li> <li>Iteration: <code>for label in obj:</code> iterates over all elements</li> <li>Membership: <code>'element' in obj</code> checks across all containers</li> <li>Standard dict methods: keys(), values(), items()</li> <li>Grouped display: Formatted repr showing elements by type</li> <li>Type hints: Full IDE and type checker support</li> </ul> Subclasses must implement <p>_get_container_groups() -&gt; dict[str, dict]:     Returns a dictionary mapping group names (e.g., 'Components', 'Buses')     to container dictionaries. Containers are displayed in the order returned.</p> Example <pre><code>class MySystem(CompositeContainerMixin[Component | Bus]):\n    def __init__(self):\n        self.components = {'Boiler': Component(...), 'CHP': Component(...)}\n        self.buses = {'Heat': Bus(...), 'Power': Bus(...)}\n\n    def _get_container_groups(self):\n        return {\n            'Components': self.components,\n            'Buses': self.buses,\n        }\n\n\nsystem = MySystem()\ncomp = system['Boiler']  # Type: Component | Bus (with proper IDE support)\n'Heat' in system  # True\nlabels = system.keys()  # Type: list[str]\nelements = system.values()  # Type: list[Component | Bus]\n</code></pre> Integration with ContainerMixin <p>This mixin is designed to work alongside ContainerMixin-based containers (ElementContainer, ResultsContainer) by aggregating them into a unified interface while preserving their individual functionality.</p>"},{"location":"api-reference/structure/#flixopt.structure.CompositeContainerMixin-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.CompositeContainerMixin.keys","title":"keys","text":"<pre><code>keys() -&gt; list[str]\n</code></pre> <p>Return all element labels across all containers.</p>"},{"location":"api-reference/structure/#flixopt.structure.CompositeContainerMixin.values","title":"values","text":"<pre><code>values() -&gt; list[T_element]\n</code></pre> <p>Return all element objects across all containers.</p>"},{"location":"api-reference/structure/#flixopt.structure.CompositeContainerMixin.items","title":"items","text":"<pre><code>items() -&gt; list[tuple[str, T_element]]\n</code></pre> <p>Return (label, element) pairs for all elements.</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel","title":"Submodel","text":"<pre><code>Submodel(model: FlowSystemModel, label_of_element: str, label_of_model: str | None = None)\n</code></pre> <p>               Bases: <code>SubmodelsMixin</code></p> <p>Stores Variables and Constraints. Its a subset of a FlowSystemModel. Variables and constraints are stored in the main FlowSystemModel, and are referenced here. Can have other Submodels assigned, and can be a Submodel of another Submodel.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FlowSystemModel</code> <p>The FlowSystemModel that is used to create the model.</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>label_of_model</code> <code>str | None</code> <p>The label of the model. Used as a prefix in all variables and constraints.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure.Submodel-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.Submodel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Submodel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodels","title":"Submodels  <code>dataclass</code>","text":"<pre><code>Submodels(data: dict[str, Submodel])\n</code></pre> <p>A simple collection for storing submodels with easy access and representation.</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodels-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Submodels.add","title":"add","text":"<pre><code>add(submodel: Submodel, name: str) -&gt; None\n</code></pre> <p>Add a submodel to the collection.</p>"},{"location":"api-reference/structure/#flixopt.structure.Submodels.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get submodel by name, returning default if not found.</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel","title":"ElementModel","text":"<pre><code>ElementModel(model: FlowSystemModel, element: Element)\n</code></pre> <p>               Bases: <code>Submodel</code></p> <p>Stores the mathematical Variables and Constraints for Elements. ElementModels are directly registered in the main FlowSystemModel</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>FlowSystemModel</code> <p>The FlowSystemModel that is used to create the model.</p> required <code>element</code> <code>Element</code> <p>The element this model is created for.</p> required"},{"location":"api-reference/structure/#flixopt.structure.ElementModel-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.ElementModel.all_submodels","title":"all_submodels  <code>property</code>","text":"<pre><code>all_submodels: list[Submodel]\n</code></pre> <p>Get all submodels including nested ones recursively.</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.variables_direct","title":"variables_direct  <code>property</code>","text":"<pre><code>variables_direct: Variables\n</code></pre> <p>Variables of the model, excluding those of sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.constraints_direct","title":"constraints_direct  <code>property</code>","text":"<pre><code>constraints_direct: Constraints\n</code></pre> <p>Constraints of the model, excluding those of sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>All constraints of the model, including those of all sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>All variables of the model, including those of all sub-models</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.ElementModel.add_submodels","title":"add_submodels","text":"<pre><code>add_submodels(submodel: Submodel, short_name: str = None) -&gt; Submodel\n</code></pre> <p>Register a sub-model with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.add_variables","title":"add_variables","text":"<pre><code>add_variables(short_name: str = None, category: VariableCategory = None, **kwargs: Any) -&gt; linopy.Variable\n</code></pre> <p>Create and register a variable in one step.</p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name for the variable (used as suffix in full name).</p> <code>None</code> <code>category</code> <code>VariableCategory</code> <p>Category for segment expansion handling. See VariableCategory.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to linopy.Model.add_variables().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Variable</code> <p>The created linopy Variable.</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.add_constraints","title":"add_constraints","text":"<pre><code>add_constraints(expression, short_name: str = None, **kwargs) -&gt; linopy.Constraint\n</code></pre> <p>Create and register a constraint in one step</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.register_variable","title":"register_variable","text":"<pre><code>register_variable(variable: Variable, short_name: str = None) -&gt; linopy.Variable\n</code></pre> <p>Register a variable with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.register_constraint","title":"register_constraint","text":"<pre><code>register_constraint(constraint: Constraint, short_name: str = None) -&gt; linopy.Constraint\n</code></pre> <p>Register a constraint with the model</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel.get","title":"get","text":"<pre><code>get(name: str, default=None)\n</code></pre> <p>Get variable by short name, returning default if not found</p>"},{"location":"api-reference/structure/#flixopt.structure-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.register_class_for_io","title":"register_class_for_io","text":"<pre><code>register_class_for_io(cls)\n</code></pre> <p>Register a class for serialization/deserialization.</p>"},{"location":"api-reference/topology_accessor/","title":"Topology accessor","text":""},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor","title":"flixopt.topology_accessor","text":"<p>Topology accessor for FlowSystem.</p> <p>This module provides the TopologyAccessor class that enables the <code>flow_system.topology</code> pattern for network structure inspection and visualization.</p>"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor-attributes","title":"Attributes","text":""},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor-classes","title":"Classes","text":""},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor","title":"TopologyAccessor","text":"<pre><code>TopologyAccessor(flow_system: FlowSystem)\n</code></pre> <p>Accessor for network topology inspection and visualization on FlowSystem.</p> <p>This class provides the topology API for FlowSystem, accessible via <code>flow_system.topology</code>. It offers methods to inspect the network structure and visualize it.</p> <p>Examples:</p> <p>Visualize the network:</p> <pre><code>&gt;&gt;&gt; flow_system.topology.plot()\n&gt;&gt;&gt; flow_system.topology.plot(path='my_network.html', show=True)\n</code></pre> <p>Interactive visualization:</p> <pre><code>&gt;&gt;&gt; flow_system.topology.start_app()\n&gt;&gt;&gt; # ... interact with the visualization ...\n&gt;&gt;&gt; flow_system.topology.stop_app()\n</code></pre> <p>Get network structure info:</p> <pre><code>&gt;&gt;&gt; nodes, edges = flow_system.topology.infos()\n</code></pre> <p>Initialize the accessor with a reference to the FlowSystem.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to inspect.</p> required"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor-attributes","title":"Attributes","text":""},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor.carrier_colors","title":"carrier_colors  <code>property</code>","text":"<pre><code>carrier_colors: dict[str, str]\n</code></pre> <p>Cached mapping of carrier name to hex color.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dict mapping carrier names (lowercase) to hex color strings.</p> <code>dict[str, str]</code> <p>Only carriers with a color defined are included.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fs.topology.carrier_colors\n{'electricity': '#FECB52', 'heat': '#D62728', 'gas': '#1F77B4'}\n</code></pre>"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor.component_colors","title":"component_colors  <code>property</code>","text":"<pre><code>component_colors: dict[str, str]\n</code></pre> <p>Cached mapping of component label to hex color.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dict mapping component labels to hex color strings.</p> <code>dict[str, str]</code> <p>Only components with a color defined are included.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fs.topology.component_colors\n{'Boiler': '#1f77b4', 'CHP': '#ff7f0e', 'HeatPump': '#2ca02c'}\n</code></pre>"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor.bus_colors","title":"bus_colors  <code>property</code>","text":"<pre><code>bus_colors: dict[str, str]\n</code></pre> <p>Cached mapping of bus label to hex color (from carrier).</p> <p>Bus colors are derived from their associated carrier's color.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dict mapping bus labels to hex color strings.</p> <code>dict[str, str]</code> <p>Only buses with a carrier that has a color defined are included.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fs.topology.bus_colors\n{'ElectricityBus': '#FECB52', 'HeatBus': '#D62728'}\n</code></pre>"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor.carrier_units","title":"carrier_units  <code>property</code>","text":"<pre><code>carrier_units: dict[str, str]\n</code></pre> <p>Cached mapping of carrier name to unit string.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dict mapping carrier names (lowercase) to unit strings.</p> <code>dict[str, str]</code> <p>Carriers without a unit defined return an empty string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fs.topology.carrier_units\n{'electricity': 'kW', 'heat': 'kW', 'gas': 'kW'}\n</code></pre>"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor.effect_units","title":"effect_units  <code>property</code>","text":"<pre><code>effect_units: dict[str, str]\n</code></pre> <p>Cached mapping of effect label to unit string.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dict mapping effect labels to unit strings.</p> <code>dict[str, str]</code> <p>Effects without a unit defined return an empty string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fs.topology.effect_units\n{'costs': '\u20ac', 'CO2': 'kg'}\n</code></pre>"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor-functions","title":"Functions","text":""},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor.set_component_color","title":"set_component_color","text":"<pre><code>set_component_color(label: str, color: str) -&gt; None\n</code></pre> <p>Set the color for a single component.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Component label.</p> required <code>color</code> <code>str</code> <p>Color string (hex like '#FF0000', named like 'red', etc.).</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If component with given label doesn't exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.topology.set_component_color('Boiler', '#D35400')\n&gt;&gt;&gt; flow_system.topology.set_component_color('CHP', 'darkred')\n</code></pre>"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor.set_component_colors","title":"set_component_colors","text":"<pre><code>set_component_colors(colors: dict[str, str | list[str]] | str, overwrite: bool = True) -&gt; dict[str, str]\n</code></pre> <p>Set colors for multiple components at once.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>dict[str, str | list[str]] | str</code> <p>Color configuration: - <code>str</code>: Colorscale name for all components (e.g., <code>'turbo'</code>) - <code>dict</code>: Component-to-color mapping (<code>{'Boiler': 'red'}</code>) or   colorscale-to-components (<code>{'Blues': ['Wind1', 'Wind2']}</code>)</p> required <code>overwrite</code> <code>bool</code> <p>If False, skip components that already have colors.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Mapping of colors that were actually assigned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.topology.set_component_colors('turbo')\n&gt;&gt;&gt; flow_system.topology.set_component_colors({'Boiler': 'red', 'CHP': '#0000FF'})\n&gt;&gt;&gt; flow_system.topology.set_component_colors({'Blues': ['Wind1', 'Wind2']})\n&gt;&gt;&gt; flow_system.topology.set_component_colors('turbo', overwrite=False)\n</code></pre>"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor.set_carrier_color","title":"set_carrier_color","text":"<pre><code>set_carrier_color(carrier: str, color: str) -&gt; None\n</code></pre> <p>Set the color for a carrier.</p> <p>This affects bus colors derived from this carrier.</p> <p>Parameters:</p> Name Type Description Default <code>carrier</code> <code>str</code> <p>Carrier name (case-insensitive).</p> required <code>color</code> <code>str</code> <p>Color string (hex like '#FF0000', named like 'red', etc.).</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.topology.set_carrier_color('electricity', '#FECB52')\n&gt;&gt;&gt; flow_system.topology.set_carrier_color('heat', 'firebrick')\n</code></pre>"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor.infos","title":"infos","text":"<pre><code>infos() -&gt; tuple[dict[str, dict[str, str]], dict[str, dict[str, str]]]\n</code></pre> <p>Get network topology information as dictionaries.</p> <p>Returns node and edge information suitable for visualization or analysis.</p> <p>Returns:</p> Type Description <code>tuple[dict[str, dict[str, str]], dict[str, dict[str, str]]]</code> <p>Tuple of (nodes_dict, edges_dict) where: - nodes_dict maps node labels to their properties (label, class, infos) - edges_dict maps edge labels to their properties (label, start, end, infos)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; nodes, edges = flow_system.topology.infos()\n&gt;&gt;&gt; print(nodes.keys())  # All component and bus labels\n&gt;&gt;&gt; print(edges.keys())  # All flow labels\n</code></pre>"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor.plot","title":"plot","text":"<pre><code>plot(colors: ColorType | None = None, show: bool | None = None, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Visualize the network structure as a Sankey diagram using Plotly.</p> <p>Creates a Sankey diagram showing the topology of the flow system, with buses and components as nodes, and flows as links between them. All links have equal width since no solution data is used.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>ColorType | None</code> <p>Color specification for nodes (buses). - <code>None</code>: Uses default color palette based on buses. - <code>str</code>: Plotly colorscale name (e.g., 'Viridis', 'Blues'). - <code>list</code>: List of colors to cycle through. - <code>dict</code>: Maps bus labels to specific colors. Links inherit colors from their connected bus.</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure in the browser. - <code>None</code>: Uses default from CONFIG.Plotting.default_show.</p> <code>None</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to Plotly layout.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult containing the Sankey diagram figure and topology data</p> <code>PlotResult</code> <p>(source, target, value for each link).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.topology.plot()\n&gt;&gt;&gt; flow_system.topology.plot(show=True)\n&gt;&gt;&gt; flow_system.topology.plot(colors='Viridis')\n&gt;&gt;&gt; flow_system.topology.plot(colors={'ElectricityBus': 'gold', 'HeatBus': 'red'})\n</code></pre> Notes <p>This visualization shows the network structure without optimization results. For visualizations that include flow values, use <code>flow_system.statistics.plot.sankey.flows()</code> after running an optimization.</p> <p>Hover over nodes and links to see detailed element information.</p> See Also <ul> <li><code>plot_legacy()</code>: Previous PyVis-based network visualization.</li> <li><code>statistics.plot.sankey.flows()</code>: Sankey with actual flow values from optimization.</li> </ul>"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor.plot_legacy","title":"plot_legacy","text":"<pre><code>plot_legacy(path: bool | str | Path = 'flow_system.html', controls: bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']] = True, show: bool | None = None) -&gt; pyvis.network.Network | None\n</code></pre> <p>Visualize the network structure using PyVis, saving it as an interactive HTML file.</p> <p>.. deprecated::     Use <code>plot()</code> instead for the new Plotly-based Sankey visualization.     This method is kept for backwards compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>bool | str | Path</code> <p>Path to save the HTML visualization. - <code>False</code>: Visualization is created but not saved. - <code>str</code> or <code>Path</code>: Specifies file path (default: 'flow_system.html').</p> <code>'flow_system.html'</code> <code>controls</code> <code>bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]</code> <p>UI controls to add to the visualization. - <code>True</code>: Enables all available controls. - <code>List</code>: Specify controls, e.g., ['nodes', 'layout']. - Options: 'nodes', 'edges', 'layout', 'interaction', 'manipulation',   'physics', 'selection', 'renderer'.</p> <code>True</code> <code>show</code> <code>bool | None</code> <p>Whether to open the visualization in the web browser.</p> <code>None</code> <p>Returns:</p> Type Description <code>Network | None</code> <p>The <code>pyvis.network.Network</code> instance representing the visualization,</p> <code>Network | None</code> <p>or <code>None</code> if <code>pyvis</code> is not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.topology.plot_legacy()\n&gt;&gt;&gt; flow_system.topology.plot_legacy(show=False)\n&gt;&gt;&gt; flow_system.topology.plot_legacy(path='output/network.html', controls=['nodes', 'layout'])\n</code></pre> Notes <p>This function requires <code>pyvis</code>. If not installed, the function prints a warning and returns <code>None</code>. Nodes are styled based on type (circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor.start_app","title":"start_app","text":"<pre><code>start_app() -&gt; None\n</code></pre> <p>Start an interactive network visualization using Dash and Cytoscape.</p> <p>Launches a web-based interactive visualization server that allows exploring the network structure dynamically.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If required dependencies are not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.topology.start_app()\n&gt;&gt;&gt; # ... interact with the visualization in browser ...\n&gt;&gt;&gt; flow_system.topology.stop_app()\n</code></pre> Notes <p>Requires optional dependencies: dash, dash-cytoscape, dash-daq, networkx, flask, werkzeug. Install with: <code>pip install flixopt[network_viz]</code> or <code>pip install flixopt[full]</code></p>"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor.TopologyAccessor.stop_app","title":"stop_app","text":"<pre><code>stop_app() -&gt; None\n</code></pre> <p>Stop the interactive network visualization server.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.topology.stop_app()\n</code></pre>"},{"location":"api-reference/topology_accessor/#flixopt.topology_accessor-functions","title":"Functions","text":""},{"location":"api-reference/transform_accessor/","title":"Transform accessor","text":""},{"location":"api-reference/transform_accessor/#flixopt.transform_accessor","title":"flixopt.transform_accessor","text":"<p>Transform accessor for FlowSystem.</p> <p>This module provides the TransformAccessor class that enables transformations on FlowSystem like clustering, selection, and resampling.</p>"},{"location":"api-reference/transform_accessor/#flixopt.transform_accessor-attributes","title":"Attributes","text":""},{"location":"api-reference/transform_accessor/#flixopt.transform_accessor-classes","title":"Classes","text":""},{"location":"api-reference/transform_accessor/#flixopt.transform_accessor.TransformAccessor","title":"TransformAccessor","text":"<pre><code>TransformAccessor(flow_system: FlowSystem)\n</code></pre> <p>Accessor for transformation methods on FlowSystem.</p> <p>This class provides transformations that create new FlowSystem instances with modified structure or data, accessible via <code>flow_system.transform</code>.</p> <p>Examples:</p> <p>Time series aggregation (8 typical days):</p> <pre><code>&gt;&gt;&gt; reduced_fs = flow_system.transform.cluster(n_clusters=8, cluster_duration='1D')\n&gt;&gt;&gt; reduced_fs.optimize(solver)\n&gt;&gt;&gt; expanded_fs = reduced_fs.transform.expand()\n</code></pre> <p>Future MGA:</p> <pre><code>&gt;&gt;&gt; mga_fs = flow_system.transform.mga(alternatives=5)\n&gt;&gt;&gt; mga_fs.optimize(solver)\n</code></pre> <p>Initialize the accessor with a reference to the FlowSystem.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to transform.</p> required"},{"location":"api-reference/transform_accessor/#flixopt.transform_accessor.TransformAccessor-functions","title":"Functions","text":""},{"location":"api-reference/transform_accessor/#flixopt.transform_accessor.TransformAccessor.sel","title":"sel","text":"<pre><code>sel(time: str | slice | list[str] | Timestamp | DatetimeIndex | None = None, period: int | slice | list[int] | Index | None = None, scenario: str | slice | list[str] | Index | None = None) -&gt; FlowSystem\n</code></pre> <p>Select a subset of the FlowSystem by label.</p> <p>Creates a new FlowSystem with data selected along the specified dimensions. The returned FlowSystem has no solution (it must be re-optimized).</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>str | slice | list[str] | Timestamp | DatetimeIndex | None</code> <p>Time selection (e.g., slice('2023-01-01', '2023-12-31'), '2023-06-15')</p> <code>None</code> <code>period</code> <code>int | slice | list[int] | Index | None</code> <p>Period selection (e.g., slice(2023, 2024), or list of periods)</p> <code>None</code> <code>scenario</code> <code>str | slice | list[str] | Index | None</code> <p>Scenario selection (e.g., 'scenario1', or list of scenarios)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>New FlowSystem with selected data (no solution).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Select specific time range\n&gt;&gt;&gt; fs_jan = flow_system.transform.sel(time=slice('2023-01-01', '2023-01-31'))\n&gt;&gt;&gt; fs_jan.optimize(solver)\n</code></pre> <pre><code>&gt;&gt;&gt; # Select single scenario\n&gt;&gt;&gt; fs_base = flow_system.transform.sel(scenario='Base Case')\n</code></pre>"},{"location":"api-reference/transform_accessor/#flixopt.transform_accessor.TransformAccessor.isel","title":"isel","text":"<pre><code>isel(time: int | slice | list[int] | None = None, period: int | slice | list[int] | None = None, scenario: int | slice | list[int] | None = None) -&gt; FlowSystem\n</code></pre> <p>Select a subset of the FlowSystem by integer indices.</p> <p>Creates a new FlowSystem with data selected along the specified dimensions. The returned FlowSystem has no solution (it must be re-optimized).</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>int | slice | list[int] | None</code> <p>Time selection by integer index (e.g., slice(0, 100), 50, or [0, 5, 10])</p> <code>None</code> <code>period</code> <code>int | slice | list[int] | None</code> <p>Period selection by integer index</p> <code>None</code> <code>scenario</code> <code>int | slice | list[int] | None</code> <p>Scenario selection by integer index</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>New FlowSystem with selected data (no solution).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Select first 24 timesteps\n&gt;&gt;&gt; fs_day1 = flow_system.transform.isel(time=slice(0, 24))\n&gt;&gt;&gt; fs_day1.optimize(solver)\n</code></pre> <pre><code>&gt;&gt;&gt; # Select first scenario\n&gt;&gt;&gt; fs_first = flow_system.transform.isel(scenario=0)\n</code></pre>"},{"location":"api-reference/transform_accessor/#flixopt.transform_accessor.TransformAccessor.resample","title":"resample","text":"<pre><code>resample(time: str, method: Literal['mean', 'sum', 'max', 'min', 'first', 'last', 'std', 'var', 'median', 'count'] = 'mean', hours_of_last_timestep: int | float | None = None, hours_of_previous_timesteps: int | float | ndarray | None = None, fill_gaps: Literal['ffill', 'bfill', 'interpolate'] | None = None, **kwargs: Any) -&gt; FlowSystem\n</code></pre> <p>Create a resampled FlowSystem by resampling data along the time dimension.</p> <p>Creates a new FlowSystem with resampled time series data. The returned FlowSystem has no solution (it must be re-optimized).</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>str</code> <p>Resampling frequency (e.g., '3h', '2D', '1M')</p> required <code>method</code> <code>Literal['mean', 'sum', 'max', 'min', 'first', 'last', 'std', 'var', 'median', 'count']</code> <p>Resampling method. Recommended: 'mean', 'first', 'last', 'max', 'min'</p> <code>'mean'</code> <code>hours_of_last_timestep</code> <code>int | float | None</code> <p>Duration of the last timestep after resampling. If None, computed from the last time interval.</p> <code>None</code> <code>hours_of_previous_timesteps</code> <code>int | float | ndarray | None</code> <p>Duration of previous timesteps after resampling. If None, computed from the first time interval. Can be a scalar or array.</p> <code>None</code> <code>fill_gaps</code> <code>Literal['ffill', 'bfill', 'interpolate'] | None</code> <p>Strategy for filling gaps (NaN values) that arise when resampling irregular timesteps to regular intervals. Options: 'ffill' (forward fill), 'bfill' (backward fill), 'interpolate' (linear interpolation). If None (default), raises an error when gaps are detected.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to xarray.resample()</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>New resampled FlowSystem (no solution).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If resampling creates gaps and fill_gaps is not specified.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Resample to 4-hour intervals\n&gt;&gt;&gt; fs_4h = flow_system.transform.resample(time='4h', method='mean')\n&gt;&gt;&gt; fs_4h.optimize(solver)\n</code></pre> <pre><code>&gt;&gt;&gt; # Resample to daily with max values\n&gt;&gt;&gt; fs_daily = flow_system.transform.resample(time='1D', method='max')\n</code></pre>"},{"location":"api-reference/transform_accessor/#flixopt.transform_accessor.TransformAccessor.fix_sizes","title":"fix_sizes","text":"<pre><code>fix_sizes(sizes: Dataset | dict[str, float] | None = None, decimal_rounding: int | None = 5) -&gt; FlowSystem\n</code></pre> <p>Create a new FlowSystem with investment sizes fixed to specified values.</p> <p>This is useful for two-stage optimization workflows: 1. Solve a sizing problem (possibly resampled for speed) 2. Fix sizes and solve dispatch at full resolution</p> <p>The returned FlowSystem has InvestParameters with fixed_size set, making those sizes mandatory rather than decision variables.</p> <p>Parameters:</p> Name Type Description Default <code>sizes</code> <code>Dataset | dict[str, float] | None</code> <p>The sizes to fix. Can be: - None: Uses sizes from this FlowSystem's solution (must be solved) - xr.Dataset: Dataset with size variables (e.g., from statistics.sizes) - dict: Mapping of component names to sizes (e.g., {'Boiler(Q_fu)': 100})</p> <code>None</code> <code>decimal_rounding</code> <code>int | None</code> <p>Number of decimal places to round sizes to. Rounding helps avoid numerical infeasibility. Set to None to disable.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>New FlowSystem with fixed sizes (no solution).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no sizes provided and FlowSystem has no solution.</p> <code>KeyError</code> <p>If a specified size doesn't match any InvestParameters.</p> <p>Examples:</p> <p>Two-stage optimization:</p> <pre><code>&gt;&gt;&gt; # Stage 1: Size with resampled data\n&gt;&gt;&gt; fs_sizing = flow_system.transform.resample('2h')\n&gt;&gt;&gt; fs_sizing.optimize(solver)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Stage 2: Fix sizes and optimize at full resolution\n&gt;&gt;&gt; fs_dispatch = flow_system.transform.fix_sizes(fs_sizing.statistics.sizes)\n&gt;&gt;&gt; fs_dispatch.optimize(solver)\n</code></pre> <p>Using a dict:</p> <pre><code>&gt;&gt;&gt; fs_fixed = flow_system.transform.fix_sizes(\n...     {\n...         'Boiler(Q_fu)': 100,\n...         'Storage': 500,\n...     }\n... )\n&gt;&gt;&gt; fs_fixed.optimize(solver)\n</code></pre>"},{"location":"api-reference/transform_accessor/#flixopt.transform_accessor.TransformAccessor.clustering_data","title":"clustering_data","text":"<pre><code>clustering_data(period: Any | None = None, scenario: Any | None = None) -&gt; xr.Dataset\n</code></pre> <p>Get the time-varying data that would be used for clustering.</p> <p>This method extracts only the data arrays that vary over time, which is the data that clustering algorithms use to identify typical periods. Constant arrays (same value for all timesteps) are excluded since they don't contribute to pattern identification.</p> <p>Use this to inspect or pre-process the data before clustering, or to understand which variables influence the clustering result.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>Any | None</code> <p>Optional period label to select. If None and the FlowSystem has multiple periods, returns data for all periods.</p> <code>None</code> <code>scenario</code> <code>Any | None</code> <p>Optional scenario label to select. If None and the FlowSystem has multiple scenarios, returns data for all scenarios.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset containing only time-varying data arrays. The dataset</p> <code>Dataset</code> <p>includes arrays like demand profiles, price profiles, and other</p> <code>Dataset</code> <p>time series that vary over the time dimension.</p> <p>Examples:</p> <p>Inspect clustering input data:</p> <pre><code>&gt;&gt;&gt; data = flow_system.transform.clustering_data()\n&gt;&gt;&gt; print(f'Variables used for clustering: {list(data.data_vars)}')\n&gt;&gt;&gt; data['HeatDemand(Q)|fixed_relative_profile'].plot()\n</code></pre> <p>Get data for a specific period/scenario:</p> <pre><code>&gt;&gt;&gt; data_2024 = flow_system.transform.clustering_data(period=2024)\n&gt;&gt;&gt; data_high = flow_system.transform.clustering_data(scenario='high')\n</code></pre> <p>Convert to DataFrame for external tools:</p> <pre><code>&gt;&gt;&gt; df = flow_system.transform.clustering_data().to_dataframe()\n</code></pre>"},{"location":"api-reference/transform_accessor/#flixopt.transform_accessor.TransformAccessor.cluster","title":"cluster","text":"<pre><code>cluster(n_clusters: int, cluster_duration: str | float, data_vars: list[str] | None = None, cluster: ClusterConfig | None = None, extremes: ExtremeConfig | None = None, segments: SegmentConfig | None = None, preserve_column_means: bool = True, rescale_exclude_columns: list[str] | None = None, round_decimals: int | None = None, numerical_tolerance: float = 1e-13, **tsam_kwargs: Any) -&gt; FlowSystem\n</code></pre> <p>Create a FlowSystem with reduced timesteps using typical clusters.</p> <p>This method creates a new FlowSystem optimized for sizing studies by reducing the number of timesteps to only the typical (representative) clusters identified through time series aggregation using the tsam package.</p> <p>The method: 1. Performs time series clustering using tsam (hierarchical by default) 2. Extracts only the typical clusters (not all original timesteps) 3. Applies timestep weighting for accurate cost representation 4. Handles storage states between clusters based on each Storage's <code>cluster_mode</code></p> <p>Use this for initial sizing optimization, then use <code>fix_sizes()</code> to re-optimize at full resolution for accurate dispatch results.</p> <p>To reuse an existing clustering on different data, use <code>apply_clustering()</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>n_clusters</code> <code>int</code> <p>Number of clusters (typical periods) to extract (e.g., 8 typical days).</p> required <code>cluster_duration</code> <code>str | float</code> <p>Duration of each cluster. Can be a pandas-style string ('1D', '24h', '6h') or a numeric value in hours.</p> required <code>data_vars</code> <code>list[str] | None</code> <p>Optional list of variable names to use for clustering. If specified, only these variables are used to determine cluster assignments, but the clustering is then applied to ALL time-varying data in the FlowSystem. Use <code>transform.clustering_data()</code> to see available variables. Example: <code>data_vars=['HeatDemand(Q)|fixed_relative_profile']</code> to cluster based only on heat demand patterns.</p> <code>None</code> <code>cluster</code> <code>ClusterConfig | None</code> <p>Optional tsam <code>ClusterConfig</code> object specifying clustering algorithm, representation method, and weights. If None, uses default settings (hierarchical clustering with medoid representation) and automatically calculated weights based on data variance.</p> <code>None</code> <code>extremes</code> <code>ExtremeConfig | None</code> <p>Optional tsam <code>ExtremeConfig</code> object specifying how to handle extreme periods (peaks). Use this to ensure peak demand days are captured. Example: <code>ExtremeConfig(method='new_cluster', max_value=['demand'])</code>.</p> <code>None</code> <code>segments</code> <code>SegmentConfig | None</code> <p>Optional tsam <code>SegmentConfig</code> object specifying intra-period segmentation. Segments divide each cluster period into variable-duration sub-segments. Example: <code>SegmentConfig(n_segments=4)</code>.</p> <code>None</code> <code>preserve_column_means</code> <code>bool</code> <p>Rescale typical periods so each column's weighted mean matches the original data's mean. Ensures total energy/load is preserved when weights represent occurrence counts. Default is True.</p> <code>True</code> <code>rescale_exclude_columns</code> <code>list[str] | None</code> <p>Column names to exclude from rescaling when <code>preserve_column_means=True</code>. Useful for binary/indicator columns (0/1 values) that should not be rescaled.</p> <code>None</code> <code>round_decimals</code> <code>int | None</code> <p>Round output values to this many decimal places. If None (default), no rounding is applied.</p> <code>None</code> <code>numerical_tolerance</code> <code>float</code> <p>Tolerance for numerical precision issues. Controls when warnings are raised for aggregated values exceeding original time series bounds. Default is 1e-13.</p> <code>1e-13</code> <code>**tsam_kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to <code>tsam.aggregate()</code> for forward compatibility. See tsam documentation for all options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FlowSystem</code> <p>A new FlowSystem with reduced timesteps (only typical clusters).</p> <code>FlowSystem</code> <p>The FlowSystem has metadata stored in <code>clustering</code> for expansion.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If timestep sizes are inconsistent.</p> <code>ValueError</code> <p>If cluster_duration is not a multiple of timestep size.</p> <p>Examples:</p> <p>Basic clustering with peak preservation:</p> <pre><code>&gt;&gt;&gt; from tsam import ExtremeConfig\n&gt;&gt;&gt; fs_clustered = flow_system.transform.cluster(\n...     n_clusters=8,\n...     cluster_duration='1D',\n...     extremes=ExtremeConfig(\n...         method='new_cluster',\n...         max_value=['HeatDemand(Q_th)|fixed_relative_profile'],\n...     ),\n... )\n&gt;&gt;&gt; fs_clustered.optimize(solver)\n</code></pre> <p>Clustering based on specific variables only:</p> <pre><code>&gt;&gt;&gt; # See available variables for clustering\n&gt;&gt;&gt; print(flow_system.transform.clustering_data().data_vars)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Cluster based only on demand profile\n&gt;&gt;&gt; fs_clustered = flow_system.transform.cluster(\n...     n_clusters=8,\n...     cluster_duration='1D',\n...     data_vars=['HeatDemand(Q)|fixed_relative_profile'],\n... )\n</code></pre> Note <ul> <li>This is best suited for initial sizing, not final dispatch optimization</li> <li>Use <code>extremes</code> to ensure peak demand clusters are captured</li> <li>A 5-10% safety margin on sizes is recommended for the dispatch stage</li> <li>For seasonal storage (e.g., hydrogen, thermal storage), set   <code>Storage.cluster_mode='intercluster'</code> or <code>'intercluster_cyclic'</code></li> </ul>"},{"location":"api-reference/transform_accessor/#flixopt.transform_accessor.TransformAccessor.apply_clustering","title":"apply_clustering","text":"<pre><code>apply_clustering(clustering: Clustering) -&gt; FlowSystem\n</code></pre> <p>Apply an existing clustering to this FlowSystem.</p> <p>This method applies a previously computed clustering (from another FlowSystem) to the current FlowSystem's data. The clustering structure (cluster assignments, number of clusters, etc.) is preserved while the time series data is aggregated according to the existing cluster assignments.</p> <p>Use this to: - Compare different scenarios with identical cluster assignments - Apply a reference clustering to new data</p> <p>Parameters:</p> Name Type Description Default <code>clustering</code> <code>Clustering</code> <p>A <code>Clustering</code> object from a previously clustered FlowSystem. Obtain this via <code>fs.clustering</code> from a clustered FlowSystem.</p> required <p>Returns:</p> Type Description <code>FlowSystem</code> <p>A new FlowSystem with reduced timesteps (only typical clusters).</p> <code>FlowSystem</code> <p>The FlowSystem has metadata stored in <code>clustering</code> for expansion.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the clustering dimensions don't match this FlowSystem's periods/scenarios.</p> <p>Examples:</p> <p>Apply clustering from one FlowSystem to another:</p> <pre><code>&gt;&gt;&gt; fs_reference = fs_base.transform.cluster(n_clusters=8, cluster_duration='1D')\n&gt;&gt;&gt; fs_other = fs_high.transform.apply_clustering(fs_reference.clustering)\n</code></pre>"},{"location":"api-reference/transform_accessor/#flixopt.transform_accessor.TransformAccessor.expand","title":"expand","text":"<pre><code>expand() -&gt; FlowSystem\n</code></pre> <p>Expand a clustered FlowSystem back to full original timesteps.</p> <p>After solving a FlowSystem created with <code>cluster()</code>, this method disaggregates the FlowSystem by: 1. Expanding all time series data from typical clusters to full timesteps 2. Expanding the solution by mapping each typical cluster back to all    original clusters it represents</p> <p>For FlowSystems with periods and/or scenarios, each (period, scenario) combination is expanded using its own cluster assignment.</p> <p>This enables using all existing solution accessors (<code>statistics</code>, <code>plot</code>, etc.) with full time resolution, where both the data and solution are consistently expanded from the typical clusters.</p> <p>Returns:</p> Name Type Description <code>FlowSystem</code> <code>FlowSystem</code> <p>A new FlowSystem with full timesteps and expanded solution.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the FlowSystem was not created with <code>cluster()</code>.</p> <code>ValueError</code> <p>If the FlowSystem has no solution.</p> <p>Examples:</p> <p>Two-stage optimization with expansion:</p> <pre><code>&gt;&gt;&gt; # Stage 1: Size with reduced timesteps\n&gt;&gt;&gt; fs_reduced = flow_system.transform.cluster(\n...     n_clusters=8,\n...     cluster_duration='1D',\n... )\n&gt;&gt;&gt; fs_reduced.optimize(solver)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Expand to full resolution FlowSystem\n&gt;&gt;&gt; fs_expanded = fs_reduced.transform.expand()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Use all existing accessors with full timesteps\n&gt;&gt;&gt; fs_expanded.statistics.flow_rates  # Full 8760 timesteps\n&gt;&gt;&gt; fs_expanded.statistics.plot.balance('HeatBus')  # Full resolution plots\n&gt;&gt;&gt; fs_expanded.statistics.plot.heatmap('Boiler(Q_th)|flow_rate')\n</code></pre> Note <p>The expanded FlowSystem repeats the typical cluster values for all original clusters belonging to the same cluster. Both input data and solution are consistently expanded, so they match. This is an approximation - the actual dispatch at full resolution would differ due to intra-cluster variations in time series data.</p> <p>For accurate dispatch results, use <code>fix_sizes()</code> to fix the sizes from the reduced optimization and re-optimize at full resolution.</p> <p>Segmented Systems Variable Handling:</p> <p>For systems clustered with <code>SegmentConfig</code>, special handling is applied to time-varying solution variables. Variables without a <code>time</code> dimension are unaffected by segment expansion. This includes:</p> <ul> <li>Investment: <code>{component}|size</code>, <code>{component}|exists</code></li> <li>Storage boundaries: <code>{storage}|SOC_boundary</code></li> <li>Aggregated totals: <code>{flow}|total_flow_hours</code>, <code>{flow}|active_hours</code></li> <li>Effect totals: <code>{effect}</code>, <code>{effect}(temporal)</code>, <code>{effect}(periodic)</code></li> </ul> <p>Time-varying variables are categorized and handled as follows:</p> <ol> <li> <p>State variables - Interpolated within segments:</p> </li> <li> <p><code>{storage}|charge_state</code>: Linear interpolation between segment      boundary values to show the charge trajectory during charge/discharge.</p> </li> <li> <p>Segment totals - Divided by segment duration:</p> </li> </ol> <p>These variables represent values summed over the segment. Division    converts them back to hourly rates for correct plotting and analysis.</p> <ul> <li><code>{effect}(temporal)|per_timestep</code>: Per-timestep effect contributions</li> <li><code>{flow}-&gt;{effect}(temporal)</code>: Flow contributions (includes both      <code>effects_per_flow_hour</code> and <code>effects_per_startup</code>)</li> <li><code>{component}-&gt;{effect}(temporal)</code>: Component-level contributions</li> <li> <p><code>{source}(temporal)-&gt;{target}(temporal)</code>: Effect-to-effect shares</p> </li> <li> <p>Rate/average variables - Expanded as-is:</p> </li> </ul> <p>These variables represent average values within the segment. tsam    already provides properly averaged values, so no correction needed.</p> <ul> <li><code>{flow}|flow_rate</code>: Average flow rate during segment</li> <li> <p><code>{storage}|netto_discharge</code>: Net discharge rate (discharge - charge)</p> </li> <li> <p>Binary status variables - Constant within segment:</p> </li> </ul> <p>These variables cannot be meaningfully interpolated. They indicate    the dominant state or whether an event occurred during the segment.</p> <ul> <li><code>{flow}|status</code>: On/off status (0 or 1)</li> <li><code>{flow}|startup</code>: Startup event occurred in segment</li> <li><code>{flow}|shutdown</code>: Shutdown event occurred in segment</li> </ul>"},{"location":"api-reference/types/","title":"Types","text":""},{"location":"api-reference/types/#flixopt.types","title":"flixopt.types","text":"<p>Type system for dimension-aware data in flixopt.</p> <p>Type aliases use suffix notation to indicate maximum dimensions. Data can have any subset of these dimensions (including scalars, which are broadcast to all dimensions).</p> Suffix Dimensions Use Case <code>_TPS</code> Time, Period, Scenario Time-varying data across all dimensions <code>_PS</code> Period, Scenario Investment parameters (no time variation) <code>_S</code> Scenario Scenario-specific parameters (none) Scalar only Single numeric values <p>All dimensioned types accept: scalars (<code>int</code>, <code>float</code>), arrays (<code>ndarray</code>), Series (<code>pd.Series</code>), DataFrames (<code>pd.DataFrame</code>), or DataArrays (<code>xr.DataArray</code>).</p> Example <pre><code>from flixopt.types import Numeric_TPS, Numeric_PS, Scalar\n\n\ndef create_flow(\n    size: Numeric_PS = None,  # Scalar, array, Series, DataFrame, or DataArray\n    profile: Numeric_TPS = 1.0,  # Time-varying data\n    efficiency: Scalar = 0.95,  # Scalars only\n): ...\n\n\n# All valid:\ncreate_flow(size=100)  # Scalar broadcast\ncreate_flow(size=np.array([100, 150]))  # Period-varying\ncreate_flow(profile=pd.DataFrame(...))  # Time + scenario\n</code></pre> Important <p>Data can have any subset of specified dimensions, but cannot have more dimensions than the FlowSystem. If the FlowSystem has only time dimension, you cannot pass period or scenario data. The type hints indicate the maximum dimensions that could be used if they exist in the FlowSystem.</p>"},{"location":"api-reference/types/#flixopt.types-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#flixopt.types.NumericOrBool","title":"NumericOrBool  <code>module-attribute</code>","text":"<pre><code>NumericOrBool: TypeAlias = int | float | bool | integer | floating | bool_ | ndarray | Series | DataFrame | DataArray\n</code></pre> <p>Numeric or boolean data without dimension metadata. For internal utilities.</p>"},{"location":"api-reference/types/#flixopt.types.Numeric_TPS","title":"Numeric_TPS  <code>module-attribute</code>","text":"<pre><code>Numeric_TPS: TypeAlias = int | float | integer | floating | ndarray | Series | DataFrame | DataArray\n</code></pre> <p>Time, Period, Scenario dimensions. For time-varying data across all dimensions.</p>"},{"location":"api-reference/types/#flixopt.types.Numeric_PS","title":"Numeric_PS  <code>module-attribute</code>","text":"<pre><code>Numeric_PS: TypeAlias = int | float | integer | floating | ndarray | Series | DataFrame | DataArray\n</code></pre> <p>Period, Scenario dimensions. For investment parameters (e.g., size, costs).</p>"},{"location":"api-reference/types/#flixopt.types.Numeric_S","title":"Numeric_S  <code>module-attribute</code>","text":"<pre><code>Numeric_S: TypeAlias = int | float | integer | floating | ndarray | Series | DataFrame | DataArray\n</code></pre> <p>Scenario dimension. For scenario-specific parameters (e.g., discount rates).</p>"},{"location":"api-reference/types/#flixopt.types.Bool_TPS","title":"Bool_TPS  <code>module-attribute</code>","text":"<pre><code>Bool_TPS: TypeAlias = bool | bool_ | ndarray | Series | DataFrame | DataArray\n</code></pre> <p>Time, Period, Scenario dimensions. For time-varying binary flags/constraints.</p>"},{"location":"api-reference/types/#flixopt.types.Bool_PS","title":"Bool_PS  <code>module-attribute</code>","text":"<pre><code>Bool_PS: TypeAlias = bool | bool_ | ndarray | Series | DataFrame | DataArray\n</code></pre> <p>Period, Scenario dimensions. For period-specific binary decisions.</p>"},{"location":"api-reference/types/#flixopt.types.Bool_S","title":"Bool_S  <code>module-attribute</code>","text":"<pre><code>Bool_S: TypeAlias = bool | bool_ | ndarray | Series | DataFrame | DataArray\n</code></pre> <p>Scenario dimension. For scenario-specific binary flags.</p>"},{"location":"api-reference/types/#flixopt.types.Effect_TPS","title":"Effect_TPS  <code>module-attribute</code>","text":"<pre><code>Effect_TPS: TypeAlias = dict[str, int | float | integer | floating | ndarray | Series | DataFrame | DataArray]\n</code></pre> <p>Time, Period, Scenario dimensions. Dict mapping effect names to numeric values. For time-varying effects (costs, emissions). Use <code>Effect_TPS | Numeric_TPS</code> to accept single values.</p>"},{"location":"api-reference/types/#flixopt.types.Effect_PS","title":"Effect_PS  <code>module-attribute</code>","text":"<pre><code>Effect_PS: TypeAlias = dict[str, int | float | integer | floating | ndarray | Series | DataFrame | DataArray]\n</code></pre> <p>Period, Scenario dimensions. Dict mapping effect names to numeric values. For period-specific effects (investment costs). Use <code>Effect_PS | Numeric_PS</code> to accept single values.</p>"},{"location":"api-reference/types/#flixopt.types.Effect_S","title":"Effect_S  <code>module-attribute</code>","text":"<pre><code>Effect_S: TypeAlias = dict[str, int | float | integer | floating | ndarray | Series | DataFrame | DataArray]\n</code></pre> <p>Scenario dimension. Dict mapping effect names to numeric values. For scenario-specific effects (carbon prices). Use <code>Effect_S | Numeric_S</code> to accept single values.</p>"},{"location":"api-reference/types/#flixopt.types.Scalar","title":"Scalar  <code>module-attribute</code>","text":"<pre><code>Scalar: TypeAlias = int | float | integer | floating\n</code></pre> <p>Scalar numeric values only. Not converted to DataArray (unlike dimensioned types).</p>"},{"location":"api-reference/clustering/","title":"Index","text":""},{"location":"api-reference/clustering/#flixopt.clustering","title":"flixopt.clustering","text":"<p>Time Series Aggregation Module for flixopt.</p> <p>This module provides wrapper classes around tsam's clustering functionality: - Clustering: Top-level class stored on FlowSystem after clustering - ClusteringResults: Manages collection of tsam ClusteringResult objects (for IO)</p> <p>Example usage:</p> <pre><code># Cluster a FlowSystem to reduce timesteps\nfrom tsam import ExtremeConfig\n\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n    extremes=ExtremeConfig(method='new_cluster', max_value=['Demand|fixed_relative_profile']),\n)\n\n# Access clustering structure (available before AND after IO)\nclustering = fs_clustered.clustering\nprint(f'Number of clusters: {clustering.n_clusters}')\nprint(f'Dims: {clustering.dims}')  # e.g., ('period', 'scenario')\nprint(f'Coords: {clustering.coords}')  # e.g., {'period': [2024, 2025]}\n\n# Access tsam AggregationResult for detailed analysis\n# NOTE: Only available BEFORE saving/loading. Lost after IO.\nresult = clustering.sel(period=2024, scenario='high')\nresult.cluster_representatives  # DataFrame with aggregated time series\nresult.accuracy  # AccuracyMetrics (rmse, mae)\nresult.plot.compare()  # tsam's built-in comparison plot\n\n# Iterate over all results (only before IO)\nfor key, result in clustering.items():\n    print(f'{key}: {result.n_clusters} clusters')\n\n# Save and load - structure preserved, AggregationResult access lost\nfs_clustered.to_netcdf('system.nc')\n# Use include_original_data=False for smaller files (~38% reduction)\nfs_clustered.to_netcdf('system.nc', include_original_data=False)\n\n# Expand back to full resolution\nfs_expanded = fs_clustered.transform.expand()\n</code></pre>"},{"location":"api-reference/clustering/#flixopt.clustering-classes","title":"Classes","text":""},{"location":"api-reference/clustering/#flixopt.clustering.Clustering","title":"Clustering","text":"<pre><code>Clustering(results: ClusteringResults | dict | None = None, original_timesteps: DatetimeIndex | list[str] | None = None, original_data: Dataset | None = None, aggregated_data: Dataset | None = None, _metrics: Dataset | None = None, _original_data_refs: list[str] | None = None, _metrics_refs: list[str] | None = None, _aggregation_results: dict[tuple, AggregationResult] | None = None, _dim_names: list[str] | None = None)\n</code></pre> <p>Clustering information for a FlowSystem.</p> <p>Thin wrapper around tsam 3.0's AggregationResult objects, providing: 1. Multi-dimensional access for (period, scenario) combinations 2. Structure properties (n_clusters, dims, coords, cluster_assignments) 3. JSON persistence via ClusteringResults</p> <p>Use <code>sel()</code> to access individual tsam AggregationResult objects for detailed analysis (cluster_representatives, accuracy, plotting).</p> <p>Attributes:</p> Name Type Description <code>results</code> <code>ClusteringResults</code> <p>ClusteringResults for structure access (works after JSON load).</p> <code>original_timesteps</code> <p>Original timesteps before clustering.</p> <code>dims</code> <code>tuple[str, ...]</code> <p>Dimension names, e.g., ('period', 'scenario').</p> <code>coords</code> <code>dict[str, list]</code> <p>Coordinate values, e.g., {'period': [2024, 2025]}.</p> Example <p>clustering = fs_clustered.clustering clustering.n_clusters 8 clustering.dims ('period',)</p> <p>Initialize Clustering object.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>ClusteringResults | dict | None</code> <p>ClusteringResults instance, or dict from to_dict() (for deserialization). Not needed if _aggregation_results is provided.</p> <code>None</code> <code>original_timesteps</code> <code>DatetimeIndex | list[str] | None</code> <p>Original timesteps before clustering.</p> <code>None</code> <code>original_data</code> <code>Dataset | None</code> <p>Original dataset before clustering (for expand/plotting).</p> <code>None</code> <code>aggregated_data</code> <code>Dataset | None</code> <p>Aggregated dataset after clustering (for plotting). After loading from file, this is reconstructed from FlowSystem data.</p> <code>None</code> <code>_metrics</code> <code>Dataset | None</code> <p>Pre-computed metrics dataset.</p> <code>None</code> <code>_original_data_refs</code> <code>list[str] | None</code> <p>Internal: resolved DataArrays from serialization.</p> <code>None</code> <code>_metrics_refs</code> <code>list[str] | None</code> <p>Internal: resolved DataArrays from serialization.</p> <code>None</code> <code>_aggregation_results</code> <code>dict[tuple, AggregationResult] | None</code> <p>Internal: dict of AggregationResult for full data access.</p> <code>None</code> <code>_dim_names</code> <code>list[str] | None</code> <p>Internal: dimension names when using _aggregation_results.</p> <code>None</code>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering--access-tsam-aggregationresult-for-detailed-analysis","title":"Access tsam AggregationResult for detailed analysis","text":"<p>result = clustering.sel(period=2024) result.cluster_representatives  # DataFrame result.accuracy  # AccuracyMetrics result.plot.compare()  # tsam's built-in plotting</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering-attributes","title":"Attributes","text":""},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.n_clusters","title":"n_clusters  <code>property</code>","text":"<pre><code>n_clusters: int\n</code></pre> <p>Number of clusters (typical periods).</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.timesteps_per_cluster","title":"timesteps_per_cluster  <code>property</code>","text":"<pre><code>timesteps_per_cluster: int\n</code></pre> <p>Number of timesteps in each cluster.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.timesteps_per_period","title":"timesteps_per_period  <code>property</code>","text":"<pre><code>timesteps_per_period: int\n</code></pre> <p>Alias for timesteps_per_cluster.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.n_original_clusters","title":"n_original_clusters  <code>property</code>","text":"<pre><code>n_original_clusters: int\n</code></pre> <p>Number of original periods (before clustering).</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.dim_names","title":"dim_names  <code>property</code>","text":"<pre><code>dim_names: list[str]\n</code></pre> <p>Names of extra dimensions, e.g., ['period', 'scenario'].</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: tuple[str, ...]\n</code></pre> <p>Dimension names as tuple (xarray-like).</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.coords","title":"coords  <code>property</code>","text":"<pre><code>coords: dict[str, list]\n</code></pre> <p>Coordinate values for each dimension (xarray-like).</p> <p>Returns:</p> Type Description <code>dict[str, list]</code> <p>Dict mapping dimension names to lists of coordinate values.</p> Example <p>clustering.coords</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.is_segmented","title":"is_segmented  <code>property</code>","text":"<pre><code>is_segmented: bool\n</code></pre> <p>Whether intra-period segmentation was used.</p> <p>Segmented systems have variable timestep durations within each cluster, where each segment represents a different number of original timesteps.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.n_segments","title":"n_segments  <code>property</code>","text":"<pre><code>n_segments: int | None\n</code></pre> <p>Number of segments per cluster, or None if not segmented.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.cluster_assignments","title":"cluster_assignments  <code>property</code>","text":"<pre><code>cluster_assignments: DataArray\n</code></pre> <p>Mapping from original periods to cluster IDs.</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims [original_cluster] or [original_cluster, period?, scenario?].</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.n_representatives","title":"n_representatives  <code>property</code>","text":"<pre><code>n_representatives: int\n</code></pre> <p>Number of representative timesteps after clustering.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.cluster_occurrences","title":"cluster_occurrences  <code>property</code>","text":"<pre><code>cluster_occurrences: DataArray\n</code></pre> <p>Count of how many original periods each cluster represents.</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims [cluster] or [cluster, period?, scenario?].</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.representative_weights","title":"representative_weights  <code>property</code>","text":"<pre><code>representative_weights: DataArray\n</code></pre> <p>Weight for each cluster (number of original periods it represents).</p> <p>This is the same as cluster_occurrences but named for API consistency. Used as cluster_weight in FlowSystem.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.timestep_mapping","title":"timestep_mapping  <code>cached</code> <code>property</code>","text":"<pre><code>timestep_mapping: DataArray\n</code></pre> <p>Mapping from original timesteps to representative timestep indices.</p> <p>Each value indicates which representative timestep index (0 to n_representatives-1) corresponds to each original timestep.</p> <p>Note: This property is cached for performance since it's accessed frequently during expand() operations.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.metrics","title":"metrics  <code>property</code>","text":"<pre><code>metrics: Dataset\n</code></pre> <p>Clustering quality metrics (RMSE, MAE, etc.).</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset with dims [time_series, period?, scenario?], or empty Dataset if no metrics.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.cluster_start_positions","title":"cluster_start_positions  <code>property</code>","text":"<pre><code>cluster_start_positions: ndarray\n</code></pre> <p>Integer positions where clusters start in reduced timesteps.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>1D array: [0, T, 2T, ...] where T = timesteps_per_cluster (or n_segments if segmented).</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.cluster_centers","title":"cluster_centers  <code>property</code>","text":"<pre><code>cluster_centers: DataArray\n</code></pre> <p>Which original period is the representative (center) for each cluster.</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims [cluster] containing original period indices.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.segment_assignments","title":"segment_assignments  <code>property</code>","text":"<pre><code>segment_assignments: DataArray | None\n</code></pre> <p>For each timestep within a cluster, which intra-period segment it belongs to.</p> <p>Only available if segmentation was configured during clustering.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>DataArray with dims [cluster, time] or None if no segmentation.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.segment_durations","title":"segment_durations  <code>property</code>","text":"<pre><code>segment_durations: DataArray | None\n</code></pre> <p>Duration of each intra-period segment in hours.</p> <p>Only available if segmentation was configured during clustering.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>DataArray with dims [cluster, segment] or None if no segmentation.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.segment_centers","title":"segment_centers  <code>property</code>","text":"<pre><code>segment_centers: DataArray | None\n</code></pre> <p>Center of each intra-period segment.</p> <p>Only available if segmentation was configured during clustering.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>DataArray with dims [cluster, segment] or None if no segmentation.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.plot","title":"plot  <code>property</code>","text":"<pre><code>plot: ClusteringPlotAccessor\n</code></pre> <p>Access plotting methods for clustering visualization.</p> <p>Returns:</p> Type Description <code>ClusteringPlotAccessor</code> <p>ClusteringPlotAccessor with compare(), heatmap(), and clusters() methods.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.results","title":"results  <code>property</code>","text":"<pre><code>results: ClusteringResults\n</code></pre> <p>ClusteringResults for structure access (derived from AggregationResults or cached).</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering-functions","title":"Functions","text":""},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.sel","title":"sel","text":"<pre><code>sel(period: int | str | None = None, scenario: str | None = None) -&gt; AggregationResult\n</code></pre> <p>Select AggregationResult by period and/or scenario.</p> <p>Access individual tsam AggregationResult objects for detailed analysis.</p> Note <p>This method is only available before saving/loading the FlowSystem. After IO (to_dataset/from_dataset or to_json), the full AggregationResult data is not preserved. Use <code>results.sel()</code> for structure-only access after loading.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int | str | None</code> <p>Period value (e.g., 2024). Required if clustering has periods.</p> <code>None</code> <code>scenario</code> <code>str | None</code> <p>Scenario name (e.g., 'high'). Required if clustering has scenarios.</p> <code>None</code> <p>Returns:</p> Type Description <code>AggregationResult</code> <p>The tsam AggregationResult for the specified combination.</p> <code>AggregationResult</code> <p>Access its properties like <code>cluster_representatives</code>, <code>accuracy</code>, etc.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no result found for the specified combination.</p> <code>ValueError</code> <p>If accessed on a Clustering loaded from JSON/NetCDF.</p> Example <p>result = clustering.sel(period=2024, scenario='high') result.cluster_representatives  # DataFrame with aggregated data result.accuracy  # AccuracyMetrics result.plot.compare()  # tsam's built-in comparison plot</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.expand_data","title":"expand_data","text":"<pre><code>expand_data(aggregated: DataArray, original_time: DatetimeIndex | None = None) -&gt; xr.DataArray\n</code></pre> <p>Expand aggregated data back to original timesteps.</p> <p>Uses the timestep_mapping to map each original timestep to its representative value from the aggregated data. Fully vectorized using xarray's advanced indexing - no loops over period/scenario dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>aggregated</code> <code>DataArray</code> <p>DataArray with aggregated (cluster, time) or (time,) dimension.</p> required <code>original_time</code> <code>DatetimeIndex | None</code> <p>Original time coordinates. Defaults to self.original_timesteps.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray expanded to original timesteps.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.build_expansion_divisor","title":"build_expansion_divisor","text":"<pre><code>build_expansion_divisor(original_time: DatetimeIndex | None = None) -&gt; xr.DataArray\n</code></pre> <p>Build divisor for correcting segment totals when expanding to hourly.</p> <p>For segmented systems, each segment value is a total that gets repeated N times when expanded to hourly resolution (where N = segment duration in timesteps). This divisor allows converting those totals back to hourly rates during expansion.</p> <p>For each original timestep, returns the number of original timesteps that map to the same (cluster, segment) - i.e., the segment duration in timesteps.</p> <p>Fully vectorized using xarray's advanced indexing - no loops over period/scenario.</p> <p>Parameters:</p> Name Type Description Default <code>original_time</code> <code>DatetimeIndex | None</code> <p>Original time coordinates. Defaults to self.original_timesteps.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims ['time'] or ['time', 'period'?, 'scenario'?] containing</p> <code>DataArray</code> <p>the number of timesteps in each segment, aligned to original timesteps.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.get_result","title":"get_result","text":"<pre><code>get_result(period: Any = None, scenario: Any = None) -&gt; TsamClusteringResult\n</code></pre> <p>Get the tsam ClusteringResult for a specific (period, scenario).</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>Any</code> <p>Period label (if applicable).</p> <code>None</code> <code>scenario</code> <code>Any</code> <p>Scenario label (if applicable).</p> <code>None</code> <p>Returns:</p> Type Description <code>ClusteringResult</code> <p>The tsam ClusteringResult for the specified combination.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.apply","title":"apply","text":"<pre><code>apply(data: DataFrame, period: Any = None, scenario: Any = None) -&gt; AggregationResult\n</code></pre> <p>Apply the saved clustering to new data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame with time series data to cluster.</p> required <code>period</code> <code>Any</code> <p>Period label (if applicable).</p> <code>None</code> <code>scenario</code> <code>Any</code> <p>Scenario label (if applicable).</p> <code>None</code> <p>Returns:</p> Type Description <code>AggregationResult</code> <p>tsam AggregationResult with the clustering applied.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path) -&gt; None\n</code></pre> <p>Save the clustering for reuse.</p> <p>Uses ClusteringResults.to_dict() which preserves full tsam ClusteringResult. Can be loaded later with Clustering.from_json() and used with flow_system.transform.apply_clustering().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the JSON file.</p> required"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(path: str | Path, original_timesteps: DatetimeIndex | None = None) -&gt; Clustering\n</code></pre> <p>Load a clustering from JSON.</p> <p>The loaded Clustering has full apply() support because ClusteringResult is fully preserved via tsam's serialization.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the JSON file.</p> required <code>original_timesteps</code> <code>DatetimeIndex | None</code> <p>Original timesteps for the new FlowSystem. If None, uses the timesteps stored in the JSON.</p> <code>None</code> <p>Returns:</p> Type Description <code>Clustering</code> <p>A Clustering that can be used with apply_clustering().</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Iterate over (key, AggregationResult) pairs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If accessed on a Clustering loaded from JSON.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Iterate over (period, scenario) keys.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.Clustering.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Iterate over AggregationResult objects.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If accessed on a Clustering loaded from JSON.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults","title":"ClusteringResults","text":"<pre><code>ClusteringResults(results: dict[tuple, ClusteringResult], dim_names: list[str])\n</code></pre> <p>Collection of tsam ClusteringResult objects for multi-dimensional data.</p> <p>Manages multiple ClusteringResult objects keyed by (period, scenario) tuples and provides convenient access and multi-dimensional DataArray building.</p> <p>Follows xarray-like patterns with <code>.dims</code>, <code>.coords</code>, <code>.sel()</code>, and <code>.isel()</code>.</p> <p>Attributes:</p> Name Type Description <code>dims</code> <code>tuple[str, ...]</code> <p>Tuple of dimension names, e.g., ('period', 'scenario').</p> <code>coords</code> <code>dict[str, list]</code> <p>Dict mapping dimension names to their coordinate values.</p> Example <p>results = ClusteringResults({(): cr}, dim_names=[]) results.n_clusters 2 results.cluster_assignments  # Returns DataArray </p> <p>Initialize ClusteringResults.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>dict[tuple, ClusteringResult]</code> <p>Dict mapping (period, scenario) tuples to tsam ClusteringResult objects. For simple cases without periods/scenarios, use {(): result}.</p> required <code>dim_names</code> <code>list[str]</code> <p>Names of extra dimensions, e.g., ['period', 'scenario'].</p> required"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults--multi-dimensional-case","title":"Multi-dimensional case","text":"<p>results = ClusteringResults( ...     {(2024, 'high'): cr1, (2024, 'low'): cr2}, ...     dim_names=['period', 'scenario'], ... ) results.dims ('period', 'scenario') results.coords {'period': [2024], 'scenario': ['high', 'low']} results.sel(period=2024, scenario='high')  # Label-based  results.isel(period=0, scenario=1)  # Index-based </p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults-attributes","title":"Attributes","text":""},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: tuple[str, ...]\n</code></pre> <p>Dimension names as tuple (xarray-like).</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.dim_names","title":"dim_names  <code>property</code>","text":"<pre><code>dim_names: list[str]\n</code></pre> <p>Dimension names as list (backwards compatibility).</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.coords","title":"coords  <code>property</code>","text":"<pre><code>coords: dict[str, list]\n</code></pre> <p>Coordinate values for each dimension (xarray-like).</p> <p>Returns:</p> Type Description <code>dict[str, list]</code> <p>Dict mapping dimension names to lists of coordinate values.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.n_clusters","title":"n_clusters  <code>property</code>","text":"<pre><code>n_clusters: int\n</code></pre> <p>Number of clusters (same for all results).</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.timesteps_per_cluster","title":"timesteps_per_cluster  <code>property</code>","text":"<pre><code>timesteps_per_cluster: int\n</code></pre> <p>Number of timesteps per cluster (same for all results).</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.n_original_periods","title":"n_original_periods  <code>property</code>","text":"<pre><code>n_original_periods: int\n</code></pre> <p>Number of original periods (same for all results).</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.n_segments","title":"n_segments  <code>property</code>","text":"<pre><code>n_segments: int | None\n</code></pre> <p>Number of segments per cluster, or None if not segmented.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.cluster_assignments","title":"cluster_assignments  <code>property</code>","text":"<pre><code>cluster_assignments: DataArray\n</code></pre> <p>Maps each original cluster to its typical cluster index.</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims [original_cluster, period?, scenario?].</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.cluster_occurrences","title":"cluster_occurrences  <code>property</code>","text":"<pre><code>cluster_occurrences: DataArray\n</code></pre> <p>How many original clusters map to each typical cluster.</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims [cluster, period?, scenario?].</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.cluster_centers","title":"cluster_centers  <code>property</code>","text":"<pre><code>cluster_centers: DataArray\n</code></pre> <p>Which original cluster is the representative (center) for each typical cluster.</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims [cluster, period?, scenario?].</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.segment_assignments","title":"segment_assignments  <code>property</code>","text":"<pre><code>segment_assignments: DataArray | None\n</code></pre> <p>For each timestep within a cluster, which segment it belongs to.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>DataArray with dims [cluster, time, period?, scenario?], or None if not segmented.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.segment_durations","title":"segment_durations  <code>property</code>","text":"<pre><code>segment_durations: DataArray | None\n</code></pre> <p>Duration of each segment in timesteps.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>DataArray with dims [cluster, segment, period?, scenario?], or None if not segmented.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.segment_centers","title":"segment_centers  <code>property</code>","text":"<pre><code>segment_centers: DataArray | None\n</code></pre> <p>Center of each intra-period segment.</p> <p>Only available if segmentation was configured during clustering.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>DataArray or None if no segmentation.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.position_within_segment","title":"position_within_segment  <code>property</code>","text":"<pre><code>position_within_segment: DataArray | None\n</code></pre> <p>Position of each timestep within its segment (0-indexed).</p> <p>For each (cluster, time) position, returns how many timesteps into the segment that position is. Used for interpolation within segments.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>DataArray with dims [cluster, time] or [cluster, time, period?, scenario?].</p> <code>DataArray | None</code> <p>Returns None if no segmentation.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults-functions","title":"Functions","text":""},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.sel","title":"sel","text":"<pre><code>sel(**kwargs: Any) -&gt; TsamClusteringResult\n</code></pre> <p>Select result by dimension labels (xarray-like).</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Dimension name=value pairs, e.g., period=2024, scenario='high'.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ClusteringResult</code> <p>The tsam ClusteringResult for the specified combination.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no result found for the specified combination.</p> Example <p>results.sel(period=2024, scenario='high') </p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.isel","title":"isel","text":"<pre><code>isel(**kwargs: int) -&gt; TsamClusteringResult\n</code></pre> <p>Select result by dimension indices (xarray-like).</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>int</code> <p>Dimension name=index pairs, e.g., period=0, scenario=1.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ClusteringResult</code> <p>The tsam ClusteringResult for the specified combination.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If index is out of range for a dimension.</p> Example <p>results.isel(period=0, scenario=1) </p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Iterate over (key, ClusteringResult) pairs.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Iterate over keys.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Iterate over ClusteringResult objects.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Serialize to dict.</p> <p>The dict can be used to reconstruct via from_dict().</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d: dict) -&gt; ClusteringResults\n</code></pre> <p>Reconstruct from dict.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dict from to_dict().</p> required <p>Returns:</p> Type Description <code>ClusteringResults</code> <p>Reconstructed ClusteringResults.</p>"},{"location":"api-reference/clustering/#flixopt.clustering.ClusteringResults.apply","title":"apply","text":"<pre><code>apply(data: Dataset) -&gt; AggregationResults\n</code></pre> <p>Apply clustering to dataset for all (period, scenario) combinations.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dataset</code> <p>Dataset with time-varying data. Must have 'time' dimension. May have 'period' and/or 'scenario' dimensions matching this object.</p> required <p>Returns:</p> Type Description <code>AggregationResults</code> <p>AggregationResults with full access to aggregated data.</p> <code>AggregationResults</code> <p>Use <code>.clustering</code> on the result to get ClusteringResults for IO.</p> Example <p>agg_results = clustering_results.apply(dataset) agg_results.clustering  # Get ClusteringResults for IO for key, result in agg_results: ...     print(result.cluster_representatives)</p>"},{"location":"api-reference/clustering/base/","title":"Base","text":""},{"location":"api-reference/clustering/base/#flixopt.clustering.base","title":"flixopt.clustering.base","text":"<p>Clustering classes for time series aggregation.</p> <p>This module provides wrapper classes around tsam's clustering functionality: - <code>ClusteringResults</code>: Collection of tsam ClusteringResult objects for multi-dim (period, scenario) data - <code>Clustering</code>: Top-level class stored on FlowSystem after clustering</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base-attributes","title":"Attributes","text":""},{"location":"api-reference/clustering/base/#flixopt.clustering.base-classes","title":"Classes","text":""},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults","title":"ClusteringResults","text":"<pre><code>ClusteringResults(results: dict[tuple, ClusteringResult], dim_names: list[str])\n</code></pre> <p>Collection of tsam ClusteringResult objects for multi-dimensional data.</p> <p>Manages multiple ClusteringResult objects keyed by (period, scenario) tuples and provides convenient access and multi-dimensional DataArray building.</p> <p>Follows xarray-like patterns with <code>.dims</code>, <code>.coords</code>, <code>.sel()</code>, and <code>.isel()</code>.</p> <p>Attributes:</p> Name Type Description <code>dims</code> <code>tuple[str, ...]</code> <p>Tuple of dimension names, e.g., ('period', 'scenario').</p> <code>coords</code> <code>dict[str, list]</code> <p>Dict mapping dimension names to their coordinate values.</p> Example <p>results = ClusteringResults({(): cr}, dim_names=[]) results.n_clusters 2 results.cluster_assignments  # Returns DataArray </p> <p>Initialize ClusteringResults.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>dict[tuple, ClusteringResult]</code> <p>Dict mapping (period, scenario) tuples to tsam ClusteringResult objects. For simple cases without periods/scenarios, use {(): result}.</p> required <code>dim_names</code> <code>list[str]</code> <p>Names of extra dimensions, e.g., ['period', 'scenario'].</p> required"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults--multi-dimensional-case","title":"Multi-dimensional case","text":"<p>results = ClusteringResults( ...     {(2024, 'high'): cr1, (2024, 'low'): cr2}, ...     dim_names=['period', 'scenario'], ... ) results.dims ('period', 'scenario') results.coords {'period': [2024], 'scenario': ['high', 'low']} results.sel(period=2024, scenario='high')  # Label-based  results.isel(period=0, scenario=1)  # Index-based </p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults-attributes","title":"Attributes","text":""},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: tuple[str, ...]\n</code></pre> <p>Dimension names as tuple (xarray-like).</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.dim_names","title":"dim_names  <code>property</code>","text":"<pre><code>dim_names: list[str]\n</code></pre> <p>Dimension names as list (backwards compatibility).</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.coords","title":"coords  <code>property</code>","text":"<pre><code>coords: dict[str, list]\n</code></pre> <p>Coordinate values for each dimension (xarray-like).</p> <p>Returns:</p> Type Description <code>dict[str, list]</code> <p>Dict mapping dimension names to lists of coordinate values.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.n_clusters","title":"n_clusters  <code>property</code>","text":"<pre><code>n_clusters: int\n</code></pre> <p>Number of clusters (same for all results).</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.timesteps_per_cluster","title":"timesteps_per_cluster  <code>property</code>","text":"<pre><code>timesteps_per_cluster: int\n</code></pre> <p>Number of timesteps per cluster (same for all results).</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.n_original_periods","title":"n_original_periods  <code>property</code>","text":"<pre><code>n_original_periods: int\n</code></pre> <p>Number of original periods (same for all results).</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.n_segments","title":"n_segments  <code>property</code>","text":"<pre><code>n_segments: int | None\n</code></pre> <p>Number of segments per cluster, or None if not segmented.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.cluster_assignments","title":"cluster_assignments  <code>property</code>","text":"<pre><code>cluster_assignments: DataArray\n</code></pre> <p>Maps each original cluster to its typical cluster index.</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims [original_cluster, period?, scenario?].</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.cluster_occurrences","title":"cluster_occurrences  <code>property</code>","text":"<pre><code>cluster_occurrences: DataArray\n</code></pre> <p>How many original clusters map to each typical cluster.</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims [cluster, period?, scenario?].</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.cluster_centers","title":"cluster_centers  <code>property</code>","text":"<pre><code>cluster_centers: DataArray\n</code></pre> <p>Which original cluster is the representative (center) for each typical cluster.</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims [cluster, period?, scenario?].</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.segment_assignments","title":"segment_assignments  <code>property</code>","text":"<pre><code>segment_assignments: DataArray | None\n</code></pre> <p>For each timestep within a cluster, which segment it belongs to.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>DataArray with dims [cluster, time, period?, scenario?], or None if not segmented.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.segment_durations","title":"segment_durations  <code>property</code>","text":"<pre><code>segment_durations: DataArray | None\n</code></pre> <p>Duration of each segment in timesteps.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>DataArray with dims [cluster, segment, period?, scenario?], or None if not segmented.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.segment_centers","title":"segment_centers  <code>property</code>","text":"<pre><code>segment_centers: DataArray | None\n</code></pre> <p>Center of each intra-period segment.</p> <p>Only available if segmentation was configured during clustering.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>DataArray or None if no segmentation.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.position_within_segment","title":"position_within_segment  <code>property</code>","text":"<pre><code>position_within_segment: DataArray | None\n</code></pre> <p>Position of each timestep within its segment (0-indexed).</p> <p>For each (cluster, time) position, returns how many timesteps into the segment that position is. Used for interpolation within segments.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>DataArray with dims [cluster, time] or [cluster, time, period?, scenario?].</p> <code>DataArray | None</code> <p>Returns None if no segmentation.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults-functions","title":"Functions","text":""},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.sel","title":"sel","text":"<pre><code>sel(**kwargs: Any) -&gt; TsamClusteringResult\n</code></pre> <p>Select result by dimension labels (xarray-like).</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Dimension name=value pairs, e.g., period=2024, scenario='high'.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ClusteringResult</code> <p>The tsam ClusteringResult for the specified combination.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no result found for the specified combination.</p> Example <p>results.sel(period=2024, scenario='high') </p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.isel","title":"isel","text":"<pre><code>isel(**kwargs: int) -&gt; TsamClusteringResult\n</code></pre> <p>Select result by dimension indices (xarray-like).</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>int</code> <p>Dimension name=index pairs, e.g., period=0, scenario=1.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ClusteringResult</code> <p>The tsam ClusteringResult for the specified combination.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If index is out of range for a dimension.</p> Example <p>results.isel(period=0, scenario=1) </p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Iterate over (key, ClusteringResult) pairs.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Iterate over keys.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Iterate over ClusteringResult objects.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Serialize to dict.</p> <p>The dict can be used to reconstruct via from_dict().</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d: dict) -&gt; ClusteringResults\n</code></pre> <p>Reconstruct from dict.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dict from to_dict().</p> required <p>Returns:</p> Type Description <code>ClusteringResults</code> <p>Reconstructed ClusteringResults.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringResults.apply","title":"apply","text":"<pre><code>apply(data: Dataset) -&gt; AggregationResults\n</code></pre> <p>Apply clustering to dataset for all (period, scenario) combinations.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dataset</code> <p>Dataset with time-varying data. Must have 'time' dimension. May have 'period' and/or 'scenario' dimensions matching this object.</p> required <p>Returns:</p> Type Description <code>AggregationResults</code> <p>AggregationResults with full access to aggregated data.</p> <code>AggregationResults</code> <p>Use <code>.clustering</code> on the result to get ClusteringResults for IO.</p> Example <p>agg_results = clustering_results.apply(dataset) agg_results.clustering  # Get ClusteringResults for IO for key, result in agg_results: ...     print(result.cluster_representatives)</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering","title":"Clustering","text":"<pre><code>Clustering(results: ClusteringResults | dict | None = None, original_timesteps: DatetimeIndex | list[str] | None = None, original_data: Dataset | None = None, aggregated_data: Dataset | None = None, _metrics: Dataset | None = None, _original_data_refs: list[str] | None = None, _metrics_refs: list[str] | None = None, _aggregation_results: dict[tuple, AggregationResult] | None = None, _dim_names: list[str] | None = None)\n</code></pre> <p>Clustering information for a FlowSystem.</p> <p>Thin wrapper around tsam 3.0's AggregationResult objects, providing: 1. Multi-dimensional access for (period, scenario) combinations 2. Structure properties (n_clusters, dims, coords, cluster_assignments) 3. JSON persistence via ClusteringResults</p> <p>Use <code>sel()</code> to access individual tsam AggregationResult objects for detailed analysis (cluster_representatives, accuracy, plotting).</p> <p>Attributes:</p> Name Type Description <code>results</code> <code>ClusteringResults</code> <p>ClusteringResults for structure access (works after JSON load).</p> <code>original_timesteps</code> <p>Original timesteps before clustering.</p> <code>dims</code> <code>tuple[str, ...]</code> <p>Dimension names, e.g., ('period', 'scenario').</p> <code>coords</code> <code>dict[str, list]</code> <p>Coordinate values, e.g., {'period': [2024, 2025]}.</p> Example <p>clustering = fs_clustered.clustering clustering.n_clusters 8 clustering.dims ('period',)</p> <p>Initialize Clustering object.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>ClusteringResults | dict | None</code> <p>ClusteringResults instance, or dict from to_dict() (for deserialization). Not needed if _aggregation_results is provided.</p> <code>None</code> <code>original_timesteps</code> <code>DatetimeIndex | list[str] | None</code> <p>Original timesteps before clustering.</p> <code>None</code> <code>original_data</code> <code>Dataset | None</code> <p>Original dataset before clustering (for expand/plotting).</p> <code>None</code> <code>aggregated_data</code> <code>Dataset | None</code> <p>Aggregated dataset after clustering (for plotting). After loading from file, this is reconstructed from FlowSystem data.</p> <code>None</code> <code>_metrics</code> <code>Dataset | None</code> <p>Pre-computed metrics dataset.</p> <code>None</code> <code>_original_data_refs</code> <code>list[str] | None</code> <p>Internal: resolved DataArrays from serialization.</p> <code>None</code> <code>_metrics_refs</code> <code>list[str] | None</code> <p>Internal: resolved DataArrays from serialization.</p> <code>None</code> <code>_aggregation_results</code> <code>dict[tuple, AggregationResult] | None</code> <p>Internal: dict of AggregationResult for full data access.</p> <code>None</code> <code>_dim_names</code> <code>list[str] | None</code> <p>Internal: dimension names when using _aggregation_results.</p> <code>None</code>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering--access-tsam-aggregationresult-for-detailed-analysis","title":"Access tsam AggregationResult for detailed analysis","text":"<p>result = clustering.sel(period=2024) result.cluster_representatives  # DataFrame result.accuracy  # AccuracyMetrics result.plot.compare()  # tsam's built-in plotting</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering-attributes","title":"Attributes","text":""},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.n_clusters","title":"n_clusters  <code>property</code>","text":"<pre><code>n_clusters: int\n</code></pre> <p>Number of clusters (typical periods).</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.timesteps_per_cluster","title":"timesteps_per_cluster  <code>property</code>","text":"<pre><code>timesteps_per_cluster: int\n</code></pre> <p>Number of timesteps in each cluster.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.timesteps_per_period","title":"timesteps_per_period  <code>property</code>","text":"<pre><code>timesteps_per_period: int\n</code></pre> <p>Alias for timesteps_per_cluster.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.n_original_clusters","title":"n_original_clusters  <code>property</code>","text":"<pre><code>n_original_clusters: int\n</code></pre> <p>Number of original periods (before clustering).</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.dim_names","title":"dim_names  <code>property</code>","text":"<pre><code>dim_names: list[str]\n</code></pre> <p>Names of extra dimensions, e.g., ['period', 'scenario'].</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.dims","title":"dims  <code>property</code>","text":"<pre><code>dims: tuple[str, ...]\n</code></pre> <p>Dimension names as tuple (xarray-like).</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.coords","title":"coords  <code>property</code>","text":"<pre><code>coords: dict[str, list]\n</code></pre> <p>Coordinate values for each dimension (xarray-like).</p> <p>Returns:</p> Type Description <code>dict[str, list]</code> <p>Dict mapping dimension names to lists of coordinate values.</p> Example <p>clustering.coords</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.is_segmented","title":"is_segmented  <code>property</code>","text":"<pre><code>is_segmented: bool\n</code></pre> <p>Whether intra-period segmentation was used.</p> <p>Segmented systems have variable timestep durations within each cluster, where each segment represents a different number of original timesteps.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.n_segments","title":"n_segments  <code>property</code>","text":"<pre><code>n_segments: int | None\n</code></pre> <p>Number of segments per cluster, or None if not segmented.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.cluster_assignments","title":"cluster_assignments  <code>property</code>","text":"<pre><code>cluster_assignments: DataArray\n</code></pre> <p>Mapping from original periods to cluster IDs.</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims [original_cluster] or [original_cluster, period?, scenario?].</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.n_representatives","title":"n_representatives  <code>property</code>","text":"<pre><code>n_representatives: int\n</code></pre> <p>Number of representative timesteps after clustering.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.cluster_occurrences","title":"cluster_occurrences  <code>property</code>","text":"<pre><code>cluster_occurrences: DataArray\n</code></pre> <p>Count of how many original periods each cluster represents.</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims [cluster] or [cluster, period?, scenario?].</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.representative_weights","title":"representative_weights  <code>property</code>","text":"<pre><code>representative_weights: DataArray\n</code></pre> <p>Weight for each cluster (number of original periods it represents).</p> <p>This is the same as cluster_occurrences but named for API consistency. Used as cluster_weight in FlowSystem.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.timestep_mapping","title":"timestep_mapping  <code>cached</code> <code>property</code>","text":"<pre><code>timestep_mapping: DataArray\n</code></pre> <p>Mapping from original timesteps to representative timestep indices.</p> <p>Each value indicates which representative timestep index (0 to n_representatives-1) corresponds to each original timestep.</p> <p>Note: This property is cached for performance since it's accessed frequently during expand() operations.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.metrics","title":"metrics  <code>property</code>","text":"<pre><code>metrics: Dataset\n</code></pre> <p>Clustering quality metrics (RMSE, MAE, etc.).</p> <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset with dims [time_series, period?, scenario?], or empty Dataset if no metrics.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.cluster_start_positions","title":"cluster_start_positions  <code>property</code>","text":"<pre><code>cluster_start_positions: ndarray\n</code></pre> <p>Integer positions where clusters start in reduced timesteps.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>1D array: [0, T, 2T, ...] where T = timesteps_per_cluster (or n_segments if segmented).</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.cluster_centers","title":"cluster_centers  <code>property</code>","text":"<pre><code>cluster_centers: DataArray\n</code></pre> <p>Which original period is the representative (center) for each cluster.</p> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims [cluster] containing original period indices.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.segment_assignments","title":"segment_assignments  <code>property</code>","text":"<pre><code>segment_assignments: DataArray | None\n</code></pre> <p>For each timestep within a cluster, which intra-period segment it belongs to.</p> <p>Only available if segmentation was configured during clustering.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>DataArray with dims [cluster, time] or None if no segmentation.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.segment_durations","title":"segment_durations  <code>property</code>","text":"<pre><code>segment_durations: DataArray | None\n</code></pre> <p>Duration of each intra-period segment in hours.</p> <p>Only available if segmentation was configured during clustering.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>DataArray with dims [cluster, segment] or None if no segmentation.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.segment_centers","title":"segment_centers  <code>property</code>","text":"<pre><code>segment_centers: DataArray | None\n</code></pre> <p>Center of each intra-period segment.</p> <p>Only available if segmentation was configured during clustering.</p> <p>Returns:</p> Type Description <code>DataArray | None</code> <p>DataArray with dims [cluster, segment] or None if no segmentation.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.plot","title":"plot  <code>property</code>","text":"<pre><code>plot: ClusteringPlotAccessor\n</code></pre> <p>Access plotting methods for clustering visualization.</p> <p>Returns:</p> Type Description <code>ClusteringPlotAccessor</code> <p>ClusteringPlotAccessor with compare(), heatmap(), and clusters() methods.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.results","title":"results  <code>property</code>","text":"<pre><code>results: ClusteringResults\n</code></pre> <p>ClusteringResults for structure access (derived from AggregationResults or cached).</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering-functions","title":"Functions","text":""},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.sel","title":"sel","text":"<pre><code>sel(period: int | str | None = None, scenario: str | None = None) -&gt; AggregationResult\n</code></pre> <p>Select AggregationResult by period and/or scenario.</p> <p>Access individual tsam AggregationResult objects for detailed analysis.</p> Note <p>This method is only available before saving/loading the FlowSystem. After IO (to_dataset/from_dataset or to_json), the full AggregationResult data is not preserved. Use <code>results.sel()</code> for structure-only access after loading.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int | str | None</code> <p>Period value (e.g., 2024). Required if clustering has periods.</p> <code>None</code> <code>scenario</code> <code>str | None</code> <p>Scenario name (e.g., 'high'). Required if clustering has scenarios.</p> <code>None</code> <p>Returns:</p> Type Description <code>AggregationResult</code> <p>The tsam AggregationResult for the specified combination.</p> <code>AggregationResult</code> <p>Access its properties like <code>cluster_representatives</code>, <code>accuracy</code>, etc.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If no result found for the specified combination.</p> <code>ValueError</code> <p>If accessed on a Clustering loaded from JSON/NetCDF.</p> Example <p>result = clustering.sel(period=2024, scenario='high') result.cluster_representatives  # DataFrame with aggregated data result.accuracy  # AccuracyMetrics result.plot.compare()  # tsam's built-in comparison plot</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.expand_data","title":"expand_data","text":"<pre><code>expand_data(aggregated: DataArray, original_time: DatetimeIndex | None = None) -&gt; xr.DataArray\n</code></pre> <p>Expand aggregated data back to original timesteps.</p> <p>Uses the timestep_mapping to map each original timestep to its representative value from the aggregated data. Fully vectorized using xarray's advanced indexing - no loops over period/scenario dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>aggregated</code> <code>DataArray</code> <p>DataArray with aggregated (cluster, time) or (time,) dimension.</p> required <code>original_time</code> <code>DatetimeIndex | None</code> <p>Original time coordinates. Defaults to self.original_timesteps.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray expanded to original timesteps.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.build_expansion_divisor","title":"build_expansion_divisor","text":"<pre><code>build_expansion_divisor(original_time: DatetimeIndex | None = None) -&gt; xr.DataArray\n</code></pre> <p>Build divisor for correcting segment totals when expanding to hourly.</p> <p>For segmented systems, each segment value is a total that gets repeated N times when expanded to hourly resolution (where N = segment duration in timesteps). This divisor allows converting those totals back to hourly rates during expansion.</p> <p>For each original timestep, returns the number of original timesteps that map to the same (cluster, segment) - i.e., the segment duration in timesteps.</p> <p>Fully vectorized using xarray's advanced indexing - no loops over period/scenario.</p> <p>Parameters:</p> Name Type Description Default <code>original_time</code> <code>DatetimeIndex | None</code> <p>Original time coordinates. Defaults to self.original_timesteps.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims ['time'] or ['time', 'period'?, 'scenario'?] containing</p> <code>DataArray</code> <p>the number of timesteps in each segment, aligned to original timesteps.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.get_result","title":"get_result","text":"<pre><code>get_result(period: Any = None, scenario: Any = None) -&gt; TsamClusteringResult\n</code></pre> <p>Get the tsam ClusteringResult for a specific (period, scenario).</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>Any</code> <p>Period label (if applicable).</p> <code>None</code> <code>scenario</code> <code>Any</code> <p>Scenario label (if applicable).</p> <code>None</code> <p>Returns:</p> Type Description <code>ClusteringResult</code> <p>The tsam ClusteringResult for the specified combination.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.apply","title":"apply","text":"<pre><code>apply(data: DataFrame, period: Any = None, scenario: Any = None) -&gt; AggregationResult\n</code></pre> <p>Apply the saved clustering to new data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame with time series data to cluster.</p> required <code>period</code> <code>Any</code> <p>Period label (if applicable).</p> <code>None</code> <code>scenario</code> <code>Any</code> <p>Scenario label (if applicable).</p> <code>None</code> <p>Returns:</p> Type Description <code>AggregationResult</code> <p>tsam AggregationResult with the clustering applied.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path) -&gt; None\n</code></pre> <p>Save the clustering for reuse.</p> <p>Uses ClusteringResults.to_dict() which preserves full tsam ClusteringResult. Can be loaded later with Clustering.from_json() and used with flow_system.transform.apply_clustering().</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to save the JSON file.</p> required"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(path: str | Path, original_timesteps: DatetimeIndex | None = None) -&gt; Clustering\n</code></pre> <p>Load a clustering from JSON.</p> <p>The loaded Clustering has full apply() support because ClusteringResult is fully preserved via tsam's serialization.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the JSON file.</p> required <code>original_timesteps</code> <code>DatetimeIndex | None</code> <p>Original timesteps for the new FlowSystem. If None, uses the timesteps stored in the JSON.</p> <code>None</code> <p>Returns:</p> Type Description <code>Clustering</code> <p>A Clustering that can be used with apply_clustering().</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Iterate over (key, AggregationResult) pairs.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If accessed on a Clustering loaded from JSON.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Iterate over (period, scenario) keys.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.Clustering.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Iterate over AggregationResult objects.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If accessed on a Clustering loaded from JSON.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringPlotAccessor","title":"ClusteringPlotAccessor","text":"<pre><code>ClusteringPlotAccessor(clustering: Clustering)\n</code></pre> <p>Plot accessor for Clustering objects.</p> <p>Provides visualization methods for comparing original vs aggregated data and understanding the clustering structure.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringPlotAccessor-functions","title":"Functions","text":""},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringPlotAccessor.compare","title":"compare","text":"<pre><code>compare(kind: str = 'timeseries', variables: str | list[str] | None = None, *, select: SelectType | None = None, colors: ColorType | None = None, show: bool | None = None, data_only: bool = False, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Compare original vs aggregated data.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>str</code> <p>Type of comparison plot. - 'timeseries': Time series comparison (default) - 'duration_curve': Sorted duration curve comparison</p> <code>'timeseries'</code> <code>variables</code> <code>str | list[str] | None</code> <p>Variable(s) to plot. Can be a string, list of strings, or None to plot all time-varying variables.</p> <code>None</code> <code>select</code> <code>SelectType | None</code> <p>xarray-style selection dict, e.g. {'scenario': 'Base Case'}.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, color list, or label-to-color dict).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure. Defaults to CONFIG.Plotting.default_show.</p> <code>None</code> <code>data_only</code> <code>bool</code> <p>If True, skip figure creation and return only data.</p> <code>False</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to plotly (e.g., color, line_dash, facet_col, facet_row). Defaults: x='time'/'duration', color='variable', line_dash='representation', symbol=None.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult containing the comparison figure and underlying data.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringPlotAccessor.heatmap","title":"heatmap","text":"<pre><code>heatmap(*, select: SelectType | None = None, colors: str | list[str] | None = None, show: bool | None = None, data_only: bool = False, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot cluster assignments over time as a heatmap timeline.</p> <p>Shows which cluster each timestep belongs to as a horizontal color bar. The x-axis is time, color indicates cluster assignment. This visualization aligns with time series data, making it easy to correlate cluster assignments with other plots.</p> <p>For multi-period/scenario data, uses faceting and/or animation.</p> <p>Parameters:</p> Name Type Description Default <code>select</code> <code>SelectType | None</code> <p>xarray-style selection dict, e.g. {'scenario': 'Base Case'}.</p> <code>None</code> <code>colors</code> <code>str | list[str] | None</code> <p>Colorscale name (str) or list of colors for heatmap coloring. Dicts are not supported for heatmaps. Defaults to plotly template's sequential colorscale.</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure. Defaults to CONFIG.Plotting.default_show.</p> <code>None</code> <code>data_only</code> <code>bool</code> <p>If True, skip figure creation and return only data.</p> <code>False</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to plotly (e.g., facet_col, animation_frame).</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult containing the heatmap figure and cluster assignment data.</p> <code>PlotResult</code> <p>The data has 'cluster' variable with time dimension, matching original timesteps.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base.ClusteringPlotAccessor.clusters","title":"clusters","text":"<pre><code>clusters(variables: str | list[str] | None = None, *, select: SelectType | None = None, colors: ColorType | None = None, show: bool | None = None, data_only: bool = False, **plotly_kwargs: Any) -&gt; PlotResult\n</code></pre> <p>Plot each cluster's typical period profile.</p> <p>Shows each cluster as a separate faceted subplot with all variables colored differently. Useful for understanding what each cluster represents.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>str | list[str] | None</code> <p>Variable(s) to plot. Can be a string, list of strings, or None to plot all time-varying variables.</p> <code>None</code> <code>select</code> <code>SelectType | None</code> <p>xarray-style selection dict, e.g. {'scenario': 'Base Case'}.</p> <code>None</code> <code>colors</code> <code>ColorType | None</code> <p>Color specification (colorscale name, color list, or label-to-color dict).</p> <code>None</code> <code>show</code> <code>bool | None</code> <p>Whether to display the figure. Defaults to CONFIG.Plotting.default_show.</p> <code>None</code> <code>data_only</code> <code>bool</code> <p>If True, skip figure creation and return only data.</p> <code>False</code> <code>**plotly_kwargs</code> <code>Any</code> <p>Additional arguments passed to plotly (e.g., color, facet_col, facet_col_wrap). Defaults: x='time', color='variable', symbol=None.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PlotResult</code> <p>PlotResult containing the figure and underlying data.</p>"},{"location":"api-reference/clustering/base/#flixopt.clustering.base-functions","title":"Functions","text":""},{"location":"api-reference/clustering/base/#flixopt.clustering.base.combine_slices","title":"combine_slices","text":"<pre><code>combine_slices(slices: dict[tuple, ndarray], extra_dims: list[str], dim_coords: dict[str, list], output_dim: str, output_coord: Any, attrs: dict | None = None) -&gt; xr.DataArray\n</code></pre> <p>Combine {(dim_values): 1D_array} dict into a DataArray.</p> <p>This utility simplifies the common pattern of iterating over extra dimensions (like period, scenario), processing each slice, and combining results.</p> <p>Parameters:</p> Name Type Description Default <code>slices</code> <code>dict[tuple, ndarray]</code> <p>Dict mapping dimension value tuples to 1D numpy arrays. Keys are tuples like ('period1', 'scenario1') matching extra_dims order.</p> required <code>extra_dims</code> <code>list[str]</code> <p>Dimension names in order (e.g., ['period', 'scenario']).</p> required <code>dim_coords</code> <code>dict[str, list]</code> <p>Dict mapping dimension names to coordinate values.</p> required <code>output_dim</code> <code>str</code> <p>Name of the output dimension (typically 'time').</p> required <code>output_coord</code> <code>Any</code> <p>Coordinate values for output dimension.</p> required <code>attrs</code> <code>dict | None</code> <p>Optional DataArray attributes.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>DataArray with dims [output_dim, *extra_dims].</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If slices is empty.</p> <code>KeyError</code> <p>If a required key is missing from slices.</p> Example <p>slices = { ...     ('P1', 'base'): np.array([1, 2, 3]), ...     ('P1', 'high'): np.array([4, 5, 6]), ...     ('P2', 'base'): np.array([7, 8, 9]), ...     ('P2', 'high'): np.array([10, 11, 12]), ... } result = combine_slices( ...     slices, ...     extra_dims=['period', 'scenario'], ...     dim_coords={'period': ['P1', 'P2'], 'scenario': ['base', 'high']}, ...     output_dim='time', ...     output_coord=[0, 1, 2], ... ) result.dims ('time', 'period', 'scenario')</p>"},{"location":"api-reference/clustering/intercluster_helpers/","title":"Intercluster helpers","text":""},{"location":"api-reference/clustering/intercluster_helpers/#flixopt.clustering.intercluster_helpers","title":"flixopt.clustering.intercluster_helpers","text":"<p>Helper utilities for inter-cluster storage linking.</p> <p>This module provides utilities for building inter-cluster storage linking constraints following the S-N model from Blanke et al. (2022).</p>"},{"location":"api-reference/clustering/intercluster_helpers/#flixopt.clustering.intercluster_helpers--background","title":"Background","text":"<p>When time series are clustered (aggregated into representative periods), storage behavior needs special handling. The S-N linking model introduces:</p> <ul> <li> <p>SOC_boundary: Absolute state-of-charge at the boundary between original periods.   With N original periods, there are N+1 boundary points.</p> </li> <li> <p>Linking: SOC_boundary[d+1] = SOC_boundary[d] + delta_SOC[cluster_assignments[d]]   Each boundary is connected to the next via the net charge change of the   representative cluster for that period.</p> </li> </ul> <p>These utilities help construct the coordinates and bounds for SOC_boundary variables.</p>"},{"location":"api-reference/clustering/intercluster_helpers/#flixopt.clustering.intercluster_helpers--references","title":"References","text":"<ul> <li>Blanke, T., et al. (2022). \"Inter-Cluster Storage Linking for Time Series   Aggregation in Energy System Optimization Models.\"</li> <li>Kotzur, L., et al. (2018). \"Time series aggregation for energy system design:   Modeling seasonal storage.\"</li> </ul>"},{"location":"api-reference/clustering/intercluster_helpers/#flixopt.clustering.intercluster_helpers--see-also","title":"See Also","text":"<p>:class:<code>flixopt.components.InterclusterStorageModel</code>     The storage model that uses these utilities.</p>"},{"location":"api-reference/clustering/intercluster_helpers/#flixopt.clustering.intercluster_helpers-classes","title":"Classes","text":""},{"location":"api-reference/clustering/intercluster_helpers/#flixopt.clustering.intercluster_helpers.CapacityBounds","title":"CapacityBounds  <code>dataclass</code>","text":"<pre><code>CapacityBounds(lower: DataArray, upper: DataArray, has_investment: bool)\n</code></pre> <p>Bounds for SOC_boundary variable creation.</p> <p>This dataclass holds the lower and upper bounds for the SOC_boundary variable, along with a flag indicating whether investment sizing is used.</p> <p>Attributes:</p> Name Type Description <code>lower</code> <code>DataArray</code> <p>Lower bound DataArray (typically zeros).</p> <code>upper</code> <code>DataArray</code> <p>Upper bound DataArray (capacity or maximum investment size).</p> <code>has_investment</code> <code>bool</code> <p>True if the storage uses InvestParameters for sizing.</p>"},{"location":"api-reference/clustering/intercluster_helpers/#flixopt.clustering.intercluster_helpers-functions","title":"Functions","text":""},{"location":"api-reference/clustering/intercluster_helpers/#flixopt.clustering.intercluster_helpers.extract_capacity_bounds","title":"extract_capacity_bounds","text":"<pre><code>extract_capacity_bounds(capacity_param: InvestParameters | int | float | None, boundary_coords: dict, boundary_dims: list[str]) -&gt; CapacityBounds\n</code></pre> <p>Extract capacity bounds from storage parameters for SOC_boundary variable.</p> <p>This function determines the appropriate bounds for the SOC_boundary variable based on the storage's capacity parameter:</p> <ul> <li>Fixed capacity (numeric): Upper bound is the fixed value.</li> <li>InvestParameters: Upper bound is maximum_size (or fixed_size if set).   The actual bound is enforced via separate constraints linked to investment.size.</li> <li>None/Unbounded: Upper bound is set to a large value (1e6).</li> </ul> <p>The lower bound is always zero (SOC cannot be negative).</p> <p>Parameters:</p> Name Type Description Default <code>capacity_param</code> <code>InvestParameters | int | float | None</code> <p>Storage capacity specification. Can be: - Numeric (int/float): Fixed capacity - InvestParameters: Investment-based sizing with min/max - None: Unbounded storage</p> required <code>boundary_coords</code> <code>dict</code> <p>Coordinate dictionary for SOC_boundary variable. Must contain 'cluster_boundary' key.</p> required <code>boundary_dims</code> <code>list[str]</code> <p>Dimension names for SOC_boundary variable. First dimension must be 'cluster_boundary'.</p> required <p>Returns:</p> Type Description <code>CapacityBounds</code> <p>CapacityBounds with lower/upper bounds and investment flag.</p> Example <p>coords, dims = build_boundary_coords(14, flow_system) bounds = extract_capacity_bounds(InvestParameters(maximum_size=10000), coords, dims) bounds.has_investment True bounds.upper.max() 10000.0</p>"},{"location":"api-reference/clustering/intercluster_helpers/#flixopt.clustering.intercluster_helpers.build_boundary_coords","title":"build_boundary_coords","text":"<pre><code>build_boundary_coords(n_original_clusters: int, flow_system: FlowSystem) -&gt; tuple[dict, list[str]]\n</code></pre> <p>Build coordinates and dimensions for SOC_boundary variable.</p> <p>Creates the coordinate dictionary and dimension list needed to create the SOC_boundary variable. The primary dimension is 'cluster_boundary' with N+1 values (one for each boundary between N original periods).</p> <p>Additional dimensions (period, scenario) are included if present in the FlowSystem, ensuring the SOC_boundary variable has the correct shape for multi-period or stochastic optimizations.</p> <p>Parameters:</p> Name Type Description Default <code>n_original_clusters</code> <code>int</code> <p>Number of original (non-aggregated) time periods. For example, if a year is clustered into 8 typical days but originally had 365 days, this would be 365.</p> required <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem containing optional period/scenario dimensions.</p> required <p>Returns:</p> Type Description <code>tuple[dict, list[str]]</code> <p>Tuple of (coords, dims) where: - coords: Dictionary mapping dimension names to coordinate arrays - dims: List of dimension names in order</p> Example <p>coords, dims = build_boundary_coords(14, flow_system) dims ['cluster_boundary']  # or ['cluster_boundary', 'period'] if periods exist coords['cluster_boundary'] array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])</p>"},{"location":"home/citing/","title":"Citing flixOpt","text":"<p>If you use flixOpt in your research, please cite it.</p>"},{"location":"home/citing/#citation","title":"Citation","text":"<p>When referencing flixOpt in academic publications, please use look here: flixopt citation</p>"},{"location":"home/citing/#publications","title":"Publications","text":"<p>If you've published research using flixOpt, please let us know! We'd love to feature it here.</p>"},{"location":"home/citing/#list-of-publications","title":"List of Publications","text":"<p>Coming soon: A list of academic publications that have used flixOpt.</p>"},{"location":"home/citing/#contributing-back","title":"Contributing Back","text":"<p>If flixOpt helped your research:</p> <ul> <li>Share your model as an example</li> <li>Report issues or contribute code</li> <li>Improve documentation</li> </ul> <p>See the Contributing Guide.</p>"},{"location":"home/citing/#license","title":"License","text":"<p>flixOpt is released under the MIT License. See License for details.</p>"},{"location":"home/installation/","title":"Installation","text":"<p>This guide covers installing flixOpt and its dependencies.</p>"},{"location":"home/installation/#basic-installation","title":"Basic Installation","text":"<p>Install flixOpt directly into your environment using pip:</p> <pre><code>pip install flixopt\n</code></pre> <p>This provides the core functionality with the HiGHS solver included.</p>"},{"location":"home/installation/#full-installation","title":"Full Installation","text":"<p>For all features including interactive network visualizations and time series aggregation:</p> <pre><code>pip install \"flixopt[full]\"\n</code></pre>"},{"location":"home/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to flixOpt or work with the latest development version:</p> <pre><code>git clone https://github.com/flixOpt/flixopt.git\ncd flixopt\npip install -e \".[full,dev,docs]\"\n</code></pre>"},{"location":"home/installation/#solver-installation","title":"Solver Installation","text":""},{"location":"home/installation/#highs-included","title":"HiGHS (Included)","text":"<p>The HiGHS solver is included with flixOpt and works out of the box. No additional installation is required.</p>"},{"location":"home/installation/#gurobi-optional","title":"Gurobi (Optional)","text":"<p>For academic use, Gurobi offers free licenses:</p> <ol> <li>Register for an academic license at gurobi.com</li> <li>Install Gurobi:    <pre><code>pip install gurobipy\n</code></pre></li> <li>Activate your license following Gurobi's instructions</li> </ol>"},{"location":"home/installation/#verification","title":"Verification","text":"<p>Verify your installation by running:</p> <pre><code>import flixopt\nprint(flixopt.__version__)\n</code></pre>"},{"location":"home/installation/#logging-configuration","title":"Logging Configuration","text":"<p>flixOpt uses Python's standard logging module with optional colored output via colorlog. Logging is silent by default but can be easily configured:</p> <pre><code>from flixopt import CONFIG\n\n# Enable colored console logging\nCONFIG.Logging.enable_console('INFO')\n\n# Or use a preset configuration for exploring\nCONFIG.exploring()\n</code></pre> <p>Since flixOpt uses Python's standard logging, you can also configure it directly:</p> <pre><code>import logging\n\n# Get the flixopt logger and configure it\nlogger = logging.getLogger('flixopt')\nlogger.setLevel(logging.DEBUG)\nlogger.addHandler(logging.StreamHandler())\n</code></pre> <p>For more details on logging configuration, see the <code>CONFIG.Logging</code> documentation.</p>"},{"location":"home/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Follow the Quick Start guide</li> <li>Explore the Minimal Example</li> <li>Read about Core Concepts</li> </ul>"},{"location":"home/license/","title":"License","text":"<p>flixOpt is released under the MIT License.</p>"},{"location":"home/license/#mit-license","title":"MIT License","text":"<pre><code>MIT License\n\nCopyright (c) 2022 Chair of Building Energy Systems and Heat Supply - TU Dresden\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"home/license/#what-this-means","title":"What This Means","text":"<p>The MIT License is a permissive open-source license that allows you to:</p> <p>\u2705 Use flixOpt for any purpose, including commercial applications \u2705 Modify the source code to fit your needs \u2705 Distribute copies of flixOpt \u2705 Sublicense under different terms \u2705 Use privately without making your modifications public</p>"},{"location":"home/license/#contributing","title":"Contributing","text":"<p>By contributing to flixOpt, you agree that your contributions will be licensed under the MIT License. See our Contributing Guide for more information.</p>"},{"location":"home/quick-start/","title":"Quick Start","text":"<p>Get up and running with flixOpt in 5 minutes! This guide walks you through creating and solving your first energy system optimization.</p>"},{"location":"home/quick-start/#installation","title":"Installation","text":"<p>First, install flixOpt:</p> <pre><code>pip install \"flixopt[full]\"\n</code></pre>"},{"location":"home/quick-start/#your-first-model","title":"Your First Model","text":"<p>Let's create a simple energy system with a generator, demand, and battery storage.</p>"},{"location":"home/quick-start/#1-import-flixopt","title":"1. Import flixOpt","text":"<pre><code>import flixopt as fx\nimport numpy as np\nimport pandas as pd\n</code></pre>"},{"location":"home/quick-start/#2-define-your-time-horizon","title":"2. Define your time horizon","text":"<pre><code># 24h period with hourly timesteps\ntimesteps = pd.date_range('2024-01-01', periods=24, freq='h')\n</code></pre>"},{"location":"home/quick-start/#2-set-up-the-flow-system","title":"2. Set Up the Flow System","text":"<pre><code># Create the flow system\nflow_system = fx.FlowSystem(timesteps)\n\n# Define an effect to minimize (costs)\ncosts = fx.Effect('costs', 'EUR', 'Minimize total system costs', is_objective=True)\nflow_system.add_elements(costs)\n</code></pre>"},{"location":"home/quick-start/#4-add-components","title":"4. Add Components","text":"<pre><code># Electricity bus\nelectricity_bus = fx.Bus('electricity')\n\n# Solar generator with time-varying output\nsolar_profile = np.array([0, 0, 0, 0, 0, 0, 0.2, 0.5, 0.8, 1.0,\n                          1.0, 0.9, 0.8, 0.7, 0.5, 0.3, 0.1, 0,\n                          0, 0, 0, 0, 0, 0])\n\nsolar = fx.Source(\n    'solar',\n    outputs=[fx.Flow(\n        'power',\n        bus='electricity',\n        size=100,  # 100 kW capacity\n        relative_maximum=solar_profile\n    )\n])\n\n# Demand\ndemand_profile = np.array([30, 25, 20, 20, 25, 35, 50, 70, 80, 75,\n                           70, 65, 60, 65, 70, 80, 90, 95, 85, 70,\n                           60, 50, 40, 35])\n\ndemand = fx.Sink('demand', inputs=[\n    fx.Flow('consumption',\n            bus='electricity',\n            size=1,\n            fixed_relative_profile=demand_profile)\n])\n\n# Battery storage\nbattery = fx.Storage(\n    'battery',\n    charging=fx.Flow('charge', bus='electricity', size=50),\n    discharging=fx.Flow('discharge', bus='electricity', size=50),\n    capacity_in_flow_hours=100,  # 100 kWh capacity\n    initial_charge_state=50,  # Start at 50%\n    eta_charge=0.95,\n    eta_discharge=0.95,\n)\n\n# Add all components to system\nflow_system.add_elements(solar, demand, battery, electricity_bus)\n</code></pre>"},{"location":"home/quick-start/#5-visualize-and-run-optimization","title":"5. Visualize and Run Optimization","text":"<pre><code># Optional: visualize your system structure\nflow_system.topology.plot(path='system.html')\n\n# Run optimization\nflow_system.optimize(fx.solvers.HighsSolver())\n</code></pre>"},{"location":"home/quick-start/#6-access-and-visualize-results","title":"6. Access and Visualize Results","text":"<pre><code># Access raw solution data\nprint(flow_system.solution)\n\n# Use statistics for aggregated data\nprint(flow_system.statistics.flow_hours)\n\n# Access component-specific results\nprint(flow_system.components['battery'].solution)\n\n# Visualize results\nflow_system.statistics.plot.balance('electricity')\nflow_system.statistics.plot.storage('battery')\n</code></pre>"},{"location":"home/quick-start/#7-save-results-optional","title":"7. Save Results (Optional)","text":"<pre><code># Save the flow system (includes inputs and solution)\nflow_system.to_netcdf('results/solar_battery.nc')\n\n# Load it back later\nloaded_fs = fx.FlowSystem.from_netcdf('results/solar_battery.nc')\n</code></pre>"},{"location":"home/quick-start/#whats-next","title":"What's Next?","text":"<p>Now that you've created your first model, you can:</p> <ul> <li>Learn the concepts - Read the Core Concepts guide</li> <li>Explore examples - Check out more Examples</li> <li>Deep dive - Study the Mathematical Formulation</li> <li>Build complex models - Use Recipes for common patterns</li> </ul>"},{"location":"home/quick-start/#common-workflow","title":"Common Workflow","text":"<p>Most flixOpt projects follow this pattern:</p> <ol> <li>Define time series - Set up the temporal resolution</li> <li>Create flow system - Initialize with time series and effects</li> <li>Add buses - Define connection points</li> <li>Add components - Create generators, storage, converters, loads</li> <li>Verify structure - Use <code>flow_system.topology.plot()</code> to visualize</li> <li>Run optimization - Call <code>flow_system.optimize(solver)</code></li> <li>Analyze results - Via <code>flow_system.statistics</code> and <code>.solution</code></li> <li>Visualize - Use <code>flow_system.statistics.plot.*</code> methods</li> </ol>"},{"location":"home/quick-start/#tips","title":"Tips","text":"<ul> <li>Start simple and add complexity incrementally</li> <li>Use meaningful names for components and flows</li> <li>Check solver status before analyzing results</li> <li>Enable logging during development for debugging</li> <li>Visualize results to verify model behavior</li> </ul>"},{"location":"home/users/","title":"Who Uses flixOpt?","text":"<p>flixOpt is developed and used primarily in academic research for energy system optimization.</p>"},{"location":"home/users/#primary-users","title":"Primary Users","text":"<ul> <li>Researchers - Energy system modeling and optimization studies</li> <li>Students - Master's and PhD thesis projects</li> <li>Engineers - Feasibility studies and system planning</li> </ul>"},{"location":"home/users/#typical-applications","title":"Typical Applications","text":"<ul> <li>Dispatch optimization with renewable integration</li> <li>Capacity expansion planning</li> <li>Battery and thermal storage sizing</li> <li>District heating network optimization</li> <li>Combined heat and power (CHP) systems</li> <li>Multi-energy systems and sector coupling</li> </ul>"},{"location":"home/users/#get-involved","title":"Get Involved","text":"<p>Using flixOpt in your research? Consider:</p> <ul> <li>Citing flixOpt in your publications</li> <li>Sharing your model as an example</li> <li>Contributing to the codebase</li> <li>Joining discussions</li> </ul>"},{"location":"notebooks/","title":"Examples","text":"<p>Learn flixopt through practical examples organized by topic. Each notebook includes a real-world user story and progressively builds your understanding.</p>"},{"location":"notebooks/#basics","title":"Basics","text":"Notebook Description 01-Quickstart Minimal working example - heat a workshop with a gas boiler 02-Heat System District heating with thermal storage and time-varying prices"},{"location":"notebooks/#investment","title":"Investment","text":"Notebook Description 03-Sizing Size a solar heating system - let the optimizer decide equipment sizes 04-Constraints Industrial boiler with startup costs, minimum uptime, and load constraints"},{"location":"notebooks/#advanced","title":"Advanced","text":"Notebook Description 05-Multi-Carrier Hospital with CHP producing both electricity and heat 10-Transmission Connect sites with pipelines or cables, including losses and bidirectional flow"},{"location":"notebooks/#non-linear-modeling","title":"Non-Linear Modeling","text":"Notebook Description 06a-Time-Varying Heat pump with temperature-dependent COP 06b-Piecewise Conversion Gas engine with load-dependent efficiency curves 06c-Piecewise Effects Economies of scale in investment costs"},{"location":"notebooks/#scaling","title":"Scaling","text":"Notebook Description 07-Scenarios Multi-year planning with uncertain demand scenarios 08a-Aggregation Speed up large problems with resampling and two-stage optimization 08b-Rolling Horizon Decompose large problems into sequential time segments"},{"location":"notebooks/#clustering","title":"Clustering","text":"Notebook Description 08c-Clustering Reduce timesteps using typical periods with tsam integration 08c2-Storage Modes Compare storage behavior modes in clustered systems 08d-Multi-Period Clustering Clustering with multiple periods and scenarios 08f-Segmentation Intra-period segmentation for variable timestep durations 08e-Clustering Internals Deep dive into clustering data structures and algorithms"},{"location":"notebooks/#results","title":"Results","text":"Notebook Description 09-Plotting Access optimization results and create visualizations"},{"location":"notebooks/#key-concepts","title":"Key Concepts","text":"Concept Introduced In <code>FlowSystem</code>, <code>Bus</code>, <code>Flow</code> Quickstart <code>Storage</code>, time-varying prices Heat System <code>InvestParameters</code>, optimal sizing Sizing <code>StatusParameters</code>, startup costs Constraints Multi-carrier, CHP Multi-Carrier <code>Transmission</code>, losses, bidirectional Transmission Time-varying <code>conversion_factors</code> Time-Varying Parameters <code>PiecewiseConversion</code>, part-load efficiency Piecewise Conversion <code>PiecewiseEffects</code>, economies of scale Piecewise Effects Periods, scenarios, weights Scenarios <code>transform.resample()</code>, <code>fix_sizes()</code> Aggregation <code>optimize.rolling_horizon()</code> Rolling Horizon <code>transform.cluster()</code>, typical periods Clustering <code>cluster_mode</code>, inter-cluster storage Storage Modes <code>transform.expand()</code>, segmentation Segmentation <code>statistics</code>, <code>topology</code>, plotting Plotting"},{"location":"notebooks/01-quickstart/","title":"Quickstart","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport plotly.express as px\nimport xarray as xr\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import pandas as pd import plotly.express as px import xarray as xr  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre>timesteps = pd.date_range('2024-01-15 08:00', periods=4, freq='h')\nprint(f'Optimizing from {timesteps[0]} to {timesteps[-1]}')\n</pre> timesteps = pd.date_range('2024-01-15 08:00', periods=4, freq='h') print(f'Optimizing from {timesteps[0]} to {timesteps[-1]}') <pre>Optimizing from 2024-01-15 08:00:00 to 2024-01-15 11:00:00\n</pre> In\u00a0[3]: Copied! <pre># Heat demand in kW for each hour - using xarray\nheat_demand = xr.DataArray(\n    [30, 50, 45, 25],\n    dims=['time'],\n    coords={'time': timesteps},\n    name='Heat Demand [kW]',\n)\n\n# Visualize the demand with plotly\nfig = px.bar(x=heat_demand.time.values, y=heat_demand.values, labels={'x': 'Time', 'y': 'Heat Demand [kW]'})\nfig\n</pre> # Heat demand in kW for each hour - using xarray heat_demand = xr.DataArray(     [30, 50, 45, 25],     dims=['time'],     coords={'time': timesteps},     name='Heat Demand [kW]', )  # Visualize the demand with plotly fig = px.bar(x=heat_demand.time.values, y=heat_demand.values, labels={'x': 'Time', 'y': 'Heat Demand [kW]'}) fig In\u00a0[4]: Copied! <pre># Create the FlowSystem container\nflow_system = fx.FlowSystem(timesteps)\n\nflow_system.add_elements(\n    # === Buses: Balance nodes for energy carriers ===\n    fx.Bus('Gas'),  # Natural gas network connection\n    fx.Bus('Heat'),  # Heat distribution within workshop\n    # === Effect: What we want to minimize ===\n    fx.Effect('costs', '\u20ac', 'Total Costs', is_standard=True, is_objective=True),\n    # === Gas Supply: Unlimited gas at 0.08 \u20ac/kWh ===\n    fx.Source(\n        'GasGrid',\n        outputs=[fx.Flow('Gas', bus='Gas', size=1000, effects_per_flow_hour=0.08)],\n    ),\n    # === Boiler: Converts gas to heat at 90% efficiency ===\n    fx.linear_converters.Boiler(\n        'Boiler',\n        thermal_efficiency=0.9,\n        thermal_flow=fx.Flow('Heat', bus='Heat', size=100),  # 100 kW capacity\n        fuel_flow=fx.Flow('Gas', bus='Gas'),\n    ),\n    # === Workshop: Heat demand that must be met ===\n    fx.Sink(\n        'Workshop',\n        inputs=[fx.Flow('Heat', bus='Heat', size=1, fixed_relative_profile=heat_demand.values)],\n    ),\n)\n</pre> # Create the FlowSystem container flow_system = fx.FlowSystem(timesteps)  flow_system.add_elements(     # === Buses: Balance nodes for energy carriers ===     fx.Bus('Gas'),  # Natural gas network connection     fx.Bus('Heat'),  # Heat distribution within workshop     # === Effect: What we want to minimize ===     fx.Effect('costs', '\u20ac', 'Total Costs', is_standard=True, is_objective=True),     # === Gas Supply: Unlimited gas at 0.08 \u20ac/kWh ===     fx.Source(         'GasGrid',         outputs=[fx.Flow('Gas', bus='Gas', size=1000, effects_per_flow_hour=0.08)],     ),     # === Boiler: Converts gas to heat at 90% efficiency ===     fx.linear_converters.Boiler(         'Boiler',         thermal_efficiency=0.9,         thermal_flow=fx.Flow('Heat', bus='Heat', size=100),  # 100 kW capacity         fuel_flow=fx.Flow('Gas', bus='Gas'),     ),     # === Workshop: Heat demand that must be met ===     fx.Sink(         'Workshop',         inputs=[fx.Flow('Heat', bus='Heat', size=1, fixed_relative_profile=heat_demand.values)],     ), ) In\u00a0[5]: Copied! <pre>flow_system.optimize(fx.solvers.HighsSolver());\n</pre> flow_system.optimize(fx.solvers.HighsSolver()); In\u00a0[6]: Copied! <pre>flow_system.statistics.plot.balance('Heat')\n</pre> flow_system.statistics.plot.balance('Heat') Out[6]: In\u00a0[7]: Copied! <pre>total_costs = flow_system.solution['costs'].item()\ntotal_heat = float(heat_demand.sum())\ngas_consumed = total_heat / 0.9  # Account for boiler efficiency\n\nprint(f'Total heat demand: {total_heat:.1f} kWh')\nprint(f'Gas consumed: {gas_consumed:.1f} kWh')\nprint(f'Total costs: {total_costs:.2f} \u20ac')\nprint(f'Average cost: {total_costs / total_heat:.3f} \u20ac/kWh_heat')\n</pre> total_costs = flow_system.solution['costs'].item() total_heat = float(heat_demand.sum()) gas_consumed = total_heat / 0.9  # Account for boiler efficiency  print(f'Total heat demand: {total_heat:.1f} kWh') print(f'Gas consumed: {gas_consumed:.1f} kWh') print(f'Total costs: {total_costs:.2f} \u20ac') print(f'Average cost: {total_costs / total_heat:.3f} \u20ac/kWh_heat') <pre>Total heat demand: 150.0 kWh\nGas consumed: 166.7 kWh\nTotal costs: 13.33 \u20ac\nAverage cost: 0.089 \u20ac/kWh_heat\n</pre> In\u00a0[8]: Copied! <pre># Plot all flow rates\nflow_system.statistics.plot.flows()\n</pre> # Plot all flow rates flow_system.statistics.plot.flows() Out[8]: In\u00a0[9]: Copied! <pre>flow_system.statistics.plot.sankey.flows()\n</pre> flow_system.statistics.plot.sankey.flows() Out[9]:"},{"location":"notebooks/01-quickstart/#quickstart","title":"Quickstart\u00b6","text":"<p>Heat a small workshop with a gas boiler - the minimal working example.</p> <p>This notebook introduces the core concepts of flixopt:</p> <ul> <li>FlowSystem: The container for your energy system model</li> <li>Bus: Balance nodes where energy flows meet</li> <li>Effect: Quantities to track and optimize (costs, emissions)</li> <li>Components: Equipment like boilers, sources, and sinks</li> <li>Flow: Connections between components and buses</li> </ul>"},{"location":"notebooks/01-quickstart/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/01-quickstart/#define-the-time-horizon","title":"Define the Time Horizon\u00b6","text":"<p>Every optimization needs a time horizon. Here we model a simple 4-hour period:</p>"},{"location":"notebooks/01-quickstart/#define-the-heat-demand","title":"Define the Heat Demand\u00b6","text":"<p>The workshop has varying heat demand throughout the morning:</p>"},{"location":"notebooks/01-quickstart/#build-the-energy-system-model","title":"Build the Energy System Model\u00b6","text":"<p>Now we create the FlowSystem and add all components:</p> <pre><code>  Gas Supply \u2500\u2500\u25ba [Gas Bus] \u2500\u2500\u25ba Boiler \u2500\u2500\u25ba [Heat Bus] \u2500\u2500\u25ba Workshop\n       \u20ac                         \u03b7=90%                    Demand\n</code></pre>"},{"location":"notebooks/01-quickstart/#run-the-optimization","title":"Run the Optimization\u00b6","text":"<p>Now we solve the model using the HiGHS solver (open-source, included with flixopt):</p>"},{"location":"notebooks/01-quickstart/#analyze-results","title":"Analyze Results\u00b6","text":""},{"location":"notebooks/01-quickstart/#heat-balance","title":"Heat Balance\u00b6","text":"<p>The <code>statistics.plot.balance()</code> method shows how each bus is balanced:</p>"},{"location":"notebooks/01-quickstart/#total-costs","title":"Total Costs\u00b6","text":"<p>Access the optimized objective value:</p>"},{"location":"notebooks/01-quickstart/#flow-rates-over-time","title":"Flow Rates Over Time\u00b6","text":"<p>Visualize all flow rates using the built-in plotting accessor:</p>"},{"location":"notebooks/01-quickstart/#energy-flow-sankey","title":"Energy Flow Sankey\u00b6","text":"<p>A Sankey diagram visualizes the total energy flows through the system:</p>"},{"location":"notebooks/01-quickstart/#summary","title":"Summary\u00b6","text":"<p>In this quickstart, you learned the basic workflow:</p> <ol> <li>Create a <code>FlowSystem</code> with timesteps</li> <li>Add buses, effects, and components</li> <li>Optimize with <code>flow_system.optimize(solver)</code></li> <li>Analyze results via <code>flow_system.statistics</code></li> </ol>"},{"location":"notebooks/01-quickstart/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>02-heat-system: Add thermal storage to shift loads</li> <li>03-investment-optimization: Optimize equipment sizing</li> </ul>"},{"location":"notebooks/02-heat-system/","title":"Heat System","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport xarray as xr\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import pandas as pd import xarray as xr  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre>from data.tutorial_data import get_heat_system_data\n\ndata = get_heat_system_data()\ntimesteps = data['timesteps']\nheat_demand = data['heat_demand']\ngas_price = data['gas_price']\n</pre> from data.tutorial_data import get_heat_system_data  data = get_heat_system_data() timesteps = data['timesteps'] heat_demand = data['heat_demand'] gas_price = data['gas_price'] In\u00a0[3]: Copied! <pre># Visualize the demand pattern with plotly\ndemand_ds = xr.Dataset(\n    {\n        'Heat Demand': xr.DataArray(heat_demand, dims=['time'], coords={'time': timesteps}),\n    }\n)\ndemand_ds.plotly.line(x='time', title='Office Heat Demand Profile')\n</pre> # Visualize the demand pattern with plotly demand_ds = xr.Dataset(     {         'Heat Demand': xr.DataArray(heat_demand, dims=['time'], coords={'time': timesteps}),     } ) demand_ds.plotly.line(x='time', title='Office Heat Demand Profile') In\u00a0[4]: Copied! <pre># Visualize time-of-use gas prices with plotly\nprice_ds = xr.Dataset(\n    {\n        'Gas Price': xr.DataArray(gas_price, dims=['time'], coords={'time': timesteps}),\n    }\n)\nprice_ds.plotly.line(x='time', title='Gas Price [\u20ac/kWh]')\n</pre> # Visualize time-of-use gas prices with plotly price_ds = xr.Dataset(     {         'Gas Price': xr.DataArray(gas_price, dims=['time'], coords={'time': timesteps}),     } ) price_ds.plotly.line(x='time', title='Gas Price [\u20ac/kWh]') In\u00a0[5]: Copied! <pre>flow_system = fx.FlowSystem(timesteps)\nflow_system.add_carriers(\n    fx.Carrier('gas', '#3498db', 'kW'),\n    fx.Carrier('heat', '#e74c3c', 'kW'),\n)\nflow_system.add_elements(\n    # === Buses ===\n    fx.Bus('Gas', carrier='gas'),\n    fx.Bus('Heat', carrier='heat'),\n    # === Effect ===\n    fx.Effect('costs', '\u20ac', 'Operating Costs', is_standard=True, is_objective=True),\n    # === Gas Supply with time-varying price ===\n    fx.Source(\n        'GasGrid',\n        outputs=[fx.Flow('Gas', bus='Gas', size=500, effects_per_flow_hour=gas_price)],\n    ),\n    # === Gas Boiler: 150 kW, 92% efficiency ===\n    fx.linear_converters.Boiler(\n        'Boiler',\n        thermal_efficiency=0.92,\n        thermal_flow=fx.Flow('Heat', bus='Heat', size=150),\n        fuel_flow=fx.Flow('Gas', bus='Gas'),\n    ),\n    # === Thermal Storage: 500 kWh tank ===\n    fx.Storage(\n        'ThermalStorage',\n        capacity_in_flow_hours=500,  # 500 kWh capacity\n        initial_charge_state=250,  # Start half-full\n        minimal_final_charge_state=200,  # End with at least 200 kWh\n        eta_charge=0.98,  # 98% charging efficiency\n        eta_discharge=0.98,  # 98% discharging efficiency\n        relative_loss_per_hour=0.005,  # 0.5% heat loss per hour\n        charging=fx.Flow('Charge', bus='Heat', size=100),  # Max 100 kW charging\n        discharging=fx.Flow('Discharge', bus='Heat', size=100),  # Max 100 kW discharging\n    ),\n    # === Office Heat Demand ===\n    fx.Sink(\n        'Office',\n        inputs=[fx.Flow('Heat', bus='Heat', size=1, fixed_relative_profile=heat_demand)],\n    ),\n)\n</pre> flow_system = fx.FlowSystem(timesteps) flow_system.add_carriers(     fx.Carrier('gas', '#3498db', 'kW'),     fx.Carrier('heat', '#e74c3c', 'kW'), ) flow_system.add_elements(     # === Buses ===     fx.Bus('Gas', carrier='gas'),     fx.Bus('Heat', carrier='heat'),     # === Effect ===     fx.Effect('costs', '\u20ac', 'Operating Costs', is_standard=True, is_objective=True),     # === Gas Supply with time-varying price ===     fx.Source(         'GasGrid',         outputs=[fx.Flow('Gas', bus='Gas', size=500, effects_per_flow_hour=gas_price)],     ),     # === Gas Boiler: 150 kW, 92% efficiency ===     fx.linear_converters.Boiler(         'Boiler',         thermal_efficiency=0.92,         thermal_flow=fx.Flow('Heat', bus='Heat', size=150),         fuel_flow=fx.Flow('Gas', bus='Gas'),     ),     # === Thermal Storage: 500 kWh tank ===     fx.Storage(         'ThermalStorage',         capacity_in_flow_hours=500,  # 500 kWh capacity         initial_charge_state=250,  # Start half-full         minimal_final_charge_state=200,  # End with at least 200 kWh         eta_charge=0.98,  # 98% charging efficiency         eta_discharge=0.98,  # 98% discharging efficiency         relative_loss_per_hour=0.005,  # 0.5% heat loss per hour         charging=fx.Flow('Charge', bus='Heat', size=100),  # Max 100 kW charging         discharging=fx.Flow('Discharge', bus='Heat', size=100),  # Max 100 kW discharging     ),     # === Office Heat Demand ===     fx.Sink(         'Office',         inputs=[fx.Flow('Heat', bus='Heat', size=1, fixed_relative_profile=heat_demand)],     ), ) In\u00a0[6]: Copied! <pre>flow_system.optimize(fx.solvers.HighsSolver(mip_gap=0.01));\n</pre> flow_system.optimize(fx.solvers.HighsSolver(mip_gap=0.01)); In\u00a0[7]: Copied! <pre>flow_system.statistics.plot.balance('Heat')\n</pre> flow_system.statistics.plot.balance('Heat') Out[7]: In\u00a0[8]: Copied! <pre>flow_system.statistics.plot.balance('ThermalStorage')\n</pre> flow_system.statistics.plot.balance('ThermalStorage') Out[8]: In\u00a0[9]: Copied! <pre>flow_system.statistics.plot.heatmap('Boiler(Heat)')\n</pre> flow_system.statistics.plot.heatmap('Boiler(Heat)') Out[9]: In\u00a0[10]: Copied! <pre>flow_system.statistics.plot.heatmap('ThermalStorage')\n</pre> flow_system.statistics.plot.heatmap('ThermalStorage') Out[10]: In\u00a0[11]: Copied! <pre>total_heat = heat_demand.sum()\n\npd.DataFrame(\n    {\n        'Total operating costs [EUR]': flow_system.solution['costs'].item(),\n        'Total heat delivered [kWh]': total_heat,\n        'Average cost [ct/kWh]': flow_system.solution['costs'].item() / total_heat * 100,\n    },\n    index=['Value'],\n).T\n</pre> total_heat = heat_demand.sum()  pd.DataFrame(     {         'Total operating costs [EUR]': flow_system.solution['costs'].item(),         'Total heat delivered [kWh]': total_heat,         'Average cost [ct/kWh]': flow_system.solution['costs'].item() / total_heat * 100,     },     index=['Value'], ).T Out[11]: Value Total operating costs [EUR] 558.830517 Total heat delivered [kWh] 8007.338386 Average cost [ct/kWh] 6.978980 In\u00a0[12]: Copied! <pre># Plot all flow rates\nflow_system.statistics.plot.flows()\n</pre> # Plot all flow rates flow_system.statistics.plot.flows() Out[12]: In\u00a0[13]: Copied! <pre># Plot storage charge states\nflow_system.statistics.plot.storage('ThermalStorage')\n</pre> # Plot storage charge states flow_system.statistics.plot.storage('ThermalStorage') Out[13]: In\u00a0[14]: Copied! <pre>flow_system.statistics.plot.sankey.flows()\n</pre> flow_system.statistics.plot.sankey.flows() Out[14]:"},{"location":"notebooks/02-heat-system/#heat-system","title":"Heat System\u00b6","text":"<p>District heating with thermal storage and time-varying prices.</p> <p>This notebook introduces:</p> <ul> <li>Storage: Thermal buffer tanks with charging/discharging</li> <li>Time series data: Using real demand profiles</li> <li>Multiple components: Combining boiler, storage, and loads</li> <li>Result visualization: Heatmaps, balance plots, and charge states</li> </ul>"},{"location":"notebooks/02-heat-system/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/02-heat-system/#define-time-horizon-and-demand","title":"Define Time Horizon and Demand\u00b6","text":"<p>We model one week with hourly resolution. The office has typical weekday patterns:</p>"},{"location":"notebooks/02-heat-system/#define-gas-prices","title":"Define Gas Prices\u00b6","text":"<p>Gas prices vary with time-of-use tariffs:</p>"},{"location":"notebooks/02-heat-system/#build-the-energy-system","title":"Build the Energy System\u00b6","text":"<p>The system includes:</p> <ul> <li>Gas boiler (150 kW thermal capacity)</li> <li>Thermal storage tank (500 kWh capacity)</li> <li>Office building heat demand</li> </ul> <pre><code>Gas Grid \u2500\u2500\u25ba [Gas] \u2500\u2500\u25ba Boiler \u2500\u2500\u25ba [Heat] \u25c4\u2500\u2500\u25ba Storage\n                                    \u2502\n                                    \u25bc\n                                 Office\n</code></pre>"},{"location":"notebooks/02-heat-system/#run-optimization","title":"Run Optimization\u00b6","text":""},{"location":"notebooks/02-heat-system/#analyze-results","title":"Analyze Results\u00b6","text":""},{"location":"notebooks/02-heat-system/#heat-balance","title":"Heat Balance\u00b6","text":"<p>See how the boiler and storage work together to meet demand:</p>"},{"location":"notebooks/02-heat-system/#storage-charge-state","title":"Storage Charge State\u00b6","text":"<p>Track how the storage level varies over time:</p>"},{"location":"notebooks/02-heat-system/#heatmap-visualization","title":"Heatmap Visualization\u00b6","text":"<p>Heatmaps show patterns across hours and days:</p>"},{"location":"notebooks/02-heat-system/#cost-analysis","title":"Cost Analysis\u00b6","text":""},{"location":"notebooks/02-heat-system/#flow-rates-and-charge-states","title":"Flow Rates and Charge States\u00b6","text":"<p>Visualize all flow rates and storage charge states:</p>"},{"location":"notebooks/02-heat-system/#energy-flow-sankey","title":"Energy Flow Sankey\u00b6","text":"<p>A Sankey diagram visualizes the total energy flows through the system:</p>"},{"location":"notebooks/02-heat-system/#key-insights","title":"Key Insights\u00b6","text":"<p>The optimization reveals how storage enables load shifting:</p> <ol> <li>Charge during off-peak: When gas is cheap (night), the boiler runs at higher output to charge the storage</li> <li>Discharge during peak: During expensive periods, storage supplements the boiler</li> <li>Weekend patterns: Lower demand allows more storage cycling</li> </ol>"},{"location":"notebooks/02-heat-system/#summary","title":"Summary\u00b6","text":"<p>You learned how to:</p> <ul> <li>Add Storage components with efficiency and losses</li> <li>Use time-varying prices in effects</li> <li>Visualize results with heatmaps and balance plots</li> <li>Access raw data via statistics.flow_rates and statistics.charge_states</li> </ul>"},{"location":"notebooks/02-heat-system/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>03-investment-optimization: Optimize storage size</li> <li>04-operational-constraints: Add startup costs and minimum run times</li> </ul>"},{"location":"notebooks/03-investment-optimization/","title":"Sizing","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport xarray as xr\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import pandas as pd import xarray as xr  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre>from data.tutorial_data import get_investment_data\n\ndata = get_investment_data()\ntimesteps = data['timesteps']\nsolar_profile = data['solar_profile']\npool_demand = data['pool_demand']\nGAS_PRICE = data['gas_price']\nSOLAR_COST_WEEKLY = data['solar_cost_per_kw_week']\nTANK_COST_WEEKLY = data['tank_cost_per_kwh_week']\n</pre> from data.tutorial_data import get_investment_data  data = get_investment_data() timesteps = data['timesteps'] solar_profile = data['solar_profile'] pool_demand = data['pool_demand'] GAS_PRICE = data['gas_price'] SOLAR_COST_WEEKLY = data['solar_cost_per_kw_week'] TANK_COST_WEEKLY = data['tank_cost_per_kwh_week'] In\u00a0[3]: Copied! <pre># Visualize profiles with plotly\nprofiles = xr.Dataset(\n    {\n        'Solar Profile [kW/kW]': xr.DataArray(solar_profile, dims=['time'], coords={'time': timesteps}),\n        'Pool Demand [kW]': xr.DataArray(pool_demand, dims=['time'], coords={'time': timesteps}),\n    }\n)\nprofiles.plotly.line(x='time', title='Solar and Pool Profiles', height=300)\n</pre> # Visualize profiles with plotly profiles = xr.Dataset(     {         'Solar Profile [kW/kW]': xr.DataArray(solar_profile, dims=['time'], coords={'time': timesteps}),         'Pool Demand [kW]': xr.DataArray(pool_demand, dims=['time'], coords={'time': timesteps}),     } ) profiles.plotly.line(x='time', title='Solar and Pool Profiles', height=300) In\u00a0[4]: Copied! <pre>flow_system = fx.FlowSystem(timesteps)\nflow_system.add_carriers(\n    fx.Carrier('gas', '#3498db', 'kW'),\n    fx.Carrier('heat', '#e74c3c', 'kW'),\n)\nflow_system.add_elements(\n    # === Buses ===\n    fx.Bus('Heat', carrier='heat'),\n    fx.Bus('Gas', carrier='gas'),\n    # === Effects ===\n    fx.Effect('costs', '\u20ac', 'Total Costs', is_standard=True, is_objective=True),\n    # === Gas Supply ===\n    fx.Source(\n        'GasGrid',\n        outputs=[fx.Flow('Gas', bus='Gas', size=500, effects_per_flow_hour=GAS_PRICE)],\n    ),\n    # === Gas Boiler (existing, fixed size) ===\n    fx.linear_converters.Boiler(\n        'GasBoiler',\n        thermal_efficiency=0.92,\n        thermal_flow=fx.Flow('Heat', bus='Heat', size=200),  # 200 kW existing\n        fuel_flow=fx.Flow('Gas', bus='Gas'),\n    ),\n    # === Solar Collectors (size to be optimized) ===\n    fx.Source(\n        'SolarCollectors',\n        outputs=[\n            fx.Flow(\n                'Heat',\n                bus='Heat',\n                # Investment optimization: find optimal size between 0-500 kW\n                size=fx.InvestParameters(\n                    minimum_size=0,\n                    maximum_size=500,\n                    effects_of_investment_per_size={'costs': SOLAR_COST_WEEKLY},\n                ),\n                # Solar output depends on radiation profile\n                fixed_relative_profile=solar_profile,\n            )\n        ],\n    ),\n    # === Buffer Tank (size to be optimized) ===\n    fx.Storage(\n        'BufferTank',\n        # Investment optimization: find optimal capacity between 0-2000 kWh\n        capacity_in_flow_hours=fx.InvestParameters(\n            minimum_size=0,\n            maximum_size=2000,\n            effects_of_investment_per_size={'costs': TANK_COST_WEEKLY},\n        ),\n        initial_charge_state=0,\n        eta_charge=0.95,\n        eta_discharge=0.95,\n        relative_loss_per_hour=0.01,  # 1% loss per hour\n        charging=fx.Flow('Charge', bus='Heat', size=200),\n        discharging=fx.Flow('Discharge', bus='Heat', size=200),\n    ),\n    # === Pool Heat Demand ===\n    fx.Sink(\n        'Pool',\n        inputs=[fx.Flow('Heat', bus='Heat', size=1, fixed_relative_profile=pool_demand)],\n    ),\n)\n</pre> flow_system = fx.FlowSystem(timesteps) flow_system.add_carriers(     fx.Carrier('gas', '#3498db', 'kW'),     fx.Carrier('heat', '#e74c3c', 'kW'), ) flow_system.add_elements(     # === Buses ===     fx.Bus('Heat', carrier='heat'),     fx.Bus('Gas', carrier='gas'),     # === Effects ===     fx.Effect('costs', '\u20ac', 'Total Costs', is_standard=True, is_objective=True),     # === Gas Supply ===     fx.Source(         'GasGrid',         outputs=[fx.Flow('Gas', bus='Gas', size=500, effects_per_flow_hour=GAS_PRICE)],     ),     # === Gas Boiler (existing, fixed size) ===     fx.linear_converters.Boiler(         'GasBoiler',         thermal_efficiency=0.92,         thermal_flow=fx.Flow('Heat', bus='Heat', size=200),  # 200 kW existing         fuel_flow=fx.Flow('Gas', bus='Gas'),     ),     # === Solar Collectors (size to be optimized) ===     fx.Source(         'SolarCollectors',         outputs=[             fx.Flow(                 'Heat',                 bus='Heat',                 # Investment optimization: find optimal size between 0-500 kW                 size=fx.InvestParameters(                     minimum_size=0,                     maximum_size=500,                     effects_of_investment_per_size={'costs': SOLAR_COST_WEEKLY},                 ),                 # Solar output depends on radiation profile                 fixed_relative_profile=solar_profile,             )         ],     ),     # === Buffer Tank (size to be optimized) ===     fx.Storage(         'BufferTank',         # Investment optimization: find optimal capacity between 0-2000 kWh         capacity_in_flow_hours=fx.InvestParameters(             minimum_size=0,             maximum_size=2000,             effects_of_investment_per_size={'costs': TANK_COST_WEEKLY},         ),         initial_charge_state=0,         eta_charge=0.95,         eta_discharge=0.95,         relative_loss_per_hour=0.01,  # 1% loss per hour         charging=fx.Flow('Charge', bus='Heat', size=200),         discharging=fx.Flow('Discharge', bus='Heat', size=200),     ),     # === Pool Heat Demand ===     fx.Sink(         'Pool',         inputs=[fx.Flow('Heat', bus='Heat', size=1, fixed_relative_profile=pool_demand)],     ), ) In\u00a0[5]: Copied! <pre>flow_system.optimize(fx.solvers.HighsSolver(mip_gap=0.01));\n</pre> flow_system.optimize(fx.solvers.HighsSolver(mip_gap=0.01)); In\u00a0[6]: Copied! <pre>solar_size = flow_system.statistics.sizes['SolarCollectors(Heat)'].item()\ntank_size = flow_system.statistics.sizes['BufferTank'].item()\n\npd.DataFrame(\n    {\n        'Solar [kW]': solar_size,\n        'Tank [kWh]': tank_size,\n        'Ratio [kWh/kW]': tank_size / solar_size if solar_size &gt; 0 else float('nan'),\n    },\n    index=['Optimal Size'],\n).T\n</pre> solar_size = flow_system.statistics.sizes['SolarCollectors(Heat)'].item() tank_size = flow_system.statistics.sizes['BufferTank'].item()  pd.DataFrame(     {         'Solar [kW]': solar_size,         'Tank [kWh]': tank_size,         'Ratio [kWh/kW]': tank_size / solar_size if solar_size &gt; 0 else float('nan'),     },     index=['Optimal Size'], ).T Out[6]: Optimal Size Solar [kW] 458.451276 Tank [kWh] 747.696332 Ratio [kWh/kW] 1.630918 In\u00a0[7]: Copied! <pre>flow_system.statistics.plot.sizes()\n</pre> flow_system.statistics.plot.sizes() Out[7]: In\u00a0[8]: Copied! <pre>total_costs = flow_system.solution['costs'].item()\n\n# Calculate cost components\nsolar_invest = solar_size * SOLAR_COST_WEEKLY\ntank_invest = tank_size * TANK_COST_WEEKLY\ngas_costs = total_costs - solar_invest - tank_invest\n\npd.DataFrame(\n    {\n        'Solar Investment': {'EUR': solar_invest, '%': solar_invest / total_costs * 100},\n        'Tank Investment': {'EUR': tank_invest, '%': tank_invest / total_costs * 100},\n        'Gas Costs': {'EUR': gas_costs, '%': gas_costs / total_costs * 100},\n        'Total': {'EUR': total_costs, '%': 100.0},\n    }\n)\n</pre> total_costs = flow_system.solution['costs'].item()  # Calculate cost components solar_invest = solar_size * SOLAR_COST_WEEKLY tank_invest = tank_size * TANK_COST_WEEKLY gas_costs = total_costs - solar_invest - tank_invest  pd.DataFrame(     {         'Solar Investment': {'EUR': solar_invest, '%': solar_invest / total_costs * 100},         'Tank Investment': {'EUR': tank_invest, '%': tank_invest / total_costs * 100},         'Gas Costs': {'EUR': gas_costs, '%': gas_costs / total_costs * 100},         'Total': {'EUR': total_costs, '%': 100.0},     } ) Out[8]: Solar Investment Tank Investment Gas Costs Total EUR 176.327414 21.568163 585.088163 782.98374 % 22.519933 2.754612 74.725455 100.00000 In\u00a0[9]: Copied! <pre>flow_system.statistics.plot.balance('Heat')\n</pre> flow_system.statistics.plot.balance('Heat') Out[9]: In\u00a0[10]: Copied! <pre>flow_system.statistics.plot.heatmap('SolarCollectors(Heat)')\n</pre> flow_system.statistics.plot.heatmap('SolarCollectors(Heat)') Out[10]: In\u00a0[11]: Copied! <pre>flow_system.statistics.plot.balance('BufferTank')\n</pre> flow_system.statistics.plot.balance('BufferTank') Out[11]: In\u00a0[12]: Copied! <pre># Gas-only scenario for comparison\ntotal_demand = pool_demand.sum()\ngas_only_cost = total_demand / 0.92 * GAS_PRICE  # All heat from gas boiler\nsavings = gas_only_cost - total_costs\n\npd.DataFrame(\n    {\n        'Gas-only [EUR/week]': gas_only_cost,\n        'With Solar [EUR/week]': total_costs,\n        'Savings [EUR/week]': savings,\n        'Savings [%]': savings / gas_only_cost * 100,\n        'Savings [EUR/year]': savings * 52,\n    },\n    index=['Value'],\n).T\n</pre> # Gas-only scenario for comparison total_demand = pool_demand.sum() gas_only_cost = total_demand / 0.92 * GAS_PRICE  # All heat from gas boiler savings = gas_only_cost - total_costs  pd.DataFrame(     {         'Gas-only [EUR/week]': gas_only_cost,         'With Solar [EUR/week]': total_costs,         'Savings [EUR/week]': savings,         'Savings [%]': savings / gas_only_cost * 100,         'Savings [EUR/year]': savings * 52,     },     index=['Value'], ).T Out[12]: Value Gas-only [EUR/week] 2465.217391 With Solar [EUR/week] 782.983740 Savings [EUR/week] 1682.233651 Savings [%] 68.238755 Savings [EUR/year] 87476.149872 In\u00a0[13]: Copied! <pre>flow_system.statistics.plot.sankey.flows()\n</pre> flow_system.statistics.plot.sankey.flows() Out[13]:"},{"location":"notebooks/03-investment-optimization/#sizing","title":"Sizing\u00b6","text":"<p>Size a solar heating system - let the optimizer decide equipment sizes.</p> <p>This notebook introduces:</p> <ul> <li>InvestParameters: Define investment decisions with size bounds and costs</li> <li>Investment costs: Fixed costs and size-dependent costs</li> <li>Optimal sizing: Let the optimizer find the best equipment sizes</li> <li>Trade-off analysis: Balance investment vs. operating costs</li> </ul>"},{"location":"notebooks/03-investment-optimization/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/03-investment-optimization/#system-description","title":"System Description\u00b6","text":"<p>The swimming pool heating system:</p> <ul> <li>Solar collectors: Convert solar radiation to heat (size to be optimized)</li> <li>Gas boiler: Backup heating when solar is insufficient (existing, 200 kW)</li> <li>Buffer tank: Store excess solar heat (size to be optimized)</li> <li>Pool: Constant heat demand of 150 kW during operating hours</li> </ul> <pre><code>   \u2600\ufe0f Solar \u2500\u2500\u25ba [Heat] \u25c4\u2500\u2500 Boiler \u25c4\u2500\u2500 [Gas]\n                  \u2502\n                  \u25bc\n              Buffer Tank\n                  \u2502\n                  \u25bc\n                Pool \ud83c\udfca\n</code></pre>"},{"location":"notebooks/03-investment-optimization/#define-time-horizon-and-profiles","title":"Define Time Horizon and Profiles\u00b6","text":"<p>We model one representative summer week:</p>"},{"location":"notebooks/03-investment-optimization/#build-the-system-with-investment-options","title":"Build the System with Investment Options\u00b6","text":"<p>Use <code>InvestParameters</code> to define which sizes should be optimized:</p>"},{"location":"notebooks/03-investment-optimization/#run-optimization","title":"Run Optimization\u00b6","text":""},{"location":"notebooks/03-investment-optimization/#analyze-investment-decisions","title":"Analyze Investment Decisions\u00b6","text":""},{"location":"notebooks/03-investment-optimization/#optimal-sizes","title":"Optimal Sizes\u00b6","text":""},{"location":"notebooks/03-investment-optimization/#visualize-sizes","title":"Visualize Sizes\u00b6","text":""},{"location":"notebooks/03-investment-optimization/#cost-breakdown","title":"Cost Breakdown\u00b6","text":""},{"location":"notebooks/03-investment-optimization/#system-operation","title":"System Operation\u00b6","text":""},{"location":"notebooks/03-investment-optimization/#compare-what-if-no-solar","title":"Compare: What if No Solar?\u00b6","text":"<p>Let's see how much the solar system saves:</p>"},{"location":"notebooks/03-investment-optimization/#energy-flow-sankey","title":"Energy Flow Sankey\u00b6","text":"<p>A Sankey diagram visualizes the total energy flows through the system:</p>"},{"location":"notebooks/03-investment-optimization/#key-concepts","title":"Key Concepts\u00b6","text":""},{"location":"notebooks/03-investment-optimization/#investparameters-options","title":"InvestParameters Options\u00b6","text":"<pre>fx.InvestParameters(\n    minimum_size=0,           # Lower bound (can be 0 for optional)\n    maximum_size=500,         # Upper bound\n    fixed_size=100,           # Or: fixed size (binary decision)\n    mandatory=True,           # Force investment to happen\n    effects_of_investment={'costs': 1000},      # Fixed cost if invested\n    effects_of_investment_per_size={'costs': 25},  # Cost per unit size\n)\n</pre>"},{"location":"notebooks/03-investment-optimization/#where-to-use-investparameters","title":"Where to Use InvestParameters\u00b6","text":"<ul> <li>Flow.size: Optimize converter/source/sink capacity</li> <li>Storage.capacity_in_flow_hours: Optimize storage capacity</li> </ul>"},{"location":"notebooks/03-investment-optimization/#summary","title":"Summary\u00b6","text":"<p>You learned how to:</p> <ul> <li>Define investment decisions with <code>InvestParameters</code></li> <li>Set size bounds (minimum/maximum)</li> <li>Add investment costs (per-size and fixed)</li> <li>Access optimal sizes via <code>statistics.sizes</code></li> <li>Visualize sizes with <code>statistics.plot.sizes()</code></li> </ul>"},{"location":"notebooks/03-investment-optimization/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>04-operational-constraints: Add startup costs and minimum run times</li> <li>05-multi-carrier-system: Model combined heat and power</li> </ul>"},{"location":"notebooks/04-operational-constraints/","title":"Constraints","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport xarray as xr\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import pandas as pd import xarray as xr  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre>from data.tutorial_data import get_constraints_data\n\ndata = get_constraints_data()\ntimesteps = data['timesteps']\nsteam_demand = data['steam_demand']\n</pre> from data.tutorial_data import get_constraints_data  data = get_constraints_data() timesteps = data['timesteps'] steam_demand = data['steam_demand'] In\u00a0[3]: Copied! <pre># Visualize the demand with plotly\ndemand_ds = xr.Dataset(\n    {\n        'Steam Demand [kW]': xr.DataArray(steam_demand, dims=['time'], coords={'time': timesteps}),\n    }\n)\ndemand_ds.plotly.line(x='time', title='Factory Steam Demand')\n</pre> # Visualize the demand with plotly demand_ds = xr.Dataset(     {         'Steam Demand [kW]': xr.DataArray(steam_demand, dims=['time'], coords={'time': timesteps}),     } ) demand_ds.plotly.line(x='time', title='Factory Steam Demand') In\u00a0[4]: Copied! <pre>flow_system = fx.FlowSystem(timesteps, name='Constrained')\n\n# Define and register custom carriers\nflow_system.add_carriers(\n    fx.Carrier('gas', '#3498db', 'kW'),\n    fx.Carrier('steam', '#87CEEB', 'kW_th', 'Process steam'),\n)\n\nflow_system.add_elements(\n    # === Buses ===\n    fx.Bus('Gas', carrier='gas'),\n    fx.Bus('Steam', carrier='steam'),\n    # === Effect ===\n    fx.Effect('costs', '\u20ac', 'Operating Costs', is_standard=True, is_objective=True),\n    # === Gas Supply ===\n    fx.Source(\n        'GasGrid',\n        outputs=[fx.Flow('Gas', bus='Gas', size=1000, effects_per_flow_hour=0.06)],\n    ),\n    # === Main Industrial Boiler (with operational constraints) ===\n    fx.linear_converters.Boiler(\n        'MainBoiler',\n        thermal_efficiency=0.94,  # High efficiency\n        # StatusParameters define on/off behavior\n        status_parameters=fx.StatusParameters(\n            effects_per_startup={'costs': 50},  # 50\u20ac startup cost\n            min_uptime=4,  # Must run at least 4 hours once started\n            min_downtime=2,  # Must stay off at least 2 hours\n        ),\n        thermal_flow=fx.Flow(\n            'Steam',\n            bus='Steam',\n            size=500,\n            relative_minimum=0.3,  # Minimum load: 30% = 150 kW\n        ),\n        fuel_flow=fx.Flow('Gas', bus='Gas', size=600),  # Size required for status_parameters\n    ),\n    # === Backup Boiler (flexible, but less efficient) ===\n    fx.linear_converters.Boiler(\n        'BackupBoiler',\n        thermal_efficiency=0.85,  # Lower efficiency\n        # No status parameters = can turn on/off freely\n        thermal_flow=fx.Flow('Steam', bus='Steam', size=150),\n        fuel_flow=fx.Flow('Gas', bus='Gas'),\n    ),\n    # === Factory Steam Demand ===\n    fx.Sink(\n        'Factory',\n        inputs=[fx.Flow('Steam', bus='Steam', size=1, fixed_relative_profile=steam_demand)],\n    ),\n)\n</pre> flow_system = fx.FlowSystem(timesteps, name='Constrained')  # Define and register custom carriers flow_system.add_carriers(     fx.Carrier('gas', '#3498db', 'kW'),     fx.Carrier('steam', '#87CEEB', 'kW_th', 'Process steam'), )  flow_system.add_elements(     # === Buses ===     fx.Bus('Gas', carrier='gas'),     fx.Bus('Steam', carrier='steam'),     # === Effect ===     fx.Effect('costs', '\u20ac', 'Operating Costs', is_standard=True, is_objective=True),     # === Gas Supply ===     fx.Source(         'GasGrid',         outputs=[fx.Flow('Gas', bus='Gas', size=1000, effects_per_flow_hour=0.06)],     ),     # === Main Industrial Boiler (with operational constraints) ===     fx.linear_converters.Boiler(         'MainBoiler',         thermal_efficiency=0.94,  # High efficiency         # StatusParameters define on/off behavior         status_parameters=fx.StatusParameters(             effects_per_startup={'costs': 50},  # 50\u20ac startup cost             min_uptime=4,  # Must run at least 4 hours once started             min_downtime=2,  # Must stay off at least 2 hours         ),         thermal_flow=fx.Flow(             'Steam',             bus='Steam',             size=500,             relative_minimum=0.3,  # Minimum load: 30% = 150 kW         ),         fuel_flow=fx.Flow('Gas', bus='Gas', size=600),  # Size required for status_parameters     ),     # === Backup Boiler (flexible, but less efficient) ===     fx.linear_converters.Boiler(         'BackupBoiler',         thermal_efficiency=0.85,  # Lower efficiency         # No status parameters = can turn on/off freely         thermal_flow=fx.Flow('Steam', bus='Steam', size=150),         fuel_flow=fx.Flow('Gas', bus='Gas'),     ),     # === Factory Steam Demand ===     fx.Sink(         'Factory',         inputs=[fx.Flow('Steam', bus='Steam', size=1, fixed_relative_profile=steam_demand)],     ), ) In\u00a0[5]: Copied! <pre>flow_system.optimize(fx.solvers.HighsSolver(mip_gap=0.01));\n</pre> flow_system.optimize(fx.solvers.HighsSolver(mip_gap=0.01)); In\u00a0[6]: Copied! <pre>flow_system.statistics.plot.balance('Steam')\n</pre> flow_system.statistics.plot.balance('Steam') Out[6]: In\u00a0[7]: Copied! <pre>flow_system.statistics.plot.heatmap('MainBoiler(Steam)')\n</pre> flow_system.statistics.plot.heatmap('MainBoiler(Steam)') Out[7]: In\u00a0[8]: Copied! <pre># Merge solution DataArrays directly - xarray aligns coordinates automatically\nstatus_ds = xr.Dataset(\n    {\n        'Status': flow_system.solution['MainBoiler|status'],\n        'Steam Production [kW]': flow_system.solution['MainBoiler(Steam)|flow_rate'],\n    }\n)\n\nstatus_ds.plotly.line(x='time', title='Main Boiler Operation', height=300)\n</pre> # Merge solution DataArrays directly - xarray aligns coordinates automatically status_ds = xr.Dataset(     {         'Status': flow_system.solution['MainBoiler|status'],         'Steam Production [kW]': flow_system.solution['MainBoiler(Steam)|flow_rate'],     } )  status_ds.plotly.line(x='time', title='Main Boiler Operation', height=300) In\u00a0[9]: Copied! <pre>total_startups = int(flow_system.solution['MainBoiler|startup'].sum().item())\ntotal_costs = flow_system.solution['costs'].item()\nstartup_costs = total_startups * 50\ngas_costs = total_costs - startup_costs\n\npd.DataFrame(\n    {\n        'Startups': {'Count': total_startups, 'EUR': startup_costs},\n        'Gas': {'Count': '-', 'EUR': gas_costs},\n        'Total': {'Count': '-', 'EUR': total_costs},\n    }\n)\n</pre> total_startups = int(flow_system.solution['MainBoiler|startup'].sum().item()) total_costs = flow_system.solution['costs'].item() startup_costs = total_startups * 50 gas_costs = total_costs - startup_costs  pd.DataFrame(     {         'Startups': {'Count': total_startups, 'EUR': startup_costs},         'Gas': {'Count': '-', 'EUR': gas_costs},         'Total': {'Count': '-', 'EUR': total_costs},     } ) Out[9]: Startups Gas Total Count 3 - - EUR 150 1291.320174 1441.320174 In\u00a0[10]: Copied! <pre>flow_system.statistics.plot.duration_curve('MainBoiler(Steam)')\n</pre> flow_system.statistics.plot.duration_curve('MainBoiler(Steam)') Out[10]: In\u00a0[11]: Copied! <pre>flow_system.statistics.plot.duration_curve('BackupBoiler(Steam)')\n</pre> flow_system.statistics.plot.duration_curve('BackupBoiler(Steam)') Out[11]: In\u00a0[12]: Copied! <pre># Build unconstrained system\nfs_unconstrained = fx.FlowSystem(timesteps, name='Unconstrained')\nfs_unconstrained.add_carriers(\n    fx.Carrier('gas', '#3498db', 'kW'),\n    fx.Carrier('steam', '#87CEEB', 'kW_th', 'Process steam'),\n)\n\nfs_unconstrained.add_elements(\n    fx.Bus('Gas', carrier='gas'),\n    fx.Bus('Steam', carrier='steam'),\n    fx.Effect('costs', '\u20ac', 'Operating Costs', is_standard=True, is_objective=True),\n    fx.Source('GasGrid', outputs=[fx.Flow('Gas', bus='Gas', size=1000, effects_per_flow_hour=0.06)]),\n    # Main boiler WITHOUT status parameters\n    fx.linear_converters.Boiler(\n        'MainBoiler',\n        thermal_efficiency=0.94,\n        thermal_flow=fx.Flow('Steam', bus='Steam', size=500),\n        fuel_flow=fx.Flow('Gas', bus='Gas'),\n    ),\n    fx.linear_converters.Boiler(\n        'BackupBoiler',\n        thermal_efficiency=0.85,\n        thermal_flow=fx.Flow('Steam', bus='Steam', size=150),\n        fuel_flow=fx.Flow('Gas', bus='Gas'),\n    ),\n    fx.Sink('Factory', inputs=[fx.Flow('Steam', bus='Steam', size=1, fixed_relative_profile=steam_demand)]),\n)\n\nfs_unconstrained.optimize(fx.solvers.HighsSolver())\nunconstrained_costs = fs_unconstrained.solution['costs'].item()\n\npd.DataFrame(\n    {\n        'Without Constraints': {'Cost [EUR]': unconstrained_costs},\n        'With Constraints': {'Cost [EUR]': total_costs},\n        'Overhead': {\n            'Cost [EUR]': total_costs - unconstrained_costs,\n            '%': (total_costs - unconstrained_costs) / unconstrained_costs * 100,\n        },\n    }\n)\n</pre> # Build unconstrained system fs_unconstrained = fx.FlowSystem(timesteps, name='Unconstrained') fs_unconstrained.add_carriers(     fx.Carrier('gas', '#3498db', 'kW'),     fx.Carrier('steam', '#87CEEB', 'kW_th', 'Process steam'), )  fs_unconstrained.add_elements(     fx.Bus('Gas', carrier='gas'),     fx.Bus('Steam', carrier='steam'),     fx.Effect('costs', '\u20ac', 'Operating Costs', is_standard=True, is_objective=True),     fx.Source('GasGrid', outputs=[fx.Flow('Gas', bus='Gas', size=1000, effects_per_flow_hour=0.06)]),     # Main boiler WITHOUT status parameters     fx.linear_converters.Boiler(         'MainBoiler',         thermal_efficiency=0.94,         thermal_flow=fx.Flow('Steam', bus='Steam', size=500),         fuel_flow=fx.Flow('Gas', bus='Gas'),     ),     fx.linear_converters.Boiler(         'BackupBoiler',         thermal_efficiency=0.85,         thermal_flow=fx.Flow('Steam', bus='Steam', size=150),         fuel_flow=fx.Flow('Gas', bus='Gas'),     ),     fx.Sink('Factory', inputs=[fx.Flow('Steam', bus='Steam', size=1, fixed_relative_profile=steam_demand)]), )  fs_unconstrained.optimize(fx.solvers.HighsSolver()) unconstrained_costs = fs_unconstrained.solution['costs'].item()  pd.DataFrame(     {         'Without Constraints': {'Cost [EUR]': unconstrained_costs},         'With Constraints': {'Cost [EUR]': total_costs},         'Overhead': {             'Cost [EUR]': total_costs - unconstrained_costs,             '%': (total_costs - unconstrained_costs) / unconstrained_costs * 100,         },     } ) Out[12]: Without Constraints With Constraints Overhead Cost [EUR] 1278.227071 1441.320174 163.093102 % NaN NaN 12.759322 In\u00a0[13]: Copied! <pre>comp = fx.Comparison([fs_unconstrained, flow_system])\ncomp.statistics.plot.effects()\n</pre> comp = fx.Comparison([fs_unconstrained, flow_system]) comp.statistics.plot.effects() Out[13]: In\u00a0[14]: Copied! <pre>flow_system.statistics.plot.sankey.flows()\n</pre> flow_system.statistics.plot.sankey.flows() Out[14]:"},{"location":"notebooks/04-operational-constraints/#constraints","title":"Constraints\u00b6","text":"<p>Industrial boiler with startup costs, minimum uptime, and load constraints.</p> <p>This notebook introduces:</p> <ul> <li>StatusParameters: Model on/off decisions with constraints</li> <li>Startup costs: Penalties for turning equipment on</li> <li>Minimum uptime/downtime: Prevent rapid cycling</li> <li>Minimum load: Equipment can't run below a certain output</li> </ul>"},{"location":"notebooks/04-operational-constraints/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/04-operational-constraints/#system-description","title":"System Description\u00b6","text":"<p>The factory has:</p> <ul> <li>Industrial boiler: 500 kW capacity, startup cost of 50\u20ac, minimum 4h uptime</li> <li>Small backup boiler: 100 kW, no startup constraints (always available)</li> <li>Steam demand: Varies with production schedule (high during shifts, low overnight)</li> </ul> <p>The main boiler is more efficient but has operational constraints. The backup is less efficient but flexible.</p>"},{"location":"notebooks/04-operational-constraints/#define-time-horizon-and-demand","title":"Define Time Horizon and Demand\u00b6","text":""},{"location":"notebooks/04-operational-constraints/#build-system-with-operational-constraints","title":"Build System with Operational Constraints\u00b6","text":""},{"location":"notebooks/04-operational-constraints/#run-optimization","title":"Run Optimization\u00b6","text":""},{"location":"notebooks/04-operational-constraints/#analyze-results","title":"Analyze Results\u00b6","text":""},{"location":"notebooks/04-operational-constraints/#steam-balance","title":"Steam Balance\u00b6","text":"<p>See how the two boilers share the load:</p>"},{"location":"notebooks/04-operational-constraints/#main-boiler-operation","title":"Main Boiler Operation\u00b6","text":"<p>Notice how the main boiler:</p> <ul> <li>Runs continuously during production (respecting min uptime)</li> <li>Stays above minimum load (30%)</li> <li>Shuts down during low-demand periods</li> </ul>"},{"location":"notebooks/04-operational-constraints/#onoff-status","title":"On/Off Status\u00b6","text":"<p>Track the boiler's operational status:</p>"},{"location":"notebooks/04-operational-constraints/#startup-count-and-costs","title":"Startup Count and Costs\u00b6","text":""},{"location":"notebooks/04-operational-constraints/#duration-curves","title":"Duration Curves\u00b6","text":"<p>See how often each boiler operates at different load levels:</p>"},{"location":"notebooks/04-operational-constraints/#compare-without-operational-constraints","title":"Compare: Without Operational Constraints\u00b6","text":"<p>What if the main boiler had no startup costs or minimum uptime?</p>"},{"location":"notebooks/04-operational-constraints/#side-by-side-comparison","title":"Side-by-Side Comparison\u00b6","text":"<p>Use the <code>Comparison</code> class to visualize both systems together:</p>"},{"location":"notebooks/04-operational-constraints/#energy-flow-sankey","title":"Energy Flow Sankey\u00b6","text":"<p>A Sankey diagram visualizes the total energy flows through the system:</p>"},{"location":"notebooks/04-operational-constraints/#key-concepts","title":"Key Concepts\u00b6","text":""},{"location":"notebooks/04-operational-constraints/#statusparameters-options","title":"StatusParameters Options\u00b6","text":"<pre>fx.StatusParameters(\n    # Startup/shutdown costs\n    effects_per_startup={'costs': 50},     # Cost per startup event\n    effects_per_shutdown={'costs': 10},    # Cost per shutdown event\n    \n    # Time constraints\n    min_uptime=4,       # Minimum hours running once started\n    min_downtime=2,     # Minimum hours off once stopped\n    \n    # Startup limits\n    max_startups=10,    # Maximum startups per period\n)\n</pre>"},{"location":"notebooks/04-operational-constraints/#minimum-load","title":"Minimum Load\u00b6","text":"<p>Set via <code>Flow.relative_minimum</code>:</p> <pre>fx.Flow('Steam', bus='Steam', size=500, relative_minimum=0.3)  # Min 30% load\n</pre>"},{"location":"notebooks/04-operational-constraints/#when-status-is-active","title":"When Status is Active\u00b6","text":"<ul> <li>When <code>StatusParameters</code> is set, a binary on/off variable is created</li> <li>Flow is zero when status=0, within bounds when status=1</li> <li>Without <code>StatusParameters</code>, flow can vary continuously from 0 to max</li> </ul>"},{"location":"notebooks/04-operational-constraints/#summary","title":"Summary\u00b6","text":"<p>You learned how to:</p> <ul> <li>Add startup costs with <code>effects_per_startup</code></li> <li>Set minimum run times with <code>min_uptime</code> and <code>min_downtime</code></li> <li>Define minimum load with <code>relative_minimum</code></li> <li>Access status variables from the solution</li> <li>Use duration curves to analyze operation patterns</li> </ul>"},{"location":"notebooks/04-operational-constraints/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>05-multi-carrier-system: Model CHP with electricity and heat</li> <li>06a-time-varying-parameters: Variable efficiency based on external conditions</li> </ul>"},{"location":"notebooks/05-multi-carrier-system/","title":"Multi-Carrier","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport xarray as xr\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import pandas as pd import xarray as xr  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre>from data.tutorial_data import get_multicarrier_data\n\ndata = get_multicarrier_data()\ntimesteps = data['timesteps']\nelectricity_demand = data['electricity_demand']\nheat_demand = data['heat_demand']\nelec_buy_price = data['elec_buy_price']\nelec_sell_price = data['elec_sell_price']\ngas_price = data['gas_price']\n</pre> from data.tutorial_data import get_multicarrier_data  data = get_multicarrier_data() timesteps = data['timesteps'] electricity_demand = data['electricity_demand'] heat_demand = data['heat_demand'] elec_buy_price = data['elec_buy_price'] elec_sell_price = data['elec_sell_price'] gas_price = data['gas_price'] In\u00a0[3]: Copied! <pre># Visualize demands and prices with plotly\nprofiles = xr.Dataset(\n    {\n        'Electricity Demand [kW]': xr.DataArray(electricity_demand, dims=['time'], coords={'time': timesteps}),\n        'Heat Demand [kW]': xr.DataArray(heat_demand, dims=['time'], coords={'time': timesteps}),\n        'Elec. Buy Price [EUR/kWh]': xr.DataArray(elec_buy_price, dims=['time'], coords={'time': timesteps}),\n    }\n)\nprofiles.plotly.line(x='time', title='Hospital Energy Profiles', height=300)\n</pre> # Visualize demands and prices with plotly profiles = xr.Dataset(     {         'Electricity Demand [kW]': xr.DataArray(electricity_demand, dims=['time'], coords={'time': timesteps}),         'Heat Demand [kW]': xr.DataArray(heat_demand, dims=['time'], coords={'time': timesteps}),         'Elec. Buy Price [EUR/kWh]': xr.DataArray(elec_buy_price, dims=['time'], coords={'time': timesteps}),     } ) profiles.plotly.line(x='time', title='Hospital Energy Profiles', height=300) In\u00a0[4]: Copied! <pre>flow_system = fx.FlowSystem(timesteps, name='With CHP')\nflow_system.add_carriers(\n    fx.Carrier('gas', '#3498db', 'kW'),\n    fx.Carrier('electricity', '#f1c40f', 'kW'),\n    fx.Carrier('heat', '#e74c3c', 'kW'),\n)\nflow_system.add_elements(\n    # === Buses with carriers for visual distinction ===\n    fx.Bus('Electricity', carrier='electricity'),\n    fx.Bus('Heat', carrier='heat'),\n    fx.Bus('Gas', carrier='gas'),\n    # === Effects ===\n    fx.Effect('costs', '\u20ac', 'Total Costs', is_standard=True, is_objective=True),\n    fx.Effect('CO2', 'kg', 'CO2 Emissions'),  # Track emissions too\n    # === Gas Supply ===\n    fx.Source(\n        'GasGrid',\n        outputs=[\n            fx.Flow(\n                'Gas',\n                bus='Gas',\n                size=1000,\n                effects_per_flow_hour={'costs': gas_price, 'CO2': 0.2},  # Gas: 0.2 kg CO2/kWh\n            )\n        ],\n    ),\n    # === Electricity Grid (buy) ===\n    fx.Source(\n        'GridBuy',\n        outputs=[\n            fx.Flow(\n                'Electricity',\n                bus='Electricity',\n                size=500,\n                effects_per_flow_hour={'costs': elec_buy_price, 'CO2': 0.4},  # Grid: 0.4 kg CO2/kWh\n            )\n        ],\n    ),\n    # === Electricity Grid (sell) - negative cost = revenue ===\n    fx.Sink(\n        'GridSell',\n        inputs=[\n            fx.Flow(\n                'Electricity',\n                bus='Electricity',\n                size=200,\n                effects_per_flow_hour={'costs': -elec_sell_price},  # Negative = income\n            )\n        ],\n    ),\n    # === CHP Unit (Combined Heat and Power) ===\n    fx.linear_converters.CHP(\n        'CHP',\n        electrical_efficiency=0.40,  # 40% to electricity\n        thermal_efficiency=0.50,  # 50% to heat (total: 90%)\n        status_parameters=fx.StatusParameters(\n            effects_per_startup={'costs': 30},\n            min_uptime=3,\n        ),\n        electrical_flow=fx.Flow('P_el', bus='Electricity', size=200),\n        thermal_flow=fx.Flow('Q_th', bus='Heat', size=250),\n        fuel_flow=fx.Flow(\n            'Q_fuel',\n            bus='Gas',\n            size=500,\n            relative_minimum=0.4,  # Min 40% load\n        ),\n    ),\n    # === Gas Boiler (heat only) ===\n    fx.linear_converters.Boiler(\n        'Boiler',\n        thermal_efficiency=0.92,\n        thermal_flow=fx.Flow('Q_th', bus='Heat', size=400),\n        fuel_flow=fx.Flow('Q_fuel', bus='Gas'),\n    ),\n    # === Hospital Loads ===\n    fx.Sink(\n        'HospitalElec',\n        inputs=[fx.Flow('Load', bus='Electricity', size=1, fixed_relative_profile=electricity_demand)],\n    ),\n    fx.Sink(\n        'HospitalHeat',\n        inputs=[fx.Flow('Load', bus='Heat', size=1, fixed_relative_profile=heat_demand)],\n    ),\n)\n</pre> flow_system = fx.FlowSystem(timesteps, name='With CHP') flow_system.add_carriers(     fx.Carrier('gas', '#3498db', 'kW'),     fx.Carrier('electricity', '#f1c40f', 'kW'),     fx.Carrier('heat', '#e74c3c', 'kW'), ) flow_system.add_elements(     # === Buses with carriers for visual distinction ===     fx.Bus('Electricity', carrier='electricity'),     fx.Bus('Heat', carrier='heat'),     fx.Bus('Gas', carrier='gas'),     # === Effects ===     fx.Effect('costs', '\u20ac', 'Total Costs', is_standard=True, is_objective=True),     fx.Effect('CO2', 'kg', 'CO2 Emissions'),  # Track emissions too     # === Gas Supply ===     fx.Source(         'GasGrid',         outputs=[             fx.Flow(                 'Gas',                 bus='Gas',                 size=1000,                 effects_per_flow_hour={'costs': gas_price, 'CO2': 0.2},  # Gas: 0.2 kg CO2/kWh             )         ],     ),     # === Electricity Grid (buy) ===     fx.Source(         'GridBuy',         outputs=[             fx.Flow(                 'Electricity',                 bus='Electricity',                 size=500,                 effects_per_flow_hour={'costs': elec_buy_price, 'CO2': 0.4},  # Grid: 0.4 kg CO2/kWh             )         ],     ),     # === Electricity Grid (sell) - negative cost = revenue ===     fx.Sink(         'GridSell',         inputs=[             fx.Flow(                 'Electricity',                 bus='Electricity',                 size=200,                 effects_per_flow_hour={'costs': -elec_sell_price},  # Negative = income             )         ],     ),     # === CHP Unit (Combined Heat and Power) ===     fx.linear_converters.CHP(         'CHP',         electrical_efficiency=0.40,  # 40% to electricity         thermal_efficiency=0.50,  # 50% to heat (total: 90%)         status_parameters=fx.StatusParameters(             effects_per_startup={'costs': 30},             min_uptime=3,         ),         electrical_flow=fx.Flow('P_el', bus='Electricity', size=200),         thermal_flow=fx.Flow('Q_th', bus='Heat', size=250),         fuel_flow=fx.Flow(             'Q_fuel',             bus='Gas',             size=500,             relative_minimum=0.4,  # Min 40% load         ),     ),     # === Gas Boiler (heat only) ===     fx.linear_converters.Boiler(         'Boiler',         thermal_efficiency=0.92,         thermal_flow=fx.Flow('Q_th', bus='Heat', size=400),         fuel_flow=fx.Flow('Q_fuel', bus='Gas'),     ),     # === Hospital Loads ===     fx.Sink(         'HospitalElec',         inputs=[fx.Flow('Load', bus='Electricity', size=1, fixed_relative_profile=electricity_demand)],     ),     fx.Sink(         'HospitalHeat',         inputs=[fx.Flow('Load', bus='Heat', size=1, fixed_relative_profile=heat_demand)],     ), ) In\u00a0[5]: Copied! <pre>flow_system.optimize(fx.solvers.HighsSolver(mip_gap=0.01));\n</pre> flow_system.optimize(fx.solvers.HighsSolver(mip_gap=0.01)); In\u00a0[6]: Copied! <pre>flow_system.statistics.plot.balance('Electricity')\n</pre> flow_system.statistics.plot.balance('Electricity') Out[6]: In\u00a0[7]: Copied! <pre>flow_system.statistics.plot.balance('Heat')\n</pre> flow_system.statistics.plot.balance('Heat') Out[7]: In\u00a0[8]: Copied! <pre>flow_system.statistics.plot.balance('Gas')\n</pre> flow_system.statistics.plot.balance('Gas') Out[8]: In\u00a0[9]: Copied! <pre>flow_system.statistics.plot.heatmap('CHP(P_el)')\n</pre> flow_system.statistics.plot.heatmap('CHP(P_el)') Out[9]: In\u00a0[10]: Copied! <pre># Energy flows\nflow_rates = flow_system.statistics.flow_rates\ngrid_buy = flow_rates['GridBuy(Electricity)'].sum().item()\ngrid_sell = flow_rates['GridSell(Electricity)'].sum().item()\nchp_elec = flow_rates['CHP(P_el)'].sum().item()\nchp_heat = flow_rates['CHP(Q_th)'].sum().item()\nboiler_heat = flow_rates['Boiler(Q_th)'].sum().item()\n\ntotal_elec = electricity_demand.sum()\ntotal_heat = heat_demand.sum()\n\npd.DataFrame(\n    {\n        'CHP Electricity [kWh]': chp_elec,\n        'CHP Electricity [%]': chp_elec / total_elec * 100,\n        'Grid Buy [kWh]': grid_buy,\n        'Grid Sell [kWh]': grid_sell,\n        'CHP Heat [kWh]': chp_heat,\n        'CHP Heat [%]': chp_heat / total_heat * 100,\n        'Boiler Heat [kWh]': boiler_heat,\n        'Total Costs [EUR]': flow_system.solution['costs'].item(),\n        'Total CO2 [kg]': flow_system.solution['CO2'].item(),\n    },\n    index=['Value'],\n).T\n</pre> # Energy flows flow_rates = flow_system.statistics.flow_rates grid_buy = flow_rates['GridBuy(Electricity)'].sum().item() grid_sell = flow_rates['GridSell(Electricity)'].sum().item() chp_elec = flow_rates['CHP(P_el)'].sum().item() chp_heat = flow_rates['CHP(Q_th)'].sum().item() boiler_heat = flow_rates['Boiler(Q_th)'].sum().item()  total_elec = electricity_demand.sum() total_heat = heat_demand.sum()  pd.DataFrame(     {         'CHP Electricity [kWh]': chp_elec,         'CHP Electricity [%]': chp_elec / total_elec * 100,         'Grid Buy [kWh]': grid_buy,         'Grid Sell [kWh]': grid_sell,         'CHP Heat [kWh]': chp_heat,         'CHP Heat [%]': chp_heat / total_heat * 100,         'Boiler Heat [kWh]': boiler_heat,         'Total Costs [EUR]': flow_system.solution['costs'].item(),         'Total CO2 [kg]': flow_system.solution['CO2'].item(),     },     index=['Value'], ).T Out[10]: Value CHP Electricity [kWh] 31304.424640 CHP Electricity [%] 102.063863 Grid Buy [kWh] 2475.425725 Grid Sell [kWh] 3108.441560 CHP Heat [kWh] 39130.530800 CHP Heat [%] 88.580014 Boiler Heat [kWh] 5044.818728 Total Costs [EUR] 4644.296833 Total CO2 [kg] 17739.082333 In\u00a0[11]: Copied! <pre># Build system without CHP\nfs_no_chp = fx.FlowSystem(timesteps, name='No CHP')\nfs_no_chp.add_carriers(\n    fx.Carrier('gas', '#3498db', 'kW'),\n    fx.Carrier('electricity', '#f1c40f', 'kW'),\n    fx.Carrier('heat', '#e74c3c', 'kW'),\n)\nfs_no_chp.add_elements(\n    fx.Bus('Electricity', carrier='electricity'),\n    fx.Bus('Heat', carrier='heat'),\n    fx.Bus('Gas', carrier='gas'),\n    fx.Effect('costs', '\u20ac', 'Total Costs', is_standard=True, is_objective=True),\n    fx.Effect('CO2', 'kg', 'CO2 Emissions'),\n    fx.Source(\n        'GasGrid',\n        outputs=[fx.Flow('Gas', bus='Gas', size=1000, effects_per_flow_hour={'costs': gas_price, 'CO2': 0.2})],\n    ),\n    fx.Source(\n        'GridBuy',\n        outputs=[\n            fx.Flow(\n                'Electricity', bus='Electricity', size=500, effects_per_flow_hour={'costs': elec_buy_price, 'CO2': 0.4}\n            )\n        ],\n    ),\n    # Only boiler for heat\n    fx.linear_converters.Boiler(\n        'Boiler',\n        thermal_efficiency=0.92,\n        thermal_flow=fx.Flow('Q_th', bus='Heat', size=500),\n        fuel_flow=fx.Flow('Q_fuel', bus='Gas'),\n    ),\n    fx.Sink(\n        'HospitalElec', inputs=[fx.Flow('Load', bus='Electricity', size=1, fixed_relative_profile=electricity_demand)]\n    ),\n    fx.Sink('HospitalHeat', inputs=[fx.Flow('Load', bus='Heat', size=1, fixed_relative_profile=heat_demand)]),\n)\n\nfs_no_chp.optimize(fx.solvers.HighsSolver())\n\ntotal_costs = flow_system.solution['costs'].item()\ntotal_co2 = flow_system.solution['CO2'].item()\nno_chp_costs = fs_no_chp.solution['costs'].item()\nno_chp_co2 = fs_no_chp.solution['CO2'].item()\n\npd.DataFrame(\n    {\n        'Without CHP': {'Cost [EUR]': no_chp_costs, 'CO2 [kg]': no_chp_co2},\n        'With CHP': {'Cost [EUR]': total_costs, 'CO2 [kg]': total_co2},\n        'Savings': {\n            'Cost [EUR]': no_chp_costs - total_costs,\n            'CO2 [kg]': no_chp_co2 - total_co2,\n        },\n        'Savings [%]': {\n            'Cost [EUR]': (no_chp_costs - total_costs) / no_chp_costs * 100,\n            'CO2 [kg]': (no_chp_co2 - total_co2) / no_chp_co2 * 100,\n        },\n    }\n)\n</pre> # Build system without CHP fs_no_chp = fx.FlowSystem(timesteps, name='No CHP') fs_no_chp.add_carriers(     fx.Carrier('gas', '#3498db', 'kW'),     fx.Carrier('electricity', '#f1c40f', 'kW'),     fx.Carrier('heat', '#e74c3c', 'kW'), ) fs_no_chp.add_elements(     fx.Bus('Electricity', carrier='electricity'),     fx.Bus('Heat', carrier='heat'),     fx.Bus('Gas', carrier='gas'),     fx.Effect('costs', '\u20ac', 'Total Costs', is_standard=True, is_objective=True),     fx.Effect('CO2', 'kg', 'CO2 Emissions'),     fx.Source(         'GasGrid',         outputs=[fx.Flow('Gas', bus='Gas', size=1000, effects_per_flow_hour={'costs': gas_price, 'CO2': 0.2})],     ),     fx.Source(         'GridBuy',         outputs=[             fx.Flow(                 'Electricity', bus='Electricity', size=500, effects_per_flow_hour={'costs': elec_buy_price, 'CO2': 0.4}             )         ],     ),     # Only boiler for heat     fx.linear_converters.Boiler(         'Boiler',         thermal_efficiency=0.92,         thermal_flow=fx.Flow('Q_th', bus='Heat', size=500),         fuel_flow=fx.Flow('Q_fuel', bus='Gas'),     ),     fx.Sink(         'HospitalElec', inputs=[fx.Flow('Load', bus='Electricity', size=1, fixed_relative_profile=electricity_demand)]     ),     fx.Sink('HospitalHeat', inputs=[fx.Flow('Load', bus='Heat', size=1, fixed_relative_profile=heat_demand)]), )  fs_no_chp.optimize(fx.solvers.HighsSolver())  total_costs = flow_system.solution['costs'].item() total_co2 = flow_system.solution['CO2'].item() no_chp_costs = fs_no_chp.solution['costs'].item() no_chp_co2 = fs_no_chp.solution['CO2'].item()  pd.DataFrame(     {         'Without CHP': {'Cost [EUR]': no_chp_costs, 'CO2 [kg]': no_chp_co2},         'With CHP': {'Cost [EUR]': total_costs, 'CO2 [kg]': total_co2},         'Savings': {             'Cost [EUR]': no_chp_costs - total_costs,             'CO2 [kg]': no_chp_co2 - total_co2,         },         'Savings [%]': {             'Cost [EUR]': (no_chp_costs - total_costs) / no_chp_costs * 100,             'CO2 [kg]': (no_chp_co2 - total_co2) / no_chp_co2 * 100,         },     } ) Out[11]: Without CHP With CHP Savings Savings [%] Cost [EUR] 11703.962760 4644.296833 7059.665927 60.318595 CO2 [kg] 21871.900376 17739.082333 4132.818042 18.895560 In\u00a0[12]: Copied! <pre>comp = fx.Comparison([fs_no_chp, flow_system])\ncomp.statistics.plot.balance('Electricity')\n</pre> comp = fx.Comparison([fs_no_chp, flow_system]) comp.statistics.plot.balance('Electricity') Out[12]: In\u00a0[13]: Copied! <pre>comp.statistics.plot.balance('Heat')\n</pre> comp.statistics.plot.balance('Heat') Out[13]: In\u00a0[14]: Copied! <pre>flow_system.statistics.plot.sankey.flows()\n</pre> flow_system.statistics.plot.sankey.flows() Out[14]:"},{"location":"notebooks/05-multi-carrier-system/#multi-carrier","title":"Multi-Carrier\u00b6","text":"<p>Hospital with CHP producing both electricity and heat.</p> <p>This notebook introduces:</p> <ul> <li>Multiple energy carriers: Electricity, heat, and gas in one system</li> <li>CHP (Cogeneration): Equipment producing multiple outputs</li> <li>Electricity market: Buying and selling to the grid</li> <li>Carrier colors: Visual distinction between energy types</li> </ul>"},{"location":"notebooks/05-multi-carrier-system/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/05-multi-carrier-system/#system-description","title":"System Description\u00b6","text":"<p>The hospital energy system:</p> <pre><code>                    Grid Buy \u2500\u2500\u25ba\n                                 [Electricity] \u2500\u2500\u25ba Hospital Elec. Load\n                    Grid Sell \u25c4\u2500\u2500     \u25b2\n                                      \u2502\n     Gas Grid \u2500\u2500\u25ba [Gas] \u2500\u2500\u25ba CHP \u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502         \u2502\n                    \u2502         \u25bc\n                    \u2502     [Heat] \u2500\u2500\u25ba Hospital Heat Load\n                    \u2502         \u25b2\n                    \u2514\u2500\u2500\u25ba Boiler\n</code></pre> <p>Equipment:</p> <ul> <li>CHP: 200 kW electrical, ~250 kW thermal (\u03b7_el=40%, \u03b7_th=50%)</li> <li>Gas Boiler: 400 kW thermal backup</li> <li>Grid: Buy electricity at variable prices, sell at lower prices</li> </ul>"},{"location":"notebooks/05-multi-carrier-system/#define-time-horizon-and-demand-profiles","title":"Define Time Horizon and Demand Profiles\u00b6","text":""},{"location":"notebooks/05-multi-carrier-system/#build-the-multi-carrier-system","title":"Build the Multi-Carrier System\u00b6","text":""},{"location":"notebooks/05-multi-carrier-system/#run-optimization","title":"Run Optimization\u00b6","text":""},{"location":"notebooks/05-multi-carrier-system/#analyze-results","title":"Analyze Results\u00b6","text":""},{"location":"notebooks/05-multi-carrier-system/#electricity-balance","title":"Electricity Balance\u00b6","text":""},{"location":"notebooks/05-multi-carrier-system/#heat-balance","title":"Heat Balance\u00b6","text":""},{"location":"notebooks/05-multi-carrier-system/#gas-balance","title":"Gas Balance\u00b6","text":""},{"location":"notebooks/05-multi-carrier-system/#chp-operation-pattern","title":"CHP Operation Pattern\u00b6","text":""},{"location":"notebooks/05-multi-carrier-system/#cost-and-emissions-summary","title":"Cost and Emissions Summary\u00b6","text":""},{"location":"notebooks/05-multi-carrier-system/#compare-what-if-no-chp","title":"Compare: What if No CHP?\u00b6","text":"<p>How much does the CHP save compared to buying all electricity?</p>"},{"location":"notebooks/05-multi-carrier-system/#side-by-side-comparison","title":"Side-by-Side Comparison\u00b6","text":"<p>Use the <code>Comparison</code> class to visualize both systems together:</p>"},{"location":"notebooks/05-multi-carrier-system/#energy-flow-sankey","title":"Energy Flow Sankey\u00b6","text":"<p>A Sankey diagram visualizes the total energy flows through the multi-carrier system:</p>"},{"location":"notebooks/05-multi-carrier-system/#key-concepts","title":"Key Concepts\u00b6","text":""},{"location":"notebooks/05-multi-carrier-system/#multi-carrier-systems","title":"Multi-Carrier Systems\u00b6","text":"<ul> <li>Multiple buses for different energy carriers (electricity, heat, gas)</li> <li>Components can connect to multiple buses (CHP produces both electricity and heat)</li> <li>Carriers enable automatic coloring in visualizations</li> </ul>"},{"location":"notebooks/05-multi-carrier-system/#chp-modeling","title":"CHP Modeling\u00b6","text":"<pre>fx.linear_converters.CHP(\n    'CHP',\n    electrical_efficiency=0.40,  # Fuel \u2192 Electricity\n    thermal_efficiency=0.50,     # Fuel \u2192 Heat\n    # Total efficiency = 0.40 + 0.50 = 0.90 (90%)\n    electrical_flow=fx.Flow('P_el', bus='Electricity', size=200),\n    thermal_flow=fx.Flow('Q_th', bus='Heat', size=250),\n    fuel_flow=fx.Flow('Q_fuel', bus='Gas', size=500),\n)\n</pre>"},{"location":"notebooks/05-multi-carrier-system/#electricity-markets","title":"Electricity Markets\u00b6","text":"<ul> <li>Buy: Source with positive cost</li> <li>Sell: Sink with negative cost (= revenue)</li> <li>Different prices for buy vs. sell (spread)</li> </ul>"},{"location":"notebooks/05-multi-carrier-system/#tracking-multiple-effects","title":"Tracking Multiple Effects\u00b6","text":"<pre>fx.Effect('costs', '\u20ac', 'Total Costs', is_objective=True)  # Minimize this\nfx.Effect('CO2', 'kg', 'CO2 Emissions')  # Just track, don't optimize\n</pre>"},{"location":"notebooks/05-multi-carrier-system/#summary","title":"Summary\u00b6","text":"<p>You learned how to:</p> <ul> <li>Model multiple energy carriers (electricity, heat, gas)</li> <li>Use CHP for combined heat and power production</li> <li>Model electricity markets with buy/sell prices</li> <li>Track multiple effects (costs and emissions)</li> <li>Analyze multi-carrier balances</li> </ul>"},{"location":"notebooks/05-multi-carrier-system/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>06a-time-varying-parameters: Variable efficiency based on conditions</li> <li>07-scenarios-and-periods: Plan under uncertainty</li> </ul>"},{"location":"notebooks/06a-time-varying-parameters/","title":"Time-Varying Parameters","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport plotly.express as px\nimport xarray as xr\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import numpy as np import plotly.express as px import xarray as xr  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre>from data.tutorial_data import get_time_varying_data\n\ndata = get_time_varying_data()\ntimesteps = data['timesteps']\noutdoor_temp = data['outdoor_temp']\nheat_demand = data['heat_demand']\ncop = data['cop']\n</pre> from data.tutorial_data import get_time_varying_data  data = get_time_varying_data() timesteps = data['timesteps'] outdoor_temp = data['outdoor_temp'] heat_demand = data['heat_demand'] cop = data['cop'] In\u00a0[3]: Copied! <pre># Visualize input profiles with plotly\nprofiles = xr.Dataset(\n    {\n        'Outdoor Temp [\u00b0C]': xr.DataArray(outdoor_temp, dims=['time'], coords={'time': timesteps}),\n        'Heat Demand [kW]': xr.DataArray(heat_demand, dims=['time'], coords={'time': timesteps}),\n    }\n)\nprofiles.plotly.line(x='time', title='Temperature and Heat Demand Profiles', height=300)\n</pre> # Visualize input profiles with plotly profiles = xr.Dataset(     {         'Outdoor Temp [\u00b0C]': xr.DataArray(outdoor_temp, dims=['time'], coords={'time': timesteps}),         'Heat Demand [kW]': xr.DataArray(heat_demand, dims=['time'], coords={'time': timesteps}),     } ) profiles.plotly.line(x='time', title='Temperature and Heat Demand Profiles', height=300) In\u00a0[4]: Copied! <pre># Visualize COP vs temperature relationship\npx.scatter(\n    x=outdoor_temp,\n    y=cop,\n    title='Heat Pump COP vs Outdoor Temperature',\n    labels={'x': 'Outdoor Temperature [\u00b0C]', 'y': 'COP'},\n    opacity=0.5,\n)\n</pre> # Visualize COP vs temperature relationship px.scatter(     x=outdoor_temp,     y=cop,     title='Heat Pump COP vs Outdoor Temperature',     labels={'x': 'Outdoor Temperature [\u00b0C]', 'y': 'COP'},     opacity=0.5, ) In\u00a0[5]: Copied! <pre>flow_system = fx.FlowSystem(timesteps)\nflow_system.add_carriers(\n    fx.Carrier('electricity', '#f1c40f', 'kW'),\n    fx.Carrier('heat', '#e74c3c', 'kW'),\n)\nflow_system.add_elements(\n    # Buses\n    fx.Bus('Electricity', carrier='electricity'),\n    fx.Bus('Heat', carrier='heat'),\n    # Effect for cost tracking\n    fx.Effect('costs', '\u20ac', 'Operating Costs', is_standard=True, is_objective=True),\n    # Grid electricity source\n    fx.Source('Grid', outputs=[fx.Flow('Elec', bus='Electricity', size=500, effects_per_flow_hour=0.30)]),\n    # Heat pump with TIME-VARYING COP\n    fx.LinearConverter(\n        'HeatPump',\n        inputs=[fx.Flow('Elec', bus='Electricity', size=150)],\n        outputs=[fx.Flow('Heat', bus='Heat', size=500)],\n        conversion_factors=[{'Elec': cop, 'Heat': 1}],  # &lt;-- Array for time-varying COP\n    ),\n    # Heat demand\n    fx.Sink('Building', inputs=[fx.Flow('Heat', bus='Heat', size=1, fixed_relative_profile=heat_demand)]),\n)\n\nflow_system.optimize(fx.solvers.HighsSolver());\n</pre> flow_system = fx.FlowSystem(timesteps) flow_system.add_carriers(     fx.Carrier('electricity', '#f1c40f', 'kW'),     fx.Carrier('heat', '#e74c3c', 'kW'), ) flow_system.add_elements(     # Buses     fx.Bus('Electricity', carrier='electricity'),     fx.Bus('Heat', carrier='heat'),     # Effect for cost tracking     fx.Effect('costs', '\u20ac', 'Operating Costs', is_standard=True, is_objective=True),     # Grid electricity source     fx.Source('Grid', outputs=[fx.Flow('Elec', bus='Electricity', size=500, effects_per_flow_hour=0.30)]),     # Heat pump with TIME-VARYING COP     fx.LinearConverter(         'HeatPump',         inputs=[fx.Flow('Elec', bus='Electricity', size=150)],         outputs=[fx.Flow('Heat', bus='Heat', size=500)],         conversion_factors=[{'Elec': cop, 'Heat': 1}],  # &lt;-- Array for time-varying COP     ),     # Heat demand     fx.Sink('Building', inputs=[fx.Flow('Heat', bus='Heat', size=1, fixed_relative_profile=heat_demand)]), )  flow_system.optimize(fx.solvers.HighsSolver()); In\u00a0[6]: Copied! <pre>flow_system.statistics.plot.balance('Heat')\n</pre> flow_system.statistics.plot.balance('Heat') Out[6]: In\u00a0[7]: Copied! <pre>flow_system.statistics.plot.balance('Electricity')\n</pre> flow_system.statistics.plot.balance('Electricity') Out[7]: In\u00a0[8]: Copied! <pre># Compare electricity consumption vs heat output using xarray for alignment\n# Create dataset with solution and input data - xarray auto-aligns by time coordinate\ncomparison = xr.Dataset(\n    {\n        'elec_consumption': flow_system.solution['HeatPump(Elec)|flow_rate'],\n        'heat_output': flow_system.solution['HeatPump(Heat)|flow_rate'],\n        'outdoor_temp': xr.DataArray(outdoor_temp, dims=['time'], coords={'time': timesteps}),\n    }\n)\n\n# Calculate effective COP at each timestep\ncomparison['effective_cop'] = xr.where(\n    comparison['elec_consumption'] &gt; 0.1, comparison['heat_output'] / comparison['elec_consumption'], np.nan\n)\n\npx.scatter(\n    x=comparison['outdoor_temp'].values,\n    y=comparison['effective_cop'].values,\n    title='Actual Operating COP vs Outdoor Temperature',\n    labels={'x': 'Outdoor Temperature [\u00b0C]', 'y': 'Operating COP'},\n)\n</pre> # Compare electricity consumption vs heat output using xarray for alignment # Create dataset with solution and input data - xarray auto-aligns by time coordinate comparison = xr.Dataset(     {         'elec_consumption': flow_system.solution['HeatPump(Elec)|flow_rate'],         'heat_output': flow_system.solution['HeatPump(Heat)|flow_rate'],         'outdoor_temp': xr.DataArray(outdoor_temp, dims=['time'], coords={'time': timesteps}),     } )  # Calculate effective COP at each timestep comparison['effective_cop'] = xr.where(     comparison['elec_consumption'] &gt; 0.1, comparison['heat_output'] / comparison['elec_consumption'], np.nan )  px.scatter(     x=comparison['outdoor_temp'].values,     y=comparison['effective_cop'].values,     title='Actual Operating COP vs Outdoor Temperature',     labels={'x': 'Outdoor Temperature [\u00b0C]', 'y': 'Operating COP'}, )"},{"location":"notebooks/06a-time-varying-parameters/#time-varying-parameters","title":"Time-Varying Parameters\u00b6","text":"<p>Model equipment with efficiency that changes based on external conditions.</p> <p>This notebook covers:</p> <ul> <li>Time-varying conversion factors: Efficiency depends on external conditions</li> <li>Temperature-dependent COP: Heat pump performance varies with weather</li> <li>Practical application: Using arrays in conversion factor definitions</li> </ul>"},{"location":"notebooks/06a-time-varying-parameters/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/06a-time-varying-parameters/#the-problem-variable-heat-pump-efficiency","title":"The Problem: Variable Heat Pump Efficiency\u00b6","text":"<p>A heat pump's COP (Coefficient of Performance) depends on the temperature difference between source and sink:</p> <ul> <li>Mild weather (10\u00b0C outside): COP \u2248 4.5 (1 kWh electricity \u2192 4.5 kWh heat)</li> <li>Cold weather (-5\u00b0C outside): COP \u2248 2.5 (1 kWh electricity \u2192 2.5 kWh heat)</li> </ul> <p>This time-varying relationship can be modeled directly using arrays in the conversion factors.</p>"},{"location":"notebooks/06a-time-varying-parameters/#when-to-use-this-approach","title":"When to Use This Approach\u00b6","text":"<p>Use time-varying conversion factors when:</p> <ul> <li>Efficiency depends on external conditions (temperature, solar irradiance, humidity)</li> <li>The relationship is independent of the load level</li> <li>You have measured or forecast data for the efficiency profile</li> </ul>"},{"location":"notebooks/06a-time-varying-parameters/#define-time-series-data","title":"Define Time Series Data\u00b6","text":""},{"location":"notebooks/06a-time-varying-parameters/#time-varying-cop","title":"Time-Varying COP\u00b6","text":"<p>The COP is pre-calculated based on outdoor temperature using a simplified Carnot-based formula:</p> <p>$$\\text{COP}_{\\text{real}} \\approx 0.45 \\times \\text{COP}_{\\text{Carnot}} = 0.45 \\times \\frac{T_{\\text{supply}}}{T_{\\text{supply}} - T_{\\text{source}}}$$</p> <p>Let's visualize the relationship:</p>"},{"location":"notebooks/06a-time-varying-parameters/#build-the-model","title":"Build the Model\u00b6","text":"<p>The key is passing the COP array directly to <code>conversion_factors</code>. The equation becomes:</p> <p>$$\\text{Elec} \\times \\text{COP}(t) = \\text{Heat} \\times 1$$</p> <p>where <code>COP(t)</code> varies at each timestep.</p>"},{"location":"notebooks/06a-time-varying-parameters/#analyze-results","title":"Analyze Results\u00b6","text":""},{"location":"notebooks/06a-time-varying-parameters/#key-concepts","title":"Key Concepts\u00b6","text":""},{"location":"notebooks/06a-time-varying-parameters/#conversion-factor-syntax","title":"Conversion Factor Syntax\u00b6","text":"<p>The <code>conversion_factors</code> parameter accepts a list of dictionaries where values can be:</p> <ul> <li>Scalars: Constant efficiency (e.g., <code>{'Fuel': 1, 'Heat': 0.9}</code>)</li> <li>Arrays: Time-varying efficiency (e.g., <code>{'Elec': cop_array, 'Heat': 1}</code>)</li> <li>TimeSeriesData: For more complex data with metadata</li> </ul> <pre>fx.LinearConverter(\n    'HeatPump',\n    inputs=[fx.Flow('Elec', bus='Electricity', size=150)],\n    outputs=[fx.Flow('Heat', bus='Heat', size=500)],\n    conversion_factors=[{'Elec': cop_array, 'Heat': 1}],  # Time-varying\n)\n</pre>"},{"location":"notebooks/06a-time-varying-parameters/#physical-interpretation","title":"Physical Interpretation\u00b6","text":"<p>The conversion equation at each timestep: $$\\text{Input}_1 \\times \\text{factor}_1(t) + \\text{Input}_2 \\times \\text{factor}_2(t) + ... = 0$$</p> <p>For a heat pump: <code>Elec * COP(t) - Heat * 1 = 0</code> \u2192 <code>Heat = Elec * COP(t)</code></p>"},{"location":"notebooks/06a-time-varying-parameters/#common-use-cases","title":"Common Use Cases\u00b6","text":"Equipment Varying Parameter External Driver Heat pump COP Outdoor temperature Solar PV Capacity factor Solar irradiance Cooling tower Efficiency Wet bulb temperature Gas turbine Heat rate Ambient temperature"},{"location":"notebooks/06a-time-varying-parameters/#summary","title":"Summary\u00b6","text":"<p>You learned how to:</p> <ul> <li>Model time-varying efficiency using arrays in conversion factors</li> <li>Calculate temperature-dependent COP for heat pumps</li> <li>Analyze the resulting operation with varying efficiency</li> </ul>"},{"location":"notebooks/06a-time-varying-parameters/#when-to-use-this-vs-other-approaches","title":"When to Use This vs Other Approaches\u00b6","text":"Approach Use When Example Time-varying factors (this notebook) Efficiency varies with external conditions Heat pump COP vs temperature PiecewiseConversion Efficiency varies with load level Gas engine efficiency curve PiecewiseEffects Costs vary non-linearly with size Economies of scale"},{"location":"notebooks/06a-time-varying-parameters/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>06b-piecewise-conversion: Load-dependent efficiency curves</li> <li>06c-piecewise-effects: Non-linear cost functions</li> </ul>"},{"location":"notebooks/06b-piecewise-conversion/","title":"Piecewise Conversion","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import numpy as np import pandas as pd  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre>piecewise_efficiency = fx.PiecewiseConversion(\n    {\n        'Fuel': fx.Piecewise(\n            [\n                fx.Piece(start=78, end=132),  # Part load\n                fx.Piece(start=132, end=179),  # Mid load\n                fx.Piece(start=179, end=250),  # Full load\n            ]\n        ),\n        'Elec': fx.Piecewise(\n            [\n                fx.Piece(start=25, end=50),  # 32% -&gt; 38% efficiency\n                fx.Piece(start=50, end=75),  # 38% -&gt; 42% efficiency\n                fx.Piece(start=75, end=100),  # 42% -&gt; 40% efficiency\n            ]\n        ),\n    }\n)\n</pre> piecewise_efficiency = fx.PiecewiseConversion(     {         'Fuel': fx.Piecewise(             [                 fx.Piece(start=78, end=132),  # Part load                 fx.Piece(start=132, end=179),  # Mid load                 fx.Piece(start=179, end=250),  # Full load             ]         ),         'Elec': fx.Piecewise(             [                 fx.Piece(start=25, end=50),  # 32% -&gt; 38% efficiency                 fx.Piece(start=50, end=75),  # 38% -&gt; 42% efficiency                 fx.Piece(start=75, end=100),  # 42% -&gt; 40% efficiency             ]         ),     } ) In\u00a0[3]: Copied! <pre>timesteps = pd.date_range('2024-01-22', periods=24, freq='h')\n\n# Demand varies through the day (30-90 kW, within piecewise range 25-100)\nelec_demand = 60 + 30 * np.sin(np.arange(24) * np.pi / 12)\n\nfs = fx.FlowSystem(timesteps)\nfs.add_elements(\n    fx.Bus('Gas'),\n    fx.Bus('Electricity'),\n    fx.Effect('costs', '\u20ac', is_standard=True, is_objective=True),\n    fx.Source('GasGrid', outputs=[fx.Flow('Gas', bus='Gas', size=300, effects_per_flow_hour=0.05)]),\n    fx.LinearConverter(\n        'GasEngine',\n        inputs=[fx.Flow('Fuel', bus='Gas')],\n        outputs=[fx.Flow('Elec', bus='Electricity')],\n        piecewise_conversion=piecewise_efficiency,\n    ),\n    fx.Sink('Load', inputs=[fx.Flow('Elec', bus='Electricity', size=1, fixed_relative_profile=elec_demand)]),\n)\n\nfs.optimize(fx.solvers.HighsSolver());\n</pre> timesteps = pd.date_range('2024-01-22', periods=24, freq='h')  # Demand varies through the day (30-90 kW, within piecewise range 25-100) elec_demand = 60 + 30 * np.sin(np.arange(24) * np.pi / 12)  fs = fx.FlowSystem(timesteps) fs.add_elements(     fx.Bus('Gas'),     fx.Bus('Electricity'),     fx.Effect('costs', '\u20ac', is_standard=True, is_objective=True),     fx.Source('GasGrid', outputs=[fx.Flow('Gas', bus='Gas', size=300, effects_per_flow_hour=0.05)]),     fx.LinearConverter(         'GasEngine',         inputs=[fx.Flow('Fuel', bus='Gas')],         outputs=[fx.Flow('Elec', bus='Electricity')],         piecewise_conversion=piecewise_efficiency,     ),     fx.Sink('Load', inputs=[fx.Flow('Elec', bus='Electricity', size=1, fixed_relative_profile=elec_demand)]), )  fs.optimize(fx.solvers.HighsSolver()); In\u00a0[4]: Copied! <pre>fs.components['GasEngine'].piecewise_conversion.plot(x_flow='Fuel')\n</pre> fs.components['GasEngine'].piecewise_conversion.plot(x_flow='Fuel') Out[4]: In\u00a0[5]: Copied! <pre>fs.statistics.plot.balance('Electricity')\n</pre> fs.statistics.plot.balance('Electricity') Out[5]: In\u00a0[6]: Copied! <pre># Verify efficiency varies with load\nfuel = fs.solution['GasEngine(Fuel)|flow_rate']\nelec = fs.solution['GasEngine(Elec)|flow_rate']\nefficiency = elec / fuel\n\nprint(f'Efficiency range: {float(efficiency.min()):.1%} - {float(efficiency.max()):.1%}')\nprint(f'Total cost: {fs.solution[\"costs\"].item():.2f} \u20ac')\n</pre> # Verify efficiency varies with load fuel = fs.solution['GasEngine(Fuel)|flow_rate'] elec = fs.solution['GasEngine(Elec)|flow_rate'] efficiency = elec / fuel  print(f'Efficiency range: {float(efficiency.min()):.1%} - {float(efficiency.max()):.1%}') print(f'Total cost: {fs.solution[\"costs\"].item():.2f} \u20ac') <pre>Efficiency range: 33.8% - 41.9%\nTotal cost: 182.96 \u20ac\n</pre>"},{"location":"notebooks/06b-piecewise-conversion/#piecewise-conversion","title":"Piecewise Conversion\u00b6","text":"<p>Model equipment with load-dependent efficiency using piecewise linear approximation.</p> <p>User Story: A gas engine's efficiency varies with load - lower at part-load, optimal at mid-load. We want to capture this non-linear behavior in our optimization.</p>"},{"location":"notebooks/06b-piecewise-conversion/#the-problem","title":"The Problem\u00b6","text":"<p>Real equipment efficiency varies with operating point:</p> Load Level Electrical Efficiency Reason 25-50% (part load) 32-38% Throttling losses 50-75% (mid load) 38-42% Near design point 75-100% (full load) 42-40% Thermal limits <p>A constant efficiency assumption misses this behavior.</p>"},{"location":"notebooks/06b-piecewise-conversion/#define-the-efficiency-curve","title":"Define the Efficiency Curve\u00b6","text":"<p>Each <code>Piece</code> defines corresponding fuel input and electricity output ranges:</p>"},{"location":"notebooks/06b-piecewise-conversion/#build-and-solve","title":"Build and Solve\u00b6","text":""},{"location":"notebooks/06b-piecewise-conversion/#visualize-the-efficiency-curve","title":"Visualize the Efficiency Curve\u00b6","text":""},{"location":"notebooks/06b-piecewise-conversion/#results","title":"Results\u00b6","text":""},{"location":"notebooks/06b-piecewise-conversion/#key-points","title":"Key Points\u00b6","text":"<p>Syntax:</p> <pre>fx.PiecewiseConversion({\n    'Input': fx.Piecewise([fx.Piece(start=a, end=b), ...]),\n    'Output': fx.Piecewise([fx.Piece(start=x, end=y), ...]),\n})\n</pre> <p>Rules:</p> <ul> <li>All flows must have the same number of segments</li> <li>Segments typically connect (end of N = start of N+1)</li> <li>Efficiency = output / input at each point</li> </ul> <p>Time-varying: Pass arrays instead of scalars to model changing limits (e.g., temperature derating).</p> <p>Next: See 06c-piecewise-effects for non-linear investment costs.</p>"},{"location":"notebooks/06c-piecewise-effects/","title":"Piecewise Effects","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import numpy as np import pandas as pd  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre># Piecewise costs with gaps between tiers\n# Cost values are CUMULATIVE at each breakpoint\npiecewise_costs = fx.PiecewiseEffects(\n    piecewise_origin=fx.Piecewise(\n        [\n            fx.Piece(start=50, end=100),  # Small tier: 50-100 kWh\n            fx.Piece(start=200, end=400),  # Medium tier: 200-400 kWh (gap: 100-200)\n            fx.Piece(start=500, end=800),  # Large tier: 500-800 kWh (gap: 400-500)\n        ]\n    ),\n    piecewise_shares={\n        'costs': fx.Piecewise(\n            [\n                fx.Piece(start=10, end=20),  # 50kWh=10\u20ac, 100kWh=20\u20ac \u2192 0.20 \u20ac/kWh\n                fx.Piece(start=24, end=48),  # 200kWh=24\u20ac, 400kWh=48\u20ac \u2192 0.12 \u20ac/kWh\n                fx.Piece(start=30, end=48),  # 500kWh=30\u20ac, 800kWh=48\u20ac \u2192 0.06 \u20ac/kWh\n            ]\n        )\n    },\n)\n\nprint('Available size tiers:')\nprint('  Small:  50-100 kWh at 0.20 \u20ac/kWh')\nprint('  Medium: 200-400 kWh at 0.12 \u20ac/kWh')\nprint('  Large:  500-800 kWh at 0.06 \u20ac/kWh')\n</pre> # Piecewise costs with gaps between tiers # Cost values are CUMULATIVE at each breakpoint piecewise_costs = fx.PiecewiseEffects(     piecewise_origin=fx.Piecewise(         [             fx.Piece(start=50, end=100),  # Small tier: 50-100 kWh             fx.Piece(start=200, end=400),  # Medium tier: 200-400 kWh (gap: 100-200)             fx.Piece(start=500, end=800),  # Large tier: 500-800 kWh (gap: 400-500)         ]     ),     piecewise_shares={         'costs': fx.Piecewise(             [                 fx.Piece(start=10, end=20),  # 50kWh=10\u20ac, 100kWh=20\u20ac \u2192 0.20 \u20ac/kWh                 fx.Piece(start=24, end=48),  # 200kWh=24\u20ac, 400kWh=48\u20ac \u2192 0.12 \u20ac/kWh                 fx.Piece(start=30, end=48),  # 500kWh=30\u20ac, 800kWh=48\u20ac \u2192 0.06 \u20ac/kWh             ]         )     }, )  print('Available size tiers:') print('  Small:  50-100 kWh at 0.20 \u20ac/kWh') print('  Medium: 200-400 kWh at 0.12 \u20ac/kWh') print('  Large:  500-800 kWh at 0.06 \u20ac/kWh') <pre>Available size tiers:\n  Small:  50-100 kWh at 0.20 \u20ac/kWh\n  Medium: 200-400 kWh at 0.12 \u20ac/kWh\n  Large:  500-800 kWh at 0.06 \u20ac/kWh\n</pre> In\u00a0[3]: Copied! <pre>timesteps = pd.date_range('2024-01-01', periods=24, freq='h')\n\n# Electricity price: cheap at night, expensive during day\nelec_price = np.array(\n    [\n        0.05,\n        0.05,\n        0.05,\n        0.05,\n        0.05,\n        0.05,  # 00-06: night (cheap)\n        0.15,\n        0.20,\n        0.25,\n        0.25,\n        0.20,\n        0.15,  # 06-12: morning\n        0.15,\n        0.20,\n        0.25,\n        0.30,\n        0.30,\n        0.25,  # 12-18: afternoon (expensive)\n        0.20,\n        0.15,\n        0.10,\n        0.08,\n        0.06,\n        0.05,  # 18-24: evening\n    ]\n)\n\ndemand = np.full(24, 100)  # 100 kW constant demand\n</pre> timesteps = pd.date_range('2024-01-01', periods=24, freq='h')  # Electricity price: cheap at night, expensive during day elec_price = np.array(     [         0.05,         0.05,         0.05,         0.05,         0.05,         0.05,  # 00-06: night (cheap)         0.15,         0.20,         0.25,         0.25,         0.20,         0.15,  # 06-12: morning         0.15,         0.20,         0.25,         0.30,         0.30,         0.25,  # 12-18: afternoon (expensive)         0.20,         0.15,         0.10,         0.08,         0.06,         0.05,  # 18-24: evening     ] )  demand = np.full(24, 100)  # 100 kW constant demand In\u00a0[4]: Copied! <pre>fs = fx.FlowSystem(timesteps)\n\nfs.add_elements(\n    fx.Bus('Elec'),\n    fx.Effect('costs', '\u20ac', is_standard=True, is_objective=True),\n    # Grid with time-varying price\n    fx.Source('Grid', outputs=[fx.Flow('Elec', bus='Elec', size=500, effects_per_flow_hour=elec_price)]),\n    # Battery with PIECEWISE investment cost (discrete tiers)\n    fx.Storage(\n        'Battery',\n        charging=fx.Flow('charge', bus='Elec', size=fx.InvestParameters(maximum_size=400)),\n        discharging=fx.Flow('discharge', bus='Elec', size=fx.InvestParameters(maximum_size=400)),\n        capacity_in_flow_hours=fx.InvestParameters(\n            piecewise_effects_of_investment=piecewise_costs,\n            minimum_size=0,\n            maximum_size=800,\n        ),\n        eta_charge=0.95,\n        eta_discharge=0.95,\n        initial_charge_state=0,\n    ),\n    fx.Sink('Demand', inputs=[fx.Flow('Elec', bus='Elec', size=1, fixed_relative_profile=demand)]),\n)\n\nfs.optimize(fx.solvers.HighsSolver());\n</pre> fs = fx.FlowSystem(timesteps)  fs.add_elements(     fx.Bus('Elec'),     fx.Effect('costs', '\u20ac', is_standard=True, is_objective=True),     # Grid with time-varying price     fx.Source('Grid', outputs=[fx.Flow('Elec', bus='Elec', size=500, effects_per_flow_hour=elec_price)]),     # Battery with PIECEWISE investment cost (discrete tiers)     fx.Storage(         'Battery',         charging=fx.Flow('charge', bus='Elec', size=fx.InvestParameters(maximum_size=400)),         discharging=fx.Flow('discharge', bus='Elec', size=fx.InvestParameters(maximum_size=400)),         capacity_in_flow_hours=fx.InvestParameters(             piecewise_effects_of_investment=piecewise_costs,             minimum_size=0,             maximum_size=800,         ),         eta_charge=0.95,         eta_discharge=0.95,         initial_charge_state=0,     ),     fx.Sink('Demand', inputs=[fx.Flow('Elec', bus='Elec', size=1, fixed_relative_profile=demand)]), )  fs.optimize(fx.solvers.HighsSolver()); In\u00a0[5]: Copied! <pre>piecewise_costs.plot(title='Battery Investment Cost (Discrete Tiers)')\n</pre> piecewise_costs.plot(title='Battery Investment Cost (Discrete Tiers)') Out[5]: In\u00a0[6]: Copied! <pre>battery_size = fs.solution['Battery|size'].item()\ntotal_cost = fs.solution['costs'].item()\n\n# Determine which tier was selected\nif battery_size &lt; 1:\n    tier = 'None'\nelif battery_size &lt;= 100:\n    tier = 'Small (50-100 kWh)'\nelif battery_size &lt;= 400:\n    tier = 'Medium (200-400 kWh)'\nelse:\n    tier = 'Large (500-800 kWh)'\n\nprint(f'Selected tier: {tier}')\nprint(f'Battery size:  {battery_size:.0f} kWh')\nprint(f'Total cost:    {total_cost:.1f} \u20ac')\n</pre> battery_size = fs.solution['Battery|size'].item() total_cost = fs.solution['costs'].item()  # Determine which tier was selected if battery_size &lt; 1:     tier = 'None' elif battery_size &lt;= 100:     tier = 'Small (50-100 kWh)' elif battery_size &lt;= 400:     tier = 'Medium (200-400 kWh)' else:     tier = 'Large (500-800 kWh)'  print(f'Selected tier: {tier}') print(f'Battery size:  {battery_size:.0f} kWh') print(f'Total cost:    {total_cost:.1f} \u20ac') <pre>Selected tier: Large (500-800 kWh)\nBattery size:  800 kWh\nTotal cost:    249.0 \u20ac\n</pre> In\u00a0[7]: Copied! <pre>fs.statistics.plot.balance('Elec')\n</pre> fs.statistics.plot.balance('Elec') Out[7]:"},{"location":"notebooks/06c-piecewise-effects/#piecewise-effects","title":"Piecewise Effects\u00b6","text":"<p>Model non-linear investment costs with economies of scale and discrete size tiers.</p> <p>This notebook demonstrates:</p> <ul> <li>PiecewiseEffects: Non-linear cost functions for investments</li> <li>Gaps between pieces: Representing discrete size tiers (unavailable sizes)</li> <li>How the optimizer selects from available size options</li> </ul>"},{"location":"notebooks/06c-piecewise-effects/#the-problem-discrete-size-tiers","title":"The Problem: Discrete Size Tiers\u00b6","text":"<p>Real equipment often comes in discrete sizes with gaps between options:</p> Tier Size Range Cost per kWh Notes Small 50-100 kWh 0.20 \u20ac/kWh Residential units Gap 100-200 kWh unavailable No products in this range Medium 200-400 kWh 0.12 \u20ac/kWh Commercial units Gap 400-500 kWh unavailable No products in this range Large 500-800 kWh 0.06 \u20ac/kWh Industrial units <p>The gaps represent size ranges where no products are available from manufacturers.</p>"},{"location":"notebooks/06c-piecewise-effects/#define-the-cost-curve-with-gaps","title":"Define the Cost Curve with Gaps\u00b6","text":"<p>Each piece defines a size tier. Gaps between pieces are forbidden zones.</p>"},{"location":"notebooks/06c-piecewise-effects/#simple-arbitrage-scenario","title":"Simple Arbitrage Scenario\u00b6","text":"<p>A battery arbitrages between cheap night and expensive day electricity.</p>"},{"location":"notebooks/06c-piecewise-effects/#build-and-solve-the-model","title":"Build and Solve the Model\u00b6","text":""},{"location":"notebooks/06c-piecewise-effects/#visualize-the-cost-curve","title":"Visualize the Cost Curve\u00b6","text":"<p>The plot shows the three discrete tiers with gaps between them.</p>"},{"location":"notebooks/06c-piecewise-effects/#results-which-tier-was-selected","title":"Results: Which Tier Was Selected?\u00b6","text":""},{"location":"notebooks/06c-piecewise-effects/#storage-operation","title":"Storage Operation\u00b6","text":""},{"location":"notebooks/06c-piecewise-effects/#best-practice-piecewiseeffects-with-gaps","title":"Best Practice: PiecewiseEffects with Gaps\u00b6","text":"<pre>fx.PiecewiseEffects(\n    piecewise_origin=fx.Piecewise([\n        fx.Piece(start=50, end=100),   # Tier 1\n        fx.Piece(start=200, end=400),  # Tier 2 (gap: 100-200 forbidden)\n    ]),\n    piecewise_shares={\n        'costs': fx.Piecewise([\n            fx.Piece(start=10, end=20),  # Cumulative cost at tier 1 boundaries\n            fx.Piece(start=24, end=48),  # Cumulative cost at tier 2 boundaries\n        ])\n    },\n)\n</pre> <p>Key points:</p> <ul> <li>Gaps between pieces = forbidden size ranges</li> <li>Cost values are cumulative at each boundary</li> <li>Use when equipment comes in discrete tiers</li> </ul>"},{"location":"notebooks/06c-piecewise-effects/#previous-piecewise-conversion","title":"Previous: Piecewise Conversion\u00b6","text":"<p>See 06b-piecewise-conversion for modeling minimum load constraints with <code>PiecewiseConversion</code> + <code>StatusParameters</code>.</p>"},{"location":"notebooks/07-scenarios-and-periods/","title":"Scenarios","text":"In\u00a0[1]: Copied! <pre>import pandas as pd\nimport xarray as xr\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import pandas as pd import xarray as xr  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre>from data.tutorial_data import get_scenarios_data\n\ndata = get_scenarios_data()\ntimesteps = data['timesteps']\nperiods = data['periods']\nscenarios = data['scenarios']\nscenario_weights = data['scenario_weights']\nheat_demand = data['heat_demand']\ngas_prices = data['gas_prices']\nelec_prices = data['elec_prices']\n</pre> from data.tutorial_data import get_scenarios_data  data = get_scenarios_data() timesteps = data['timesteps'] periods = data['periods'] scenarios = data['scenarios'] scenario_weights = data['scenario_weights'] heat_demand = data['heat_demand'] gas_prices = data['gas_prices'] elec_prices = data['elec_prices'] In\u00a0[3]: Copied! <pre># Visualize demand scenarios with plotly\ndemand_ds = xr.Dataset(\n    {\n        scenario: xr.DataArray(\n            heat_demand[scenario].values,\n            dims=['time'],\n            coords={'time': timesteps},\n        )\n        for scenario in scenarios\n    }\n)\ndemand_ds.plotly.line(x='time', title='Heat Demand by Scenario')\n</pre> # Visualize demand scenarios with plotly demand_ds = xr.Dataset(     {         scenario: xr.DataArray(             heat_demand[scenario].values,             dims=['time'],             coords={'time': timesteps},         )         for scenario in scenarios     } ) demand_ds.plotly.line(x='time', title='Heat Demand by Scenario') In\u00a0[4]: Copied! <pre>flow_system = fx.FlowSystem(\n    timesteps=timesteps,\n    periods=periods,\n    scenarios=scenarios,\n    scenario_weights=scenario_weights,\n    name='Both Scenarios',\n)\nflow_system.add_carriers(\n    fx.Carrier('gas', '#3498db', 'kW'),\n    fx.Carrier('electricity', '#f1c40f', 'kW'),\n    fx.Carrier('heat', '#e74c3c', 'kW'),\n)\n\nflow_system\n</pre> flow_system = fx.FlowSystem(     timesteps=timesteps,     periods=periods,     scenarios=scenarios,     scenario_weights=scenario_weights,     name='Both Scenarios', ) flow_system.add_carriers(     fx.Carrier('gas', '#3498db', 'kW'),     fx.Carrier('electricity', '#f1c40f', 'kW'),     fx.Carrier('heat', '#e74c3c', 'kW'), )  flow_system Out[4]: <pre>FlowSystem\n==========\nTimesteps: 168 (Hour) [2024-01-15 to 2024-01-21]\nPeriods: 3 (2024, 2025, 2026)\nScenarios: 2 (Mild Winter, Harsh Winter)\nStatus: \u26a0\n</pre> In\u00a0[5]: Copied! <pre>flow_system.add_elements(\n    # === Buses ===\n    fx.Bus('Electricity', carrier='electricity'),\n    fx.Bus('Heat', carrier='heat'),\n    fx.Bus('Gas', carrier='gas'),\n    # === Effects ===\n    fx.Effect('costs', '\u20ac', 'Total Costs', is_standard=True, is_objective=True),\n    # === Gas Supply (price varies by period) ===\n    fx.Source(\n        'GasGrid',\n        outputs=[\n            fx.Flow(\n                'Gas',\n                bus='Gas',\n                size=1000,\n                effects_per_flow_hour=gas_prices,  # Array = varies by period\n            )\n        ],\n    ),\n    # === CHP Unit (investment decision) ===\n    fx.linear_converters.CHP(\n        'CHP',\n        electrical_efficiency=0.35,\n        thermal_efficiency=0.50,\n        electrical_flow=fx.Flow(\n            'P_el',\n            bus='Electricity',\n            # Investment optimization: find optimal CHP size\n            size=fx.InvestParameters(\n                minimum_size=0,\n                maximum_size=100,\n                effects_of_investment_per_size={'costs': 15},  # 15 \u20ac/kW/week annualized\n            ),\n        ),\n        thermal_flow=fx.Flow('Q_th', bus='Heat'),\n        fuel_flow=fx.Flow('Q_fuel', bus='Gas'),\n    ),\n    # === Gas Boiler (existing backup) ===\n    fx.linear_converters.Boiler(\n        'Boiler',\n        thermal_efficiency=0.90,\n        thermal_flow=fx.Flow('Q_th', bus='Heat', size=500),\n        fuel_flow=fx.Flow('Q_fuel', bus='Gas'),\n    ),\n    # === Electricity Sales (revenue varies by period) ===\n    fx.Sink(\n        'ElecSales',\n        inputs=[\n            fx.Flow(\n                'P_el',\n                bus='Electricity',\n                size=100,\n                effects_per_flow_hour=-elec_prices,  # Negative = revenue\n            )\n        ],\n    ),\n    # === Heat Demand (varies by scenario) ===\n    fx.Sink(\n        'HeatDemand',\n        inputs=[\n            fx.Flow(\n                'Q_th',\n                bus='Heat',\n                size=1,\n                fixed_relative_profile=heat_demand,  # DataFrame with scenario columns\n            )\n        ],\n    ),\n)\n</pre> flow_system.add_elements(     # === Buses ===     fx.Bus('Electricity', carrier='electricity'),     fx.Bus('Heat', carrier='heat'),     fx.Bus('Gas', carrier='gas'),     # === Effects ===     fx.Effect('costs', '\u20ac', 'Total Costs', is_standard=True, is_objective=True),     # === Gas Supply (price varies by period) ===     fx.Source(         'GasGrid',         outputs=[             fx.Flow(                 'Gas',                 bus='Gas',                 size=1000,                 effects_per_flow_hour=gas_prices,  # Array = varies by period             )         ],     ),     # === CHP Unit (investment decision) ===     fx.linear_converters.CHP(         'CHP',         electrical_efficiency=0.35,         thermal_efficiency=0.50,         electrical_flow=fx.Flow(             'P_el',             bus='Electricity',             # Investment optimization: find optimal CHP size             size=fx.InvestParameters(                 minimum_size=0,                 maximum_size=100,                 effects_of_investment_per_size={'costs': 15},  # 15 \u20ac/kW/week annualized             ),         ),         thermal_flow=fx.Flow('Q_th', bus='Heat'),         fuel_flow=fx.Flow('Q_fuel', bus='Gas'),     ),     # === Gas Boiler (existing backup) ===     fx.linear_converters.Boiler(         'Boiler',         thermal_efficiency=0.90,         thermal_flow=fx.Flow('Q_th', bus='Heat', size=500),         fuel_flow=fx.Flow('Q_fuel', bus='Gas'),     ),     # === Electricity Sales (revenue varies by period) ===     fx.Sink(         'ElecSales',         inputs=[             fx.Flow(                 'P_el',                 bus='Electricity',                 size=100,                 effects_per_flow_hour=-elec_prices,  # Negative = revenue             )         ],     ),     # === Heat Demand (varies by scenario) ===     fx.Sink(         'HeatDemand',         inputs=[             fx.Flow(                 'Q_th',                 bus='Heat',                 size=1,                 fixed_relative_profile=heat_demand,  # DataFrame with scenario columns             )         ],     ), ) In\u00a0[6]: Copied! <pre>flow_system.optimize(fx.solvers.HighsSolver(mip_gap=0.01));\n</pre> flow_system.optimize(fx.solvers.HighsSolver(mip_gap=0.01)); In\u00a0[7]: Copied! <pre>chp_size = flow_system.statistics.sizes['CHP(P_el)']\n\npd.DataFrame(\n    {\n        'CHP Electrical [kW]': float(chp_size.max()),\n        'CHP Thermal [kW]': float(chp_size.max()) * 0.50 / 0.35,\n        'Expected Cost [EUR]': float(flow_system.solution['costs'].sum()),\n    },\n    index=['Optimal'],\n).T\n</pre> chp_size = flow_system.statistics.sizes['CHP(P_el)']  pd.DataFrame(     {         'CHP Electrical [kW]': float(chp_size.max()),         'CHP Thermal [kW]': float(chp_size.max()) * 0.50 / 0.35,         'Expected Cost [EUR]': float(flow_system.solution['costs'].sum()),     },     index=['Optimal'], ).T Out[7]: Optimal CHP Electrical [kW] 99.671000 CHP Thermal [kW] 142.387143 Expected Cost [EUR] 77.793625 In\u00a0[8]: Copied! <pre>flow_system.statistics.plot.balance('Heat')\n</pre> flow_system.statistics.plot.balance('Heat') Out[8]: In\u00a0[9]: Copied! <pre>flow_system.statistics.plot.heatmap('CHP(Q_th)')\n</pre> flow_system.statistics.plot.heatmap('CHP(Q_th)') Out[9]: In\u00a0[10]: Copied! <pre>flow_rates = flow_system.statistics.flow_rates\n\n# Plot flow rates\nflow_system.statistics.plot.flows()\n</pre> flow_rates = flow_system.statistics.flow_rates  # Plot flow rates flow_system.statistics.plot.flows() Out[10]: In\u00a0[11]: Copied! <pre># CHP operation summary by scenario\nchp_heat = flow_rates['CHP(Q_th)']\n\npd.DataFrame(\n    {\n        scenario: {\n            'Avg [kW]': float(chp_heat.sel(scenario=scenario).mean()),\n            'Max [kW]': float(chp_heat.sel(scenario=scenario).max()),\n        }\n        for scenario in scenarios\n    }\n)\n</pre> # CHP operation summary by scenario chp_heat = flow_rates['CHP(Q_th)']  pd.DataFrame(     {         scenario: {             'Avg [kW]': float(chp_heat.sel(scenario=scenario).mean()),             'Max [kW]': float(chp_heat.sel(scenario=scenario).max()),         }         for scenario in scenarios     } ) Out[11]: Mild Winter Harsh Winter Avg [kW] 101.749508 133.619672 Max [kW] 142.387143 142.387143 In\u00a0[12]: Copied! <pre># Select only the mild winter scenario\nfs_mild = flow_system.transform.sel(scenario='Mild Winter')\nfs_mild.optimize(fx.solvers.HighsSolver(mip_gap=0.01))\n\nchp_size_mild = float(fs_mild.statistics.sizes['CHP(P_el)'].max())\nchp_size_both = float(chp_size.max())\n\npd.DataFrame(\n    {\n        'Mild Only': {'CHP Size [kW]': chp_size_mild},\n        'Both Scenarios': {'CHP Size [kW]': chp_size_both},\n        'Uncertainty Buffer': {'CHP Size [kW]': chp_size_both - chp_size_mild},\n    }\n)\n</pre> # Select only the mild winter scenario fs_mild = flow_system.transform.sel(scenario='Mild Winter') fs_mild.optimize(fx.solvers.HighsSolver(mip_gap=0.01))  chp_size_mild = float(fs_mild.statistics.sizes['CHP(P_el)'].max()) chp_size_both = float(chp_size.max())  pd.DataFrame(     {         'Mild Only': {'CHP Size [kW]': chp_size_mild},         'Both Scenarios': {'CHP Size [kW]': chp_size_both},         'Uncertainty Buffer': {'CHP Size [kW]': chp_size_both - chp_size_mild},     } ) Out[12]: Mild Only Both Scenarios Uncertainty Buffer CHP Size [kW] 84.561091 99.671 15.109909 In\u00a0[13]: Copied! <pre>flow_system.statistics.plot.sankey.flows()\n</pre> flow_system.statistics.plot.sankey.flows() Out[13]:"},{"location":"notebooks/07-scenarios-and-periods/#scenarios","title":"Scenarios\u00b6","text":"<p>Multi-year planning with uncertain demand scenarios.</p> <p>This notebook introduces:</p> <ul> <li>Periods: Multiple planning years with different conditions</li> <li>Scenarios: Uncertain futures (mild vs. harsh winter)</li> <li>Scenario weights: Probability-weighted optimization</li> <li>Multi-dimensional data: Parameters that vary by time, period, and scenario</li> </ul>"},{"location":"notebooks/07-scenarios-and-periods/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/07-scenarios-and-periods/#the-planning-problem","title":"The Planning Problem\u00b6","text":"<p>We're designing a heating system with:</p> <ul> <li>3 periods (years): 2024, 2025, 2026 - gas prices expected to rise</li> <li>2 scenarios: \"Mild Winter\" (60% probability) and \"Harsh Winter\" (40% probability)</li> <li>Investment decision: Size of CHP unit (made once, works across all futures)</li> </ul> <p>The optimizer finds the investment that minimizes expected cost across all scenarios.</p>"},{"location":"notebooks/07-scenarios-and-periods/#define-dimensions","title":"Define Dimensions\u00b6","text":""},{"location":"notebooks/07-scenarios-and-periods/#scenario-dependent-demand-profiles","title":"Scenario-Dependent Demand Profiles\u00b6","text":"<p>Heat demand differs significantly between mild and harsh winters:</p>"},{"location":"notebooks/07-scenarios-and-periods/#build-the-flow-system","title":"Build the Flow System\u00b6","text":"<p>Initialize with all dimensions:</p>"},{"location":"notebooks/07-scenarios-and-periods/#add-components","title":"Add Components\u00b6","text":""},{"location":"notebooks/07-scenarios-and-periods/#run-optimization","title":"Run Optimization\u00b6","text":""},{"location":"notebooks/07-scenarios-and-periods/#analyze-results","title":"Analyze Results\u00b6","text":""},{"location":"notebooks/07-scenarios-and-periods/#optimal-investment-decision","title":"Optimal Investment Decision\u00b6","text":""},{"location":"notebooks/07-scenarios-and-periods/#heat-balance-by-scenario","title":"Heat Balance by Scenario\u00b6","text":"<p>See how the system operates differently in each scenario:</p>"},{"location":"notebooks/07-scenarios-and-periods/#chp-operation-patterns","title":"CHP Operation Patterns\u00b6","text":""},{"location":"notebooks/07-scenarios-and-periods/#multi-dimensional-data-access","title":"Multi-Dimensional Data Access\u00b6","text":"<p>Results include all dimensions (time, period, scenario):</p>"},{"location":"notebooks/07-scenarios-and-periods/#sensitivity-what-if-only-mild-winter","title":"Sensitivity: What if Only Mild Winter?\u00b6","text":"<p>Compare optimal CHP size if we only planned for mild winters:</p>"},{"location":"notebooks/07-scenarios-and-periods/#energy-flow-sankey","title":"Energy Flow Sankey\u00b6","text":"<p>A Sankey diagram visualizes the total energy flows through the system:</p>"},{"location":"notebooks/07-scenarios-and-periods/#key-concepts","title":"Key Concepts\u00b6","text":""},{"location":"notebooks/07-scenarios-and-periods/#multi-dimensional-flowsystem","title":"Multi-Dimensional FlowSystem\u00b6","text":"<pre>flow_system = fx.FlowSystem(\n    timesteps=timesteps,      # Time dimension\n    periods=periods,          # Planning periods (years)\n    scenarios=scenarios,      # Uncertain futures\n    scenario_weights=weights, # Probabilities\n)\n</pre>"},{"location":"notebooks/07-scenarios-and-periods/#dimension-varying-parameters","title":"Dimension-Varying Parameters\u00b6","text":"Data Shape Meaning Scalar Same for all time/period/scenario Array (n_periods,) Varies by period Array (n_scenarios,) Varies by scenario DataFrame with columns Columns match scenario names Full array (time, period, scenario) Full specification"},{"location":"notebooks/07-scenarios-and-periods/#scenario-optimization","title":"Scenario Optimization\u00b6","text":"<p>The optimizer minimizes expected cost: $$\\min \\sum_s w_s \\cdot \\text{Cost}_s$$</p> <p>where $w_s$ is the scenario weight (probability).</p>"},{"location":"notebooks/07-scenarios-and-periods/#selection-methods","title":"Selection Methods\u00b6","text":"<pre># Select specific scenario\nfs_mild = flow_system.transform.sel(scenario='Mild Winter')\n\n# Select specific period\nfs_2025 = flow_system.transform.sel(period=2025)\n\n# Select time range\nfs_day1 = flow_system.transform.sel(time=slice('2024-01-15', '2024-01-16'))\n</pre>"},{"location":"notebooks/07-scenarios-and-periods/#summary","title":"Summary\u00b6","text":"<p>You learned how to:</p> <ul> <li>Define multiple periods for multi-year planning</li> <li>Create scenarios for uncertain futures</li> <li>Use scenario weights for probability-weighted optimization</li> <li>Pass dimension-varying parameters (arrays and DataFrames)</li> <li>Select specific scenarios or periods for analysis</li> </ul>"},{"location":"notebooks/07-scenarios-and-periods/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>08a-Aggregation: Speed up large problems with resampling and clustering</li> <li>08b-Rolling Horizon: Decompose large problems into sequential time segments</li> </ul>"},{"location":"notebooks/08a-aggregation/","title":"Aggregation","text":"In\u00a0[1]: Copied! <pre>import timeit\n\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import timeit  import pandas as pd import plotly.graph_objects as go from plotly.subplots import make_subplots  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre>from data.generate_example_systems import create_district_heating_system\n\nflow_system = create_district_heating_system()\nflow_system.connect_and_transform()  # Align all data as xarray\n\ntimesteps = flow_system.timesteps\nprint(f'Loaded FlowSystem: {len(timesteps)} timesteps ({len(timesteps) / 24:.0f} days at hourly resolution)')\nprint(f'Components: {list(flow_system.components.keys())}')\n</pre> from data.generate_example_systems import create_district_heating_system  flow_system = create_district_heating_system() flow_system.connect_and_transform()  # Align all data as xarray  timesteps = flow_system.timesteps print(f'Loaded FlowSystem: {len(timesteps)} timesteps ({len(timesteps) / 24:.0f} days at hourly resolution)') print(f'Components: {list(flow_system.components.keys())}') <pre>Loaded FlowSystem: 744 timesteps (31 days at hourly resolution)\nComponents: ['CHP', 'Boiler', 'Storage', 'GasGrid', 'CoalSupply', 'GridBuy', 'GridSell', 'HeatDemand', 'ElecDemand']\n</pre> In\u00a0[3]: Copied! <pre># Visualize first week of data\nheat_demand = flow_system.components['HeatDemand'].inputs[0].fixed_relative_profile\nelectricity_price = flow_system.components['GridBuy'].outputs[0].effects_per_flow_hour['costs']\n\nfig = make_subplots(rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.1)\n\nfig.add_trace(go.Scatter(x=timesteps[:168], y=heat_demand.values[:168], name='Heat Demand'), row=1, col=1)\nfig.add_trace(go.Scatter(x=timesteps[:168], y=electricity_price.values[:168], name='Electricity Price'), row=2, col=1)\n\nfig.update_layout(height=400, title='First Week of Data')\nfig.update_yaxes(title_text='Heat Demand [MW]', row=1, col=1)\nfig.update_yaxes(title_text='El. Price [\u20ac/MWh]', row=2, col=1)\nfig.show()\n</pre> # Visualize first week of data heat_demand = flow_system.components['HeatDemand'].inputs[0].fixed_relative_profile electricity_price = flow_system.components['GridBuy'].outputs[0].effects_per_flow_hour['costs']  fig = make_subplots(rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.1)  fig.add_trace(go.Scatter(x=timesteps[:168], y=heat_demand.values[:168], name='Heat Demand'), row=1, col=1) fig.add_trace(go.Scatter(x=timesteps[:168], y=electricity_price.values[:168], name='Electricity Price'), row=2, col=1)  fig.update_layout(height=400, title='First Week of Data') fig.update_yaxes(title_text='Heat Demand [MW]', row=1, col=1) fig.update_yaxes(title_text='El. Price [\u20ac/MWh]', row=2, col=1) fig.show() In\u00a0[4]: Copied! <pre>solver = fx.solvers.HighsSolver(mip_gap=0.01)\n\n# Resample from 1h to 4h resolution\nfs_resampled = flow_system.transform.resample('4h')\n\nreduction = (1 - len(fs_resampled.timesteps) / len(flow_system.timesteps)) * 100\nprint(f'Resampled: {len(flow_system.timesteps)} \u2192 {len(fs_resampled.timesteps)} timesteps ({reduction:.0f}% reduction)')\n</pre> solver = fx.solvers.HighsSolver(mip_gap=0.01)  # Resample from 1h to 4h resolution fs_resampled = flow_system.transform.resample('4h')  reduction = (1 - len(fs_resampled.timesteps) / len(flow_system.timesteps)) * 100 print(f'Resampled: {len(flow_system.timesteps)} \u2192 {len(fs_resampled.timesteps)} timesteps ({reduction:.0f}% reduction)') <pre>Resampled: 744 \u2192 186 timesteps (75% reduction)\n</pre> In\u00a0[5]: Copied! <pre># Optimize resampled system\nstart = timeit.default_timer()\nfs_resampled.optimize(solver)\ntime_resampled = timeit.default_timer() - start\n\nprint(f'Resampled: {time_resampled:.1f}s, {fs_resampled.solution[\"costs\"].item():,.0f} \u20ac')\n</pre> # Optimize resampled system start = timeit.default_timer() fs_resampled.optimize(solver) time_resampled = timeit.default_timer() - start  print(f'Resampled: {time_resampled:.1f}s, {fs_resampled.solution[\"costs\"].item():,.0f} \u20ac') <pre>Resampled: 6.0s, -135,955 \u20ac\n</pre> In\u00a0[6]: Copied! <pre># Stage 1: Sizing with resampled data\nstart = timeit.default_timer()\nfs_sizing = flow_system.transform.resample('4h')\nfs_sizing.optimize(solver)\ntime_stage1 = timeit.default_timer() - start\n\nsizes = {k: float(v.item()) for k, v in fs_sizing.statistics.sizes.items()}\nprint(\n    f'Stage 1 (sizing): {time_stage1:.1f}s \u2192 CHP {sizes[\"CHP(Q_th)\"]:.0f}, Boiler {sizes[\"Boiler(Q_th)\"]:.0f}, Storage {sizes[\"Storage\"]:.0f}'\n)\n</pre> # Stage 1: Sizing with resampled data start = timeit.default_timer() fs_sizing = flow_system.transform.resample('4h') fs_sizing.optimize(solver) time_stage1 = timeit.default_timer() - start  sizes = {k: float(v.item()) for k, v in fs_sizing.statistics.sizes.items()} print(     f'Stage 1 (sizing): {time_stage1:.1f}s \u2192 CHP {sizes[\"CHP(Q_th)\"]:.0f}, Boiler {sizes[\"Boiler(Q_th)\"]:.0f}, Storage {sizes[\"Storage\"]:.0f}' ) <pre>Stage 1 (sizing): 5.9s \u2192 CHP 157, Boiler 0, Storage 1000\n</pre> In\u00a0[7]: Copied! <pre># Stage 2: Dispatch at full resolution with fixed sizes\nstart = timeit.default_timer()\nfs_dispatch = flow_system.transform.fix_sizes(fs_sizing.statistics.sizes)\nfs_dispatch.name = 'Two-Stage'\nfs_dispatch.optimize(solver)\ntime_stage2 = timeit.default_timer() - start\n\nprint(\n    f'Stage 2 (dispatch): {time_stage2:.1f}s, {fs_dispatch.solution[\"costs\"].item():,.0f} \u20ac (total: {time_stage1 + time_stage2:.1f}s)'\n)\n</pre> # Stage 2: Dispatch at full resolution with fixed sizes start = timeit.default_timer() fs_dispatch = flow_system.transform.fix_sizes(fs_sizing.statistics.sizes) fs_dispatch.name = 'Two-Stage' fs_dispatch.optimize(solver) time_stage2 = timeit.default_timer() - start  print(     f'Stage 2 (dispatch): {time_stage2:.1f}s, {fs_dispatch.solution[\"costs\"].item():,.0f} \u20ac (total: {time_stage1 + time_stage2:.1f}s)' ) <pre>Stage 2 (dispatch): 7.9s, -148,776 \u20ac (total: 13.8s)\n</pre> In\u00a0[8]: Copied! <pre>start = timeit.default_timer()\nfs_full = flow_system.copy()\nfs_full.name = 'Full Optimization'\nfs_full.optimize(solver)\ntime_full = timeit.default_timer() - start\n\nprint(f'Full optimization: {time_full:.1f}s, {fs_full.solution[\"costs\"].item():,.0f} \u20ac')\n</pre> start = timeit.default_timer() fs_full = flow_system.copy() fs_full.name = 'Full Optimization' fs_full.optimize(solver) time_full = timeit.default_timer() - start  print(f'Full optimization: {time_full:.1f}s, {fs_full.solution[\"costs\"].item():,.0f} \u20ac') <pre>Full optimization: 17.4s, -148,912 \u20ac\n</pre> In\u00a0[9]: Copied! <pre># Collect results\nresults = {\n    'Full (baseline)': {\n        'Time [s]': time_full,\n        'Cost [\u20ac]': fs_full.solution['costs'].item(),\n        'CHP Size [MW]': fs_full.statistics.sizes['CHP(Q_th)'].item(),\n        'Boiler Size [MW]': fs_full.statistics.sizes['Boiler(Q_th)'].item(),\n        'Storage Size [MWh]': fs_full.statistics.sizes['Storage'].item(),\n    },\n    'Resampled (4h)': {\n        'Time [s]': time_resampled,\n        'Cost [\u20ac]': fs_resampled.solution['costs'].item(),\n        'CHP Size [MW]': fs_resampled.statistics.sizes['CHP(Q_th)'].item(),\n        'Boiler Size [MW]': fs_resampled.statistics.sizes['Boiler(Q_th)'].item(),\n        'Storage Size [MWh]': fs_resampled.statistics.sizes['Storage'].item(),\n    },\n    'Two-Stage': {\n        'Time [s]': time_stage1 + time_stage2,\n        'Cost [\u20ac]': fs_dispatch.solution['costs'].item(),\n        'CHP Size [MW]': fs_dispatch.statistics.sizes['CHP(Q_th)'].item(),\n        'Boiler Size [MW]': fs_dispatch.statistics.sizes['Boiler(Q_th)'].item(),\n        'Storage Size [MWh]': fs_dispatch.statistics.sizes['Storage'].item(),\n    },\n}\n\ncomparison = pd.DataFrame(results).T\n\n# Add relative metrics\nbaseline_cost = comparison.loc['Full (baseline)', 'Cost [\u20ac]']\nbaseline_time = comparison.loc['Full (baseline)', 'Time [s]']\ncomparison['Cost Gap [%]'] = ((comparison['Cost [\u20ac]'] - baseline_cost) / baseline_cost * 100).round(2)\ncomparison['Speedup'] = (baseline_time / comparison['Time [s]']).round(1)\n\ncomparison.style.format(\n    {\n        'Time [s]': '{:.2f}',\n        'Cost [\u20ac]': '{:,.0f}',\n        'CHP Size [MW]': '{:.1f}',\n        'Boiler Size [MW]': '{:.1f}',\n        'Storage Size [MWh]': '{:.0f}',\n        'Cost Gap [%]': '{:.2f}',\n        'Speedup': '{:.1f}x',\n    }\n)\n</pre> # Collect results results = {     'Full (baseline)': {         'Time [s]': time_full,         'Cost [\u20ac]': fs_full.solution['costs'].item(),         'CHP Size [MW]': fs_full.statistics.sizes['CHP(Q_th)'].item(),         'Boiler Size [MW]': fs_full.statistics.sizes['Boiler(Q_th)'].item(),         'Storage Size [MWh]': fs_full.statistics.sizes['Storage'].item(),     },     'Resampled (4h)': {         'Time [s]': time_resampled,         'Cost [\u20ac]': fs_resampled.solution['costs'].item(),         'CHP Size [MW]': fs_resampled.statistics.sizes['CHP(Q_th)'].item(),         'Boiler Size [MW]': fs_resampled.statistics.sizes['Boiler(Q_th)'].item(),         'Storage Size [MWh]': fs_resampled.statistics.sizes['Storage'].item(),     },     'Two-Stage': {         'Time [s]': time_stage1 + time_stage2,         'Cost [\u20ac]': fs_dispatch.solution['costs'].item(),         'CHP Size [MW]': fs_dispatch.statistics.sizes['CHP(Q_th)'].item(),         'Boiler Size [MW]': fs_dispatch.statistics.sizes['Boiler(Q_th)'].item(),         'Storage Size [MWh]': fs_dispatch.statistics.sizes['Storage'].item(),     }, }  comparison = pd.DataFrame(results).T  # Add relative metrics baseline_cost = comparison.loc['Full (baseline)', 'Cost [\u20ac]'] baseline_time = comparison.loc['Full (baseline)', 'Time [s]'] comparison['Cost Gap [%]'] = ((comparison['Cost [\u20ac]'] - baseline_cost) / baseline_cost * 100).round(2) comparison['Speedup'] = (baseline_time / comparison['Time [s]']).round(1)  comparison.style.format(     {         'Time [s]': '{:.2f}',         'Cost [\u20ac]': '{:,.0f}',         'CHP Size [MW]': '{:.1f}',         'Boiler Size [MW]': '{:.1f}',         'Storage Size [MWh]': '{:.0f}',         'Cost Gap [%]': '{:.2f}',         'Speedup': '{:.1f}x',     } ) Out[9]: Time [s] Cost [\u20ac] CHP Size [MW] Boiler Size [MW] Storage Size [MWh] Cost Gap [%] Speedup Full (baseline) 17.39 -148,912 165.7 0.0 1000 -0.00 1.0x Resampled (4h) 6.04 -135,955 156.6 0.0 1000 -8.70 2.9x Two-Stage 13.75 -148,776 156.6 0.0 1000 -0.09 1.3x In\u00a0[10]: Copied! <pre># Side-by-side comparison of full optimization vs two-stage\ncomp = fx.Comparison([fs_full, fs_dispatch])\ncomp.statistics.plot.balance('Heat')\n</pre> # Side-by-side comparison of full optimization vs two-stage comp = fx.Comparison([fs_full, fs_dispatch]) comp.statistics.plot.balance('Heat') Out[10]: In\u00a0[11]: Copied! <pre>fs_full.statistics.plot.sankey.flows()\n</pre> fs_full.statistics.plot.sankey.flows() Out[11]:"},{"location":"notebooks/08a-aggregation/#aggregation","title":"Aggregation\u00b6","text":"<p>Speed up large problems with time series aggregation techniques.</p> <p>This notebook introduces:</p> <ul> <li>Resampling: Reduce time resolution (e.g., hourly \u2192 4-hourly)</li> <li>Two-stage optimization: Size with reduced data, dispatch at full resolution</li> <li>Speed vs. accuracy trade-offs: When to use each technique</li> </ul>"},{"location":"notebooks/08a-aggregation/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/08a-aggregation/#create-the-flowsystem","title":"Create the FlowSystem\u00b6","text":"<p>We use a district heating system with real-world time series data (one month at hourly resolution):</p>"},{"location":"notebooks/08a-aggregation/#technique-1-resampling","title":"Technique 1: Resampling\u00b6","text":"<p>Reduce time resolution to speed up optimization:</p>"},{"location":"notebooks/08a-aggregation/#technique-2-two-stage-optimization","title":"Technique 2: Two-Stage Optimization\u00b6","text":"<ol> <li>Stage 1: Size components with resampled data (fast)</li> <li>Stage 2: Fix sizes and optimize dispatch at full resolution</li> </ol>"},{"location":"notebooks/08a-aggregation/#technique-3-full-optimization-baseline","title":"Technique 3: Full Optimization (Baseline)\u00b6","text":"<p>For comparison, solve the full problem:</p>"},{"location":"notebooks/08a-aggregation/#compare-results","title":"Compare Results\u00b6","text":""},{"location":"notebooks/08a-aggregation/#visual-comparison-heat-balance","title":"Visual Comparison: Heat Balance\u00b6","text":"<p>Compare the full optimization with the two-stage approach side-by-side:</p>"},{"location":"notebooks/08a-aggregation/#energy-flow-sankey-full-optimization","title":"Energy Flow Sankey (Full Optimization)\u00b6","text":"<p>A Sankey diagram visualizes the total energy flows:</p>"},{"location":"notebooks/08a-aggregation/#when-to-use-each-technique","title":"When to Use Each Technique\u00b6","text":"Technique Best For Trade-off Full optimization Final results, small problems Slowest, most accurate Resampling Quick screening, trend analysis Fast, loses temporal detail Two-stage Investment decisions, large problems Good balance of speed and accuracy Clustering Preserves extreme periods Requires <code>tsam</code> package"},{"location":"notebooks/08a-aggregation/#resampling-options","title":"Resampling Options\u00b6","text":"<pre># Different resolutions\nfs_2h = flow_system.transform.resample('2h')   # 2-hourly\nfs_4h = flow_system.transform.resample('4h')   # 4-hourly\nfs_daily = flow_system.transform.resample('1D')  # Daily\n\n# Different aggregation methods\nfs_mean = flow_system.transform.resample('4h', method='mean')  # Default\nfs_max = flow_system.transform.resample('4h', method='max')    # Preserve peaks\n</pre>"},{"location":"notebooks/08a-aggregation/#two-stage-workflow","title":"Two-Stage Workflow\u00b6","text":"<pre># Stage 1: Sizing\nfs_sizing = flow_system.transform.resample('4h')\nfs_sizing.optimize(solver)\n\n# Stage 2: Dispatch\nfs_dispatch = flow_system.transform.fix_sizes(fs_sizing.statistics.sizes)\nfs_dispatch.optimize(solver)\n</pre>"},{"location":"notebooks/08a-aggregation/#summary","title":"Summary\u00b6","text":"<p>You learned how to:</p> <ul> <li>Use <code>transform.resample()</code> to reduce time resolution</li> <li>Apply two-stage optimization for large investment problems</li> <li>Use <code>transform.fix_sizes()</code> to lock in investment decisions</li> <li>Compare speed vs. accuracy trade-offs</li> </ul>"},{"location":"notebooks/08a-aggregation/#key-takeaways","title":"Key Takeaways\u00b6","text":"<ol> <li>Start fast: Use resampling for initial exploration</li> <li>Iterate: Refine with two-stage optimization</li> <li>Validate: Run full optimization for final results</li> <li>Monitor: Check cost gaps to ensure acceptable accuracy</li> </ol>"},{"location":"notebooks/08a-aggregation/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>08b-Rolling Horizon: For operational problems, decompose time into sequential segments</li> <li>08c-Clustering: Use typical periods with the <code>tsam</code> package</li> </ul>"},{"location":"notebooks/08a-aggregation/#further-reading","title":"Further Reading\u00b6","text":"<ul> <li>For clustering with typical periods, see <code>transform.cluster()</code> (requires <code>tsam</code> package)</li> <li>For time selection, see <code>transform.sel()</code> and <code>transform.isel()</code></li> </ul>"},{"location":"notebooks/08b-rolling-horizon/","title":"Rolling Horizon","text":"In\u00a0[1]: Copied! <pre>import timeit\n\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nimport xarray as xr\nfrom plotly.subplots import make_subplots\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import timeit  import pandas as pd import plotly.express as px import plotly.graph_objects as go import xarray as xr from plotly.subplots import make_subplots  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre>from data.generate_example_systems import create_operational_system\n\nflow_system = create_operational_system().transform.resample('1h')\nflow_system.connect_and_transform()  # Align all data as xarray\n\ntimesteps = flow_system.timesteps\nprint(f'Loaded FlowSystem: {len(timesteps)} timesteps ({len(timesteps) / 24:.0f} days at 1h resolution)')\nprint(f'Components: {list(flow_system.components.keys())}')\n</pre> from data.generate_example_systems import create_operational_system  flow_system = create_operational_system().transform.resample('1h') flow_system.connect_and_transform()  # Align all data as xarray  timesteps = flow_system.timesteps print(f'Loaded FlowSystem: {len(timesteps)} timesteps ({len(timesteps) / 24:.0f} days at 1h resolution)') print(f'Components: {list(flow_system.components.keys())}') <pre>Loaded FlowSystem: 336 timesteps (14 days at 1h resolution)\nComponents: ['CHP', 'Boiler', 'Storage', 'GasGrid', 'CoalSupply', 'GridBuy', 'GridSell', 'HeatDemand', 'ElecDemand']\n</pre> In\u00a0[3]: Copied! <pre>solver = fx.solvers.HighsSolver(mip_gap=0.01, time_limit_seconds=240)\n\nfs_full = flow_system.copy()\nfs_full.name = 'Full Optimization'\nstart = timeit.default_timer()\nfs_full.optimize(solver)\ntime_full = timeit.default_timer() - start\n\nprint(f'Full: {time_full:.1f}s, {fs_full.solution[\"costs\"].item():.0f} \u20ac')\n</pre> solver = fx.solvers.HighsSolver(mip_gap=0.01, time_limit_seconds=240)  fs_full = flow_system.copy() fs_full.name = 'Full Optimization' start = timeit.default_timer() fs_full.optimize(solver) time_full = timeit.default_timer() - start  print(f'Full: {time_full:.1f}s, {fs_full.solution[\"costs\"].item():.0f} \u20ac') <pre>Full: 141.9s, -3829 \u20ac\n</pre> In\u00a0[4]: Copied! <pre>start = timeit.default_timer()\nfs_rolling = flow_system.copy()\nfs_rolling.name = 'Rolling Horizon'\nsegments = fs_rolling.optimize.rolling_horizon(\n    solver,\n    horizon=96,  # 4-day segments (96 timesteps at 1h resolution)\n    overlap=24,  # 1-day lookahead\n)\ntime_rolling = timeit.default_timer() - start\n\nprint(f'Rolling ({len(segments)} segments): {time_rolling:.1f}s, {fs_rolling.solution[\"costs\"].item():.0f} \u20ac')\n</pre> start = timeit.default_timer() fs_rolling = flow_system.copy() fs_rolling.name = 'Rolling Horizon' segments = fs_rolling.optimize.rolling_horizon(     solver,     horizon=96,  # 4-day segments (96 timesteps at 1h resolution)     overlap=24,  # 1-day lookahead ) time_rolling = timeit.default_timer() - start  print(f'Rolling ({len(segments)} segments): {time_rolling:.1f}s, {fs_rolling.solution[\"costs\"].item():.0f} \u20ac') <pre>HighsMipSolverData::transformNewIntegerFeasibleSolution tmpSolver.run();\n</pre> <pre>Rolling (4 segments): 95.8s, 20505 \u20ac\n</pre> In\u00a0[5]: Copied! <pre>cost_full = fs_full.solution['costs'].item()\ncost_rolling = fs_rolling.solution['costs'].item()\ncost_gap = (cost_rolling - cost_full) / abs(cost_full) * 100 if cost_full != 0 else 0.0\n\nresults = pd.DataFrame(\n    {\n        'Method': ['Full optimization', 'Rolling horizon'],\n        'Time [s]': [time_full, time_rolling],\n        'Cost [\u20ac]': [cost_full, cost_rolling],\n        'Cost Gap [%]': [0.0, cost_gap],\n    }\n).set_index('Method')\n\nresults.style.format({'Time [s]': '{:.2f}', 'Cost [\u20ac]': '{:.0f}', 'Cost Gap [%]': '{:.2f}'})\n</pre> cost_full = fs_full.solution['costs'].item() cost_rolling = fs_rolling.solution['costs'].item() cost_gap = (cost_rolling - cost_full) / abs(cost_full) * 100 if cost_full != 0 else 0.0  results = pd.DataFrame(     {         'Method': ['Full optimization', 'Rolling horizon'],         'Time [s]': [time_full, time_rolling],         'Cost [\u20ac]': [cost_full, cost_rolling],         'Cost Gap [%]': [0.0, cost_gap],     } ).set_index('Method')  results.style.format({'Time [s]': '{:.2f}', 'Cost [\u20ac]': '{:.0f}', 'Cost Gap [%]': '{:.2f}'}) Out[5]: Time [s] Cost [\u20ac] Cost Gap [%] Method Full optimization 141.94 -3829 0.00 Rolling horizon 95.75 20505 635.53 In\u00a0[6]: Copied! <pre>comp = fx.Comparison([fs_full, fs_rolling])\ncomp.statistics.plot.effects(by='contributor', effect='costs')\n</pre> comp = fx.Comparison([fs_full, fs_rolling]) comp.statistics.plot.effects(by='contributor', effect='costs') Out[6]: In\u00a0[7]: Copied! <pre>fig = make_subplots(\n    rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.1, subplot_titles=['Full Optimization', 'Rolling Horizon']\n)\n\n# Full optimization\ncharge_full = fs_full.solution['Storage|charge_state'].values[:-1]  # Drop final value\nfig.add_trace(go.Scatter(x=timesteps, y=charge_full, name='Full', line=dict(color='blue')), row=1, col=1)\n\n# Rolling horizon\ncharge_rolling = fs_rolling.solution['Storage|charge_state'].values[:-1]\nfig.add_trace(go.Scatter(x=timesteps, y=charge_rolling, name='Rolling', line=dict(color='orange')), row=2, col=1)\n\nfig.update_yaxes(title_text='Charge State [MWh]', row=1, col=1)\nfig.update_yaxes(title_text='Charge State [MWh]', row=2, col=1)\nfig.update_layout(height=400, showlegend=False)\nfig.show()\n</pre> fig = make_subplots(     rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.1, subplot_titles=['Full Optimization', 'Rolling Horizon'] )  # Full optimization charge_full = fs_full.solution['Storage|charge_state'].values[:-1]  # Drop final value fig.add_trace(go.Scatter(x=timesteps, y=charge_full, name='Full', line=dict(color='blue')), row=1, col=1)  # Rolling horizon charge_rolling = fs_rolling.solution['Storage|charge_state'].values[:-1] fig.add_trace(go.Scatter(x=timesteps, y=charge_rolling, name='Rolling', line=dict(color='orange')), row=2, col=1)  fig.update_yaxes(title_text='Charge State [MWh]', row=1, col=1) fig.update_yaxes(title_text='Charge State [MWh]', row=2, col=1) fig.update_layout(height=400, showlegend=False) fig.show() In\u00a0[8]: Copied! <pre>print(f'{len(segments)} segments:')\nfor i, seg in enumerate(segments):\n    print(\n        f'  {i + 1}: {seg.timesteps[0]:%m-%d %H:%M} \u2192 {seg.timesteps[-1]:%m-%d %H:%M} | {seg.solution[\"costs\"].item():,.0f} \u20ac'\n    )\n</pre> print(f'{len(segments)} segments:') for i, seg in enumerate(segments):     print(         f'  {i + 1}: {seg.timesteps[0]:%m-%d %H:%M} \u2192 {seg.timesteps[-1]:%m-%d %H:%M} | {seg.solution[\"costs\"].item():,.0f} \u20ac'     ) <pre>4 segments:\n  1: 01-01 00:00 \u2192 01-05 23:00 | 18,073 \u20ac\n  2: 01-05 00:00 \u2192 01-09 23:00 | -9,916 \u20ac\n  3: 01-09 00:00 \u2192 01-13 23:00 | 15,378 \u20ac\n  4: 01-13 00:00 \u2192 01-14 23:00 | -5,875 \u20ac\n</pre> In\u00a0[9]: Copied! <pre># Concatenate all segment solutions into one dataset (including overlaps)\nds = xr.concat([seg.solution for seg in segments], dim=pd.RangeIndex(len(segments), name='segment'), join='outer')\n\n# Plot CHP thermal flow across all segments - each segment as a separate line\npx.line(\n    ds['Boiler(Q_th)|flow_rate'].to_pandas().T,\n    labels={'value': 'Boiler Thermal Output [MW]', 'index': 'Timestep'},\n)\n</pre> # Concatenate all segment solutions into one dataset (including overlaps) ds = xr.concat([seg.solution for seg in segments], dim=pd.RangeIndex(len(segments), name='segment'), join='outer')  # Plot CHP thermal flow across all segments - each segment as a separate line px.line(     ds['Boiler(Q_th)|flow_rate'].to_pandas().T,     labels={'value': 'Boiler Thermal Output [MW]', 'index': 'Timestep'}, ) In\u00a0[10]: Copied! <pre>px.line(\n    ds['Storage|charge_state'].to_pandas().T,\n    labels={'value': 'Storage Charge State [MW]', 'index': 'Timestep'},\n)\n</pre> px.line(     ds['Storage|charge_state'].to_pandas().T,     labels={'value': 'Storage Charge State [MW]', 'index': 'Timestep'}, )"},{"location":"notebooks/08b-rolling-horizon/#rolling-horizon","title":"Rolling Horizon\u00b6","text":"<p>Solve large operational problems by decomposing the time horizon into sequential segments.</p> <p>This notebook introduces:</p> <ul> <li>Rolling horizon optimization: Divide time into overlapping segments</li> <li>State transfer: Pass storage states and flow history between segments</li> <li>When to use: Memory limits, operational planning with limited foresight</li> </ul> <p>We use a realistic district heating system with CHP, boiler, and storage to demonstrate the approach.</p>"},{"location":"notebooks/08b-rolling-horizon/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/08b-rolling-horizon/#create-the-flowsystem","title":"Create the FlowSystem\u00b6","text":"<p>We use an operational district heating system with real-world data (two weeks at 15-min resolution):</p>"},{"location":"notebooks/08b-rolling-horizon/#full-optimization-baseline","title":"Full Optimization (Baseline)\u00b6","text":"<p>First, solve the full problem as a baseline:</p>"},{"location":"notebooks/08b-rolling-horizon/#rolling-horizon-optimization","title":"Rolling Horizon Optimization\u00b6","text":"<p>The <code>optimize.rolling_horizon()</code> method divides the time horizon into segments that are solved sequentially:</p> <pre><code>Full horizon:  |---------- 336 timesteps (14 days) ----------|\n                \nSegment 1:     |==== 96 (4 days) ====|-- overlap --|\nSegment 2:                |==== 96 (4 days) ====|-- overlap --|\nSegment 3:                              |==== 96 (4 days) ====|-- overlap --|\n...                                                  \n</code></pre> <p>Key parameters:</p> <ul> <li>horizon: Timesteps per segment (excluding overlap)</li> <li>overlap: Additional lookahead timesteps (improves storage optimization)</li> <li>nr_of_previous_values: Flow history transferred between segments</li> </ul>"},{"location":"notebooks/08b-rolling-horizon/#compare-results","title":"Compare Results\u00b6","text":""},{"location":"notebooks/08b-rolling-horizon/#visualize-heat-balance-comparison","title":"Visualize: Heat Balance Comparison\u00b6","text":"<p>Use the <code>Comparison</code> class to view both methods side-by-side:</p>"},{"location":"notebooks/08b-rolling-horizon/#storage-state-continuity","title":"Storage State Continuity\u00b6","text":"<p>Rolling horizon transfers storage charge states between segments to ensure continuity:</p>"},{"location":"notebooks/08b-rolling-horizon/#inspect-individual-segments","title":"Inspect Individual Segments\u00b6","text":"<p>The method returns the individual segment FlowSystems, which can be inspected:</p>"},{"location":"notebooks/08b-rolling-horizon/#visualize-segment-overlaps","title":"Visualize Segment Overlaps\u00b6","text":"<p>Understanding how segments overlap is key to tuning rolling horizon. Let's visualize the flow rates from each segment including their overlap regions:</p>"},{"location":"notebooks/08b-rolling-horizon/#when-to-use-rolling-horizon","title":"When to Use Rolling Horizon\u00b6","text":"Use Case Recommendation Memory limits Large problems that exceed available memory Operational planning When limited foresight is realistic Quick approximate solutions Faster than full optimization Investment decisions Use full optimization instead"},{"location":"notebooks/08b-rolling-horizon/#limitations","title":"Limitations\u00b6","text":"<ul> <li>No investments: <code>InvestParameters</code> are not supported (raises error)</li> <li>Suboptimal storage: Limited foresight may miss long-term storage opportunities</li> <li>Global constraints: <code>flow_hours_max</code> etc. cannot be enforced globally</li> </ul>"},{"location":"notebooks/08b-rolling-horizon/#api-reference","title":"API Reference\u00b6","text":"<pre>segments = flow_system.optimize.rolling_horizon(\n    solver,              # Solver instance\n    horizon=192,         # Timesteps per segment (e.g., 2 days at 15-min resolution)\n    overlap=48,          # Additional lookahead timesteps (e.g., 12 hours)\n    nr_of_previous_values=1,  # Flow history for uptime/downtime tracking\n)\n\n# Combined solution on original FlowSystem\nflow_system.solution['costs'].item()\n\n# Individual segment solutions\nfor seg in segments:\n    print(seg.solution['costs'].item())\n</pre>"},{"location":"notebooks/08b-rolling-horizon/#summary","title":"Summary\u00b6","text":"<p>You learned how to:</p> <ul> <li>Use <code>optimize.rolling_horizon()</code> to decompose large problems</li> <li>Choose horizon and overlap parameters</li> <li>Understand the trade-offs vs. full optimization</li> </ul>"},{"location":"notebooks/08b-rolling-horizon/#key-takeaways","title":"Key Takeaways\u00b6","text":"<ol> <li>Rolling horizon is useful for memory-limited or operational planning problems</li> <li>Overlap improves solution quality at the cost of computation time</li> <li>Storage states are automatically transferred between segments</li> <li>Use full optimization for investment decisions</li> </ol>"},{"location":"notebooks/08b-rolling-horizon/#related-notebooks","title":"Related Notebooks\u00b6","text":"<ul> <li>08a-Aggregation: For investment problems, use time series aggregation (resampling, clustering) instead</li> </ul>"},{"location":"notebooks/08c-clustering/","title":"Time Series Clustering with","text":"In\u00a0[1]: Copied! <pre>import timeit\n\nimport pandas as pd\nimport xarray as xr\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import timeit  import pandas as pd import xarray as xr  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre>from data.generate_example_systems import create_district_heating_system\n\nflow_system = create_district_heating_system()\nflow_system.connect_and_transform()\n\ntimesteps = flow_system.timesteps\n\nflow_system\n</pre> from data.generate_example_systems import create_district_heating_system  flow_system = create_district_heating_system() flow_system.connect_and_transform()  timesteps = flow_system.timesteps  flow_system Out[2]: <pre>FlowSystem\n==========\nTimesteps: 744 (Hour) [2020-01-01 to 2020-01-31]\nPeriods: None\nScenarios: None\nStatus: \u2713\n\nComponents (9 items)\n--------------------\n * Boiler\n * CHP\n * CoalSupply\n * ElecDemand\n * GasGrid\n * GridBuy\n * GridSell\n * HeatDemand\n * Storage\n\nBuses (4 items)\n---------------\n * Coal\n * Electricity\n * Gas\n * Heat\n\nEffects (2 items)\n-----------------\n * CO2\n * costs\n\nFlows (13 items)\n----------------\n * Boiler(Q_fu)\n * Boiler(Q_th)\n * CHP(P_el)\n * CHP(Q_fu)\n * CHP(Q_th)\n * CoalSupply(Q_Coal)\n * ElecDemand(P_el)\n * GasGrid(Q_Gas)\n * GridBuy(P_el)\n * GridSell(P_el)\n ... (+3 more)</pre> In\u00a0[3]: Copied! <pre># Visualize input data\ninput_ds = xr.Dataset(\n    {\n        'Heat Demand': flow_system.components['HeatDemand'].inputs[0].fixed_relative_profile,\n        'Electricity Price': flow_system.components['GridBuy'].outputs[0].effects_per_flow_hour['costs'],\n    }\n)\ninput_ds.plotly.line(x='time', facet_row='variable', title='One Month of Input Data')\n</pre> # Visualize input data input_ds = xr.Dataset(     {         'Heat Demand': flow_system.components['HeatDemand'].inputs[0].fixed_relative_profile,         'Electricity Price': flow_system.components['GridBuy'].outputs[0].effects_per_flow_hour['costs'],     } ) input_ds.plotly.line(x='time', facet_row='variable', title='One Month of Input Data') In\u00a0[4]: Copied! <pre>solver = fx.solvers.HighsSolver(mip_gap=0.01)\n\nstart = timeit.default_timer()\nfs_full = flow_system.copy()\nfs_full.name = 'Full Optimization'\nfs_full.optimize(solver)\ntime_full = timeit.default_timer() - start\n</pre> solver = fx.solvers.HighsSolver(mip_gap=0.01)  start = timeit.default_timer() fs_full = flow_system.copy() fs_full.name = 'Full Optimization' fs_full.optimize(solver) time_full = timeit.default_timer() - start In\u00a0[5]: Copied! <pre>from tsam import ExtremeConfig\n\nstart = timeit.default_timer()\n\n# IMPORTANT: Force inclusion of peak demand periods!\npeak_series = ['HeatDemand(Q_th)|fixed_relative_profile']\n\n# Create reduced FlowSystem with 8 typical days\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=8,  # 8 typical days\n    cluster_duration='1D',  # Daily clustering\n    extremes=ExtremeConfig(method='new_cluster', max_value=peak_series),  # Capture peak demand day\n)\nfs_clustered.name = 'Clustered (8 days)'\n\ntime_clustering = timeit.default_timer() - start\n</pre> from tsam import ExtremeConfig  start = timeit.default_timer()  # IMPORTANT: Force inclusion of peak demand periods! peak_series = ['HeatDemand(Q_th)|fixed_relative_profile']  # Create reduced FlowSystem with 8 typical days fs_clustered = flow_system.transform.cluster(     n_clusters=8,  # 8 typical days     cluster_duration='1D',  # Daily clustering     extremes=ExtremeConfig(method='new_cluster', max_value=peak_series),  # Capture peak demand day ) fs_clustered.name = 'Clustered (8 days)'  time_clustering = timeit.default_timer() - start In\u00a0[6]: Copied! <pre># Optimize the reduced system\nstart = timeit.default_timer()\nfs_clustered.optimize(solver)\ntime_clustered = timeit.default_timer() - start\n</pre> # Optimize the reduced system start = timeit.default_timer() fs_clustered.optimize(solver) time_clustered = timeit.default_timer() - start In\u00a0[7]: Copied! <pre># Access clustering metadata directly\nclustering = fs_clustered.clustering.results\nclustering\n</pre> # Access clustering metadata directly clustering = fs_clustered.clustering.results clustering Out[7]: <pre>ClusteringResults(n_clusters=9)</pre> In\u00a0[8]: Copied! <pre># Show clustering info using __repr__\nfs_clustered.clustering\n</pre> # Show clustering info using __repr__ fs_clustered.clustering Out[8]: <pre>Clustering(\n  31 periods \u2192 9 clusters\n  timesteps_per_cluster=24\n  dims=[]\n)</pre> In\u00a0[9]: Copied! <pre># Quality metrics - how well do the clusters represent the original data?\n# Lower RMSE/MAE = better representation\nfs_clustered.clustering.metrics.to_dataframe().style.format('{:.3f}')\n</pre> # Quality metrics - how well do the clusters represent the original data? # Lower RMSE/MAE = better representation fs_clustered.clustering.metrics.to_dataframe().style.format('{:.3f}') Out[9]: RMSE MAE RMSE_duration time_series ElecDemand(P_el)|fixed_relative_profile 0.056 0.016 0.030 GasGrid(Q_Gas)|costs|per_flow_hour 0.088 0.064 0.059 GridBuy(P_el)|costs|per_flow_hour 0.108 0.071 0.028 GridSell(P_el)|costs|per_flow_hour 0.109 0.072 0.025 HeatDemand(Q_th)|fixed_relative_profile 0.079 0.048 0.017 In\u00a0[10]: Copied! <pre># Visual comparison: original vs clustered time series\nfs_clustered.clustering.plot.compare()\n</pre> # Visual comparison: original vs clustered time series fs_clustered.clustering.plot.compare() Out[10]: In\u00a0[11]: Copied! <pre># See what data will be used for clustering\nclustering_data = flow_system.transform.clustering_data()\nprint(f'Variables used for clustering ({len(clustering_data.data_vars)} total):')\nfor var in clustering_data.data_vars:\n    print(f'  - {var}')\n</pre> # See what data will be used for clustering clustering_data = flow_system.transform.clustering_data() print(f'Variables used for clustering ({len(clustering_data.data_vars)} total):') for var in clustering_data.data_vars:     print(f'  - {var}') <pre>Variables used for clustering (5 total):\n  - GasGrid(Q_Gas)|costs|per_flow_hour\n  - GridBuy(P_el)|costs|per_flow_hour\n  - GridSell(P_el)|costs|per_flow_hour\n  - HeatDemand(Q_th)|fixed_relative_profile\n  - ElecDemand(P_el)|fixed_relative_profile\n</pre> In\u00a0[12]: Copied! <pre># Visualize the time-varying data (select a few key variables)\nkey_vars = [v for v in clustering_data.data_vars if 'fixed_relative_profile' in v or 'effects_per_flow_hour' in v]\nclustering_data[key_vars].plotly.line(facet_row='variable', title='Time-Varying Data Used for Clustering')\n</pre> # Visualize the time-varying data (select a few key variables) key_vars = [v for v in clustering_data.data_vars if 'fixed_relative_profile' in v or 'effects_per_flow_hour' in v] clustering_data[key_vars].plotly.line(facet_row='variable', title='Time-Varying Data Used for Clustering') In\u00a0[13]: Copied! <pre># Cluster based ONLY on heat demand pattern (ignore electricity prices)\ndemand_var = 'HeatDemand(Q_th)|fixed_relative_profile'\n\nfs_demand_only = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n    data_vars=[demand_var],  # Only this variable determines clustering\n    extremes=ExtremeConfig(method='new_cluster', max_value=[demand_var]),\n)\n\n# Verify: clustering was determined by demand but applied to all data\nprint(f'Clustered using: {demand_var}')\nprint(f'But all {len(clustering_data.data_vars)} variables are included in the result')\n</pre> # Cluster based ONLY on heat demand pattern (ignore electricity prices) demand_var = 'HeatDemand(Q_th)|fixed_relative_profile'  fs_demand_only = flow_system.transform.cluster(     n_clusters=8,     cluster_duration='1D',     data_vars=[demand_var],  # Only this variable determines clustering     extremes=ExtremeConfig(method='new_cluster', max_value=[demand_var]), )  # Verify: clustering was determined by demand but applied to all data print(f'Clustered using: {demand_var}') print(f'But all {len(clustering_data.data_vars)} variables are included in the result') <pre>Clustered using: HeatDemand(Q_th)|fixed_relative_profile\nBut all 5 variables are included in the result\n</pre> In\u00a0[14]: Copied! <pre># Compare metrics: clustering with all data vs. demand-only\npd.DataFrame(\n    {\n        'All Variables': fs_clustered.clustering.metrics.to_dataframe().iloc[0],\n        'Demand Only': fs_demand_only.clustering.metrics.to_dataframe().iloc[0],\n    }\n).round(4)\n</pre> # Compare metrics: clustering with all data vs. demand-only pd.DataFrame(     {         'All Variables': fs_clustered.clustering.metrics.to_dataframe().iloc[0],         'Demand Only': fs_demand_only.clustering.metrics.to_dataframe().iloc[0],     } ).round(4) Out[14]: All Variables Demand Only RMSE 0.0563 0.0380 MAE 0.0157 0.0223 RMSE_duration 0.0303 0.0107 In\u00a0[15]: Copied! <pre>from tsam import ClusterConfig\n\n# Try different clustering algorithms\nfs_kmeans = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n    cluster=ClusterConfig(method='kmeans'),  # Alternative: 'hierarchical' (default), 'kmedoids', 'averaging'\n)\n\nfs_kmeans.clustering\n</pre> from tsam import ClusterConfig  # Try different clustering algorithms fs_kmeans = flow_system.transform.cluster(     n_clusters=8,     cluster_duration='1D',     cluster=ClusterConfig(method='kmeans'),  # Alternative: 'hierarchical' (default), 'kmedoids', 'averaging' )  fs_kmeans.clustering Out[15]: <pre>Clustering(\n  31 periods \u2192 8 clusters\n  timesteps_per_cluster=24\n  dims=[]\n)</pre> In\u00a0[16]: Copied! <pre># Compare quality metrics between algorithms\npd.DataFrame(\n    {\n        'hierarchical': fs_clustered.clustering.metrics.to_dataframe().iloc[0],\n        'kmeans': fs_kmeans.clustering.metrics.to_dataframe().iloc[0],\n    }\n)\n</pre> # Compare quality metrics between algorithms pd.DataFrame(     {         'hierarchical': fs_clustered.clustering.metrics.to_dataframe().iloc[0],         'kmeans': fs_kmeans.clustering.metrics.to_dataframe().iloc[0],     } ) Out[16]: hierarchical kmeans RMSE 0.056259 0.047047 MAE 0.015673 0.012596 RMSE_duration 0.030335 0.022595 In\u00a0[17]: Copied! <pre># Visualize cluster structure with heatmap\nfs_clustered.clustering.plot.heatmap()\n</pre> # Visualize cluster structure with heatmap fs_clustered.clustering.plot.heatmap() Out[17]: In\u00a0[18]: Copied! <pre># Apply safety margin to sizes\nSAFETY_MARGIN = 1.05  # 5% buffer\nsizes_with_margin = {name: float(size.item()) * SAFETY_MARGIN for name, size in fs_clustered.statistics.sizes.items()}\n</pre> # Apply safety margin to sizes SAFETY_MARGIN = 1.05  # 5% buffer sizes_with_margin = {name: float(size.item()) * SAFETY_MARGIN for name, size in fs_clustered.statistics.sizes.items()} In\u00a0[19]: Copied! <pre># Stage 2: Fix sizes and optimize at full resolution\nstart = timeit.default_timer()\n\nfs_dispatch = flow_system.transform.fix_sizes(sizes_with_margin)\nfs_dispatch.name = 'Two-Stage'\nfs_dispatch.optimize(solver)\n\ntime_dispatch = timeit.default_timer() - start\n\n# Total two-stage time\ntotal_two_stage = time_clustering + time_clustered + time_dispatch\n</pre> # Stage 2: Fix sizes and optimize at full resolution start = timeit.default_timer()  fs_dispatch = flow_system.transform.fix_sizes(sizes_with_margin) fs_dispatch.name = 'Two-Stage' fs_dispatch.optimize(solver)  time_dispatch = timeit.default_timer() - start  # Total two-stage time total_two_stage = time_clustering + time_clustered + time_dispatch In\u00a0[20]: Copied! <pre>results = {\n    'Full (baseline)': {\n        'Time [s]': time_full,\n        'Cost [\u20ac]': fs_full.solution['costs'].item(),\n        'CHP': fs_full.statistics.sizes['CHP(Q_th)'].item(),\n        'Boiler': fs_full.statistics.sizes['Boiler(Q_th)'].item(),\n        'Storage': fs_full.statistics.sizes['Storage'].item(),\n    },\n    'Clustered (8 days)': {\n        'Time [s]': time_clustering + time_clustered,\n        'Cost [\u20ac]': fs_clustered.solution['costs'].item(),\n        'CHP': fs_clustered.statistics.sizes['CHP(Q_th)'].item(),\n        'Boiler': fs_clustered.statistics.sizes['Boiler(Q_th)'].item(),\n        'Storage': fs_clustered.statistics.sizes['Storage'].item(),\n    },\n    'Two-Stage': {\n        'Time [s]': total_two_stage,\n        'Cost [\u20ac]': fs_dispatch.solution['costs'].item(),\n        'CHP': sizes_with_margin['CHP(Q_th)'],\n        'Boiler': sizes_with_margin['Boiler(Q_th)'],\n        'Storage': sizes_with_margin['Storage'],\n    },\n}\n\ncomparison = pd.DataFrame(results).T\nbaseline_cost = comparison.loc['Full (baseline)', 'Cost [\u20ac]']\nbaseline_time = comparison.loc['Full (baseline)', 'Time [s]']\ncomparison['Cost Gap [%]'] = ((comparison['Cost [\u20ac]'] - baseline_cost) / abs(baseline_cost) * 100).round(2)\ncomparison['Speedup'] = (baseline_time / comparison['Time [s]']).round(1)\n\ncomparison.style.format(\n    {\n        'Time [s]': '{:.1f}',\n        'Cost [\u20ac]': '{:,.0f}',\n        'CHP': '{:.1f}',\n        'Boiler': '{:.1f}',\n        'Storage': '{:.0f}',\n        'Cost Gap [%]': '{:.2f}',\n        'Speedup': '{:.1f}x',\n    }\n)\n</pre> results = {     'Full (baseline)': {         'Time [s]': time_full,         'Cost [\u20ac]': fs_full.solution['costs'].item(),         'CHP': fs_full.statistics.sizes['CHP(Q_th)'].item(),         'Boiler': fs_full.statistics.sizes['Boiler(Q_th)'].item(),         'Storage': fs_full.statistics.sizes['Storage'].item(),     },     'Clustered (8 days)': {         'Time [s]': time_clustering + time_clustered,         'Cost [\u20ac]': fs_clustered.solution['costs'].item(),         'CHP': fs_clustered.statistics.sizes['CHP(Q_th)'].item(),         'Boiler': fs_clustered.statistics.sizes['Boiler(Q_th)'].item(),         'Storage': fs_clustered.statistics.sizes['Storage'].item(),     },     'Two-Stage': {         'Time [s]': total_two_stage,         'Cost [\u20ac]': fs_dispatch.solution['costs'].item(),         'CHP': sizes_with_margin['CHP(Q_th)'],         'Boiler': sizes_with_margin['Boiler(Q_th)'],         'Storage': sizes_with_margin['Storage'],     }, }  comparison = pd.DataFrame(results).T baseline_cost = comparison.loc['Full (baseline)', 'Cost [\u20ac]'] baseline_time = comparison.loc['Full (baseline)', 'Time [s]'] comparison['Cost Gap [%]'] = ((comparison['Cost [\u20ac]'] - baseline_cost) / abs(baseline_cost) * 100).round(2) comparison['Speedup'] = (baseline_time / comparison['Time [s]']).round(1)  comparison.style.format(     {         'Time [s]': '{:.1f}',         'Cost [\u20ac]': '{:,.0f}',         'CHP': '{:.1f}',         'Boiler': '{:.1f}',         'Storage': '{:.0f}',         'Cost Gap [%]': '{:.2f}',         'Speedup': '{:.1f}x',     } ) Out[20]: Time [s] Cost [\u20ac] CHP Boiler Storage Cost Gap [%] Speedup Full (baseline) 17.2 -148,912 165.7 0.0 1000 0.00 1.0x Clustered (8 days) 7.0 -138,770 171.0 0.0 1000 6.81 2.5x Two-Stage 14.1 -150,105 179.5 0.0 1050 -0.80 1.2x In\u00a0[21]: Copied! <pre># Expand the clustered solution to full resolution\nfs_expanded = fs_clustered.transform.expand()\n</pre> # Expand the clustered solution to full resolution fs_expanded = fs_clustered.transform.expand() In\u00a0[22]: Copied! <pre># Compare heat production: Full vs Expanded\nheat_flows = ['CHP(Q_th)|flow_rate', 'Boiler(Q_th)|flow_rate']\n\n# Create comparison dataset\ncomparison_ds = xr.Dataset(\n    {\n        name.replace('|flow_rate', ''): xr.concat(\n            [fs_full.solution[name], fs_expanded.solution[name]], dim=pd.Index(['Full', 'Expanded'], name='method')\n        )\n        for name in heat_flows\n    }\n)\n\ncomparison_ds.plotly.line(x='time', facet_col='variable', color='method', title='Heat Production Comparison')\n</pre> # Compare heat production: Full vs Expanded heat_flows = ['CHP(Q_th)|flow_rate', 'Boiler(Q_th)|flow_rate']  # Create comparison dataset comparison_ds = xr.Dataset(     {         name.replace('|flow_rate', ''): xr.concat(             [fs_full.solution[name], fs_expanded.solution[name]], dim=pd.Index(['Full', 'Expanded'], name='method')         )         for name in heat_flows     } )  comparison_ds.plotly.line(x='time', facet_col='variable', color='method', title='Heat Production Comparison') In\u00a0[23]: Copied! <pre>fs_clustered.statistics.plot.storage('Storage')\n</pre> fs_clustered.statistics.plot.storage('Storage') Out[23]: In\u00a0[24]: Copied! <pre>fs_expanded.statistics.plot.storage('Storage')\n</pre> fs_expanded.statistics.plot.storage('Storage') Out[24]:"},{"location":"notebooks/08c-clustering/#time-series-clustering-with-cluster","title":"Time Series Clustering with <code>cluster()</code>\u00b6","text":"<p>Accelerate investment optimization using typical periods (clustering).</p> <p>This notebook demonstrates:</p> <ul> <li>Typical periods: Cluster similar time segments (e.g., days) and solve only representative ones</li> <li>Weighted costs: Automatically weight operational costs by cluster occurrence</li> <li>Two-stage workflow: Fast sizing with clustering, accurate dispatch at full resolution</li> </ul> <p>!!! note \"Requirements\" This notebook requires the <code>tsam</code> package with <code>ClusterConfig</code> and <code>ExtremeConfig</code> support. Install with: <code>pip install \"flixopt[full]\"</code> or <code>pip install git+https://github.com/FBumann/tsam.git@v3-rebased</code></p>"},{"location":"notebooks/08c-clustering/#create-the-flowsystem","title":"Create the FlowSystem\u00b6","text":"<p>We use a district heating system with real-world time series data (one month at 15-min resolution):</p>"},{"location":"notebooks/08c-clustering/#method-1-full-optimization-baseline","title":"Method 1: Full Optimization (Baseline)\u00b6","text":"<p>First, solve the complete problem with all 2976 timesteps:</p>"},{"location":"notebooks/08c-clustering/#method-2-clustering-with-cluster","title":"Method 2: Clustering with <code>cluster()</code>\u00b6","text":"<p>The <code>cluster()</code> method:</p> <ol> <li>Clusters similar days using the TSAM (Time Series Aggregation Module) package</li> <li>Reduces timesteps to only typical periods (e.g., 8 typical days = 768 timesteps)</li> <li>Weights costs by how many original days each typical day represents</li> <li>Handles storage with configurable behavior via <code>storage_mode</code></li> </ol> <p>!!! warning \"Peak Forcing\" Always use <code>extremes=ExtremeConfig(max_value=[...])</code> to ensure extreme demand days are captured. Without this, clustering may miss peak periods, causing undersized components.</p>"},{"location":"notebooks/08c-clustering/#understanding-the-clustering","title":"Understanding the Clustering\u00b6","text":"<p>The clustering algorithm groups similar days together. Access all metadata via <code>fs.clustering</code>:</p>"},{"location":"notebooks/08c-clustering/#inspect-clustering-input-data","title":"Inspect Clustering Input Data\u00b6","text":"<p>Before clustering, you can inspect which time-varying data will be used. The <code>clustering_data()</code> method returns only the arrays that vary over time (constant arrays are excluded since they don't affect clustering):</p>"},{"location":"notebooks/08c-clustering/#selective-clustering-with-data_vars","title":"Selective Clustering with <code>data_vars</code>\u00b6","text":"<p>By default, clustering uses all time-varying data to determine typical periods. However, you may want to cluster based on only a subset of variables while still applying the clustering to all data.</p> <p>Use the <code>data_vars</code> parameter to specify which variables determine the clustering:</p> <ul> <li>Cluster based on subset: Only the specified variables affect which days are grouped together</li> <li>Apply to all data: The resulting clustering is applied to ALL time-varying data</li> </ul> <p>This is useful when:</p> <ul> <li>You want to cluster based on demand patterns only (ignoring price variations)</li> <li>You have dominant time series that should drive the clustering</li> <li>You want to ensure certain patterns are well-represented in typical periods</li> </ul>"},{"location":"notebooks/08c-clustering/#advanced-clustering-options","title":"Advanced Clustering Options\u00b6","text":"<p>The <code>cluster()</code> method exposes many parameters for fine-tuning:</p>"},{"location":"notebooks/08c-clustering/#apply-existing-clustering","title":"Apply Existing Clustering\u00b6","text":"<p>When comparing design variants or performing sensitivity analysis, you often want to use the same cluster structure across different FlowSystem configurations. Use <code>apply_clustering()</code> to reuse a clustering from another FlowSystem:</p> <pre># First, create a reference clustering\nfs_reference = flow_system.transform.cluster(n_clusters=8, cluster_duration='1D')\n\n# Modify the FlowSystem (e.g., different storage size)\nflow_system_modified = flow_system.copy()\nflow_system_modified.components['Storage'].capacity_in_flow_hours.maximum_size = 2000\n\n# Apply the SAME clustering for fair comparison\nfs_modified = flow_system_modified.transform.apply_clustering(fs_reference.clustering)\n</pre> <p>This ensures both systems use identical typical periods for fair comparison.</p>"},{"location":"notebooks/08c-clustering/#method-3-two-stage-workflow-recommended","title":"Method 3: Two-Stage Workflow (Recommended)\u00b6","text":"<p>The recommended approach for investment optimization:</p> <ol> <li>Stage 1: Fast sizing with <code>cluster()</code></li> <li>Stage 2: Fix sizes (with safety margin) and dispatch at full resolution</li> </ol> <p>!!! tip \"Safety Margin\" Typical periods aggregate similar days, so individual days may have higher demand than the typical day. Adding a 5-10% margin ensures feasibility.</p>"},{"location":"notebooks/08c-clustering/#compare-results","title":"Compare Results\u00b6","text":""},{"location":"notebooks/08c-clustering/#expand-solution-to-full-resolution","title":"Expand Solution to Full Resolution\u00b6","text":"<p>Use <code>expand()</code> to map the clustered solution back to all original timesteps. This repeats the typical period values for all days belonging to that cluster:</p>"},{"location":"notebooks/08c-clustering/#visualize-clustered-heat-balance","title":"Visualize Clustered Heat Balance\u00b6","text":""},{"location":"notebooks/08c-clustering/#api-reference","title":"API Reference\u00b6","text":""},{"location":"notebooks/08c-clustering/#transformcluster-parameters","title":"<code>transform.cluster()</code> Parameters\u00b6","text":"Parameter Type Default Description <code>n_clusters</code> <code>int</code> - Number of typical periods (e.g., 8 typical days) <code>cluster_duration</code> <code>str \\| float</code> - Duration per cluster ('1D', '24h') or hours <code>data_vars</code> <code>list[str]</code> None Variables to cluster on (applies result to all) <code>weights</code> <code>dict[str, float]</code> None Optional weights for time series in clustering <code>cluster</code> <code>ClusterConfig</code> None Clustering algorithm configuration <code>extremes</code> <code>ExtremeConfig</code> None Essential: Force inclusion of peak/min periods <code>**tsam_kwargs</code> - - Additional tsam parameters"},{"location":"notebooks/08c-clustering/#transformclustering_data-method","title":"<code>transform.clustering_data()</code> Method\u00b6","text":"<p>Inspect which time-varying data will be used for clustering:</p> <pre># Get all time-varying variables\nclustering_data = flow_system.transform.clustering_data()\nprint(list(clustering_data.data_vars))\n\n# Get data for a specific period (multi-period systems)\nclustering_data = flow_system.transform.clustering_data(period=2024)\n</pre>"},{"location":"notebooks/08c-clustering/#clustering-object-properties","title":"Clustering Object Properties\u00b6","text":"<p>After clustering, access metadata via <code>fs.clustering</code>:</p> Property Description <code>n_clusters</code> Number of clusters <code>n_original_clusters</code> Number of original time segments (e.g., 365 days) <code>timesteps_per_cluster</code> Timesteps in each cluster (e.g., 24 for daily) <code>cluster_assignments</code> xr.DataArray mapping original segment \u2192 cluster ID <code>cluster_occurrences</code> How many original segments each cluster represents <code>metrics</code> xr.Dataset with RMSE, MAE per time series <code>results</code> <code>ClusteringResults</code> with xarray-like interface <code>plot.compare()</code> Compare original vs clustered time series <code>plot.heatmap()</code> Visualize cluster structure"},{"location":"notebooks/08c-clustering/#clusteringresults-xarray-like","title":"ClusteringResults (xarray-like)\u00b6","text":"<p>Access the underlying tsam results via <code>clustering.results</code>:</p> <pre># Dimension info (like xarray)\nclustering.results.dims      # ('period', 'scenario') or ()\nclustering.results.coords    # {'period': [2020, 2030], 'scenario': ['high', 'low']}\n\n# Select specific result (like xarray)\nclustering.results.sel(period=2020, scenario='high')   # Label-based\nclustering.results.isel(period=0, scenario=1)          # Index-based\n\n# Apply existing clustering to new data\nagg_results = clustering.results.apply(dataset)  # Returns AggregationResults\n</pre>"},{"location":"notebooks/08c-clustering/#storage-behavior","title":"Storage Behavior\u00b6","text":"<p>Each <code>Storage</code> component has a <code>cluster_mode</code> parameter:</p> Mode Description <code>'intercluster_cyclic'</code> Links storage across clusters + yearly cyclic (default) <code>'intercluster'</code> Links storage across clusters, free start/end <code>'cyclic'</code> Each cluster is independent but cyclic (start = end) <code>'independent'</code> Each cluster is independent, free start/end <p>For a detailed comparison of storage modes, see 08c2-clustering-storage-modes.</p>"},{"location":"notebooks/08c-clustering/#peak-forcing-with-extremeconfig","title":"Peak Forcing with ExtremeConfig\u00b6","text":"<pre>from tsam import ExtremeConfig\n\nextremes = ExtremeConfig(\n    method='new_cluster',  # Creates new cluster for extremes\n    max_value=['ComponentName(FlowName)|fixed_relative_profile'],  # Capture peak demand\n)\n</pre>"},{"location":"notebooks/08c-clustering/#recommended-workflow","title":"Recommended Workflow\u00b6","text":"<pre>from tsam import ExtremeConfig\n\n# Stage 1: Fast sizing\nfs_sizing = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n    extremes=ExtremeConfig(method='new_cluster', max_value=['Demand(Flow)|fixed_relative_profile']),\n)\nfs_sizing.optimize(solver)\n\n# Apply safety margin\nsizes = {k: v.item() * 1.05 for k, v in fs_sizing.statistics.sizes.items()}\n\n# Stage 2: Accurate dispatch\nfs_dispatch = flow_system.transform.fix_sizes(sizes)\nfs_dispatch.optimize(solver)\n</pre>"},{"location":"notebooks/08c-clustering/#summary","title":"Summary\u00b6","text":"<p>You learned how to:</p> <ul> <li>Use <code>cluster()</code> to reduce time series into typical periods</li> <li>Inspect clustering data with <code>clustering_data()</code> before clustering</li> <li>Use <code>data_vars</code> to cluster based on specific variables only</li> <li>Apply peak forcing with <code>ExtremeConfig</code> to capture extreme demand days</li> <li>Use two-stage optimization for fast yet accurate investment decisions</li> <li>Expand solutions back to full resolution with <code>expand()</code></li> <li>Access clustering metadata via <code>fs.clustering</code> (metrics, cluster_assignments, cluster_occurrences)</li> <li>Use advanced options like different algorithms with <code>ClusterConfig</code></li> <li>Apply existing clustering to other FlowSystems using <code>apply_clustering()</code></li> </ul>"},{"location":"notebooks/08c-clustering/#key-takeaways","title":"Key Takeaways\u00b6","text":"<ol> <li>Always use peak forcing (<code>extremes=ExtremeConfig(max_value=[...])</code>) for demand time series</li> <li>Inspect data first with <code>clustering_data()</code> to see available variables</li> <li>Use <code>data_vars</code> to cluster on specific variables (e.g., demand only, ignoring prices)</li> <li>Add safety margin (5-10%) when fixing sizes from clustering</li> <li>Two-stage is recommended: clustering for sizing, full resolution for dispatch</li> <li>Storage handling is configurable via <code>cluster_mode</code></li> <li>Check metrics to evaluate clustering quality</li> <li>Use <code>apply_clustering()</code> to apply the same clustering to different FlowSystem variants</li> </ol>"},{"location":"notebooks/08c-clustering/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>08c2-clustering-storage-modes: Compare storage modes using a seasonal storage system</li> <li>08d-clustering-multiperiod: Clustering with multiple periods and scenarios</li> </ul>"},{"location":"notebooks/08c2-clustering-storage-modes/","title":"Clustering Storage Modes","text":"In\u00a0[1]: Copied! <pre>import timeit\n\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import timeit  import pandas as pd import plotly.graph_objects as go from plotly.subplots import make_subplots  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre>from data.generate_example_systems import create_seasonal_storage_system\n\nflow_system = create_seasonal_storage_system()\nflow_system.connect_and_transform()  # Align all data as xarray\n\ntimesteps = flow_system.timesteps\nprint(f'FlowSystem: {len(timesteps)} timesteps ({len(timesteps) / 24:.0f} days)')\nprint(f'Components: {list(flow_system.components.keys())}')\n</pre> from data.generate_example_systems import create_seasonal_storage_system  flow_system = create_seasonal_storage_system() flow_system.connect_and_transform()  # Align all data as xarray  timesteps = flow_system.timesteps print(f'FlowSystem: {len(timesteps)} timesteps ({len(timesteps) / 24:.0f} days)') print(f'Components: {list(flow_system.components.keys())}') <pre>FlowSystem: 8760 timesteps (365 days)\nComponents: ['SolarThermal', 'GasBoiler', 'GasGrid', 'SeasonalStorage', 'HeatDemand']\n</pre> In\u00a0[3]: Copied! <pre># Visualize the seasonal patterns\nsolar_profile = flow_system.components['SolarThermal'].outputs[0].fixed_relative_profile\nheat_demand = flow_system.components['HeatDemand'].inputs[0].fixed_relative_profile\n\n# Compute daily averages using xarray resample\nsolar_daily = solar_profile.resample(time='1D').mean()\ndemand_daily = heat_demand.resample(time='1D').mean()\n\nfig = make_subplots(rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.1)\nfig.add_trace(\n    go.Scatter(x=solar_daily.time.values, y=solar_daily.values, name='Solar (daily avg)', fill='tozeroy'), row=1, col=1\n)\nfig.add_trace(\n    go.Scatter(x=demand_daily.time.values, y=demand_daily.values, name='Heat Demand (daily avg)', fill='tozeroy'),\n    row=2,\n    col=1,\n)\nfig.update_layout(height=400, title='Seasonal Mismatch: Solar vs Heat Demand')\nfig.update_xaxes(title_text='Day of Year', row=2, col=1)\nfig.update_yaxes(title_text='Solar Profile', row=1, col=1)\nfig.update_yaxes(title_text='Heat Demand [MW]', row=2, col=1)\nfig.show()\n</pre> # Visualize the seasonal patterns solar_profile = flow_system.components['SolarThermal'].outputs[0].fixed_relative_profile heat_demand = flow_system.components['HeatDemand'].inputs[0].fixed_relative_profile  # Compute daily averages using xarray resample solar_daily = solar_profile.resample(time='1D').mean() demand_daily = heat_demand.resample(time='1D').mean()  fig = make_subplots(rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.1) fig.add_trace(     go.Scatter(x=solar_daily.time.values, y=solar_daily.values, name='Solar (daily avg)', fill='tozeroy'), row=1, col=1 ) fig.add_trace(     go.Scatter(x=demand_daily.time.values, y=demand_daily.values, name='Heat Demand (daily avg)', fill='tozeroy'),     row=2,     col=1, ) fig.update_layout(height=400, title='Seasonal Mismatch: Solar vs Heat Demand') fig.update_xaxes(title_text='Day of Year', row=2, col=1) fig.update_yaxes(title_text='Solar Profile', row=1, col=1) fig.update_yaxes(title_text='Heat Demand [MW]', row=2, col=1) fig.show() In\u00a0[4]: Copied! <pre>solver = fx.solvers.HighsSolver(mip_gap=0.02)\n\nstart = timeit.default_timer()\nfs_full = flow_system.copy()\nfs_full.name = 'Full Optimization'\nfs_full.optimize(solver)\ntime_full = timeit.default_timer() - start\n\nprint(f'Full optimization: {time_full:.1f} seconds')\nprint(f'Total cost: {fs_full.solution[\"costs\"].item():,.0f} EUR')\nprint('\\nOptimized sizes:')\nfor name, size in fs_full.statistics.sizes.items():\n    print(f'  {name}: {float(size.item()):.2f}')\n</pre> solver = fx.solvers.HighsSolver(mip_gap=0.02)  start = timeit.default_timer() fs_full = flow_system.copy() fs_full.name = 'Full Optimization' fs_full.optimize(solver) time_full = timeit.default_timer() - start  print(f'Full optimization: {time_full:.1f} seconds') print(f'Total cost: {fs_full.solution[\"costs\"].item():,.0f} EUR') print('\\nOptimized sizes:') for name, size in fs_full.statistics.sizes.items():     print(f'  {name}: {float(size.item()):.2f}') <pre>Full optimization: 313.4 seconds\nTotal cost: 0 EUR\n\nOptimized sizes:\n  SolarThermal(Q_th): 0.00\n  GasBoiler(Q_th): 0.00\n  SeasonalStorage(Charge): 0.00\n  SeasonalStorage(Discharge): 0.00\n  SeasonalStorage: 0.00\n</pre> In\u00a0[5]: Copied! <pre>from tsam import ExtremeConfig\n\n# Clustering parameters\nN_CLUSTERS = 24  # 24 typical days for a full year\nCLUSTER_DURATION = '1D'\nPEAK_SERIES = ['HeatDemand(Q_th)|fixed_relative_profile']\n\n# Storage modes to compare\nstorage_modes = ['independent', 'cyclic', 'intercluster', 'intercluster_cyclic']\n\nresults = {}\nclustered_systems = {}\n\nfor mode in storage_modes:\n    print(f'\\n--- Mode: {mode} ---')\n\n    # Create a copy and set the storage mode\n    fs_copy = flow_system.copy()\n    fs_copy.storages['SeasonalStorage'].cluster_mode = mode\n\n    start = timeit.default_timer()\n    fs_clustered = fs_copy.transform.cluster(\n        n_clusters=N_CLUSTERS,\n        cluster_duration=CLUSTER_DURATION,\n        extremes=ExtremeConfig(method='new_cluster', max_value=PEAK_SERIES),\n    )\n    time_cluster = timeit.default_timer() - start\n\n    start = timeit.default_timer()\n    fs_clustered.optimize(solver)\n    time_solve = timeit.default_timer() - start\n\n    clustered_systems[mode] = fs_clustered\n\n    results[mode] = {\n        'Time [s]': time_cluster + time_solve,\n        'Cost [EUR]': fs_clustered.solution['costs'].item(),\n        'Solar [MW]': fs_clustered.statistics.sizes.get('SolarThermal(Q_th)', 0),\n        'Boiler [MW]': fs_clustered.statistics.sizes.get('GasBoiler(Q_th)', 0),\n        'Storage [MWh]': fs_clustered.statistics.sizes.get('SeasonalStorage', 0),\n    }\n\n    # Handle xarray types\n    for key in ['Solar [MW]', 'Boiler [MW]', 'Storage [MWh]']:\n        val = results[mode][key]\n        results[mode][key] = float(val.item()) if hasattr(val, 'item') else float(val)\n\n    print(f'  Time: {results[mode][\"Time [s]\"]:.1f}s')\n    print(f'  Cost: {results[mode][\"Cost [EUR]\"]:,.0f} EUR')\n    print(f'  Storage: {results[mode][\"Storage [MWh]\"]:.0f} MWh')\n</pre> from tsam import ExtremeConfig  # Clustering parameters N_CLUSTERS = 24  # 24 typical days for a full year CLUSTER_DURATION = '1D' PEAK_SERIES = ['HeatDemand(Q_th)|fixed_relative_profile']  # Storage modes to compare storage_modes = ['independent', 'cyclic', 'intercluster', 'intercluster_cyclic']  results = {} clustered_systems = {}  for mode in storage_modes:     print(f'\\n--- Mode: {mode} ---')      # Create a copy and set the storage mode     fs_copy = flow_system.copy()     fs_copy.storages['SeasonalStorage'].cluster_mode = mode      start = timeit.default_timer()     fs_clustered = fs_copy.transform.cluster(         n_clusters=N_CLUSTERS,         cluster_duration=CLUSTER_DURATION,         extremes=ExtremeConfig(method='new_cluster', max_value=PEAK_SERIES),     )     time_cluster = timeit.default_timer() - start      start = timeit.default_timer()     fs_clustered.optimize(solver)     time_solve = timeit.default_timer() - start      clustered_systems[mode] = fs_clustered      results[mode] = {         'Time [s]': time_cluster + time_solve,         'Cost [EUR]': fs_clustered.solution['costs'].item(),         'Solar [MW]': fs_clustered.statistics.sizes.get('SolarThermal(Q_th)', 0),         'Boiler [MW]': fs_clustered.statistics.sizes.get('GasBoiler(Q_th)', 0),         'Storage [MWh]': fs_clustered.statistics.sizes.get('SeasonalStorage', 0),     }      # Handle xarray types     for key in ['Solar [MW]', 'Boiler [MW]', 'Storage [MWh]']:         val = results[mode][key]         results[mode][key] = float(val.item()) if hasattr(val, 'item') else float(val)      print(f'  Time: {results[mode][\"Time [s]\"]:.1f}s')     print(f'  Cost: {results[mode][\"Cost [EUR]\"]:,.0f} EUR')     print(f'  Storage: {results[mode][\"Storage [MWh]\"]:.0f} MWh') <pre>\n--- Mode: independent ---\n</pre> <pre>  Time: 3.5s\n  Cost: 49,823 EUR\n  Storage: 155 MWh\n\n--- Mode: cyclic ---\n</pre> <pre>  Time: 6.5s\n  Cost: 1,415,045 EUR\n  Storage: 13 MWh\n\n--- Mode: intercluster ---\n</pre> <pre>  Time: 3.7s\n  Cost: 600,322 EUR\n  Storage: 12780 MWh\n\n--- Mode: intercluster_cyclic ---\n</pre> <pre>  Time: 6.9s\n  Cost: 1,216,234 EUR\n  Storage: 5496 MWh\n</pre> In\u00a0[6]: Copied! <pre># Add full optimization result for comparison\nresults['Full (baseline)'] = {\n    'Time [s]': time_full,\n    'Cost [EUR]': fs_full.solution['costs'].item(),\n    'Solar [MW]': float(fs_full.statistics.sizes.get('SolarThermal(Q_th)', 0).item()),\n    'Boiler [MW]': float(fs_full.statistics.sizes.get('GasBoiler(Q_th)', 0).item()),\n    'Storage [MWh]': float(fs_full.statistics.sizes.get('SeasonalStorage', 0).item()),\n}\n\n# Create comparison DataFrame\ncomparison = pd.DataFrame(results).T\nbaseline_cost = comparison.loc['Full (baseline)', 'Cost [EUR]']\nbaseline_time = comparison.loc['Full (baseline)', 'Time [s]']\ncomparison['Cost Gap [%]'] = (comparison['Cost [EUR]'] - baseline_cost) / abs(baseline_cost) * 100\ncomparison['Speedup'] = baseline_time / comparison['Time [s]']\n\ncomparison.style.format(\n    {\n        'Time [s]': '{:.1f}',\n        'Cost [EUR]': '{:,.0f}',\n        'Solar [MW]': '{:.1f}',\n        'Boiler [MW]': '{:.1f}',\n        'Storage [MWh]': '{:.0f}',\n        'Cost Gap [%]': '{:+.1f}',\n        'Speedup': '{:.1f}x',\n    }\n)\n</pre> # Add full optimization result for comparison results['Full (baseline)'] = {     'Time [s]': time_full,     'Cost [EUR]': fs_full.solution['costs'].item(),     'Solar [MW]': float(fs_full.statistics.sizes.get('SolarThermal(Q_th)', 0).item()),     'Boiler [MW]': float(fs_full.statistics.sizes.get('GasBoiler(Q_th)', 0).item()),     'Storage [MWh]': float(fs_full.statistics.sizes.get('SeasonalStorage', 0).item()), }  # Create comparison DataFrame comparison = pd.DataFrame(results).T baseline_cost = comparison.loc['Full (baseline)', 'Cost [EUR]'] baseline_time = comparison.loc['Full (baseline)', 'Time [s]'] comparison['Cost Gap [%]'] = (comparison['Cost [EUR]'] - baseline_cost) / abs(baseline_cost) * 100 comparison['Speedup'] = baseline_time / comparison['Time [s]']  comparison.style.format(     {         'Time [s]': '{:.1f}',         'Cost [EUR]': '{:,.0f}',         'Solar [MW]': '{:.1f}',         'Boiler [MW]': '{:.1f}',         'Storage [MWh]': '{:.0f}',         'Cost Gap [%]': '{:+.1f}',         'Speedup': '{:.1f}x',     } ) Out[6]: Time [s] Cost [EUR] Solar [MW] Boiler [MW] Storage [MWh] Cost Gap [%] Speedup independent 3.5 49,823 0.0 0.0 155 +inf 89.2x cyclic 6.5 1,415,045 1.2 6.4 13 +inf 48.4x intercluster 3.7 600,322 16.5 0.0 12780 +inf 85.7x intercluster_cyclic 6.9 1,216,234 16.5 4.8 5496 +inf 45.3x Full (baseline) 313.4 0 0.0 0.0 0 +nan 1.0x In\u00a0[7]: Copied! <pre># Expand clustered solutions to full resolution\nexpanded_systems = {}\nfor mode in storage_modes:\n    fs_expanded = clustered_systems[mode].transform.expand()\n    fs_expanded.name = f'Mode: {mode}'\n    expanded_systems[mode] = fs_expanded\n</pre> # Expand clustered solutions to full resolution expanded_systems = {} for mode in storage_modes:     fs_expanded = clustered_systems[mode].transform.expand()     fs_expanded.name = f'Mode: {mode}'     expanded_systems[mode] = fs_expanded In\u00a0[8]: Copied! <pre># Plot storage charge state for each mode\nfig = make_subplots(\n    rows=len(storage_modes) + 1,\n    cols=1,\n    shared_xaxes=True,\n    vertical_spacing=0.05,\n    subplot_titles=['Full Optimization'] + [f'Mode: {m}' for m in storage_modes],\n)\n\n# Full optimization\nsoc_full = fs_full.solution['SeasonalStorage|charge_state']\nfig.add_trace(go.Scatter(x=fs_full.timesteps, y=soc_full.values, name='Full', line=dict(width=0.8)), row=1, col=1)\n\n# Expanded clustered solutions\nfor i, mode in enumerate(storage_modes, start=2):\n    fs_exp = expanded_systems[mode]\n    soc = fs_exp.solution['SeasonalStorage|charge_state']\n    fig.add_trace(go.Scatter(x=fs_exp.timesteps, y=soc.values, name=mode, line=dict(width=0.8)), row=i, col=1)\n\nfig.update_layout(height=800, title='Storage Charge State by Mode', showlegend=False)\nfor i in range(1, len(storage_modes) + 2):\n    fig.update_yaxes(title_text='SOC [MWh]', row=i, col=1)\nfig.show()\n</pre> # Plot storage charge state for each mode fig = make_subplots(     rows=len(storage_modes) + 1,     cols=1,     shared_xaxes=True,     vertical_spacing=0.05,     subplot_titles=['Full Optimization'] + [f'Mode: {m}' for m in storage_modes], )  # Full optimization soc_full = fs_full.solution['SeasonalStorage|charge_state'] fig.add_trace(go.Scatter(x=fs_full.timesteps, y=soc_full.values, name='Full', line=dict(width=0.8)), row=1, col=1)  # Expanded clustered solutions for i, mode in enumerate(storage_modes, start=2):     fs_exp = expanded_systems[mode]     soc = fs_exp.solution['SeasonalStorage|charge_state']     fig.add_trace(go.Scatter(x=fs_exp.timesteps, y=soc.values, name=mode, line=dict(width=0.8)), row=i, col=1)  fig.update_layout(height=800, title='Storage Charge State by Mode', showlegend=False) for i in range(1, len(storage_modes) + 2):     fig.update_yaxes(title_text='SOC [MWh]', row=i, col=1) fig.show() In\u00a0[9]: Copied! <pre># Compare full optimization with the recommended intercluster_cyclic mode\ncomp = fx.Comparison([fs_full, expanded_systems['intercluster_cyclic']])\ncomp.statistics.plot.balance('Heat')\n</pre> # Compare full optimization with the recommended intercluster_cyclic mode comp = fx.Comparison([fs_full, expanded_systems['intercluster_cyclic']]) comp.statistics.plot.balance('Heat') Out[9]:"},{"location":"notebooks/08c2-clustering-storage-modes/#clustering-storage-modes","title":"Clustering Storage Modes\u00b6","text":"<p>Compare different storage handling modes when clustering time series.</p> <p>This notebook demonstrates:</p> <ul> <li>Four storage modes: <code>independent</code>, <code>cyclic</code>, <code>intercluster</code>, <code>intercluster_cyclic</code></li> <li>Seasonal storage: Why inter-cluster linking matters for long-term storage</li> <li>When to use each mode: Choosing the right mode for your application</li> </ul> <p>!!! note \"Requirements\" This notebook requires the <code>tsam</code> package with <code>ExtremeConfig</code> support. Install with: <code>pip install \"flixopt[full]\"</code> or <code>pip install git+https://github.com/FBumann/tsam.git@v3-rebased</code></p> <p>!!! note \"Prerequisites\" Read 08c-clustering first for clustering basics.</p>"},{"location":"notebooks/08c2-clustering-storage-modes/#create-the-seasonal-storage-system","title":"Create the Seasonal Storage System\u00b6","text":"<p>We use a solar thermal + seasonal pit storage system with a full year of data. This is ideal for demonstrating storage modes because:</p> <ul> <li>Solar peaks in summer when heat demand is low</li> <li>Heat demand peaks in winter when solar is minimal</li> <li>Seasonal storage bridges this gap by storing summer heat for winter</li> </ul>"},{"location":"notebooks/08c2-clustering-storage-modes/#understanding-storage-modes","title":"Understanding Storage Modes\u00b6","text":"<p>When clustering reduces a full year to typical periods (e.g., 12 typical days), we need to decide how storage behaves across these periods. Each <code>Storage</code> component has a <code>cluster_mode</code> parameter with four options:</p> Mode Description Use Case <code>'intercluster_cyclic'</code> Links storage across clusters + yearly cyclic Default. Seasonal storage, yearly optimization <code>'intercluster'</code> Links storage across clusters, free start/end Multi-year optimization, flexible boundaries <code>'cyclic'</code> Each cluster independent, but cyclic (start = end) Daily storage only, no seasonal effects <code>'independent'</code> Each cluster independent, free start/end Fastest solve, ignores long-term storage <p>Let's compare them!</p>"},{"location":"notebooks/08c2-clustering-storage-modes/#baseline-full-year-optimization","title":"Baseline: Full Year Optimization\u00b6","text":"<p>First, optimize the full system to establish a baseline:</p>"},{"location":"notebooks/08c2-clustering-storage-modes/#compare-storage-modes","title":"Compare Storage Modes\u00b6","text":"<p>Now let's cluster with each storage mode and compare results. We set <code>cluster_mode</code> on the Storage component before calling <code>cluster()</code>:</p>"},{"location":"notebooks/08c2-clustering-storage-modes/#visualize-storage-behavior","title":"Visualize Storage Behavior\u00b6","text":"<p>The key difference between modes is how storage is utilized across the year. Let's expand each solution back to full resolution and compare:</p>"},{"location":"notebooks/08c2-clustering-storage-modes/#side-by-side-comparison","title":"Side-by-Side Comparison\u00b6","text":"<p>Use the <code>Comparison</code> class to compare the full optimization with the recommended mode:</p>"},{"location":"notebooks/08c2-clustering-storage-modes/#interpretation","title":"Interpretation\u00b6","text":""},{"location":"notebooks/08c2-clustering-storage-modes/#independent-mode","title":"<code>'independent'</code> Mode\u00b6","text":"<ul> <li>Each typical period is solved independently</li> <li>Storage starts and ends at arbitrary states within each cluster</li> <li>No seasonal storage benefit captured - storage is only used for daily fluctuations</li> <li>Fastest to solve but least accurate for seasonal systems</li> </ul>"},{"location":"notebooks/08c2-clustering-storage-modes/#cyclic-mode","title":"<code>'cyclic'</code> Mode\u00b6","text":"<ul> <li>Each cluster is independent but enforces start = end state</li> <li>Better than independent but still no cross-season linking</li> <li>Good for systems where storage only balances within-day variations</li> </ul>"},{"location":"notebooks/08c2-clustering-storage-modes/#intercluster-mode","title":"<code>'intercluster'</code> Mode\u00b6","text":"<ul> <li>Links storage state across the original time series via typical periods</li> <li>Captures seasonal storage behavior - summer charging, winter discharging</li> <li>Free start and end states (useful for multi-year optimization)</li> </ul>"},{"location":"notebooks/08c2-clustering-storage-modes/#intercluster_cyclic-mode-default","title":"<code>'intercluster_cyclic'</code> Mode (Default)\u00b6","text":"<ul> <li>Inter-cluster linking plus yearly cyclic constraint (end = start)</li> <li>Best for yearly investment optimization with seasonal storage</li> <li>Ensures the storage cycle is sustainable year after year</li> </ul>"},{"location":"notebooks/08c2-clustering-storage-modes/#when-to-use-each-mode","title":"When to Use Each Mode\u00b6","text":"Your System Has... Recommended Mode Seasonal storage (pit, underground) <code>'intercluster_cyclic'</code> Only daily storage (batteries, hot water tanks) <code>'cyclic'</code> Multi-year optimization with inter-annual storage <code>'intercluster'</code> Quick sizing estimate, storage not critical <code>'independent'</code>"},{"location":"notebooks/08c2-clustering-storage-modes/#setting-the-mode","title":"Setting the Mode\u00b6","text":"<pre># Option 1: Set when creating the Storage\nstorage = fx.Storage(\n    'SeasonalStorage',\n    capacity_in_flow_hours=5000,\n    cluster_mode='intercluster_cyclic',  # default\n    ...\n)\n\n# Option 2: Modify before clustering\nflow_system.components['SeasonalStorage'].cluster_mode = 'cyclic'\nfs_clustered = flow_system.transform.cluster(...)\n</pre> <p>!!! tip \"Rule of Thumb\" Use <code>'intercluster_cyclic'</code> (default) unless you have a specific reason not to. It provides the most accurate representation of storage behavior in clustered systems.</p>"},{"location":"notebooks/08c2-clustering-storage-modes/#summary","title":"Summary\u00b6","text":"<p>You learned how to:</p> <ul> <li>Use <code>cluster_mode</code> on Storage components to control behavior in clustering</li> <li>Understand the difference between modes and their impact on results</li> <li>Choose the right mode for your optimization problem</li> </ul>"},{"location":"notebooks/08c2-clustering-storage-modes/#key-takeaways","title":"Key Takeaways\u00b6","text":"<ol> <li>Seasonal storage requires inter-cluster linking to capture charging/discharging across seasons</li> <li><code>'intercluster_cyclic'</code> is the default and best for yearly investment optimization</li> <li><code>'independent'</code> and <code>'cyclic'</code> are faster but miss long-term storage value</li> <li>Expand solutions with <code>expand()</code> to visualize storage behavior across the year</li> </ol>"},{"location":"notebooks/08c2-clustering-storage-modes/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>08d-clustering-multiperiod: Clustering with multiple periods and scenarios</li> </ul>"},{"location":"notebooks/08d-clustering-multiperiod/","title":"Multi-Period Clustering with","text":"In\u00a0[1]: Copied! <pre>import timeit\n\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import timeit  import numpy as np import pandas as pd import plotly.express as px  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre>from data.generate_example_systems import create_multiperiod_system\n\nflow_system = create_multiperiod_system()\n\nprint(f'Timesteps: {len(flow_system.timesteps)} ({len(flow_system.timesteps) // 24} days)')\nprint(f'Periods: {list(flow_system.periods.values)}')\nprint(f'Scenarios: {list(flow_system.scenarios.values)}')\nprint(f'Scenario weights: {flow_system.scenario_weights.values}')\nprint(f'\\nComponents: {list(flow_system.components.keys())}')\n</pre> from data.generate_example_systems import create_multiperiod_system  flow_system = create_multiperiod_system()  print(f'Timesteps: {len(flow_system.timesteps)} ({len(flow_system.timesteps) // 24} days)') print(f'Periods: {list(flow_system.periods.values)}') print(f'Scenarios: {list(flow_system.scenarios.values)}') print(f'Scenario weights: {flow_system.scenario_weights.values}') print(f'\\nComponents: {list(flow_system.components.keys())}') <pre>Timesteps: 336 (14 days)\nPeriods: [np.int64(2024), np.int64(2025), np.int64(2026)]\nScenarios: ['high_demand', 'low_demand']\nScenario weights: [0.3 0.7]\n\nComponents: ['GasGrid', 'Boiler', 'ThermalStorage', 'Building']\n</pre> In\u00a0[3]: Copied! <pre># Select first week only (168 hours)\nflow_system = flow_system.transform.isel(time=slice(0, 168))\n\nprint(f'After isel: {len(flow_system.timesteps)} timesteps ({len(flow_system.timesteps) // 24} days)')\n</pre> # Select first week only (168 hours) flow_system = flow_system.transform.isel(time=slice(0, 168))  print(f'After isel: {len(flow_system.timesteps)} timesteps ({len(flow_system.timesteps) // 24} days)') <pre>After isel: 168 timesteps (7 days)\n</pre> In\u00a0[4]: Copied! <pre># Visualize demand scenarios (equal across periods)\nheat_demand = flow_system.components['Building'].inputs[0].fixed_relative_profile\n\nfig = px.line(heat_demand.to_dataframe('value').reset_index(), x='time', y='value', facet_row='scenario')\n\nfig.update_layout(\n    height=350,\n    title='Heat Demand by Scenario (One Week)',\n    xaxis_title='Time',\n    yaxis_title='Heat Demand [kW]',\n)\nfig.show()\n</pre> # Visualize demand scenarios (equal across periods) heat_demand = flow_system.components['Building'].inputs[0].fixed_relative_profile  fig = px.line(heat_demand.to_dataframe('value').reset_index(), x='time', y='value', facet_row='scenario')  fig.update_layout(     height=350,     title='Heat Demand by Scenario (One Week)',     xaxis_title='Time',     yaxis_title='Heat Demand [kW]', ) fig.show() In\u00a0[5]: Copied! <pre>solver = fx.solvers.HighsSolver(mip_gap=0.01)\n\nstart = timeit.default_timer()\nfs_full = flow_system.copy()\nfs_full.name = 'Full Optimization'\nfs_full.optimize(solver)\ntime_full = timeit.default_timer() - start\n\nprint(f'Full optimization: {time_full:.2f} seconds')\nprint(f'Total cost (objective): {fs_full.solution[\"objective\"].item():,.0f} \u20ac')\nprint('\\nOptimized sizes:')\nfor name, size in fs_full.statistics.sizes.items():\n    print(f'  {name}: {size.max().item():.1f}')\n</pre> solver = fx.solvers.HighsSolver(mip_gap=0.01)  start = timeit.default_timer() fs_full = flow_system.copy() fs_full.name = 'Full Optimization' fs_full.optimize(solver) time_full = timeit.default_timer() - start  print(f'Full optimization: {time_full:.2f} seconds') print(f'Total cost (objective): {fs_full.solution[\"objective\"].item():,.0f} \u20ac') print('\\nOptimized sizes:') for name, size in fs_full.statistics.sizes.items():     print(f'  {name}: {size.max().item():.1f}') <pre>Full optimization: 6.63 seconds\nTotal cost (objective): 31,145 \u20ac\n\nOptimized sizes:\n  Boiler(Heat): 147.1\n  ThermalStorage: 53.7\n</pre> In\u00a0[6]: Copied! <pre>from tsam import ExtremeConfig\n\nstart = timeit.default_timer()\n\n# Force inclusion of peak demand periods\npeak_series = ['Building(Heat)|fixed_relative_profile']\n\n# Cluster to 3 typical days (from 7 days)\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=3,\n    cluster_duration='1D',\n    extremes=ExtremeConfig(method='new_cluster', max_value=peak_series),\n)\n\ntime_clustering = timeit.default_timer() - start\n\nprint(f'Clustering time: {time_clustering:.2f} seconds')\nprint(f'Reduced: {len(flow_system.timesteps)} \u2192 {len(fs_clustered.timesteps)} timesteps per period')\nprint('Total problem reduction: 7 days \u00d7 3 periods \u00d7 2 scenarios \u2192 3 days \u00d7 3 \u00d7 2')\n</pre> from tsam import ExtremeConfig  start = timeit.default_timer()  # Force inclusion of peak demand periods peak_series = ['Building(Heat)|fixed_relative_profile']  # Cluster to 3 typical days (from 7 days) fs_clustered = flow_system.transform.cluster(     n_clusters=3,     cluster_duration='1D',     extremes=ExtremeConfig(method='new_cluster', max_value=peak_series), )  time_clustering = timeit.default_timer() - start  print(f'Clustering time: {time_clustering:.2f} seconds') print(f'Reduced: {len(flow_system.timesteps)} \u2192 {len(fs_clustered.timesteps)} timesteps per period') print('Total problem reduction: 7 days \u00d7 3 periods \u00d7 2 scenarios \u2192 3 days \u00d7 3 \u00d7 2') <pre>Clustering time: 0.74 seconds\nReduced: 168 \u2192 24 timesteps per period\nTotal problem reduction: 7 days \u00d7 3 periods \u00d7 2 scenarios \u2192 3 days \u00d7 3 \u00d7 2\n</pre> In\u00a0[7]: Copied! <pre># Optimize the reduced system\nstart = timeit.default_timer()\nfs_clustered.optimize(solver)\ntime_clustered = timeit.default_timer() - start\n\nprint(f'Clustered optimization: {time_clustered:.2f} seconds')\nprint(f'Total cost (objective): {fs_clustered.solution[\"objective\"].item():,.0f} \u20ac')\nprint(f'\\nSpeedup vs full: {time_full / (time_clustering + time_clustered):.1f}x')\nprint('\\nOptimized sizes:')\nfor name, size in fs_clustered.statistics.sizes.items():\n    print(f'  {name}: {size.max().item():.1f}')\n</pre> # Optimize the reduced system start = timeit.default_timer() fs_clustered.optimize(solver) time_clustered = timeit.default_timer() - start  print(f'Clustered optimization: {time_clustered:.2f} seconds') print(f'Total cost (objective): {fs_clustered.solution[\"objective\"].item():,.0f} \u20ac') print(f'\\nSpeedup vs full: {time_full / (time_clustering + time_clustered):.1f}x') print('\\nOptimized sizes:') for name, size in fs_clustered.statistics.sizes.items():     print(f'  {name}: {size.max().item():.1f}') <pre>HighsMipSolverData::transformNewIntegerFeasibleSolution tmpSolver.run();\n</pre> <pre>Clustered optimization: 12.23 seconds\nTotal cost (objective): 29,656 \u20ac\n\nSpeedup vs full: 0.5x\n\nOptimized sizes:\n  Boiler(Heat): 142.5\n  ThermalStorage: 46.0\n</pre> In\u00a0[8]: Copied! <pre># Duration curves show how well the distribution is preserved per period/scenario\nfs_clustered.clustering.plot.compare(\n    kind='duration_curve',\n)\n</pre> # Duration curves show how well the distribution is preserved per period/scenario fs_clustered.clustering.plot.compare(     kind='duration_curve', ) Out[8]: In\u00a0[9]: Copied! <pre># Heatmap shows cluster assignments - faceted by period and scenario\nfs_clustered.clustering.plot.heatmap()\n</pre> # Heatmap shows cluster assignments - faceted by period and scenario fs_clustered.clustering.plot.heatmap() Out[9]: In\u00a0[10]: Copied! <pre>clustering = fs_clustered.clustering\n\nprint('Clustering Configuration:')\nprint(f'  Typical periods (clusters): {clustering.n_clusters}')\nprint(f'  Timesteps per cluster: {clustering.timesteps_per_cluster}')\n\n# Access underlying results via xarray-like interface\nprint(f'\\nClusteringResults dimensions: {clustering.results.dims}')\nprint(f'ClusteringResults coords: {clustering.results.coords}')\n\n# The cluster_assignments shows which cluster each original day belongs to\n# For multi-period systems, select a specific period/scenario combination\ncluster_assignments = clustering.cluster_assignments.isel(period=0, scenario=0).values\nday_names = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n\nprint('\\nCluster assignments per day (period=2024, scenario=High):')\nfor i, cluster_id in enumerate(cluster_assignments):\n    print(f'  {day_names[i]}: Cluster {cluster_id}')\n\n# Cluster occurrences (how many original days each cluster represents)\nunique, counts = np.unique(cluster_assignments, return_counts=True)\nprint('\\nCluster weights (days represented):')\nfor cluster_id, count in zip(unique, counts, strict=True):\n    print(f'  Cluster {cluster_id}: {count} days')\n</pre> clustering = fs_clustered.clustering  print('Clustering Configuration:') print(f'  Typical periods (clusters): {clustering.n_clusters}') print(f'  Timesteps per cluster: {clustering.timesteps_per_cluster}')  # Access underlying results via xarray-like interface print(f'\\nClusteringResults dimensions: {clustering.results.dims}') print(f'ClusteringResults coords: {clustering.results.coords}')  # The cluster_assignments shows which cluster each original day belongs to # For multi-period systems, select a specific period/scenario combination cluster_assignments = clustering.cluster_assignments.isel(period=0, scenario=0).values day_names = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']  print('\\nCluster assignments per day (period=2024, scenario=High):') for i, cluster_id in enumerate(cluster_assignments):     print(f'  {day_names[i]}: Cluster {cluster_id}')  # Cluster occurrences (how many original days each cluster represents) unique, counts = np.unique(cluster_assignments, return_counts=True) print('\\nCluster weights (days represented):') for cluster_id, count in zip(unique, counts, strict=True):     print(f'  Cluster {cluster_id}: {count} days') <pre>Clustering Configuration:\n  Typical periods (clusters): 4\n  Timesteps per cluster: 24\n\nClusteringResults dimensions: ('period', 'scenario')\nClusteringResults coords: {'period': [2024, 2025, 2026], 'scenario': ['high_demand', 'low_demand']}\n\nCluster assignments per day (period=2024, scenario=High):\n  Mon: Cluster 0\n  Tue: Cluster 0\n  Wed: Cluster 0\n  Thu: Cluster 2\n  Fri: Cluster 0\n  Sat: Cluster 1\n  Sun: Cluster 3\n\nCluster weights (days represented):\n  Cluster 0: 4 days\n  Cluster 1: 1 days\n  Cluster 2: 1 days\n  Cluster 3: 1 days\n</pre> In\u00a0[11]: Copied! <pre># Stage 1 already done - apply safety margin\nSAFETY_MARGIN = 1.10  # 10% buffer for multi-period uncertainty\n\nsizes_with_margin = {name: size.max().item() * SAFETY_MARGIN for name, size in fs_clustered.statistics.sizes.items()}\n\nprint('Stage 1: Sizing with clustering')\nprint(f'  Time: {time_clustering + time_clustered:.2f} seconds')\nprint(f'  Cost estimate: {fs_clustered.solution[\"objective\"].item():,.0f} \u20ac')\nprint(f'\\nSizes with {(SAFETY_MARGIN - 1) * 100:.0f}% safety margin:')\nfor name, size in sizes_with_margin.items():\n    original = fs_clustered.statistics.sizes[name].max().item()\n    print(f'  {name}: {original:.1f} \u2192 {size:.1f}')\n</pre> # Stage 1 already done - apply safety margin SAFETY_MARGIN = 1.10  # 10% buffer for multi-period uncertainty  sizes_with_margin = {name: size.max().item() * SAFETY_MARGIN for name, size in fs_clustered.statistics.sizes.items()}  print('Stage 1: Sizing with clustering') print(f'  Time: {time_clustering + time_clustered:.2f} seconds') print(f'  Cost estimate: {fs_clustered.solution[\"objective\"].item():,.0f} \u20ac') print(f'\\nSizes with {(SAFETY_MARGIN - 1) * 100:.0f}% safety margin:') for name, size in sizes_with_margin.items():     original = fs_clustered.statistics.sizes[name].max().item()     print(f'  {name}: {original:.1f} \u2192 {size:.1f}') <pre>Stage 1: Sizing with clustering\n  Time: 12.97 seconds\n  Cost estimate: 29,656 \u20ac\n\nSizes with 10% safety margin:\n  Boiler(Heat): 142.5 \u2192 156.7\n  ThermalStorage: 46.0 \u2192 50.6\n</pre> In\u00a0[12]: Copied! <pre># Stage 2: Full resolution dispatch with fixed sizes\nprint('Stage 2: Full resolution dispatch')\nstart = timeit.default_timer()\n\nfs_dispatch = flow_system.transform.fix_sizes(sizes_with_margin)\nfs_dispatch.name = 'Two-Stage'\nfs_dispatch.optimize(solver)\n\ntime_dispatch = timeit.default_timer() - start\n\nprint(f'  Time: {time_dispatch:.2f} seconds')\nprint(f'  Actual cost: {fs_dispatch.solution[\"objective\"].item():,.0f} \u20ac')\n\n# Total comparison\ntotal_two_stage = time_clustering + time_clustered + time_dispatch\nprint(f'\\nTotal two-stage time: {total_two_stage:.2f} seconds')\nprint(f'Speedup vs full: {time_full / total_two_stage:.1f}x')\n</pre> # Stage 2: Full resolution dispatch with fixed sizes print('Stage 2: Full resolution dispatch') start = timeit.default_timer()  fs_dispatch = flow_system.transform.fix_sizes(sizes_with_margin) fs_dispatch.name = 'Two-Stage' fs_dispatch.optimize(solver)  time_dispatch = timeit.default_timer() - start  print(f'  Time: {time_dispatch:.2f} seconds') print(f'  Actual cost: {fs_dispatch.solution[\"objective\"].item():,.0f} \u20ac')  # Total comparison total_two_stage = time_clustering + time_clustered + time_dispatch print(f'\\nTotal two-stage time: {total_two_stage:.2f} seconds') print(f'Speedup vs full: {time_full / total_two_stage:.1f}x') <pre>Stage 2: Full resolution dispatch\n</pre> <pre>HighsMipSolverData::transformNewIntegerFeasibleSolution tmpSolver.run();\nHighsMipSolverData::transformNewIntegerFeasibleSolution tmpSolver.run();\nHighsMipSolverData::transformNewIntegerFeasibleSolution tmpSolver.run();\nHighsMipSolverData::transformNewIntegerFeasibleSolution tmpSolver.run();\nHighsMipSolverData::transformNewIntegerFeasibleSolution tmpSolver.run();\n</pre> <pre>  Time: 4.05 seconds\n  Actual cost: 32,597 \u20ac\n\nTotal two-stage time: 17.02 seconds\nSpeedup vs full: 0.4x\n</pre> In\u00a0[13]: Copied! <pre>results = {\n    'Full (baseline)': {\n        'Time [s]': time_full,\n        'Cost [\u20ac]': fs_full.solution['objective'].item(),\n        'Boiler': fs_full.statistics.sizes['Boiler(Heat)'].max().item(),\n        'Storage': fs_full.statistics.sizes['ThermalStorage'].max().item(),\n    },\n    'Clustered (3 days)': {\n        'Time [s]': time_clustering + time_clustered,\n        'Cost [\u20ac]': fs_clustered.solution['objective'].item(),\n        'Boiler': fs_clustered.statistics.sizes['Boiler(Heat)'].max().item(),\n        'Storage': fs_clustered.statistics.sizes['ThermalStorage'].max().item(),\n    },\n    'Two-Stage': {\n        'Time [s]': total_two_stage,\n        'Cost [\u20ac]': fs_dispatch.solution['objective'].item(),\n        'Boiler': sizes_with_margin['Boiler(Heat)'],\n        'Storage': sizes_with_margin['ThermalStorage'],\n    },\n}\n\ncomparison = pd.DataFrame(results).T\nbaseline_cost = comparison.loc['Full (baseline)', 'Cost [\u20ac]']\nbaseline_time = comparison.loc['Full (baseline)', 'Time [s]']\ncomparison['Cost Gap [%]'] = ((comparison['Cost [\u20ac]'] - baseline_cost) / abs(baseline_cost) * 100).round(2)\ncomparison['Speedup'] = (baseline_time / comparison['Time [s]']).round(1)\n\ncomparison.style.format(\n    {\n        'Time [s]': '{:.2f}',\n        'Cost [\u20ac]': '{:,.0f}',\n        'Boiler': '{:.1f}',\n        'Storage': '{:.0f}',\n        'Cost Gap [%]': '{:.2f}',\n        'Speedup': '{:.1f}x',\n    }\n)\n</pre> results = {     'Full (baseline)': {         'Time [s]': time_full,         'Cost [\u20ac]': fs_full.solution['objective'].item(),         'Boiler': fs_full.statistics.sizes['Boiler(Heat)'].max().item(),         'Storage': fs_full.statistics.sizes['ThermalStorage'].max().item(),     },     'Clustered (3 days)': {         'Time [s]': time_clustering + time_clustered,         'Cost [\u20ac]': fs_clustered.solution['objective'].item(),         'Boiler': fs_clustered.statistics.sizes['Boiler(Heat)'].max().item(),         'Storage': fs_clustered.statistics.sizes['ThermalStorage'].max().item(),     },     'Two-Stage': {         'Time [s]': total_two_stage,         'Cost [\u20ac]': fs_dispatch.solution['objective'].item(),         'Boiler': sizes_with_margin['Boiler(Heat)'],         'Storage': sizes_with_margin['ThermalStorage'],     }, }  comparison = pd.DataFrame(results).T baseline_cost = comparison.loc['Full (baseline)', 'Cost [\u20ac]'] baseline_time = comparison.loc['Full (baseline)', 'Time [s]'] comparison['Cost Gap [%]'] = ((comparison['Cost [\u20ac]'] - baseline_cost) / abs(baseline_cost) * 100).round(2) comparison['Speedup'] = (baseline_time / comparison['Time [s]']).round(1)  comparison.style.format(     {         'Time [s]': '{:.2f}',         'Cost [\u20ac]': '{:,.0f}',         'Boiler': '{:.1f}',         'Storage': '{:.0f}',         'Cost Gap [%]': '{:.2f}',         'Speedup': '{:.1f}x',     } ) Out[13]: Time [s] Cost [\u20ac] Boiler Storage Cost Gap [%] Speedup Full (baseline) 6.63 31,145 147.1 54 0.00 1.0x Clustered (3 days) 12.97 29,656 142.5 46 -4.78 0.5x Two-Stage 17.02 32,597 156.7 51 4.66 0.4x In\u00a0[14]: Copied! <pre># Plot flow rates with automatic faceting by period and scenario\nfs_full.statistics.plot.flows(component='Boiler')\n</pre> # Plot flow rates with automatic faceting by period and scenario fs_full.statistics.plot.flows(component='Boiler') Out[14]: In\u00a0[15]: Copied! <pre># Side-by-side comparison using the Comparison class\ncomp = fx.Comparison([fs_full, fs_dispatch])\ncomp.statistics.plot.balance('Heat')\n</pre> # Side-by-side comparison using the Comparison class comp = fx.Comparison([fs_full, fs_dispatch]) comp.statistics.plot.balance('Heat') Out[15]: In\u00a0[16]: Copied! <pre># Expand the clustered solution\nfs_expanded = fs_clustered.transform.expand()\n\nprint(f'Expanded: {len(fs_clustered.timesteps)} \u2192 {len(fs_expanded.timesteps)} timesteps')\nprint(f'Cost (objective): {fs_expanded.solution[\"objective\"].item():,.0f} \u20ac')\n</pre> # Expand the clustered solution fs_expanded = fs_clustered.transform.expand()  print(f'Expanded: {len(fs_clustered.timesteps)} \u2192 {len(fs_expanded.timesteps)} timesteps') print(f'Cost (objective): {fs_expanded.solution[\"objective\"].item():,.0f} \u20ac') <pre>Expanded: 24 \u2192 168 timesteps\nCost (objective): 29,656 \u20ac\n</pre> In\u00a0[17]: Copied! <pre># Compare expanded solution - shows the repeated cluster patterns\nfs_expanded.statistics.plot.flows(component='Boiler')\n</pre> # Compare expanded solution - shows the repeated cluster patterns fs_expanded.statistics.plot.flows(component='Boiler') Out[17]:"},{"location":"notebooks/08d-clustering-multiperiod/#multi-period-clustering-with-cluster","title":"Multi-Period Clustering with <code>cluster()</code>\u00b6","text":"<p>Combine time series clustering with multi-period investment optimization.</p> <p>This notebook demonstrates:</p> <ul> <li>Multi-period modeling: Optimize investments across multiple planning periods (years)</li> <li>Scenario analysis: Handle demand uncertainty with weighted scenarios</li> <li>Clustering per period: Apply typical-period clustering independently for each period/scenario</li> <li>Scalability: Reduce computational complexity for long-horizon planning</li> </ul> <p>!!! note \"Requirements\" This notebook requires the <code>tsam</code> package with <code>ExtremeConfig</code> support. Install with: <code>pip install \"flixopt[full]\"</code> or <code>pip install git+https://github.com/FBumann/tsam.git@v3-rebased</code></p>"},{"location":"notebooks/08d-clustering-multiperiod/#create-the-multi-period-system","title":"Create the Multi-Period System\u00b6","text":"<p>We use a multi-period heating system with:</p> <ul> <li>3 planning periods (years 2024, 2025, 2026)</li> <li>2 scenarios (high demand 30%, low demand 70%)</li> <li>2 weeks at hourly resolution (336 timesteps)</li> </ul> <p>This represents a capacity expansion problem where we optimize component sizes once, but operations are simulated across multiple future years and demand scenarios.</p>"},{"location":"notebooks/08d-clustering-multiperiod/#selecting-a-subset-with-transformisel","title":"Selecting a Subset with <code>transform.isel()</code>\u00b6","text":"<p>For demonstration purposes, we'll use only the first week of data. The <code>isel()</code> method (index select) lets you slice FlowSystems by time:</p>"},{"location":"notebooks/08d-clustering-multiperiod/#full-optimization-baseline","title":"Full Optimization (Baseline)\u00b6","text":"<p>First, solve the complete problem with all timesteps across all periods and scenarios:</p>"},{"location":"notebooks/08d-clustering-multiperiod/#multi-period-clustering-with-cluster","title":"Multi-Period Clustering with <code>cluster()</code>\u00b6","text":"<p>When applied to a multi-period system, <code>cluster()</code> clusters each period/scenario combination independently. This is because demand patterns and optimal operations may differ across:</p> <ul> <li>Periods: Different years may have different characteristics</li> <li>Scenarios: High vs low demand scenarios need different representative days</li> </ul> <p>The investment decisions (sizes) remain consistent across all periods and scenarios, while the operational patterns are optimized for each cluster.</p>"},{"location":"notebooks/08d-clustering-multiperiod/#visualize-clustering-quality","title":"Visualize Clustering Quality\u00b6","text":"<p>The <code>.plot</code> accessor provides built-in visualizations with automatic faceting by period and scenario:</p>"},{"location":"notebooks/08d-clustering-multiperiod/#understand-the-cluster-structure","title":"Understand the Cluster Structure\u00b6","text":"<p>Let's inspect how days were grouped into clusters:</p>"},{"location":"notebooks/08d-clustering-multiperiod/#two-stage-workflow-for-multi-period","title":"Two-Stage Workflow for Multi-Period\u00b6","text":"<p>For investment optimization across multiple periods, the recommended workflow is:</p> <ol> <li>Stage 1: Fast sizing with clustering (reduced timesteps)</li> <li>Stage 2: Fix sizes and run full-resolution dispatch</li> </ol> <p>This gives accurate investment decisions while maintaining computational tractability.</p>"},{"location":"notebooks/08d-clustering-multiperiod/#safety-margin-rationale","title":"Safety Margin Rationale\u00b6","text":"<p>A 10% safety margin is applied to compensate for:</p> <ul> <li>Peak underestimation: Clustering averages similar days, potentially underestimating true peak demands</li> <li>Temporal detail loss: Representative periods may miss short-duration extreme events</li> <li>Scenario averaging: Weighted scenarios smooth out worst-case conditions</li> </ul> <p>For critical applications, consider 15-20% margins or validate with full-resolution runs.</p>"},{"location":"notebooks/08d-clustering-multiperiod/#compare-results-across-methods","title":"Compare Results Across Methods\u00b6","text":""},{"location":"notebooks/08d-clustering-multiperiod/#visualize-optimization-results","title":"Visualize Optimization Results\u00b6","text":"<p>Use the built-in statistics plotting to compare results across periods and scenarios:</p>"},{"location":"notebooks/08d-clustering-multiperiod/#expand-clustered-solution-to-full-resolution","title":"Expand Clustered Solution to Full Resolution\u00b6","text":"<p>Use <code>expand()</code> to map the clustered results back to all original timesteps:</p>"},{"location":"notebooks/08d-clustering-multiperiod/#key-considerations-for-multi-period-clustering","title":"Key Considerations for Multi-Period Clustering\u00b6","text":""},{"location":"notebooks/08d-clustering-multiperiod/#1-independent-clustering-per-periodscenario","title":"1. Independent Clustering per Period/Scenario\u00b6","text":"<p>Each period and scenario combination is clustered independently because:</p> <ul> <li>Demand patterns may differ across years (growth, seasonality)</li> <li>Scenarios represent different futures that shouldn't be mixed</li> <li>Investment decisions must be robust across all combinations</li> </ul>"},{"location":"notebooks/08d-clustering-multiperiod/#2-safety-margins","title":"2. Safety Margins\u00b6","text":"<p>Multi-period systems often warrant larger safety margins (10-15%) because:</p> <ul> <li>More uncertainty across multiple years</li> <li>Investments made once must work for all periods</li> <li>Scenario weights may not perfectly represent actual outcomes</li> </ul>"},{"location":"notebooks/08d-clustering-multiperiod/#3-computational-benefits","title":"3. Computational Benefits\u00b6","text":"<p>Clustering becomes more valuable as problem size grows:</p> Scenario Full Problem With Clustering 1 period, 1 scenario, 365 days 8,760 timesteps ~730 (10 typical days) 3 periods, 2 scenarios, 365 days 52,560 timesteps ~4,380 10 periods, 3 scenarios, 365 days 262,800 timesteps ~21,900 <p>The speedup factor increases with problem size.</p>"},{"location":"notebooks/08d-clustering-multiperiod/#summary","title":"Summary\u00b6","text":"<p>You learned how to:</p> <ul> <li>Load multi-period systems with periods and scenarios</li> <li>Use <code>transform.isel()</code> to select time subsets</li> <li>Apply <code>cluster()</code> to multi-dimensional FlowSystems</li> <li>Visualize clustering with the <code>.plot</code> accessor (compare, duration curves, heatmaps)</li> <li>Use the two-stage workflow for robust investment optimization</li> <li>Expand solutions back to full resolution with <code>expand()</code></li> </ul>"},{"location":"notebooks/08d-clustering-multiperiod/#key-takeaways","title":"Key Takeaways\u00b6","text":"<ol> <li>Clustering is applied per period/scenario: Each combination gets independent typical periods</li> <li>Investments are shared: Component sizes are optimized once across all periods/scenarios</li> <li>Use larger safety margins: Multi-period uncertainty warrants 10-15% buffers</li> <li>Two-stage is recommended: Fast sizing with clustering, accurate dispatch at full resolution</li> <li>Built-in plotting: Use <code>.plot</code> accessor for automatic faceting by period/scenario</li> </ol>"},{"location":"notebooks/08d-clustering-multiperiod/#api-reference","title":"API Reference\u00b6","text":"<pre>from tsam import ExtremeConfig\n\n# Load multi-period system\nfs = fx.FlowSystem.from_netcdf('multiperiod_system.nc4')\n\n# Select time subset (optional)\nfs = fs.transform.isel(time=slice(0, 168))  # First 168 timesteps\n\n# Cluster (applies per period/scenario)\nfs_clustered = fs.transform.cluster(\n    n_clusters=10,\n    cluster_duration='1D',\n    extremes=ExtremeConfig(method='new_cluster', max_value=['Demand(Flow)|fixed_relative_profile']),\n)\n\n# Visualize clustering quality\nfs_clustered.clustering.plot.compare(variable='Demand(Flow)|profile')\nfs_clustered.clustering.plot.heatmap()\n\n# Access underlying results (xarray-like interface)\nfs_clustered.clustering.results.dims      # ('period', 'scenario')\nfs_clustered.clustering.results.coords    # {'period': [...], 'scenario': [...]}\nfs_clustered.clustering.results.sel(period=2024, scenario='High')   # Label-based\nfs_clustered.clustering.results.isel(period=0, scenario=0)          # Index-based\n\n# Two-stage workflow\nfs_clustered.optimize(solver)\nsizes = {k: v.max().item() * 1.10 for k, v in fs_clustered.statistics.sizes.items()}\nfs_dispatch = fs.transform.fix_sizes(sizes)\nfs_dispatch.optimize(solver)\n\n# Visualize results\nfs_dispatch.statistics.plot.flows(component='Boiler')\n</pre>"},{"location":"notebooks/08e-clustering-internals/","title":"Clustering Internals","text":"In\u00a0[1]: Copied! <pre>from data.generate_example_systems import create_district_heating_system\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n\nflow_system = create_district_heating_system()\nflow_system.connect_and_transform()\n</pre> from data.generate_example_systems import create_district_heating_system  import flixopt as fx  fx.CONFIG.notebook()  flow_system = create_district_heating_system() flow_system.connect_and_transform() In\u00a0[2]: Copied! <pre>from tsam import ExtremeConfig\n\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n    extremes=ExtremeConfig(method='new_cluster', max_value=['HeatDemand(Q_th)|fixed_relative_profile']),\n)\n\nfs_clustered.clustering\n</pre> from tsam import ExtremeConfig  fs_clustered = flow_system.transform.cluster(     n_clusters=8,     cluster_duration='1D',     extremes=ExtremeConfig(method='new_cluster', max_value=['HeatDemand(Q_th)|fixed_relative_profile']), )  fs_clustered.clustering Out[2]: <pre>Clustering(\n  31 periods \u2192 9 clusters\n  timesteps_per_cluster=24\n  dims=[]\n)</pre> <p>The <code>Clustering</code> object contains:</p> <ul> <li><code>cluster_assignments</code>: Which cluster each original period maps to</li> <li><code>cluster_occurrences</code>: How many original periods each cluster represents</li> <li><code>timestep_mapping</code>: Maps each original timestep to its representative</li> <li><code>original_data</code> / <code>aggregated_data</code>: The data before and after clustering</li> <li><code>results</code>: <code>ClusteringResults</code> object with xarray-like interface (<code>.dims</code>, <code>.coords</code>, <code>.sel()</code>)</li> </ul> In\u00a0[3]: Copied! <pre># Cluster order shows which cluster each original period maps to\nfs_clustered.clustering.cluster_assignments\n</pre> # Cluster order shows which cluster each original period maps to fs_clustered.clustering.cluster_assignments Out[3]: <pre>&lt;xarray.DataArray 'cluster_assignments' (original_cluster: 31)&gt; Size: 248B\narray([6, 1, 1, 2, 6, 5, 5, 8, 5, 8, 0, 4, 5, 0, 0, 0, 0, 0, 4, 3, 3, 3,\n       3, 3, 2, 6, 1, 1, 1, 7, 7])\nDimensions without coordinates: original_cluster</pre>xarray.DataArray'cluster_assignments'<ul><li>original_cluster: 31</li></ul><ul><li>6 1 1 2 6 5 5 8 5 8 0 4 5 0 0 0 0 0 4 3 3 3 3 3 2 6 1 1 1 7 7<pre>array([6, 1, 1, 2, 6, 5, 5, 8, 5, 8, 0, 4, 5, 0, 0, 0, 0, 0, 4, 3, 3, 3,\n       3, 3, 2, 6, 1, 1, 1, 7, 7])</pre></li></ul> In\u00a0[4]: Copied! <pre># Cluster occurrences shows how many original periods each cluster represents\nfs_clustered.clustering.cluster_occurrences\n</pre> # Cluster occurrences shows how many original periods each cluster represents fs_clustered.clustering.cluster_occurrences Out[4]: <pre>&lt;xarray.DataArray 'cluster_occurrences' (cluster: 9)&gt; Size: 72B\narray([6, 5, 2, 5, 2, 4, 3, 2, 2])\nCoordinates:\n  * cluster  (cluster) int64 72B 0 1 2 3 4 5 6 7 8</pre>xarray.DataArray'cluster_occurrences'<ul><li>cluster: 9</li></ul><ul><li>6 5 2 5 2 4 3 2 2<pre>array([6, 5, 2, 5, 2, 4, 3, 2, 2])</pre></li><li>Coordinates: (1)<ul><li>cluster(cluster)int640 1 2 3 4 5 6 7 8<pre>array([0, 1, 2, 3, 4, 5, 6, 7, 8])</pre></li></ul></li></ul> In\u00a0[5]: Copied! <pre># Compare original vs aggregated data as timeseries\n# By default, plots all time-varying variables\nfs_clustered.clustering.plot.compare()\n</pre> # Compare original vs aggregated data as timeseries # By default, plots all time-varying variables fs_clustered.clustering.plot.compare() Out[5]: In\u00a0[6]: Copied! <pre># Use a different approach of visualizing the data using normalize heatmaps\nds = fs_clustered.clustering.plot.compare(data_only=True).data\n\nds_normalized = (ds - ds.min()) / (ds.max() - ds.min())\nds_normalized.to_array().plotly.imshow(\n    x='time',\n    animation_frame='representation',\n    zmin=0,\n    zmax=1,\n    color_continuous_scale='viridis',\n    title='Normalized Comparison',\n)\n</pre> # Use a different approach of visualizing the data using normalize heatmaps ds = fs_clustered.clustering.plot.compare(data_only=True).data  ds_normalized = (ds - ds.min()) / (ds.max() - ds.min()) ds_normalized.to_array().plotly.imshow(     x='time',     animation_frame='representation',     zmin=0,     zmax=1,     color_continuous_scale='viridis',     title='Normalized Comparison', ) In\u00a0[7]: Copied! <pre># Compare specific variables only\nfs_clustered.clustering.plot.compare(variables='HeatDemand(Q_th)|fixed_relative_profile')\n</pre> # Compare specific variables only fs_clustered.clustering.plot.compare(variables='HeatDemand(Q_th)|fixed_relative_profile') Out[7]: In\u00a0[8]: Copied! <pre># Duration curves show how well the aggregated data preserves the distribution\nfs_clustered.clustering.plot.compare(kind='duration_curve').data\n</pre> # Duration curves show how well the aggregated data preserves the distribution fs_clustered.clustering.plot.compare(kind='duration_curve').data Out[8]: <pre>&lt;xarray.Dataset&gt; Size: 54kB\nDimensions:                                  (representation: 2, duration: 744)\nCoordinates:\n  * representation                           (representation) &lt;U9 72B 'Origin...\n  * duration                                 (duration) int64 6kB 0 1 ... 743\nData variables:\n    GridBuy(P_el)|costs|per_flow_hour        (representation, duration) float64 12kB ...\n    GridSell(P_el)|costs|per_flow_hour       (representation, duration) float64 12kB ...\n    HeatDemand(Q_th)|fixed_relative_profile  (representation, duration) float64 12kB ...\n    ElecDemand(P_el)|fixed_relative_profile  (representation, duration) float64 12kB ...</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>representation: 2</li><li>duration: 744</li></ul></li><li>Coordinates: (2)<ul><li>representation(representation)&lt;U9'Original' 'Clustered'<pre>array(['Original', 'Clustered'], dtype='&lt;U9')</pre></li><li>duration(duration)int640 1 2 3 4 5 ... 739 740 741 742 743<pre>array([  0,   1,   2, ..., 741, 742, 743], shape=(744,))</pre></li></ul></li><li>Data variables: (4)<ul><li>GridBuy(P_el)|costs|per_flow_hour(representation, duration)float6469.14 67.24 67.12 ... 0.3067 0.3067<pre>array([[69.14      , 67.24      , 67.12      , ...,  0.46      ,\n        -3.39      , -8.27      ],\n       [64.29287399, 64.29287399, 64.29287399, ...,  0.41475232,\n         0.30668413,  0.30668413]], shape=(2, 744))</pre></li><li>GridSell(P_el)|costs|per_flow_hour(representation, duration)float649.27 4.39 0.54 ... -64.51 -64.51<pre>array([[  9.27      ,   4.39      ,   0.54      , ..., -66.12      ,\n        -66.24      , -68.14      ],\n       [  2.17263147,   2.17263147,   2.0600166 , ..., -64.50561092,\n        -64.50561092, -64.50561092]], shape=(2, 744))</pre></li><li>HeatDemand(Q_th)|fixed_relative_profile(representation, duration)float6437.89 37.08 36.94 ... 14.55 14.55<pre>array([[37.89455185, 37.08413136, 36.94272637, ..., 13.76743558,\n        13.70172107, 13.46883063],\n       [37.89455185, 37.89455185, 36.94272637, ..., 14.54502063,\n        14.54502063, 14.54502063]], shape=(2, 744))</pre></li><li>ElecDemand(P_el)|fixed_relative_profile(representation, duration)float641.184 1.184 1.184 ... 0.2073 0.2073<pre>array([[1.18415431, 1.18415431, 1.18415431, ..., 0.20728517, 0.20728517,\n        0.20728517],\n       [1.18415431, 1.18415431, 1.16504801, ..., 0.20728517, 0.20728517,\n        0.20728517]], shape=(2, 744))</pre></li></ul></li></ul> In\u00a0[9]: Copied! <pre># View typical period profiles for each cluster\n# Each line represents a cluster's representative day\nfs_clustered.clustering.plot.clusters(variables='HeatDemand(Q_th)|fixed_relative_profile', color='cluster')\n</pre> # View typical period profiles for each cluster # Each line represents a cluster's representative day fs_clustered.clustering.plot.clusters(variables='HeatDemand(Q_th)|fixed_relative_profile', color='cluster') Out[9]: In\u00a0[10]: Copied! <pre># Heatmap shows cluster assignments for each original period\nfs_clustered.clustering.plot.heatmap()\n</pre> # Heatmap shows cluster assignments for each original period fs_clustered.clustering.plot.heatmap() Out[10]: In\u00a0[11]: Copied! <pre># Get original and aggregated data\nclustering = fs_clustered.clustering\noriginal = clustering.original_data['HeatDemand(Q_th)|fixed_relative_profile']\naggregated = clustering.aggregated_data['HeatDemand(Q_th)|fixed_relative_profile']\n\n# Expand aggregated data back to original timesteps\nexpanded = clustering.expand_data(aggregated)\n\nprint(f'Original:   {len(original.time)} timesteps')\nprint(f'Aggregated: {len(aggregated.time)} timesteps')\nprint(f'Expanded:   {len(expanded.time)} timesteps')\n</pre> # Get original and aggregated data clustering = fs_clustered.clustering original = clustering.original_data['HeatDemand(Q_th)|fixed_relative_profile'] aggregated = clustering.aggregated_data['HeatDemand(Q_th)|fixed_relative_profile']  # Expand aggregated data back to original timesteps expanded = clustering.expand_data(aggregated)  print(f'Original:   {len(original.time)} timesteps') print(f'Aggregated: {len(aggregated.time)} timesteps') print(f'Expanded:   {len(expanded.time)} timesteps') <pre>Original:   744 timesteps\nAggregated: 24 timesteps\nExpanded:   744 timesteps\n</pre> In\u00a0[12]: Copied! <pre>print(f'Sum of weights: {fs_clustered.cluster_weight.sum().item():.0f}')\nprint(f'Original timesteps: {len(flow_system.timesteps)}')\n</pre> print(f'Sum of weights: {fs_clustered.cluster_weight.sum().item():.0f}') print(f'Original timesteps: {len(flow_system.timesteps)}') <pre>Sum of weights: 31\nOriginal timesteps: 744\n</pre> In\u00a0[13]: Copied! <pre>solver = fx.solvers.HighsSolver(mip_gap=0.01, log_to_console=False)\nfs_clustered.optimize(solver)\n\nfs_expanded = fs_clustered.transform.expand()\n\nprint(f'Clustered: {len(fs_clustered.timesteps)} timesteps')\nprint(f'Expanded:  {len(fs_expanded.timesteps)} timesteps')\n</pre> solver = fx.solvers.HighsSolver(mip_gap=0.01, log_to_console=False) fs_clustered.optimize(solver)  fs_expanded = fs_clustered.transform.expand()  print(f'Clustered: {len(fs_clustered.timesteps)} timesteps') print(f'Expanded:  {len(fs_expanded.timesteps)} timesteps') <pre>Clustered: 24 timesteps\nExpanded:  744 timesteps\n</pre> In\u00a0[14]: Copied! <pre># Before IO: Full tsam access is available\nresult = fs_clustered.clustering.sel()  # Get the AggregationResult\nprint(f'Before IO - AggregationResult available: {type(result).__name__}')\nprint(f'  - n_clusters: {result.n_clusters}')\nprint(f'  - accuracy.rmse (mean): {result.accuracy.rmse.mean():.4f}')\n</pre> # Before IO: Full tsam access is available result = fs_clustered.clustering.sel()  # Get the AggregationResult print(f'Before IO - AggregationResult available: {type(result).__name__}') print(f'  - n_clusters: {result.n_clusters}') print(f'  - accuracy.rmse (mean): {result.accuracy.rmse.mean():.4f}') <pre>Before IO - AggregationResult available: AggregationResult\n  - n_clusters: 9\n  - accuracy.rmse (mean): 0.0882\n</pre> In\u00a0[15]: Copied! <pre># Save and load the clustered system\nimport tempfile\nfrom pathlib import Path\n\ntry:\n    with tempfile.TemporaryDirectory() as tmpdir:\n        path = Path(tmpdir) / 'clustered_system.nc'\n        fs_clustered.to_netcdf(path)\n        fs_loaded = fx.FlowSystem.from_netcdf(path)\n\n    # Structure is preserved\n    print('After IO - Structure preserved:')\n    print(f'  - n_clusters: {fs_loaded.clustering.n_clusters}')\n    print(f'  - dims: {fs_loaded.clustering.dims}')\n    print(f'  - original_data variables: {list(fs_loaded.clustering.original_data.data_vars)[:3]}...')\nexcept OSError as e:\n    print(f'Note: NetCDF save/load skipped due to environment issue: {type(e).__name__}')\n    print('This can happen in some CI environments. The functionality works locally.')\n    fs_loaded = fs_clustered  # Use original for subsequent cells\n</pre> # Save and load the clustered system import tempfile from pathlib import Path  try:     with tempfile.TemporaryDirectory() as tmpdir:         path = Path(tmpdir) / 'clustered_system.nc'         fs_clustered.to_netcdf(path)         fs_loaded = fx.FlowSystem.from_netcdf(path)      # Structure is preserved     print('After IO - Structure preserved:')     print(f'  - n_clusters: {fs_loaded.clustering.n_clusters}')     print(f'  - dims: {fs_loaded.clustering.dims}')     print(f'  - original_data variables: {list(fs_loaded.clustering.original_data.data_vars)[:3]}...') except OSError as e:     print(f'Note: NetCDF save/load skipped due to environment issue: {type(e).__name__}')     print('This can happen in some CI environments. The functionality works locally.')     fs_loaded = fs_clustered  # Use original for subsequent cells <pre>Note: NetCDF save/load skipped due to environment issue: OSError\nThis can happen in some CI environments. The functionality works locally.\n</pre> In\u00a0[16]: Copied! <pre># After IO: sel() raises ValueError because AggregationResult is not preserved\ntry:\n    fs_loaded.clustering.sel()\nexcept ValueError as e:\n    print('After IO - sel() raises ValueError:')\n    print(f'  \"{e}\"')\n</pre> # After IO: sel() raises ValueError because AggregationResult is not preserved try:     fs_loaded.clustering.sel() except ValueError as e:     print('After IO - sel() raises ValueError:')     print(f'  \"{e}\"') In\u00a0[17]: Copied! <pre># Key operations still work after IO:\n# - Optimization\n# - Expansion back to full resolution\n# - Accessing original_data and aggregated_data\n\nfs_loaded.optimize(solver)\nfs_loaded_expanded = fs_loaded.transform.expand()\n\nprint('Loaded system can still be:')\nprint(f'  - Optimized: {fs_loaded.solution is not None}')\nprint(f'  - Expanded: {len(fs_loaded_expanded.timesteps)} timesteps')\n</pre> # Key operations still work after IO: # - Optimization # - Expansion back to full resolution # - Accessing original_data and aggregated_data  fs_loaded.optimize(solver) fs_loaded_expanded = fs_loaded.transform.expand()  print('Loaded system can still be:') print(f'  - Optimized: {fs_loaded.solution is not None}') print(f'  - Expanded: {len(fs_loaded_expanded.timesteps)} timesteps') <pre>Loaded system can still be:\n  - Optimized: True\n  - Expanded: 744 timesteps\n</pre> In\u00a0[18]: Copied! <pre>import tempfile\nfrom pathlib import Path\n\n# Compare file sizes with and without original_data\ntry:\n    with tempfile.TemporaryDirectory() as tmpdir:\n        path_full = Path(tmpdir) / 'full.nc'\n        path_small = Path(tmpdir) / 'small.nc'\n\n        fs_clustered.to_netcdf(path_full, include_original_data=True)\n        fs_clustered.to_netcdf(path_small, include_original_data=False)\n\n        size_full = path_full.stat().st_size / 1024\n        size_small = path_small.stat().st_size / 1024\n\n    print(f'With original_data:    {size_full:.1f} KB')\n    print(f'Without original_data: {size_small:.1f} KB')\n    print(f'Size reduction: {(1 - size_small / size_full) * 100:.0f}%')\nexcept OSError as e:\n    print(f'Note: File size comparison skipped due to environment issue: {type(e).__name__}')\n</pre> import tempfile from pathlib import Path  # Compare file sizes with and without original_data try:     with tempfile.TemporaryDirectory() as tmpdir:         path_full = Path(tmpdir) / 'full.nc'         path_small = Path(tmpdir) / 'small.nc'          fs_clustered.to_netcdf(path_full, include_original_data=True)         fs_clustered.to_netcdf(path_small, include_original_data=False)          size_full = path_full.stat().st_size / 1024         size_small = path_small.stat().st_size / 1024      print(f'With original_data:    {size_full:.1f} KB')     print(f'Without original_data: {size_small:.1f} KB')     print(f'Size reduction: {(1 - size_small / size_full) * 100:.0f}%') except OSError as e:     print(f'Note: File size comparison skipped due to environment issue: {type(e).__name__}') <pre>Note: File size comparison skipped due to environment issue: OSError\n</pre>"},{"location":"notebooks/08e-clustering-internals/#clustering-internals","title":"Clustering Internals\u00b6","text":"<p>Understanding the data structures and visualization tools behind time series clustering.</p> <p>This notebook demonstrates:</p> <ul> <li>Data structure: The <code>Clustering</code> class that stores all clustering information</li> <li>Plot accessor: Built-in visualizations via <code>.plot</code></li> <li>Data expansion: Using <code>expand_data()</code> to map aggregated data back to original timesteps</li> <li>IO workflow: What's preserved and lost when saving/loading clustered systems</li> </ul> <p>!!! note \"Requirements\" This notebook requires the <code>tsam</code> package for time series aggregation. Install with: <code>pip install \"flixopt[full]\"</code></p> <p>!!! note \"Prerequisites\" This notebook assumes familiarity with 08c-clustering.</p>"},{"location":"notebooks/08e-clustering-internals/#clustering-metadata","title":"Clustering Metadata\u00b6","text":"<p>After calling <code>cluster()</code>, metadata is stored in <code>fs.clustering</code>:</p>"},{"location":"notebooks/08e-clustering-internals/#visualizing-clustering","title":"Visualizing Clustering\u00b6","text":"<p>The <code>.plot</code> accessor provides built-in visualizations for understanding clustering results.</p>"},{"location":"notebooks/08e-clustering-internals/#expanding-aggregated-data","title":"Expanding Aggregated Data\u00b6","text":"<p>The <code>Clustering.expand_data()</code> method maps aggregated data back to original timesteps. This is useful for comparing clustering results before optimization:</p>"},{"location":"notebooks/08e-clustering-internals/#summary","title":"Summary\u00b6","text":"Property Description <code>clustering.n_clusters</code> Number of representative clusters <code>clustering.timesteps_per_cluster</code> Timesteps in each cluster period <code>clustering.cluster_assignments</code> Maps original periods to clusters <code>clustering.cluster_occurrences</code> Count of original periods per cluster <code>clustering.timestep_mapping</code> Maps original timesteps to representative indices <code>clustering.original_data</code> Dataset before clustering <code>clustering.aggregated_data</code> Dataset after clustering <code>clustering.results</code> <code>ClusteringResults</code> with xarray-like interface"},{"location":"notebooks/08e-clustering-internals/#clusteringresults-xarray-like","title":"ClusteringResults (xarray-like)\u00b6","text":"<p>Access the underlying tsam results via <code>clustering.results</code>:</p> <pre># Dimension info (like xarray)\nclustering.results.dims      # ('period', 'scenario') or ()\nclustering.results.coords    # {'period': [2020, 2030], 'scenario': ['high', 'low']}\n\n# Select specific result (like xarray)\nclustering.results.sel(period=2020, scenario='high')   # Label-based\nclustering.results.isel(period=0, scenario=1)          # Index-based\n</pre>"},{"location":"notebooks/08e-clustering-internals/#plot-accessor-methods","title":"Plot Accessor Methods\u00b6","text":"Method Description <code>plot.compare()</code> Compare original vs aggregated data (timeseries) <code>plot.compare(kind='duration_curve')</code> Compare as duration curves <code>plot.clusters()</code> View each cluster's profile <code>plot.heatmap()</code> Visualize cluster assignments"},{"location":"notebooks/08e-clustering-internals/#key-parameters","title":"Key Parameters\u00b6","text":"<pre># Compare with options\nclustering.plot.compare(\n    variables='Demand|profile',       # Single variable, list, or None (all)\n    kind='timeseries',                # 'timeseries' or 'duration_curve'\n    select={'scenario': 'Base'},      # xarray-style selection\n    colors='viridis',                 # Colorscale name, list, or dict\n    facet_col='period',               # Facet by period if present\n    facet_row='scenario',             # Facet by scenario if present\n)\n\n# Heatmap shows cluster assignments (no variable needed)\nclustering.plot.heatmap()\n\n# Expand aggregated data to original timesteps\nexpanded = clustering.expand_data(aggregated_data)\n</pre>"},{"location":"notebooks/08e-clustering-internals/#cluster-weights","title":"Cluster Weights\u00b6","text":"<p>Each representative timestep has a weight equal to the number of original periods it represents. This ensures operational costs scale correctly:</p> <p>$$\\text{Objective} = \\sum_{t \\in \\text{typical}} w_t \\cdot c_t$$</p> <p>The weights sum to the original timestep count:</p>"},{"location":"notebooks/08e-clustering-internals/#solution-expansion","title":"Solution Expansion\u00b6","text":"<p>After optimization, <code>expand()</code> maps results back to full resolution:</p>"},{"location":"notebooks/08e-clustering-internals/#io-workflow","title":"IO Workflow\u00b6","text":"<p>When saving and loading a clustered FlowSystem, most clustering information is preserved. However, some methods that access tsam's internal <code>AggregationResult</code> objects are not available after IO.</p>"},{"location":"notebooks/08e-clustering-internals/#whats-preserved-after-io","title":"What's Preserved After IO\u00b6","text":"<ul> <li>Structure: <code>n_clusters</code>, <code>timesteps_per_cluster</code>, <code>dims</code>, <code>coords</code></li> <li>Mappings: <code>cluster_assignments</code>, <code>cluster_occurrences</code>, <code>timestep_mapping</code></li> <li>Data: <code>original_data</code>, <code>aggregated_data</code></li> <li>Original timesteps: <code>original_timesteps</code></li> <li>Results structure: <code>results.sel()</code>, <code>results.isel()</code> for <code>ClusteringResult</code> access</li> </ul>"},{"location":"notebooks/08e-clustering-internals/#whats-lost-after-io","title":"What's Lost After IO\u00b6","text":"<ul> <li><code>clustering.sel()</code>: Accessing full <code>AggregationResult</code> objects</li> <li><code>clustering.items()</code>: Iterating over <code>AggregationResult</code> objects</li> <li>tsam internals: <code>AggregationResult.accuracy</code>, <code>AggregationResult.plot</code>, etc.</li> </ul>"},{"location":"notebooks/08e-clustering-internals/#io-workflow-summary","title":"IO Workflow Summary\u00b6","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    to_netcdf()     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  fs_clustered   \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502   NetCDF file   \u2502\n\u2502                 \u2502                    \u2502                 \u2502\n\u2502 \u2713 clustering    \u2502                    \u2502 \u2713 structure     \u2502\n\u2502 \u2713 sel()         \u2502                    \u2502 \u2713 mappings      \u2502\n\u2502 \u2713 items()       \u2502                    \u2502 \u2713 data          \u2502\n\u2502 \u2713 AggregationResult                  \u2502 \u2717 AggregationResult\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                              \u2502\n                                              \u2502 from_netcdf()\n                                              \u25bc\n                                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                       \u2502   fs_loaded     \u2502\n                                       \u2502                 \u2502\n                                       \u2502 \u2713 optimize()    \u2502\n                                       \u2502 \u2713 expand()      \u2502\n                                       \u2502 \u2713 original_data \u2502\n                                       \u2502 \u2717 sel()         \u2502\n                                       \u2502 \u2717 items()       \u2502\n                                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>!!! tip \"Best Practice\" If you need tsam's <code>AggregationResult</code> for analysis (accuracy metrics, built-in plots), do this before saving the FlowSystem. After loading, the core workflow (optimize \u2192 expand) works normally.</p>"},{"location":"notebooks/08e-clustering-internals/#reducing-file-size","title":"Reducing File Size\u00b6","text":"<p>For smaller files (~38% reduction), use <code>include_original_data=False</code> when saving. This disables <code>plot.compare()</code> after loading, but the core workflow still works:</p>"},{"location":"notebooks/08f-clustering-segmentation/","title":"Intra-Period Segmentation with","text":"In\u00a0[1]: Copied! <pre>import timeit\n\nimport pandas as pd\nimport plotly.express as px\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import timeit  import pandas as pd import plotly.express as px  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre>from data.generate_example_systems import create_district_heating_system\n\nflow_system = create_district_heating_system()\nflow_system.connect_and_transform()\n\nprint(f'Timesteps: {len(flow_system.timesteps)}')\nprint(f'Duration: {(flow_system.timesteps[-1] - flow_system.timesteps[0]).days + 1} days')\n</pre> from data.generate_example_systems import create_district_heating_system  flow_system = create_district_heating_system() flow_system.connect_and_transform()  print(f'Timesteps: {len(flow_system.timesteps)}') print(f'Duration: {(flow_system.timesteps[-1] - flow_system.timesteps[0]).days + 1} days') <pre>Timesteps: 744\nDuration: 31 days\n</pre> In\u00a0[3]: Copied! <pre># Visualize input data\nheat_demand = flow_system.components['HeatDemand'].inputs[0].fixed_relative_profile\nheat_demand.plotly.line(title='Heat Demand Profile')\n</pre> # Visualize input data heat_demand = flow_system.components['HeatDemand'].inputs[0].fixed_relative_profile heat_demand.plotly.line(title='Heat Demand Profile') In\u00a0[4]: Copied! <pre>solver = fx.solvers.HighsSolver(mip_gap=0.01)\n\nstart = timeit.default_timer()\nfs_full = flow_system.copy()\nfs_full.name = 'Full Optimization'\nfs_full.optimize(solver)\ntime_full = timeit.default_timer() - start\n\nprint(f'Full optimization: {time_full:.2f} seconds')\nprint(f'Total cost: {fs_full.solution[\"costs\"].item():,.0f} \u20ac')\n</pre> solver = fx.solvers.HighsSolver(mip_gap=0.01)  start = timeit.default_timer() fs_full = flow_system.copy() fs_full.name = 'Full Optimization' fs_full.optimize(solver) time_full = timeit.default_timer() - start  print(f'Full optimization: {time_full:.2f} seconds') print(f'Total cost: {fs_full.solution[\"costs\"].item():,.0f} \u20ac') <pre>Full optimization: 18.07 seconds\nTotal cost: -148,912 \u20ac\n</pre> In\u00a0[5]: Copied! <pre>from tsam import ExtremeConfig, SegmentConfig\n\nstart = timeit.default_timer()\n\n# Cluster into 8 typical days with 6 segments each\nfs_segmented = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n    segments=SegmentConfig(n_segments=6),  # 6 segments per day instead of 96 quarter-hours\n    extremes=ExtremeConfig(method='new_cluster', max_value=['HeatDemand(Q_th)|fixed_relative_profile']),\n)\n\ntime_clustering = timeit.default_timer() - start\n\nprint(f'Clustering time: {time_clustering:.2f} seconds')\nprint(f'Original timesteps: {len(flow_system.timesteps)}')\nprint(\n    f'Segmented timesteps: {len(fs_segmented.timesteps)} \u00d7 {len(fs_segmented.clusters)} clusters = {len(fs_segmented.timesteps) * len(fs_segmented.clusters)}'\n)\n</pre> from tsam import ExtremeConfig, SegmentConfig  start = timeit.default_timer()  # Cluster into 8 typical days with 6 segments each fs_segmented = flow_system.transform.cluster(     n_clusters=8,     cluster_duration='1D',     segments=SegmentConfig(n_segments=6),  # 6 segments per day instead of 96 quarter-hours     extremes=ExtremeConfig(method='new_cluster', max_value=['HeatDemand(Q_th)|fixed_relative_profile']), )  time_clustering = timeit.default_timer() - start  print(f'Clustering time: {time_clustering:.2f} seconds') print(f'Original timesteps: {len(flow_system.timesteps)}') print(     f'Segmented timesteps: {len(fs_segmented.timesteps)} \u00d7 {len(fs_segmented.clusters)} clusters = {len(fs_segmented.timesteps) * len(fs_segmented.clusters)}' ) <pre>Clustering time: 0.44 seconds\nOriginal timesteps: 744\nSegmented timesteps: 6 \u00d7 9 clusters = 54\n</pre> In\u00a0[6]: Copied! <pre>clustering = fs_segmented.clustering\n\nprint('Segmentation Properties:')\nprint(f'  is_segmented: {clustering.is_segmented}')\nprint(f'  n_segments: {clustering.n_segments}')\nprint(f'  n_clusters: {clustering.n_clusters}')\nprint(f'  timesteps_per_cluster (original): {clustering.timesteps_per_cluster}')\nprint(f'\\nTime dimension uses RangeIndex: {type(fs_segmented.timesteps)}')\n</pre> clustering = fs_segmented.clustering  print('Segmentation Properties:') print(f'  is_segmented: {clustering.is_segmented}') print(f'  n_segments: {clustering.n_segments}') print(f'  n_clusters: {clustering.n_clusters}') print(f'  timesteps_per_cluster (original): {clustering.timesteps_per_cluster}') print(f'\\nTime dimension uses RangeIndex: {type(fs_segmented.timesteps)}') <pre>Segmentation Properties:\n  is_segmented: True\n  n_segments: 6\n  n_clusters: 9\n  timesteps_per_cluster (original): 24\n\nTime dimension uses RangeIndex: &lt;class 'pandas.core.indexes.range.RangeIndex'&gt;\n</pre> In\u00a0[7]: Copied! <pre># Timestep duration is now a DataArray with (cluster, time) dimensions\ntimestep_duration = fs_segmented.timestep_duration\n\nprint(f'Timestep duration shape: {dict(timestep_duration.sizes)}')\nprint('\\nSegment durations for cluster 0:')\ncluster_0_durations = timestep_duration.sel(cluster=0).values\nfor i, dur in enumerate(cluster_0_durations):\n    print(f'  Segment {i}: {dur:.2f} hours')\nprint(f'  Total: {cluster_0_durations.sum():.2f} hours (should be 24h)')\n</pre> # Timestep duration is now a DataArray with (cluster, time) dimensions timestep_duration = fs_segmented.timestep_duration  print(f'Timestep duration shape: {dict(timestep_duration.sizes)}') print('\\nSegment durations for cluster 0:') cluster_0_durations = timestep_duration.sel(cluster=0).values for i, dur in enumerate(cluster_0_durations):     print(f'  Segment {i}: {dur:.2f} hours') print(f'  Total: {cluster_0_durations.sum():.2f} hours (should be 24h)') <pre>Timestep duration shape: {'cluster': 9, 'time': 6}\n\nSegment durations for cluster 0:\n  Segment 0: 6.00 hours\n  Segment 1: 2.00 hours\n  Segment 2: 5.00 hours\n  Segment 3: 6.00 hours\n  Segment 4: 4.00 hours\n  Segment 5: 1.00 hours\n  Total: 24.00 hours (should be 24h)\n</pre> In\u00a0[8]: Copied! <pre># Visualize segment durations across clusters\nduration_df = timestep_duration.to_dataframe('duration').reset_index()\nfig = px.bar(\n    duration_df,\n    x='time',\n    y='duration',\n    facet_col='cluster',\n    facet_col_wrap=4,\n    title='Segment Durations by Cluster',\n    labels={'time': 'Segment', 'duration': 'Duration [hours]'},\n)\nfig.update_layout(height=400)\nfig.show()\n</pre> # Visualize segment durations across clusters duration_df = timestep_duration.to_dataframe('duration').reset_index() fig = px.bar(     duration_df,     x='time',     y='duration',     facet_col='cluster',     facet_col_wrap=4,     title='Segment Durations by Cluster',     labels={'time': 'Segment', 'duration': 'Duration [hours]'}, ) fig.update_layout(height=400) fig.show() In\u00a0[9]: Copied! <pre>start = timeit.default_timer()\nfs_segmented.optimize(solver)\ntime_segmented = timeit.default_timer() - start\n\nprint(f'Segmented optimization: {time_segmented:.2f} seconds')\nprint(f'Total cost: {fs_segmented.solution[\"costs\"].item():,.0f} \u20ac')\nprint(f'\\nSpeedup vs full: {time_full / (time_clustering + time_segmented):.1f}x')\n</pre> start = timeit.default_timer() fs_segmented.optimize(solver) time_segmented = timeit.default_timer() - start  print(f'Segmented optimization: {time_segmented:.2f} seconds') print(f'Total cost: {fs_segmented.solution[\"costs\"].item():,.0f} \u20ac') print(f'\\nSpeedup vs full: {time_full / (time_clustering + time_segmented):.1f}x') <pre>Segmented optimization: 5.48 seconds\nTotal cost: -127,299 \u20ac\n\nSpeedup vs full: 3.1x\n</pre> In\u00a0[10]: Copied! <pre># Duration curves show how well the distribution is preserved\nfs_segmented.clustering.plot.compare(kind='duration_curve')\n</pre> # Duration curves show how well the distribution is preserved fs_segmented.clustering.plot.compare(kind='duration_curve') Out[10]: In\u00a0[11]: Copied! <pre># Clustering quality metrics\nfs_segmented.clustering.metrics.to_dataframe().style.format('{:.3f}')\n</pre> # Clustering quality metrics fs_segmented.clustering.metrics.to_dataframe().style.format('{:.3f}') Out[11]: RMSE MAE RMSE_duration time_series ElecDemand(P_el)|fixed_relative_profile 0.082 0.057 0.055 GasGrid(Q_Gas)|costs|per_flow_hour 0.088 0.064 0.059 GridBuy(P_el)|costs|per_flow_hour 0.112 0.078 0.033 GridSell(P_el)|costs|per_flow_hour 0.113 0.079 0.030 HeatDemand(Q_th)|fixed_relative_profile 0.089 0.063 0.027 In\u00a0[12]: Copied! <pre>start = timeit.default_timer()\nfs_expanded = fs_segmented.transform.expand()\ntime_expand = timeit.default_timer() - start\n\nprint(f'Expansion time: {time_expand:.3f} seconds')\nprint(f'Expanded timesteps: {len(fs_expanded.timesteps)}')\nprint(f'Objective preserved: {fs_expanded.solution[\"costs\"].item():,.0f} \u20ac')\n</pre> start = timeit.default_timer() fs_expanded = fs_segmented.transform.expand() time_expand = timeit.default_timer() - start  print(f'Expansion time: {time_expand:.3f} seconds') print(f'Expanded timesteps: {len(fs_expanded.timesteps)}') print(f'Objective preserved: {fs_expanded.solution[\"costs\"].item():,.0f} \u20ac') <pre>Expansion time: 0.207 seconds\nExpanded timesteps: 744\nObjective preserved: -127,299 \u20ac\n</pre> In\u00a0[13]: Copied! <pre># Compare flow rates: Full vs Expanded\nimport xarray as xr\n\nflow_var = 'CHP(Q_th)|flow_rate'\ncomparison_ds = xr.concat(\n    [fs_full.solution[flow_var], fs_expanded.solution[flow_var]],\n    dim=pd.Index(['Full', 'Expanded'], name='method'),\n)\ncomparison_ds.plotly.line(color='method', title='CHP Heat Output Comparison')\n</pre> # Compare flow rates: Full vs Expanded import xarray as xr  flow_var = 'CHP(Q_th)|flow_rate' comparison_ds = xr.concat(     [fs_full.solution[flow_var], fs_expanded.solution[flow_var]],     dim=pd.Index(['Full', 'Expanded'], name='method'), ) comparison_ds.plotly.line(color='method', title='CHP Heat Output Comparison') In\u00a0[14]: Copied! <pre># Stage 1: Sizing with segmentation (already done)\nSAFETY_MARGIN = 1.05\nsizes_with_margin = {name: float(size.item()) * SAFETY_MARGIN for name, size in fs_segmented.statistics.sizes.items()}\n\nprint('Optimized sizes with safety margin:')\nfor name, size in sizes_with_margin.items():\n    print(f'  {name}: {size:.1f}')\n</pre> # Stage 1: Sizing with segmentation (already done) SAFETY_MARGIN = 1.05 sizes_with_margin = {name: float(size.item()) * SAFETY_MARGIN for name, size in fs_segmented.statistics.sizes.items()}  print('Optimized sizes with safety margin:') for name, size in sizes_with_margin.items():     print(f'  {name}: {size:.1f}') <pre>Optimized sizes with safety margin:\n  CHP(Q_th): 180.1\n  Boiler(Q_th): 0.0\n  Storage: 1050.0\n</pre> In\u00a0[15]: Copied! <pre># Stage 2: Full resolution dispatch with fixed sizes\nstart = timeit.default_timer()\nfs_dispatch = flow_system.transform.fix_sizes(sizes_with_margin)\nfs_dispatch.name = 'Two-Stage'\nfs_dispatch.optimize(solver)\ntime_dispatch = timeit.default_timer() - start\n\nprint(f'Dispatch time: {time_dispatch:.2f} seconds')\nprint(f'Final cost: {fs_dispatch.solution[\"costs\"].item():,.0f} \u20ac')\n</pre> # Stage 2: Full resolution dispatch with fixed sizes start = timeit.default_timer() fs_dispatch = flow_system.transform.fix_sizes(sizes_with_margin) fs_dispatch.name = 'Two-Stage' fs_dispatch.optimize(solver) time_dispatch = timeit.default_timer() - start  print(f'Dispatch time: {time_dispatch:.2f} seconds') print(f'Final cost: {fs_dispatch.solution[\"costs\"].item():,.0f} \u20ac') <pre>Dispatch time: 6.12 seconds\nFinal cost: -150,098 \u20ac\n</pre> In\u00a0[16]: Copied! <pre>total_segmented = time_clustering + time_segmented\ntotal_two_stage = total_segmented + time_dispatch\n\nresults = {\n    'Full (baseline)': {\n        'Time [s]': time_full,\n        'Cost [\u20ac]': fs_full.solution['costs'].item(),\n        'CHP': fs_full.statistics.sizes['CHP(Q_th)'].item(),\n        'Boiler': fs_full.statistics.sizes['Boiler(Q_th)'].item(),\n        'Storage': fs_full.statistics.sizes['Storage'].item(),\n    },\n    'Segmented (8\u00d76)': {\n        'Time [s]': total_segmented,\n        'Cost [\u20ac]': fs_segmented.solution['costs'].item(),\n        'CHP': fs_segmented.statistics.sizes['CHP(Q_th)'].item(),\n        'Boiler': fs_segmented.statistics.sizes['Boiler(Q_th)'].item(),\n        'Storage': fs_segmented.statistics.sizes['Storage'].item(),\n    },\n    'Two-Stage': {\n        'Time [s]': total_two_stage,\n        'Cost [\u20ac]': fs_dispatch.solution['costs'].item(),\n        'CHP': sizes_with_margin['CHP(Q_th)'],\n        'Boiler': sizes_with_margin['Boiler(Q_th)'],\n        'Storage': sizes_with_margin['Storage'],\n    },\n}\n\ncomparison = pd.DataFrame(results).T\nbaseline_cost = comparison.loc['Full (baseline)', 'Cost [\u20ac]']\nbaseline_time = comparison.loc['Full (baseline)', 'Time [s]']\ncomparison['Cost Gap [%]'] = ((comparison['Cost [\u20ac]'] - baseline_cost) / abs(baseline_cost) * 100).round(2)\ncomparison['Speedup'] = (baseline_time / comparison['Time [s]']).round(1)\n\ncomparison.style.format(\n    {\n        'Time [s]': '{:.2f}',\n        'Cost [\u20ac]': '{:,.0f}',\n        'CHP': '{:.1f}',\n        'Boiler': '{:.1f}',\n        'Storage': '{:.0f}',\n        'Cost Gap [%]': '{:.2f}',\n        'Speedup': '{:.1f}x',\n    }\n)\n</pre> total_segmented = time_clustering + time_segmented total_two_stage = total_segmented + time_dispatch  results = {     'Full (baseline)': {         'Time [s]': time_full,         'Cost [\u20ac]': fs_full.solution['costs'].item(),         'CHP': fs_full.statistics.sizes['CHP(Q_th)'].item(),         'Boiler': fs_full.statistics.sizes['Boiler(Q_th)'].item(),         'Storage': fs_full.statistics.sizes['Storage'].item(),     },     'Segmented (8\u00d76)': {         'Time [s]': total_segmented,         'Cost [\u20ac]': fs_segmented.solution['costs'].item(),         'CHP': fs_segmented.statistics.sizes['CHP(Q_th)'].item(),         'Boiler': fs_segmented.statistics.sizes['Boiler(Q_th)'].item(),         'Storage': fs_segmented.statistics.sizes['Storage'].item(),     },     'Two-Stage': {         'Time [s]': total_two_stage,         'Cost [\u20ac]': fs_dispatch.solution['costs'].item(),         'CHP': sizes_with_margin['CHP(Q_th)'],         'Boiler': sizes_with_margin['Boiler(Q_th)'],         'Storage': sizes_with_margin['Storage'],     }, }  comparison = pd.DataFrame(results).T baseline_cost = comparison.loc['Full (baseline)', 'Cost [\u20ac]'] baseline_time = comparison.loc['Full (baseline)', 'Time [s]'] comparison['Cost Gap [%]'] = ((comparison['Cost [\u20ac]'] - baseline_cost) / abs(baseline_cost) * 100).round(2) comparison['Speedup'] = (baseline_time / comparison['Time [s]']).round(1)  comparison.style.format(     {         'Time [s]': '{:.2f}',         'Cost [\u20ac]': '{:,.0f}',         'CHP': '{:.1f}',         'Boiler': '{:.1f}',         'Storage': '{:.0f}',         'Cost Gap [%]': '{:.2f}',         'Speedup': '{:.1f}x',     } ) Out[16]: Time [s] Cost [\u20ac] CHP Boiler Storage Cost Gap [%] Speedup Full (baseline) 18.07 -148,912 165.7 0.0 1000 0.00 1.0x Segmented (8\u00d76) 5.92 -127,299 171.5 0.0 1000 14.51 3.1x Two-Stage 12.05 -150,098 180.1 0.0 1050 -0.80 1.5x In\u00a0[17]: Copied! <pre>from data.generate_example_systems import create_multiperiod_system\n\nfs_multi = create_multiperiod_system()\n# Use first week only for faster demo\nfs_multi = fs_multi.transform.isel(time=slice(0, 168))\n\nprint(f'Periods: {list(fs_multi.periods.values)}')\nprint(f'Scenarios: {list(fs_multi.scenarios.values)}')\n</pre> from data.generate_example_systems import create_multiperiod_system  fs_multi = create_multiperiod_system() # Use first week only for faster demo fs_multi = fs_multi.transform.isel(time=slice(0, 168))  print(f'Periods: {list(fs_multi.periods.values)}') print(f'Scenarios: {list(fs_multi.scenarios.values)}') <pre>Periods: [np.int64(2024), np.int64(2025), np.int64(2026)]\nScenarios: ['high_demand', 'low_demand']\n</pre> In\u00a0[18]: Copied! <pre># Cluster with segmentation\nfs_multi_seg = fs_multi.transform.cluster(\n    n_clusters=3,\n    cluster_duration='1D',\n    segments=SegmentConfig(n_segments=6),\n    extremes=ExtremeConfig(method='new_cluster', max_value=['Building(Heat)|fixed_relative_profile']),\n)\n\nprint(f'Original: {len(fs_multi.timesteps)} timesteps')\nprint(f'Segmented: {len(fs_multi_seg.timesteps)} \u00d7 {len(fs_multi_seg.clusters)} clusters')\nprint(f'is_segmented: {fs_multi_seg.clustering.is_segmented}')\n</pre> # Cluster with segmentation fs_multi_seg = fs_multi.transform.cluster(     n_clusters=3,     cluster_duration='1D',     segments=SegmentConfig(n_segments=6),     extremes=ExtremeConfig(method='new_cluster', max_value=['Building(Heat)|fixed_relative_profile']), )  print(f'Original: {len(fs_multi.timesteps)} timesteps') print(f'Segmented: {len(fs_multi_seg.timesteps)} \u00d7 {len(fs_multi_seg.clusters)} clusters') print(f'is_segmented: {fs_multi_seg.clustering.is_segmented}') <pre>Original: 168 timesteps\nSegmented: 6 \u00d7 4 clusters\nis_segmented: True\n</pre> In\u00a0[19]: Copied! <pre># Cluster assignments have period/scenario dimensions\nfs_multi_seg.clustering.cluster_assignments\n</pre> # Cluster assignments have period/scenario dimensions fs_multi_seg.clustering.cluster_assignments Out[19]: <pre>&lt;xarray.DataArray 'cluster_assignments' (original_cluster: 7, period: 3,\n                                         scenario: 2)&gt; Size: 336B\narray([[[0, 0],\n        [0, 0],\n        [0, 0]],\n\n       [[0, 0],\n        [0, 0],\n        [0, 0]],\n\n       [[0, 0],\n        [0, 0],\n        [0, 0]],\n\n       [[2, 2],\n        [2, 2],\n        [2, 2]],\n\n       [[0, 0],\n        [0, 0],\n        [0, 0]],\n\n       [[1, 1],\n        [1, 1],\n        [1, 1]],\n\n       [[3, 3],\n        [3, 3],\n        [3, 3]]])\nCoordinates:\n  * period    (period) int64 24B 2024 2025 2026\n  * scenario  (scenario) &lt;U11 88B 'high_demand' 'low_demand'\nDimensions without coordinates: original_cluster</pre>xarray.DataArray'cluster_assignments'<ul><li>original_cluster: 7</li><li>period: 3</li><li>scenario: 2</li></ul><ul><li>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 1 1 1 1 1 1 3 3 3 3 3 3<pre>array([[[0, 0],\n        [0, 0],\n        [0, 0]],\n\n       [[0, 0],\n        [0, 0],\n        [0, 0]],\n\n       [[0, 0],\n        [0, 0],\n        [0, 0]],\n\n       [[2, 2],\n        [2, 2],\n        [2, 2]],\n\n       [[0, 0],\n        [0, 0],\n        [0, 0]],\n\n       [[1, 1],\n        [1, 1],\n        [1, 1]],\n\n       [[3, 3],\n        [3, 3],\n        [3, 3]]])</pre></li><li>Coordinates: (2)<ul><li>period(period)int642024 2025 2026<pre>array([2024, 2025, 2026])</pre></li><li>scenario(scenario)&lt;U11'high_demand' 'low_demand'<pre>array(['high_demand', 'low_demand'], dtype='&lt;U11')</pre></li></ul></li></ul> In\u00a0[20]: Copied! <pre># Optimize and expand\nfs_multi_seg.optimize(solver)\nfs_multi_expanded = fs_multi_seg.transform.expand()\n\nprint(f'Expanded timesteps: {len(fs_multi_expanded.timesteps)}')\nprint(f'Objective: {fs_multi_expanded.solution[\"objective\"].item():,.0f} \u20ac')\n</pre> # Optimize and expand fs_multi_seg.optimize(solver) fs_multi_expanded = fs_multi_seg.transform.expand()  print(f'Expanded timesteps: {len(fs_multi_expanded.timesteps)}') print(f'Objective: {fs_multi_expanded.solution[\"objective\"].item():,.0f} \u20ac') <pre>Expanded timesteps: 168\nObjective: 29,610 \u20ac\n</pre>"},{"location":"notebooks/08f-clustering-segmentation/#intra-period-segmentation-with-cluster","title":"Intra-Period Segmentation with <code>cluster()</code>\u00b6","text":"<p>Reduce timesteps within each typical period using segmentation.</p> <p>This notebook demonstrates:</p> <ul> <li>Segmentation: Aggregate timesteps within each cluster into fewer segments</li> <li>Variable durations: Each segment can have different duration (hours)</li> <li>Combined reduction: Use clustering AND segmentation for maximum speedup</li> <li>Expansion: Map segmented results back to original timesteps</li> </ul> <p>!!! note \"Requirements\" This notebook requires the <code>tsam</code> package with <code>SegmentConfig</code> and <code>ExtremeConfig</code> support. Install with: <code>pip install \"flixopt[full]\"</code> or <code>pip install git+https://github.com/FBumann/tsam.git@v3-rebased</code></p>"},{"location":"notebooks/08f-clustering-segmentation/#what-is-segmentation","title":"What is Segmentation?\u00b6","text":"<p>Clustering groups similar time periods (e.g., days) into representative clusters.</p> <p>Segmentation goes further by aggregating timesteps within each cluster into fewer segments with variable durations.</p> <pre><code>Original:     | Day 1 (24h) | Day 2 (24h) | Day 3 (24h) | ... | Day 365 (24h) |\n                 \u2193               \u2193               \u2193                   \u2193\nClustered:    | Typical Day A (24h) | Typical Day B (24h) | Typical Day C (24h) |\n                 \u2193                      \u2193                      \u2193\nSegmented:    | Seg1 (4h) | Seg2 (8h) | Seg3 (8h) | Seg4 (4h) |  (per typical day)\n</code></pre> <p>This can dramatically reduce problem size:</p> <ul> <li>Original: 365 days \u00d7 24 hours = 8,760 timesteps</li> <li>Clustered (8 days): 8 \u00d7 24 = 192 timesteps</li> <li>Segmented (6 segments): 8 \u00d7 6 = 48 timesteps</li> </ul>"},{"location":"notebooks/08f-clustering-segmentation/#create-the-flowsystem","title":"Create the FlowSystem\u00b6","text":"<p>We use a district heating system with one month of data at 15-min resolution:</p>"},{"location":"notebooks/08f-clustering-segmentation/#full-optimization-baseline","title":"Full Optimization (Baseline)\u00b6","text":""},{"location":"notebooks/08f-clustering-segmentation/#clustering-with-segmentation","title":"Clustering with Segmentation\u00b6","text":"<p>Use <code>SegmentConfig</code> to enable intra-period segmentation:</p>"},{"location":"notebooks/08f-clustering-segmentation/#understanding-segmentation-properties","title":"Understanding Segmentation Properties\u00b6","text":"<p>After segmentation, the clustering object has additional properties:</p>"},{"location":"notebooks/08f-clustering-segmentation/#variable-timestep-durations","title":"Variable Timestep Durations\u00b6","text":"<p>Each segment has a different duration, determined by how many original timesteps it represents:</p>"},{"location":"notebooks/08f-clustering-segmentation/#optimize-the-segmented-system","title":"Optimize the Segmented System\u00b6","text":""},{"location":"notebooks/08f-clustering-segmentation/#compare-clustering-quality","title":"Compare Clustering Quality\u00b6","text":"<p>View how well the segmented data represents the original:</p>"},{"location":"notebooks/08f-clustering-segmentation/#expand-to-original-timesteps","title":"Expand to Original Timesteps\u00b6","text":"<p>Use <code>expand()</code> to map the segmented solution back to all original timesteps:</p>"},{"location":"notebooks/08f-clustering-segmentation/#two-stage-workflow-with-segmentation","title":"Two-Stage Workflow with Segmentation\u00b6","text":"<p>For investment optimization, use segmentation for fast sizing, then dispatch at full resolution:</p>"},{"location":"notebooks/08f-clustering-segmentation/#compare-results","title":"Compare Results\u00b6","text":""},{"location":"notebooks/08f-clustering-segmentation/#segmentation-with-multi-period-systems","title":"Segmentation with Multi-Period Systems\u00b6","text":"<p>Segmentation works with multi-period systems (multiple years, scenarios). Each period/scenario combination is segmented independently:</p>"},{"location":"notebooks/08f-clustering-segmentation/#api-reference","title":"API Reference\u00b6","text":""},{"location":"notebooks/08f-clustering-segmentation/#segmentconfig-parameters","title":"SegmentConfig Parameters\u00b6","text":"<pre>from tsam import SegmentConfig\n\nsegments = SegmentConfig(\n    n_segments=6,              # Number of segments per cluster period\n    representation_method='mean',  # How to represent segment values ('mean', 'medoid', etc.)\n)\n</pre>"},{"location":"notebooks/08f-clustering-segmentation/#segmentation-properties","title":"Segmentation Properties\u00b6","text":"<p>After segmentation, <code>fs.clustering</code> has additional properties:</p> Property Description <code>is_segmented</code> <code>True</code> if segmentation was used <code>n_segments</code> Number of segments per cluster <code>timesteps_per_cluster</code> Original timesteps per cluster (before segmentation)"},{"location":"notebooks/08f-clustering-segmentation/#timestep-duration","title":"Timestep Duration\u00b6","text":"<p>For segmented systems, <code>fs.timestep_duration</code> is a DataArray with <code>(cluster, time)</code> dimensions:</p> <pre># Each segment has different duration\nfs_segmented.timestep_duration  # Shape: (n_clusters, n_segments)\n\n# Sum should equal original period duration\nfs_segmented.timestep_duration.sum('time')  # Should be 24h for daily clusters\n</pre>"},{"location":"notebooks/08f-clustering-segmentation/#example-workflow","title":"Example Workflow\u00b6","text":"<pre>from tsam import ExtremeConfig, SegmentConfig\n\n# Cluster with segmentation\nfs_segmented = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n    segments=SegmentConfig(n_segments=6),\n    extremes=ExtremeConfig(method='new_cluster', max_value=['Demand|profile']),\n)\n\n# Optimize\nfs_segmented.optimize(solver)\n\n# Expand back to original timesteps\nfs_expanded = fs_segmented.transform.expand()\n\n# Two-stage workflow\nsizes = {k: v.item() * 1.05 for k, v in fs_segmented.statistics.sizes.items()}\nfs_dispatch = flow_system.transform.fix_sizes(sizes)\nfs_dispatch.optimize(solver)\n</pre>"},{"location":"notebooks/08f-clustering-segmentation/#summary","title":"Summary\u00b6","text":"<p>You learned how to:</p> <ul> <li>Use <code>SegmentConfig</code> to enable intra-period segmentation</li> <li>Work with variable timestep durations for each segment</li> <li>Combine clustering and segmentation for maximum problem size reduction</li> <li>Expand segmented solutions back to original timesteps</li> <li>Use segmentation with multi-period systems</li> </ul>"},{"location":"notebooks/08f-clustering-segmentation/#key-takeaways","title":"Key Takeaways\u00b6","text":"<ol> <li>Segmentation reduces problem size further: From 8\u00d724=192 to 8\u00d76=48 timesteps</li> <li>Variable durations preserve accuracy: Important periods get more timesteps</li> <li>Works with multi-period: Each period/scenario is segmented independently</li> <li>expand() works correctly: Maps segment values to all original timesteps</li> <li>Two-stage is still recommended: Use segmentation for sizing, full resolution for dispatch</li> </ol>"},{"location":"notebooks/08f-clustering-segmentation/#trade-offs","title":"Trade-offs\u00b6","text":"More Segments Fewer Segments Higher accuracy Lower accuracy Slower solve Faster solve More memory Less memory <p>Start with 6-12 segments and adjust based on your accuracy needs.</p>"},{"location":"notebooks/09-plotting-and-data-access/","title":"Plotting","text":"In\u00a0[1]: Copied! <pre>from data.generate_example_systems import create_complex_system, create_multiperiod_system, create_simple_system\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> from data.generate_example_systems import create_complex_system, create_multiperiod_system, create_simple_system  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre># Create and optimize the example systems\nsolver = fx.solvers.HighsSolver(mip_gap=0.01, log_to_console=False)\n\nsimple = create_simple_system()\nsimple.optimize(solver)\n\ncomplex_sys = create_complex_system()\ncomplex_sys.optimize(solver)\n\nmultiperiod = create_multiperiod_system()\nmultiperiod.optimize(solver)\n\nprint('Created systems:')\nprint(f'  simple:      {len(simple.components)} components, {len(simple.buses)} buses')\nprint(f'  complex_sys: {len(complex_sys.components)} components, {len(complex_sys.buses)} buses')\nprint(f'  multiperiod: {len(multiperiod.components)} components, dims={dict(multiperiod.solution.sizes)}')\n</pre> # Create and optimize the example systems solver = fx.solvers.HighsSolver(mip_gap=0.01, log_to_console=False)  simple = create_simple_system() simple.optimize(solver)  complex_sys = create_complex_system() complex_sys.optimize(solver)  multiperiod = create_multiperiod_system() multiperiod.optimize(solver)  print('Created systems:') print(f'  simple:      {len(simple.components)} components, {len(simple.buses)} buses') print(f'  complex_sys: {len(complex_sys.components)} components, {len(complex_sys.buses)} buses') print(f'  multiperiod: {len(multiperiod.components)} components, dims={dict(multiperiod.solution.sizes)}') <pre>HighsMipSolverData::transformNewIntegerFeasibleSolution tmpSolver.run();\n</pre> <pre>Created systems:\n  simple:      4 components, 2 buses\n  complex_sys: 9 components, 3 buses\n  multiperiod: 4 components, dims={'period': 3, 'scenario': 2, 'time': 337}\n</pre> In\u00a0[3]: Copied! <pre># Balance plot for the Heat bus - shows all inflows and outflows\nsimple.statistics.plot.balance('Heat')\n</pre> # Balance plot for the Heat bus - shows all inflows and outflows simple.statistics.plot.balance('Heat') Out[3]: In\u00a0[4]: Copied! <pre># Get plot result and access the underlying data\nresult = simple.statistics.plot.balance('Heat', show=False)\n\n# Convert to DataFrame for easy viewing/export\ndf = result.data.to_dataframe()\ndf.head(10)\n</pre> # Get plot result and access the underlying data result = simple.statistics.plot.balance('Heat', show=False)  # Convert to DataFrame for easy viewing/export df = result.data.to_dataframe() df.head(10) Out[4]: Boiler(Heat) Office(Heat) ThermalStorage(Charge) ThermalStorage(Discharge) time 2020-01-15 00:00:00 -0.000000 74.814983 0.0 -74.814983 2020-01-15 01:00:00 -75.497186 75.497186 -0.0 0.000000 2020-01-15 02:00:00 -0.000000 75.724587 0.0 -75.724587 2020-01-15 03:00:00 -88.004250 88.004250 0.0 -0.000000 2020-01-15 04:00:00 -104.149733 104.149733 0.0 0.000000 2020-01-15 05:00:00 -104.604535 104.604535 -0.0 0.000000 2020-01-15 06:00:00 -123.478832 123.478832 0.0 -0.000000 2020-01-15 07:00:00 -127.117250 127.117250 -0.0 0.000000 2020-01-15 08:00:00 -122.569227 122.569227 0.0 -0.000000 2020-01-15 09:00:00 -117.111599 117.111599 0.0 -0.000000 In\u00a0[5]: Copied! <pre>import pandas as pd\n\n# Total energy per flow\ntotals = {var: float(simple.statistics.flow_hours[var].sum()) for var in simple.statistics.flow_hours.data_vars}\n\npd.Series(totals, name='Energy [kWh]').to_frame().T\n</pre> import pandas as pd  # Total energy per flow totals = {var: float(simple.statistics.flow_hours[var].sum()) for var in simple.statistics.flow_hours.data_vars}  pd.Series(totals, name='Energy [kWh]').to_frame().T Out[5]: GasGrid(Gas) Boiler(Gas) Boiler(Heat) ThermalStorage(Charge) ThermalStorage(Discharge) Office(Heat) Energy [kWh] 16317.686404 16317.686404 15012.271491 162.811061 150.53957 15000.0 In\u00a0[6]: Copied! <pre># Component balance (all flows of a component)\nsimple.statistics.plot.balance('ThermalStorage')\n</pre> # Component balance (all flows of a component) simple.statistics.plot.balance('ThermalStorage') Out[6]: In\u00a0[7]: Copied! <pre>complex_sys.statistics.plot.carrier_balance('heat')\n</pre> complex_sys.statistics.plot.carrier_balance('heat') Out[7]: In\u00a0[8]: Copied! <pre>complex_sys.statistics.plot.carrier_balance('electricity')\n</pre> complex_sys.statistics.plot.carrier_balance('electricity') Out[8]: In\u00a0[9]: Copied! <pre># All flows\nsimple.statistics.plot.flows()\n</pre> # All flows simple.statistics.plot.flows() Out[9]: In\u00a0[10]: Copied! <pre># Flows filtered by component\nsimple.statistics.plot.flows(component='Boiler')\n</pre> # Flows filtered by component simple.statistics.plot.flows(component='Boiler') Out[10]: In\u00a0[11]: Copied! <pre>simple.statistics.plot.storage('ThermalStorage')\n</pre> simple.statistics.plot.storage('ThermalStorage') Out[11]: In\u00a0[12]: Copied! <pre>simple.statistics.plot.charge_states('ThermalStorage')\n</pre> simple.statistics.plot.charge_states('ThermalStorage') Out[12]: In\u00a0[13]: Copied! <pre>multiperiod.statistics.plot.sizes()\n</pre> multiperiod.statistics.plot.sizes() Out[13]: In\u00a0[14]: Copied! <pre>simple.statistics.plot.effects(effect='costs')\n</pre> simple.statistics.plot.effects(effect='costs') Out[14]: In\u00a0[15]: Copied! <pre># Multi-effect system: compare costs and CO2\ncomplex_sys.statistics.plot.effects(effect='costs')\n</pre> # Multi-effect system: compare costs and CO2 complex_sys.statistics.plot.effects(effect='costs') Out[15]: In\u00a0[16]: Copied! <pre>complex_sys.statistics.plot.effects(effect='CO2')\n</pre> complex_sys.statistics.plot.effects(effect='CO2') Out[16]: In\u00a0[17]: Copied! <pre>simple.statistics.plot.duration_curve('Boiler(Heat)')\n</pre> simple.statistics.plot.duration_curve('Boiler(Heat)') Out[17]: In\u00a0[18]: Copied! <pre># Multiple variables\ncomplex_sys.statistics.plot.duration_curve(['CHP(Heat)', 'HeatPump(Heat)', 'BackupBoiler(Heat)'])\n</pre> # Multiple variables complex_sys.statistics.plot.duration_curve(['CHP(Heat)', 'HeatPump(Heat)', 'BackupBoiler(Heat)']) Out[18]: In\u00a0[19]: Copied! <pre># Auto-reshape based on data frequency\nsimple.statistics.plot.heatmap('Boiler(Heat)')\n</pre> # Auto-reshape based on data frequency simple.statistics.plot.heatmap('Boiler(Heat)') Out[19]: In\u00a0[20]: Copied! <pre># Storage charge state heatmap\nsimple.statistics.plot.heatmap('ThermalStorage')\n</pre> # Storage charge state heatmap simple.statistics.plot.heatmap('ThermalStorage') Out[20]: In\u00a0[21]: Copied! <pre># Custom colorscale\nsimple.statistics.plot.heatmap('Office(Heat)', color_continuous_scale='Blues', title='Heat Demand Pattern')\n</pre> # Custom colorscale simple.statistics.plot.heatmap('Office(Heat)', color_continuous_scale='Blues', title='Heat Demand Pattern') Out[21]: In\u00a0[22]: Copied! <pre>simple.statistics.plot.sankey.flows()\n</pre> simple.statistics.plot.sankey.flows() Out[22]: In\u00a0[23]: Copied! <pre># Complex system with multiple carriers\ncomplex_sys.statistics.plot.sankey.flows()\n</pre> # Complex system with multiple carriers complex_sys.statistics.plot.sankey.flows() Out[23]: In\u00a0[24]: Copied! <pre>multiperiod.statistics.plot.sankey.sizes()\n</pre> multiperiod.statistics.plot.sankey.sizes() Out[24]: In\u00a0[25]: Copied! <pre>simple.statistics.plot.sankey.peak_flow()\n</pre> simple.statistics.plot.sankey.peak_flow() Out[25]: In\u00a0[26]: Copied! <pre>simple.statistics.plot.sankey.effects(select={'effect': 'costs'})\n</pre> simple.statistics.plot.sankey.effects(select={'effect': 'costs'}) Out[26]: In\u00a0[27]: Copied! <pre># CO2 allocation in complex system\ncomplex_sys.statistics.plot.sankey.effects(select={'effect': 'CO2'})\n</pre> # CO2 allocation in complex system complex_sys.statistics.plot.sankey.effects(select={'effect': 'CO2'}) Out[27]: In\u00a0[28]: Copied! <pre># Only heat flows\ncomplex_sys.statistics.plot.sankey.flows(select={'bus': 'Heat'})\n</pre> # Only heat flows complex_sys.statistics.plot.sankey.flows(select={'bus': 'Heat'}) Out[28]: In\u00a0[29]: Copied! <pre>simple.topology.plot()\n</pre> simple.topology.plot() Out[29]: In\u00a0[30]: Copied! <pre>complex_sys.topology.plot(title='Complex System Topology')\n</pre> complex_sys.topology.plot(title='Complex System Topology') Out[30]: In\u00a0[31]: Copied! <pre>nodes, edges = simple.topology.infos()\n\nprint('Nodes:')\nfor label, info in nodes.items():\n    print(f'  {label}: {info[\"class\"]}')\n\nprint('\\nEdges (flows):')\nfor label, info in edges.items():\n    print(f'  {info[\"start\"]} -&gt; {info[\"end\"]}: {label}')\n</pre> nodes, edges = simple.topology.infos()  print('Nodes:') for label, info in nodes.items():     print(f'  {label}: {info[\"class\"]}')  print('\\nEdges (flows):') for label, info in edges.items():     print(f'  {info[\"start\"]} -&gt; {info[\"end\"]}: {label}') <pre>Nodes:\n  GasGrid: Component\n  Boiler: Component\n  ThermalStorage: Component\n  Office: Component\n  Gas: Bus\n  Heat: Bus\n\nEdges (flows):\n  Gas -&gt; Boiler: Boiler(Gas)\n  Boiler -&gt; Heat: Boiler(Heat)\n  GasGrid -&gt; Gas: GasGrid(Gas)\n  Heat -&gt; Office: Office(Heat)\n  Heat -&gt; ThermalStorage: ThermalStorage(Charge)\n  ThermalStorage -&gt; Heat: ThermalStorage(Discharge)\n</pre> In\u00a0[32]: Copied! <pre>print('Multiperiod system dimensions:')\nprint(f'  Periods: {list(multiperiod.periods)}')\nprint(f'  Scenarios: {list(multiperiod.scenarios)}')\nprint(f'  Solution dims: {dict(multiperiod.solution.sizes)}')\n</pre> print('Multiperiod system dimensions:') print(f'  Periods: {list(multiperiod.periods)}') print(f'  Scenarios: {list(multiperiod.scenarios)}') print(f'  Solution dims: {dict(multiperiod.solution.sizes)}') <pre>Multiperiod system dimensions:\n  Periods: [2024, 2025, 2026]\n  Scenarios: ['high_demand', 'low_demand']\n  Solution dims: {'period': 3, 'scenario': 2, 'time': 337}\n</pre> In\u00a0[33]: Copied! <pre># Balance plot with faceting by scenario\nmultiperiod.statistics.plot.balance('Heat')\n</pre> # Balance plot with faceting by scenario multiperiod.statistics.plot.balance('Heat') Out[33]: In\u00a0[34]: Copied! <pre># Filter to specific scenario/period\nmultiperiod.statistics.plot.balance('Heat', select={'scenario': 'high_demand', 'period': 2024})\n</pre> # Filter to specific scenario/period multiperiod.statistics.plot.balance('Heat', select={'scenario': 'high_demand', 'period': 2024}) Out[34]: In\u00a0[35]: Copied! <pre># Sankey aggregates across all dimensions by default\nmultiperiod.statistics.plot.sankey.flows()\n</pre> # Sankey aggregates across all dimensions by default multiperiod.statistics.plot.sankey.flows() Out[35]: In\u00a0[36]: Copied! <pre># Using a colorscale name\nsimple.statistics.plot.balance('Heat', colors='Set2')\n</pre> # Using a colorscale name simple.statistics.plot.balance('Heat', colors='Set2') Out[36]: In\u00a0[37]: Copied! <pre># Using a list of colors\nsimple.statistics.plot.balance('Heat', colors=['#e41a1c', '#377eb8', '#4daf4a', '#984ea3'])\n</pre> # Using a list of colors simple.statistics.plot.balance('Heat', colors=['#e41a1c', '#377eb8', '#4daf4a', '#984ea3']) Out[37]: In\u00a0[38]: Copied! <pre># Using a dictionary for specific labels\nsimple.statistics.plot.balance(\n    'Heat',\n    colors={\n        'Boiler(Heat)': 'orangered',\n        'ThermalStorage(Charge)': 'steelblue',\n        'ThermalStorage(Discharge)': 'lightblue',\n        'Office(Heat)': 'forestgreen',\n    },\n)\n</pre> # Using a dictionary for specific labels simple.statistics.plot.balance(     'Heat',     colors={         'Boiler(Heat)': 'orangered',         'ThermalStorage(Charge)': 'steelblue',         'ThermalStorage(Discharge)': 'lightblue',         'Office(Heat)': 'forestgreen',     }, ) Out[38]: In\u00a0[39]: Copied! <pre># Get plot result\nresult = simple.statistics.plot.balance('Heat')\n\nprint('PlotResult contains:')\nprint(f'  data: {type(result.data).__name__} with vars {list(result.data.data_vars)}')\nprint(f'  figure: {type(result.figure).__name__}')\n</pre> # Get plot result result = simple.statistics.plot.balance('Heat')  print('PlotResult contains:') print(f'  data: {type(result.data).__name__} with vars {list(result.data.data_vars)}') print(f'  figure: {type(result.figure).__name__}') <pre>PlotResult contains:\n  data: Dataset with vars ['Boiler(Heat)', 'Office(Heat)', 'ThermalStorage(Charge)', 'ThermalStorage(Discharge)']\n  figure: Figure\n</pre> In\u00a0[40]: Copied! <pre># Export data to pandas DataFrame\ndf = result.data.to_dataframe()\ndf.head()\n</pre> # Export data to pandas DataFrame df = result.data.to_dataframe() df.head() Out[40]: Boiler(Heat) Office(Heat) ThermalStorage(Charge) ThermalStorage(Discharge) time 2020-01-15 00:00:00 -0.000000 74.814983 0.0 -74.814983 2020-01-15 01:00:00 -75.497186 75.497186 -0.0 0.000000 2020-01-15 02:00:00 -0.000000 75.724587 0.0 -75.724587 2020-01-15 03:00:00 -88.004250 88.004250 0.0 -0.000000 2020-01-15 04:00:00 -104.149733 104.149733 0.0 0.000000 In\u00a0[41]: Copied! <pre># Export figure to HTML (interactive)\n# result.figure.write_html('balance_plot.html')\n\n# Export figure to image\n# result.figure.write_image('balance_plot.png', scale=2)\n</pre> # Export figure to HTML (interactive) # result.figure.write_html('balance_plot.html')  # Export figure to image # result.figure.write_image('balance_plot.png', scale=2)"},{"location":"notebooks/09-plotting-and-data-access/#plotting","title":"Plotting\u00b6","text":"<p>Access optimization results and create visualizations.</p> <p>This notebook covers:</p> <ul> <li>Accessing data (flow rates, sizes, effects, charge states)</li> <li>Time series plots (balance, flows, storage)</li> <li>Aggregated plots (sizes, effects, duration curves)</li> <li>Heatmaps with time reshaping</li> <li>Sankey diagrams</li> <li>Topology visualization</li> <li>Color customization and export</li> </ul>"},{"location":"notebooks/09-plotting-and-data-access/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/09-plotting-and-data-access/#generate-example-systems","title":"Generate Example Systems\u00b6","text":"<p>First, create three example FlowSystems with solutions:</p>"},{"location":"notebooks/09-plotting-and-data-access/#2-quick-overview-balance-plot","title":"2. Quick Overview: Balance Plot\u00b6","text":"<p>Let's start with the most common visualization - a balance plot showing energy flows:</p>"},{"location":"notebooks/09-plotting-and-data-access/#accessing-plot-data","title":"Accessing Plot Data\u00b6","text":"<p>Every plot returns a <code>PlotResult</code> with both the figure and underlying data. Use <code>.data.to_dataframe()</code> to get a pandas DataFrame:</p>"},{"location":"notebooks/09-plotting-and-data-access/#energy-totals","title":"Energy Totals\u00b6","text":"<p>Get total energy by flow using <code>flow_hours</code>:</p>"},{"location":"notebooks/09-plotting-and-data-access/#3-time-series-plots","title":"3. Time Series Plots\u00b6","text":""},{"location":"notebooks/09-plotting-and-data-access/#31-balance-plot","title":"3.1 Balance Plot\u00b6","text":"<p>Shows inflows (positive) and outflows (negative) for a bus or component:</p>"},{"location":"notebooks/09-plotting-and-data-access/#32-carrier-balance","title":"3.2 Carrier Balance\u00b6","text":"<p>Shows all flows of a specific carrier across the entire system:</p>"},{"location":"notebooks/09-plotting-and-data-access/#33-flow-rates","title":"3.3 Flow Rates\u00b6","text":"<p>Plot multiple flow rates together:</p>"},{"location":"notebooks/09-plotting-and-data-access/#34-storage-plot","title":"3.4 Storage Plot\u00b6","text":"<p>Combined view of storage charge state and flows:</p>"},{"location":"notebooks/09-plotting-and-data-access/#35-charge-states-plot","title":"3.5 Charge States Plot\u00b6","text":"<p>Plot charge state time series directly:</p>"},{"location":"notebooks/09-plotting-and-data-access/#4-aggregated-plots","title":"4. Aggregated Plots\u00b6","text":""},{"location":"notebooks/09-plotting-and-data-access/#41-sizes-plot","title":"4.1 Sizes Plot\u00b6","text":"<p>Bar chart of component/flow sizes:</p>"},{"location":"notebooks/09-plotting-and-data-access/#42-effects-plot","title":"4.2 Effects Plot\u00b6","text":"<p>Bar chart of effect totals by component:</p>"},{"location":"notebooks/09-plotting-and-data-access/#43-duration-curve","title":"4.3 Duration Curve\u00b6","text":"<p>Shows how often each power level is reached:</p>"},{"location":"notebooks/09-plotting-and-data-access/#5-heatmaps","title":"5. Heatmaps\u00b6","text":"<p>Heatmaps reshape time series into 2D grids (e.g., hour-of-day vs day):</p>"},{"location":"notebooks/09-plotting-and-data-access/#6-sankey-diagrams","title":"6. Sankey Diagrams\u00b6","text":"<p>Sankey diagrams visualize energy flows through the system.</p>"},{"location":"notebooks/09-plotting-and-data-access/#61-flow-sankey","title":"6.1 Flow Sankey\u00b6","text":"<p>Total energy flows:</p>"},{"location":"notebooks/09-plotting-and-data-access/#62-sizes-sankey","title":"6.2 Sizes Sankey\u00b6","text":"<p>Capacity/size allocation:</p>"},{"location":"notebooks/09-plotting-and-data-access/#63-peak-flow-sankey","title":"6.3 Peak Flow Sankey\u00b6","text":"<p>Maximum flow rates (peak power):</p>"},{"location":"notebooks/09-plotting-and-data-access/#64-effects-sankey","title":"6.4 Effects Sankey\u00b6","text":"<p>Cost/emission allocation:</p>"},{"location":"notebooks/09-plotting-and-data-access/#65-filtering-with-select","title":"6.5 Filtering with <code>select</code>\u00b6","text":"<p>Filter Sankey to specific buses or carriers:</p>"},{"location":"notebooks/09-plotting-and-data-access/#7-topology-visualization","title":"7. Topology Visualization\u00b6","text":"<p>Visualize the system structure (no solution data required).</p>"},{"location":"notebooks/09-plotting-and-data-access/#71-topology-plot","title":"7.1 Topology Plot\u00b6","text":"<p>Sankey-style network diagram:</p>"},{"location":"notebooks/09-plotting-and-data-access/#72-topology-info","title":"7.2 Topology Info\u00b6","text":"<p>Get node and edge information programmatically:</p>"},{"location":"notebooks/09-plotting-and-data-access/#8-multi-periodscenario-data","title":"8. Multi-Period/Scenario Data\u00b6","text":"<p>Working with multi-dimensional results:</p>"},{"location":"notebooks/09-plotting-and-data-access/#9-color-customization","title":"9. Color Customization\u00b6","text":"<p>Colors can be customized in multiple ways:</p>"},{"location":"notebooks/09-plotting-and-data-access/#10-exporting-results","title":"10. Exporting Results\u00b6","text":"<p>Plots return a <code>PlotResult</code> with data and figure that can be exported:</p>"},{"location":"notebooks/09-plotting-and-data-access/#summary","title":"Summary\u00b6","text":""},{"location":"notebooks/09-plotting-and-data-access/#data-access","title":"Data Access\u00b6","text":"Property Description <code>statistics.flow_rates</code> Time series of flow rates (power) <code>statistics.flow_hours</code> Energy values (rate \u00d7 duration) <code>statistics.sizes</code> Component/flow capacities <code>statistics.charge_states</code> Storage charge levels <code>statistics.temporal_effects</code> Effects per timestep <code>statistics.periodic_effects</code> Effects per period <code>statistics.total_effects</code> Aggregated effect totals <code>topology.carrier_colors</code> Cached carrier color mapping <code>topology.component_colors</code> Cached component color mapping <code>topology.bus_colors</code> Cached bus color mapping"},{"location":"notebooks/09-plotting-and-data-access/#plot-methods","title":"Plot Methods\u00b6","text":"Method Description <code>plot.balance(node)</code> Stacked bar of in/outflows <code>plot.carrier_balance(carrier)</code> Balance for all flows of a carrier <code>plot.flows(variables)</code> Time series line/area plot <code>plot.storage(component)</code> Combined charge state and flows <code>plot.charge_states(component)</code> Charge state time series <code>plot.sizes()</code> Bar chart of sizes <code>plot.effects(effect)</code> Bar chart of effect contributions <code>plot.duration_curve(variables)</code> Sorted duration curve <code>plot.heatmap(variable)</code> 2D time-reshaped heatmap <code>plot.sankey.flows()</code> Energy flow Sankey <code>plot.sankey.sizes()</code> Capacity Sankey <code>plot.sankey.peak_flow()</code> Peak power Sankey <code>plot.sankey.effects(effect)</code> Effect allocation Sankey <code>topology.plot()</code> System structure diagram"},{"location":"notebooks/10-transmission/","title":"Transmission","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nimport plotly.express as px\nimport xarray as xr\n\nimport flixopt as fx\n\nfx.CONFIG.notebook()\n</pre> import numpy as np import pandas as pd import plotly.express as px import xarray as xr  import flixopt as fx  fx.CONFIG.notebook() Out[1]: <pre>flixopt.config.CONFIG</pre> In\u00a0[2]: Copied! <pre># One week simulation\ntimesteps = pd.date_range('2024-01-22', periods=168, freq='h')\nhours = np.arange(168)\nhour_of_day = hours % 24\n\n# Site A: Industrial facility with steady demand\ndemand_a_base = 150\ndemand_a_variation = 30 * np.sin(hour_of_day * np.pi / 12)  # Day/night cycle\ndemand_a = demand_a_base + demand_a_variation\n\n# Site B: Office building with peak during work hours\ndemand_b = np.where(\n    (hour_of_day &gt;= 8) &amp; (hour_of_day &lt;= 18),\n    180,  # Daytime: 180 kW\n    80,  # Nighttime: 80 kW\n)\n# Add weekly pattern (lower on weekends)\nday_of_week = (hours // 24) % 7\ndemand_b = np.where(day_of_week &gt;= 5, demand_b * 0.6, demand_b)  # Weekend reduction\n</pre> # One week simulation timesteps = pd.date_range('2024-01-22', periods=168, freq='h') hours = np.arange(168) hour_of_day = hours % 24  # Site A: Industrial facility with steady demand demand_a_base = 150 demand_a_variation = 30 * np.sin(hour_of_day * np.pi / 12)  # Day/night cycle demand_a = demand_a_base + demand_a_variation  # Site B: Office building with peak during work hours demand_b = np.where(     (hour_of_day &gt;= 8) &amp; (hour_of_day &lt;= 18),     180,  # Daytime: 180 kW     80,  # Nighttime: 80 kW ) # Add weekly pattern (lower on weekends) day_of_week = (hours // 24) % 7 demand_b = np.where(day_of_week &gt;= 5, demand_b * 0.6, demand_b)  # Weekend reduction In\u00a0[3]: Copied! <pre># Visualize demand profiles\nfig = px.line(\n    x=timesteps.tolist() * 2,\n    y=np.concatenate([demand_a, demand_b]),\n    color=['Site A (Industrial)'] * 168 + ['Site B (Office)'] * 168,\n    title='Heat Demand at Both Sites',\n    labels={'x': 'Time', 'y': 'Heat Demand [kW]', 'color': 'Site'},\n)\nfig\n</pre> # Visualize demand profiles fig = px.line(     x=timesteps.tolist() * 2,     y=np.concatenate([demand_a, demand_b]),     color=['Site A (Industrial)'] * 168 + ['Site B (Office)'] * 168,     title='Heat Demand at Both Sites',     labels={'x': 'Time', 'y': 'Heat Demand [kW]', 'color': 'Site'}, ) fig In\u00a0[4]: Copied! <pre>fs_unidirectional = fx.FlowSystem(timesteps)\nfs_unidirectional.add_carriers(\n    fx.Carrier('gas', '#3498db', 'kW'),\n    fx.Carrier('electricity', '#f1c40f', 'kW'),\n    fx.Carrier('heat', '#e74c3c', 'kW'),\n)\nfs_unidirectional.add_elements(\n    # === Buses (one per site) ===\n    fx.Bus('Heat_A', carrier='heat'),  # Site A heat network\n    fx.Bus('Heat_B', carrier='heat'),  # Site B heat network\n    fx.Bus('Gas', carrier='gas'),  # Gas supply network\n    fx.Bus('Electricity', carrier='electricity'),  # Electricity grid\n    # === Effect ===\n    fx.Effect('costs', '\u20ac', 'Operating Costs', is_standard=True, is_objective=True),\n    # === External supplies ===\n    fx.Source('GasSupply', outputs=[fx.Flow('Gas', bus='Gas', size=1000, effects_per_flow_hour=0.06)]),\n    fx.Source('ElecGrid', outputs=[fx.Flow('Elec', bus='Electricity', size=500, effects_per_flow_hour=0.25)]),\n    # === Site A: Large gas boiler (cheap) ===\n    fx.LinearConverter(\n        'GasBoiler_A',\n        inputs=[fx.Flow('Gas', bus='Gas', size=500)],\n        outputs=[fx.Flow('Heat', bus='Heat_A', size=400)],\n        conversion_factors=[{'Gas': 1, 'Heat': 0.92}],  # 92% efficiency\n    ),\n    # === Site B: Small electric boiler (expensive but flexible) ===\n    fx.LinearConverter(\n        'ElecBoiler_B',\n        inputs=[fx.Flow('Elec', bus='Electricity', size=250)],\n        outputs=[fx.Flow('Heat', bus='Heat_B', size=250)],\n        conversion_factors=[{'Elec': 1, 'Heat': 0.99}],  # 99% efficiency\n    ),\n    # === Transmission: A \u2192 B (unidirectional) ===\n    fx.Transmission(\n        'Pipe_A_to_B',\n        in1=fx.Flow('from_A', bus='Heat_A', size=200),  # Input from Site A\n        out1=fx.Flow('to_B', bus='Heat_B', size=200),  # Output to Site B\n        relative_losses=0.05,  # 5% heat loss in pipe\n    ),\n    # === Demands ===\n    fx.Sink('Demand_A', inputs=[fx.Flow('Heat', bus='Heat_A', size=1, fixed_relative_profile=demand_a)]),\n    fx.Sink('Demand_B', inputs=[fx.Flow('Heat', bus='Heat_B', size=1, fixed_relative_profile=demand_b)]),\n)\n\nfs_unidirectional.optimize(fx.solvers.HighsSolver());\n</pre> fs_unidirectional = fx.FlowSystem(timesteps) fs_unidirectional.add_carriers(     fx.Carrier('gas', '#3498db', 'kW'),     fx.Carrier('electricity', '#f1c40f', 'kW'),     fx.Carrier('heat', '#e74c3c', 'kW'), ) fs_unidirectional.add_elements(     # === Buses (one per site) ===     fx.Bus('Heat_A', carrier='heat'),  # Site A heat network     fx.Bus('Heat_B', carrier='heat'),  # Site B heat network     fx.Bus('Gas', carrier='gas'),  # Gas supply network     fx.Bus('Electricity', carrier='electricity'),  # Electricity grid     # === Effect ===     fx.Effect('costs', '\u20ac', 'Operating Costs', is_standard=True, is_objective=True),     # === External supplies ===     fx.Source('GasSupply', outputs=[fx.Flow('Gas', bus='Gas', size=1000, effects_per_flow_hour=0.06)]),     fx.Source('ElecGrid', outputs=[fx.Flow('Elec', bus='Electricity', size=500, effects_per_flow_hour=0.25)]),     # === Site A: Large gas boiler (cheap) ===     fx.LinearConverter(         'GasBoiler_A',         inputs=[fx.Flow('Gas', bus='Gas', size=500)],         outputs=[fx.Flow('Heat', bus='Heat_A', size=400)],         conversion_factors=[{'Gas': 1, 'Heat': 0.92}],  # 92% efficiency     ),     # === Site B: Small electric boiler (expensive but flexible) ===     fx.LinearConverter(         'ElecBoiler_B',         inputs=[fx.Flow('Elec', bus='Electricity', size=250)],         outputs=[fx.Flow('Heat', bus='Heat_B', size=250)],         conversion_factors=[{'Elec': 1, 'Heat': 0.99}],  # 99% efficiency     ),     # === Transmission: A \u2192 B (unidirectional) ===     fx.Transmission(         'Pipe_A_to_B',         in1=fx.Flow('from_A', bus='Heat_A', size=200),  # Input from Site A         out1=fx.Flow('to_B', bus='Heat_B', size=200),  # Output to Site B         relative_losses=0.05,  # 5% heat loss in pipe     ),     # === Demands ===     fx.Sink('Demand_A', inputs=[fx.Flow('Heat', bus='Heat_A', size=1, fixed_relative_profile=demand_a)]),     fx.Sink('Demand_B', inputs=[fx.Flow('Heat', bus='Heat_B', size=1, fixed_relative_profile=demand_b)]), )  fs_unidirectional.optimize(fx.solvers.HighsSolver()); In\u00a0[5]: Copied! <pre># View results\nprint(f'Total cost: {fs_unidirectional.solution[\"costs\"].item():.2f} \u20ac')\n</pre> # View results print(f'Total cost: {fs_unidirectional.solution[\"costs\"].item():.2f} \u20ac') <pre>Total cost: 2479.00 \u20ac\n</pre> In\u00a0[6]: Copied! <pre># Heat balance at Site A\nfs_unidirectional.statistics.plot.balance('Heat_A')\n</pre> # Heat balance at Site A fs_unidirectional.statistics.plot.balance('Heat_A') Out[6]: In\u00a0[7]: Copied! <pre># Heat balance at Site B\nfs_unidirectional.statistics.plot.balance('Heat_B')\n</pre> # Heat balance at Site B fs_unidirectional.statistics.plot.balance('Heat_B') Out[7]: In\u00a0[8]: Copied! <pre># Energy flow overview\nfs_unidirectional.statistics.plot.sankey.flows()\n</pre> # Energy flow overview fs_unidirectional.statistics.plot.sankey.flows() Out[8]: In\u00a0[9]: Copied! <pre># Add a heat pump at Site B (cheaper during certain hours)\n# Electricity price varies: cheap at night, expensive during day\nelec_price = np.where(\n    (hour_of_day &gt;= 22) | (hour_of_day &lt;= 6),\n    0.08,  # Night: 0.08 \u20ac/kWh\n    0.25,  # Day: 0.25 \u20ac/kWh\n)\n</pre> # Add a heat pump at Site B (cheaper during certain hours) # Electricity price varies: cheap at night, expensive during day elec_price = np.where(     (hour_of_day &gt;= 22) | (hour_of_day &lt;= 6),     0.08,  # Night: 0.08 \u20ac/kWh     0.25,  # Day: 0.25 \u20ac/kWh ) In\u00a0[10]: Copied! <pre>fs_bidirectional = fx.FlowSystem(timesteps)\nfs_bidirectional.add_carriers(\n    fx.Carrier('gas', '#3498db', 'kW'),\n    fx.Carrier('electricity', '#f1c40f', 'kW'),\n    fx.Carrier('heat', '#e74c3c', 'kW'),\n)\nfs_bidirectional.add_elements(\n    # === Buses ===\n    fx.Bus('Heat_A', carrier='heat'),\n    fx.Bus('Heat_B', carrier='heat'),\n    fx.Bus('Gas', carrier='gas'),\n    fx.Bus('Electricity', carrier='electricity'),\n    # === Effect ===\n    fx.Effect('costs', '\u20ac', 'Operating Costs', is_standard=True, is_objective=True),\n    # === External supplies ===\n    fx.Source('GasSupply', outputs=[fx.Flow('Gas', bus='Gas', size=1000, effects_per_flow_hour=0.06)]),\n    fx.Source('ElecGrid', outputs=[fx.Flow('Elec', bus='Electricity', size=500, effects_per_flow_hour=elec_price)]),\n    # === Site A: Gas boiler ===\n    fx.LinearConverter(\n        'GasBoiler_A',\n        inputs=[fx.Flow('Gas', bus='Gas', size=500)],\n        outputs=[fx.Flow('Heat', bus='Heat_A', size=400)],\n        conversion_factors=[{'Gas': 1, 'Heat': 0.92}],\n    ),\n    # === Site B: Heat pump (efficient with variable electricity price) ===\n    fx.LinearConverter(\n        'HeatPump_B',\n        inputs=[fx.Flow('Elec', bus='Electricity', size=100)],\n        outputs=[fx.Flow('Heat', bus='Heat_B', size=350)],\n        conversion_factors=[{'Elec': 1, 'Heat': 3.5}],  # COP = 3.5\n    ),\n    # === BIDIRECTIONAL Transmission ===\n    fx.Transmission(\n        'Pipe_AB',\n        # Direction 1: A \u2192 B\n        in1=fx.Flow('from_A', bus='Heat_A', size=200),\n        out1=fx.Flow('to_B', bus='Heat_B', size=200),\n        # Direction 2: B \u2192 A\n        in2=fx.Flow('from_B', bus='Heat_B', size=200),\n        out2=fx.Flow('to_A', bus='Heat_A', size=200),\n        relative_losses=0.05,\n        prevent_simultaneous_flows_in_both_directions=True,  # Can't flow both ways at once\n    ),\n    # === Demands ===\n    fx.Sink('Demand_A', inputs=[fx.Flow('Heat', bus='Heat_A', size=1, fixed_relative_profile=demand_a)]),\n    fx.Sink('Demand_B', inputs=[fx.Flow('Heat', bus='Heat_B', size=1, fixed_relative_profile=demand_b)]),\n)\n\nfs_bidirectional.optimize(fx.solvers.HighsSolver());\n</pre> fs_bidirectional = fx.FlowSystem(timesteps) fs_bidirectional.add_carriers(     fx.Carrier('gas', '#3498db', 'kW'),     fx.Carrier('electricity', '#f1c40f', 'kW'),     fx.Carrier('heat', '#e74c3c', 'kW'), ) fs_bidirectional.add_elements(     # === Buses ===     fx.Bus('Heat_A', carrier='heat'),     fx.Bus('Heat_B', carrier='heat'),     fx.Bus('Gas', carrier='gas'),     fx.Bus('Electricity', carrier='electricity'),     # === Effect ===     fx.Effect('costs', '\u20ac', 'Operating Costs', is_standard=True, is_objective=True),     # === External supplies ===     fx.Source('GasSupply', outputs=[fx.Flow('Gas', bus='Gas', size=1000, effects_per_flow_hour=0.06)]),     fx.Source('ElecGrid', outputs=[fx.Flow('Elec', bus='Electricity', size=500, effects_per_flow_hour=elec_price)]),     # === Site A: Gas boiler ===     fx.LinearConverter(         'GasBoiler_A',         inputs=[fx.Flow('Gas', bus='Gas', size=500)],         outputs=[fx.Flow('Heat', bus='Heat_A', size=400)],         conversion_factors=[{'Gas': 1, 'Heat': 0.92}],     ),     # === Site B: Heat pump (efficient with variable electricity price) ===     fx.LinearConverter(         'HeatPump_B',         inputs=[fx.Flow('Elec', bus='Electricity', size=100)],         outputs=[fx.Flow('Heat', bus='Heat_B', size=350)],         conversion_factors=[{'Elec': 1, 'Heat': 3.5}],  # COP = 3.5     ),     # === BIDIRECTIONAL Transmission ===     fx.Transmission(         'Pipe_AB',         # Direction 1: A \u2192 B         in1=fx.Flow('from_A', bus='Heat_A', size=200),         out1=fx.Flow('to_B', bus='Heat_B', size=200),         # Direction 2: B \u2192 A         in2=fx.Flow('from_B', bus='Heat_B', size=200),         out2=fx.Flow('to_A', bus='Heat_A', size=200),         relative_losses=0.05,         prevent_simultaneous_flows_in_both_directions=True,  # Can't flow both ways at once     ),     # === Demands ===     fx.Sink('Demand_A', inputs=[fx.Flow('Heat', bus='Heat_A', size=1, fixed_relative_profile=demand_a)]),     fx.Sink('Demand_B', inputs=[fx.Flow('Heat', bus='Heat_B', size=1, fixed_relative_profile=demand_b)]), )  fs_bidirectional.optimize(fx.solvers.HighsSolver()); In\u00a0[11]: Copied! <pre># Compare costs\nprint(f'Unidirectional cost: {fs_unidirectional.solution[\"costs\"].item():.2f} \u20ac')\nprint(f'Bidirectional cost:  {fs_bidirectional.solution[\"costs\"].item():.2f} \u20ac')\nsavings = fs_unidirectional.solution['costs'].item() - fs_bidirectional.solution['costs'].item()\nprint(f'Savings from bidirectional: {savings:.2f} \u20ac')\n</pre> # Compare costs print(f'Unidirectional cost: {fs_unidirectional.solution[\"costs\"].item():.2f} \u20ac') print(f'Bidirectional cost:  {fs_bidirectional.solution[\"costs\"].item():.2f} \u20ac') savings = fs_unidirectional.solution['costs'].item() - fs_bidirectional.solution['costs'].item() print(f'Savings from bidirectional: {savings:.2f} \u20ac') <pre>Unidirectional cost: 2479.00 \u20ac\nBidirectional cost:  2479.00 \u20ac\nSavings from bidirectional: 0.00 \u20ac\n</pre> In\u00a0[12]: Copied! <pre># Visualize transmission flows in both directions using xarray\nflow_data = xr.Dataset(\n    {\n        'A_to_B': fs_bidirectional.solution['Pipe_AB(from_A)|flow_rate'],\n        'B_to_A': fs_bidirectional.solution['Pipe_AB(from_B)|flow_rate'],\n    }\n)\n\nfig = px.line(\n    x=list(flow_data['time'].values) * 2,\n    y=np.concatenate([flow_data['A_to_B'].values, flow_data['B_to_A'].values]),\n    color=['A \u2192 B'] * len(flow_data['time']) + ['B \u2192 A'] * len(flow_data['time']),\n    title='Transmission Flow Direction Over Time',\n    labels={'x': 'Time', 'y': 'Flow Rate [kW]', 'color': 'Direction'},\n)\nfig\n</pre> # Visualize transmission flows in both directions using xarray flow_data = xr.Dataset(     {         'A_to_B': fs_bidirectional.solution['Pipe_AB(from_A)|flow_rate'],         'B_to_A': fs_bidirectional.solution['Pipe_AB(from_B)|flow_rate'],     } )  fig = px.line(     x=list(flow_data['time'].values) * 2,     y=np.concatenate([flow_data['A_to_B'].values, flow_data['B_to_A'].values]),     color=['A \u2192 B'] * len(flow_data['time']) + ['B \u2192 A'] * len(flow_data['time']),     title='Transmission Flow Direction Over Time',     labels={'x': 'Time', 'y': 'Flow Rate [kW]', 'color': 'Direction'}, ) fig In\u00a0[13]: Copied! <pre># Heat balance at Site B showing bidirectional flows\nfs_bidirectional.statistics.plot.balance('Heat_B')\n</pre> # Heat balance at Site B showing bidirectional flows fs_bidirectional.statistics.plot.balance('Heat_B') Out[13]: In\u00a0[14]: Copied! <pre># Energy flow overview\nfs_bidirectional.statistics.plot.sankey.flows()\n</pre> # Energy flow overview fs_bidirectional.statistics.plot.sankey.flows() Out[14]: In\u00a0[15]: Copied! <pre># Daily amortized pipe cost (simplified)\nPIPE_COST_PER_KW = 0.05  # \u20ac/kW/day capacity cost\n\nfs_invest = fx.FlowSystem(timesteps)\nfs_invest.add_carriers(\n    fx.Carrier('gas', '#3498db', 'kW'),\n    fx.Carrier('electricity', '#f1c40f', 'kW'),\n    fx.Carrier('heat', '#e74c3c', 'kW'),\n)\nfs_invest.add_elements(\n    # === Buses ===\n    fx.Bus('Heat_A', carrier='heat'),\n    fx.Bus('Heat_B', carrier='heat'),\n    fx.Bus('Gas', carrier='gas'),\n    fx.Bus('Electricity', carrier='electricity'),\n    # === Effect ===\n    fx.Effect('costs', '\u20ac', 'Operating Costs', is_standard=True, is_objective=True),\n    # === External supplies ===\n    fx.Source('GasSupply', outputs=[fx.Flow('Gas', bus='Gas', size=1000, effects_per_flow_hour=0.06)]),\n    fx.Source('ElecGrid', outputs=[fx.Flow('Elec', bus='Electricity', size=500, effects_per_flow_hour=elec_price)]),\n    # === Site A: Gas boiler ===\n    fx.LinearConverter(\n        'GasBoiler_A',\n        inputs=[fx.Flow('Gas', bus='Gas', size=500)],\n        outputs=[fx.Flow('Heat', bus='Heat_A', size=400)],\n        conversion_factors=[{'Gas': 1, 'Heat': 0.92}],\n    ),\n    # === Site B: Heat pump ===\n    fx.LinearConverter(\n        'HeatPump_B',\n        inputs=[fx.Flow('Elec', bus='Electricity', size=100)],\n        outputs=[fx.Flow('Heat', bus='Heat_B', size=350)],\n        conversion_factors=[{'Elec': 1, 'Heat': 3.5}],\n    ),\n    # === Site B: Backup electric boiler ===\n    fx.LinearConverter(\n        'ElecBoiler_B',\n        inputs=[fx.Flow('Elec', bus='Electricity', size=200)],\n        outputs=[fx.Flow('Heat', bus='Heat_B', size=200)],\n        conversion_factors=[{'Elec': 1, 'Heat': 0.99}],\n    ),\n    # === Transmission with INVESTMENT OPTIMIZATION ===\n    # Investment parameters are passed via 'size' parameter\n    fx.Transmission(\n        'Pipe_AB',\n        in1=fx.Flow(\n            'from_A',\n            bus='Heat_A',\n            size=fx.InvestParameters(\n                effects_of_investment_per_size={'costs': PIPE_COST_PER_KW * 7},  # Weekly cost\n                minimum_size=0,\n                maximum_size=300,\n            ),\n        ),\n        out1=fx.Flow('to_B', bus='Heat_B'),\n        in2=fx.Flow(\n            'from_B',\n            bus='Heat_B',\n            size=fx.InvestParameters(\n                effects_of_investment_per_size={'costs': PIPE_COST_PER_KW * 7},\n                minimum_size=0,\n                maximum_size=300,\n            ),\n        ),\n        out2=fx.Flow('to_A', bus='Heat_A'),\n        relative_losses=0.05,\n        balanced=True,  # Same capacity in both directions\n        prevent_simultaneous_flows_in_both_directions=True,\n    ),\n    # === Demands ===\n    fx.Sink('Demand_A', inputs=[fx.Flow('Heat', bus='Heat_A', size=1, fixed_relative_profile=demand_a)]),\n    fx.Sink('Demand_B', inputs=[fx.Flow('Heat', bus='Heat_B', size=1, fixed_relative_profile=demand_b)]),\n)\n\nfs_invest.optimize(fx.solvers.HighsSolver());\n</pre> # Daily amortized pipe cost (simplified) PIPE_COST_PER_KW = 0.05  # \u20ac/kW/day capacity cost  fs_invest = fx.FlowSystem(timesteps) fs_invest.add_carriers(     fx.Carrier('gas', '#3498db', 'kW'),     fx.Carrier('electricity', '#f1c40f', 'kW'),     fx.Carrier('heat', '#e74c3c', 'kW'), ) fs_invest.add_elements(     # === Buses ===     fx.Bus('Heat_A', carrier='heat'),     fx.Bus('Heat_B', carrier='heat'),     fx.Bus('Gas', carrier='gas'),     fx.Bus('Electricity', carrier='electricity'),     # === Effect ===     fx.Effect('costs', '\u20ac', 'Operating Costs', is_standard=True, is_objective=True),     # === External supplies ===     fx.Source('GasSupply', outputs=[fx.Flow('Gas', bus='Gas', size=1000, effects_per_flow_hour=0.06)]),     fx.Source('ElecGrid', outputs=[fx.Flow('Elec', bus='Electricity', size=500, effects_per_flow_hour=elec_price)]),     # === Site A: Gas boiler ===     fx.LinearConverter(         'GasBoiler_A',         inputs=[fx.Flow('Gas', bus='Gas', size=500)],         outputs=[fx.Flow('Heat', bus='Heat_A', size=400)],         conversion_factors=[{'Gas': 1, 'Heat': 0.92}],     ),     # === Site B: Heat pump ===     fx.LinearConverter(         'HeatPump_B',         inputs=[fx.Flow('Elec', bus='Electricity', size=100)],         outputs=[fx.Flow('Heat', bus='Heat_B', size=350)],         conversion_factors=[{'Elec': 1, 'Heat': 3.5}],     ),     # === Site B: Backup electric boiler ===     fx.LinearConverter(         'ElecBoiler_B',         inputs=[fx.Flow('Elec', bus='Electricity', size=200)],         outputs=[fx.Flow('Heat', bus='Heat_B', size=200)],         conversion_factors=[{'Elec': 1, 'Heat': 0.99}],     ),     # === Transmission with INVESTMENT OPTIMIZATION ===     # Investment parameters are passed via 'size' parameter     fx.Transmission(         'Pipe_AB',         in1=fx.Flow(             'from_A',             bus='Heat_A',             size=fx.InvestParameters(                 effects_of_investment_per_size={'costs': PIPE_COST_PER_KW * 7},  # Weekly cost                 minimum_size=0,                 maximum_size=300,             ),         ),         out1=fx.Flow('to_B', bus='Heat_B'),         in2=fx.Flow(             'from_B',             bus='Heat_B',             size=fx.InvestParameters(                 effects_of_investment_per_size={'costs': PIPE_COST_PER_KW * 7},                 minimum_size=0,                 maximum_size=300,             ),         ),         out2=fx.Flow('to_A', bus='Heat_A'),         relative_losses=0.05,         balanced=True,  # Same capacity in both directions         prevent_simultaneous_flows_in_both_directions=True,     ),     # === Demands ===     fx.Sink('Demand_A', inputs=[fx.Flow('Heat', bus='Heat_A', size=1, fixed_relative_profile=demand_a)]),     fx.Sink('Demand_B', inputs=[fx.Flow('Heat', bus='Heat_B', size=1, fixed_relative_profile=demand_b)]), )  fs_invest.optimize(fx.solvers.HighsSolver()); In\u00a0[16]: Copied! <pre># Results\noptimal_capacity = fs_invest.solution['Pipe_AB(from_A)|size'].item()\ntotal_cost = fs_invest.solution['costs'].item()\n\nprint(f'Optimal pipe capacity: {optimal_capacity:.1f} kW')\nprint(f'Total cost: {total_cost:.2f} \u20ac')\n</pre> # Results optimal_capacity = fs_invest.solution['Pipe_AB(from_A)|size'].item() total_cost = fs_invest.solution['costs'].item()  print(f'Optimal pipe capacity: {optimal_capacity:.1f} kW') print(f'Total cost: {total_cost:.2f} \u20ac') <pre>Optimal pipe capacity: 189.5 kW\nTotal cost: 2611.63 \u20ac\n</pre> In\u00a0[17]: Copied! <pre># Effect breakdown by component\nfs_invest.statistics.plot.effects()\n</pre> # Effect breakdown by component fs_invest.statistics.plot.effects() Out[17]: In\u00a0[18]: Copied! <pre># Energy flows\nfs_invest.statistics.plot.sankey.flows()\n</pre> # Energy flows fs_invest.statistics.plot.sankey.flows() Out[18]:"},{"location":"notebooks/10-transmission/#transmission","title":"Transmission\u00b6","text":"<p>Model energy or material transport between locations with losses.</p> <p>This notebook covers:</p> <ul> <li>Transmission component: Connecting sites with pipelines, cables, or conveyors</li> <li>Transmission losses: Relative losses (proportional) and absolute losses (fixed)</li> <li>Bidirectional flow: Two-way transmission with flow direction constraints</li> <li>Capacity optimization: Sizing transmission infrastructure</li> </ul>"},{"location":"notebooks/10-transmission/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/10-transmission/#the-problem-connecting-two-sites","title":"The Problem: Connecting Two Sites\u00b6","text":"<p>Consider a district heating network with two sites:</p> <ul> <li>Site A: Has a large gas boiler (cheap production)</li> <li>Site B: Has a smaller electric boiler (expensive, but flexible)</li> </ul> <p>A district heating pipe connects both sites. The question: How should heat flow between sites to minimize total costs?</p>"},{"location":"notebooks/10-transmission/#transmission-characteristics","title":"Transmission Characteristics\u00b6","text":"Parameter Value Description Relative losses 5% Heat loss proportional to flow (pipe heat loss) Capacity 200 kW Maximum transmission rate Bidirectional Yes Heat can flow A\u2192B or B\u2192A"},{"location":"notebooks/10-transmission/#define-time-series-data","title":"Define Time Series Data\u00b6","text":""},{"location":"notebooks/10-transmission/#example-1-unidirectional-transmission","title":"Example 1: Unidirectional Transmission\u00b6","text":"<p>Start with a simple case: heat flows only from Site A to Site B.</p>"},{"location":"notebooks/10-transmission/#observations","title":"Observations\u00b6","text":"<ul> <li>The optimizer uses the cheaper gas boiler at Site A as much as possible</li> <li>Heat is transmitted to Site B (despite 5% losses) because gas is much cheaper than electricity</li> <li>The electric boiler at Site B only runs when transmission capacity is insufficient</li> </ul>"},{"location":"notebooks/10-transmission/#example-2-bidirectional-transmission","title":"Example 2: Bidirectional Transmission\u00b6","text":"<p>Now allow heat to flow in both directions. This is useful when:</p> <ul> <li>Both sites have generation capacity</li> <li>Demand patterns differ between sites</li> <li>Prices or availability vary over time</li> </ul>"},{"location":"notebooks/10-transmission/#observations","title":"Observations\u00b6","text":"<ul> <li>During cheap electricity hours (night): Heat pump at Site B produces heat, some flows to Site A</li> <li>During expensive electricity hours (day): Gas boiler at Site A supplies both sites</li> <li>The bidirectional transmission enables load shifting and arbitrage between sites</li> </ul>"},{"location":"notebooks/10-transmission/#example-3-transmission-capacity-optimization","title":"Example 3: Transmission Capacity Optimization\u00b6","text":"<p>What's the optimal pipe capacity? Let the optimizer decide.</p>"},{"location":"notebooks/10-transmission/#key-concepts","title":"Key Concepts\u00b6","text":""},{"location":"notebooks/10-transmission/#transmission-component-structure","title":"Transmission Component Structure\u00b6","text":"<pre>fx.Transmission(\n    label='pipe_name',\n    # Direction 1: A \u2192 B\n    in1=fx.Flow('from_A', bus='Bus_A', size=100),\n    out1=fx.Flow('to_B', bus='Bus_B', size=100),\n    # Direction 2: B \u2192 A (optional - omit for unidirectional)\n    in2=fx.Flow('from_B', bus='Bus_B', size=100),\n    out2=fx.Flow('to_A', bus='Bus_A', size=100),\n    # Loss parameters\n    relative_losses=0.05,  # 5% proportional loss\n    absolute_losses=10,    # 10 kW fixed loss when active (optional)\n    # Operational constraints\n    prevent_simultaneous_flows_in_both_directions=True,\n    balanced=True,  # Same capacity both directions (needs InvestParameters)\n)\n</pre>"},{"location":"notebooks/10-transmission/#loss-types","title":"Loss Types\u00b6","text":"Loss Type Formula Use Case Relative <code>out = in \u00d7 (1 - loss)</code> Heat pipes, electrical lines Absolute <code>out = in - loss</code> (when active) Pump energy, standby losses"},{"location":"notebooks/10-transmission/#bidirectional-vs-unidirectional","title":"Bidirectional vs Unidirectional\u00b6","text":"Configuration Parameters Use Case Unidirectional <code>in1</code>, <code>out1</code> only One-way pipelines, conveyors Bidirectional <code>in1</code>, <code>out1</code>, <code>in2</code>, <code>out2</code> Power lines, reversible pipes"},{"location":"notebooks/10-transmission/#investment-optimization","title":"Investment Optimization\u00b6","text":"<p>Use <code>InvestParameters</code> as the <code>size</code> parameter for capacity optimization:</p> <pre>in1=fx.Flow(\n    'from_A', \n    bus='Bus_A',\n    size=fx.InvestParameters(  # Pass InvestParameters as size\n        effects_of_investment_per_size={'costs': cost_per_kw},\n        minimum_size=0,\n        maximum_size=500,\n    ),\n)\n</pre>"},{"location":"notebooks/10-transmission/#common-use-cases","title":"Common Use Cases\u00b6","text":"Application Typical Losses Notes District heating pipe 2-10% relative Temperature-dependent High voltage line 1-5% relative Distance-dependent Natural gas pipeline 0.5-2% relative Compressor energy as absolute loss Conveyor belt Fixed absolute Motor energy consumption Hydrogen pipeline 1-3% relative Compression losses"},{"location":"notebooks/10-transmission/#summary","title":"Summary\u00b6","text":"<p>You learned how to:</p> <ul> <li>Create unidirectional transmission between two buses</li> <li>Model bidirectional transmission with flow direction constraints</li> <li>Apply relative and absolute losses to transmission</li> <li>Optimize transmission capacity using InvestParameters</li> <li>Analyze multi-site energy systems with interconnections</li> </ul>"},{"location":"notebooks/10-transmission/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>07-scenarios-and-periods: Multi-year planning with uncertainty</li> <li>08a-Aggregation: Speed up large problems with time series aggregation</li> <li>08b-Rolling Horizon: Decompose large problems into sequential segments</li> </ul>"},{"location":"notebooks/data/raw/","title":"Bundled Data Sources","text":""},{"location":"notebooks/data/raw/#weather-data-tmy","title":"Weather Data (TMY)","text":"<p>File: <code>tmy_dresden.csv</code> Location: Dresden, Germany (51.05\u00b0N, 13.74\u00b0E) Source: PVGIS - Photovoltaic Geographical Information System Provider: European Commission Joint Research Centre License: Free for any use URL: https://re.jrc.ec.europa.eu/pvg_tools/en/</p> <p>Columns: - <code>temperature_C</code>: 2m air temperature (\u00b0C) - <code>ghi_W_m2</code>: Global horizontal irradiance (W/m\u00b2) - <code>dni_W_m2</code>: Direct normal irradiance (W/m\u00b2) - <code>dhi_W_m2</code>: Diffuse horizontal irradiance (W/m\u00b2) - <code>wind_speed_m_s</code>: Wind speed at 10m (m/s) - <code>relative_humidity_percent</code>: Relative humidity (%)</p>"},{"location":"notebooks/data/raw/#electricity-prices","title":"Electricity Prices","text":"<p>File: <code>electricity_prices_de_2020.csv</code> Coverage: Germany, Jan-Sep 2020, hourly Source: Open Power System Data License: Open Database License (ODbL) URL: https://data.open-power-system-data.org/time_series/</p> <p>Attribution required: \"Data from Open Power System Data. https://open-power-system-data.org\"</p> <p>Columns: - <code>price_eur_mwh</code>: Day-ahead electricity price (EUR/MWh)</p>"},{"location":"user-guide/","title":"User Guide","text":"<p>Welcome to the flixOpt User Guide! This guide will help you master energy and material flow optimization with flixOpt.</p>"},{"location":"user-guide/#what-is-flixopt","title":"What is flixOpt?","text":"<p>flixOpt is a comprehensive framework for modeling and optimizing energy and material flow systems. It supports:</p> <ul> <li>Operational Optimization - Dispatch optimization with fixed capacities</li> <li>Investment Optimization - Capacity expansion planning with binary or continuous sizing</li> <li>Multi-Period Planning - Sequential investment decisions across multiple periods</li> <li>Scenario Analysis - Stochastic modeling with weighted scenarios</li> </ul>"},{"location":"user-guide/#key-features","title":"Key Features","text":"<ul> <li> <p> Flexible Components</p> <p>Flow, Bus, Storage, LinearConverter - build any system topology</p> </li> <li> <p> Advanced Modeling</p> <p>Investment decisions, On/Off states, Piecewise linearization</p> </li> <li> <p> Multiple Solvers</p> <p>HiGHS (default), Gurobi, CPLEX - choose what fits your needs</p> </li> <li> <p> Built-in Analysis</p> <p>Plotting, export, and result exploration tools</p> </li> </ul>"},{"location":"user-guide/#learning-path","title":"Learning Path","text":"<p>This guide follows a sequential learning path:</p> Step Section What You'll Learn 1 Core Concepts Fundamental building blocks: FlowSystem, Bus, Flow, Components, Effects 2 Building Models How to construct models step by step 3 Running Optimizations Solver configuration and execution 4 Analyzing Results Extracting and visualizing outcomes 5 Mathematical Notation Deep dive into the math behind each element 6 Recipes Common patterns and solutions"},{"location":"user-guide/#quick-links","title":"Quick Links","text":""},{"location":"user-guide/#getting-started","title":"Getting Started","text":"<ul> <li>Quick Start - Build your first model in 5 minutes</li> <li>Minimal Example - Simplest possible model</li> <li>Core Concepts - Understand the fundamentals</li> </ul>"},{"location":"user-guide/#reference","title":"Reference","text":"<ul> <li>Mathematical Notation - Detailed specifications</li> <li>API Reference - Complete class documentation</li> <li>Examples - Working code to learn from</li> </ul>"},{"location":"user-guide/#help","title":"Help","text":"<ul> <li>FAQ - Frequently asked questions</li> <li>Troubleshooting - Common issues and solutions</li> <li>Community - Get help from the community</li> </ul>"},{"location":"user-guide/#use-cases","title":"Use Cases","text":"<p>flixOpt handles any flow-based optimization problem:</p> <p>Energy Systems: Power dispatch, CHP optimization, renewable integration, battery storage, district heating</p> <p>Industrial Applications: Process optimization, multi-commodity networks, supply chains, resource allocation</p>"},{"location":"user-guide/colors/","title":"Color Management","text":"<p>flixOpt provides centralized color management to ensure consistent colors across all visualizations.</p>"},{"location":"user-guide/colors/#carriers","title":"Carriers","text":"<p><code>Carriers</code> define energy or material types with associated colors. Built-in carriers are available in <code>CONFIG.Carriers</code>:</p> Carrier Color Hex <code>electricity</code> <code>#FECB52</code> <code>heat</code> <code>#D62728</code> <code>gas</code> <code>#1F77B4</code> <code>hydrogen</code> <code>#9467BD</code> <code>fuel</code> <code>#8C564B</code> <code>biomass</code> <code>#2CA02C</code> <p>Assign carriers to buses for automatic coloring:</p> <pre><code>heat_bus = fx.Bus('HeatNetwork', carrier='heat')\nelec_bus = fx.Bus('Grid', carrier='electricity')\n\n# Plots automatically use carrier colors\nflow_system.statistics.plot.sankey.flows()\n</code></pre>"},{"location":"user-guide/colors/#custom-carriers","title":"Custom Carriers","text":"<p>Register custom carriers on your FlowSystem:</p> <pre><code>biogas = fx.Carrier('biogas', color='#228B22', unit='kW', description='Biogas fuel')\n\nflow_system.add_carrier(biogas)\n</code></pre>"},{"location":"user-guide/colors/#setting-component-colors","title":"Setting Component Colors","text":""},{"location":"user-guide/colors/#at-construction","title":"At Construction","text":"<pre><code>boiler = fx.LinearConverter('Boiler', ..., color='#D35400')\nstorage = fx.Storage('Battery', ..., color='green')\n</code></pre>"},{"location":"user-guide/colors/#via-topology-accessor","title":"Via Topology Accessor","text":"<pre><code># Single component\nflow_system.topology.set_component_color('Boiler', '#D35400')\n\n# Multiple components\nflow_system.topology.set_component_colors({\n    'Boiler': '#D35400',\n    'CHP': '#8E44AD',\n    'HeatPump': '#27AE60',\n})\n\n# Apply a colorscale to all components\nflow_system.topology.set_component_colors('turbo')\n\n# Apply colorscales to groups\nflow_system.topology.set_component_colors({\n    'Oranges': ['Solar1', 'Solar2', 'Solar3'],\n    'Blues': ['Wind1', 'Wind2'],\n})\n</code></pre>"},{"location":"user-guide/colors/#carrier-colors","title":"Carrier Colors","text":"<pre><code>flow_system.topology.set_carrier_color('electricity', '#FECB52')\n</code></pre>"},{"location":"user-guide/colors/#context-aware-coloring","title":"Context-Aware Coloring","text":"<p>Plot colors are automatically resolved based on context:</p> <ul> <li>Bus balance plots: Flows colored by their parent component</li> <li>Component balance plots: Flows colored by their connected bus/carrier</li> <li>Sankey diagrams: Buses use carrier colors, components use configured colors</li> </ul> <pre><code># Plotting a bus \u2192 flows colored by component\nflow_system.statistics.plot.balance('ElectricityBus')\n\n# Plotting a component \u2192 flows colored by carrier\nflow_system.statistics.plot.balance('CHP')\n</code></pre>"},{"location":"user-guide/colors/#color-resolution-priority","title":"Color Resolution Priority","text":"<p>Colors are resolved in this order:</p> <ol> <li>Explicit colors passed to plot methods (always override)</li> <li>Component colors set via topology or at construction</li> <li>Carrier colors for buses</li> <li>Default colorscale (<code>CONFIG.Plotting.default_qualitative_colorscale</code>)</li> </ol>"},{"location":"user-guide/colors/#persistence","title":"Persistence","text":"<p>Colors are automatically saved and restored with the FlowSystem:</p> <pre><code># Colors are persisted\nflow_system.to_netcdf('my_system.nc')\n\n# And restored\nloaded = fx.FlowSystem.from_netcdf('my_system.nc')\nloaded.topology.component_colors  # Colors preserved\n</code></pre>"},{"location":"user-guide/colors/#accessing-colors-programmatically","title":"Accessing Colors Programmatically","text":"<p>The <code>topology</code> accessor provides cached dictionaries:</p> <pre><code>flow_system.topology.carrier_colors   # {'electricity': '#FECB52', ...}\nflow_system.topology.component_colors # {'Boiler': '#1f77b4', ...}\nflow_system.topology.bus_colors       # {'ElecBus': '#FECB52', ...}\n</code></pre> <p>You can also inspect individual components:</p> <pre><code>for comp in flow_system.components.values():\n    print(f\"{comp.label}: {comp.color}\")\n</code></pre>"},{"location":"user-guide/colors/#auto-assignment","title":"Auto-Assignment","text":"<p>Components without explicit colors are automatically assigned colors when you call <code>optimize()</code> or <code>connect_and_transform()</code>. The colors come from <code>CONFIG.Plotting.default_qualitative_colorscale</code> (default: <code>'plotly'</code>).</p>"},{"location":"user-guide/core-concepts/","title":"Core Concepts","text":"<p>This page introduces the fundamental concepts of flixOpt through practical scenarios. Understanding these concepts will help you model any system involving flows and conversions.</p>"},{"location":"user-guide/core-concepts/#the-big-picture","title":"The Big Picture","text":"<p>Imagine you're managing a district heating system. You have:</p> <ul> <li>A gas boiler that burns natural gas to produce heat</li> <li>A heat pump that uses electricity to extract heat from the environment</li> <li>A thermal storage tank to buffer heat production and demand</li> <li>Buildings that need heat throughout the day</li> <li>Access to the gas grid and electricity grid</li> </ul> <p>Your goal: minimize total operating costs while meeting all heat demands.</p> <p>This is exactly the kind of problem flixOpt solves. Let's see how each concept maps to this scenario.</p>"},{"location":"user-guide/core-concepts/#buses-where-things-connect","title":"Buses: Where Things Connect","text":"<p>A <code>Bus</code> is a connection point where energy or material flows meet. Think of it as a junction or hub.</p> <p>In our heating system</p> <ul> <li>Heat Bus \u2014 where heat from the boiler, heat pump, and storage meets the building demand</li> <li>Gas Bus \u2014 connection to the gas grid</li> <li>Electricity Bus \u2014 connection to the power grid</li> </ul> <p>The key rule: At every bus, inputs must equal outputs at each timestep.</p> \\[\\sum inputs = \\sum outputs\\] <p>This balance constraint is what makes your model physically meaningful \u2014 energy can't appear or disappear.</p>"},{"location":"user-guide/core-concepts/#carriers","title":"Carriers","text":"<p>Buses can be assigned a carrier \u2014 a type of energy or material (electricity, heat, gas, etc.). Carriers enable automatic coloring in plots and help organize your system semantically:</p> <pre><code>heat_bus = fx.Bus('HeatNetwork', carrier='heat')  # Uses default heat color\nelec_bus = fx.Bus('Grid', carrier='electricity')\n</code></pre> <p>See Color Management for details.</p>"},{"location":"user-guide/core-concepts/#flows-what-moves-between-elements","title":"Flows: What Moves Between Elements","text":"<p>A <code>Flow</code> represents the movement of energy or material. Every flow connects a component to a bus, with a defined direction.</p> <p>In our heating system</p> <ul> <li>Heat flowing from the boiler to the Heat Bus</li> <li>Gas flowing from the Gas Bus to the boiler</li> <li>Heat flowing from the Heat Bus to the buildings</li> </ul> <p>Flows have:</p> <ul> <li>A size (capacity) \u2014 \"This boiler can deliver up to 500 kW\"</li> <li>A flow rate \u2014 \"Right now it's running at 300 kW\"</li> </ul>"},{"location":"user-guide/core-concepts/#components-the-equipment","title":"Components: The Equipment","text":"<p><code>Components</code> are the physical (or logical) elements that transform, store, or transfer flows.</p>"},{"location":"user-guide/core-concepts/#converters-transform-one-thing-into-another","title":"Converters \u2014 Transform One Thing Into Another","text":"<p>A <code>LinearConverter</code> takes inputs and produces outputs with a defined efficiency.</p> <p>In our heating system</p> <ul> <li>Gas Boiler: Gas \u2192 Heat (\u03b7 = 90%)</li> <li>Heat Pump: Electricity \u2192 Heat (COP = 3.5)</li> </ul> <p>The conversion relationship:</p> \\[output = \\eta \\cdot input\\]"},{"location":"user-guide/core-concepts/#storages-save-for-later","title":"Storages \u2014 Save for Later","text":"<p>A <code>Storage</code> accumulates and releases energy or material over time.</p> <p>In our heating system</p> <ul> <li>Thermal Tank: Store excess heat during cheap hours, use it during expensive hours</li> </ul> <p>The storage tracks its state over time:</p> \\[charge(t+1) = charge(t) + charging - discharging\\]"},{"location":"user-guide/core-concepts/#sources-sinks-system-boundaries","title":"Sources &amp; Sinks \u2014 System Boundaries","text":"<p><code>Sources</code> and <code>Sinks</code> connect your system to the outside world.</p> <p>In our heating system</p> <ul> <li>Gas Source: Buy gas from the grid at market prices</li> <li>Electricity Source: Buy power at time-varying prices</li> <li>Heat Sink: The building demand that must be met</li> </ul>"},{"location":"user-guide/core-concepts/#effects-what-youre-tracking","title":"Effects: What You're Tracking","text":"<p>An <code>Effect</code> represents any metric you want to track or optimize. One effect is your objective (what you minimize or maximize), others can be constraints.</p> <p>In our heating system</p> <ul> <li>Costs (objective) \u2014 minimize total operating costs</li> <li>CO\u2082 Emissions (constraint) \u2014 stay below 1000 tonnes/year</li> <li>Gas Consumption (tracking) \u2014 report total gas used</li> </ul> <p>Effects can be linked: \"Each kg of CO\u2082 costs \u20ac80 in emissions trading\" \u2014 this creates a connection from the CO\u2082 effect to the Costs effect.</p>"},{"location":"user-guide/core-concepts/#flowsystem-putting-it-all-together","title":"FlowSystem: Putting It All Together","text":"<p>The <code>FlowSystem</code> is your complete model. It contains all buses, components, flows, and effects, plus the time definition for your optimization.</p> <pre><code>import flixopt as fx\n\n# Define timesteps (e.g., hourly for one week)\ntimesteps = pd.date_range('2024-01-01', periods=168, freq='h')\n\n# Create the system\nflow_system = fx.FlowSystem(timesteps)\n\n# Add elements\nflow_system.add_elements(heat_bus, gas_bus, electricity_bus)\nflow_system.add_elements(boiler, heat_pump, storage)\nflow_system.add_elements(costs_effect, co2_effect)\n</code></pre>"},{"location":"user-guide/core-concepts/#the-workflow-model-optimize-analyze","title":"The Workflow: Model \u2192 Optimize \u2192 Analyze","text":"<p>Working with flixOpt follows three steps:</p> <pre><code>graph LR\n    A[1. Build FlowSystem] --&gt; B[2. Run Optimization]\n    B --&gt; C[3. Analyze Results]</code></pre>"},{"location":"user-guide/core-concepts/#1-build-your-model","title":"1. Build Your Model","text":"<p>Define your system structure, parameters, and time series data.</p>"},{"location":"user-guide/core-concepts/#2-run-the-optimization","title":"2. Run the Optimization","text":"<p>Optimize your FlowSystem with a solver:</p> <pre><code>flow_system.optimize(fx.solvers.HighsSolver())\n</code></pre>"},{"location":"user-guide/core-concepts/#3-analyze-results","title":"3. Analyze Results","text":"<p>Access solution data directly from the FlowSystem:</p> <pre><code># Access component solutions\nboiler = flow_system.components['Boiler']\nprint(boiler.solution)\n\n# Get total costs\ntotal_costs = flow_system.solution['costs|total']\n\n# Use statistics for aggregated data\nprint(flow_system.statistics.flow_hours)\n\n# Plot results\nflow_system.statistics.plot.balance('HeatBus')\n</code></pre> <p> </p> Conceptual Usage and IO operations of FlixOpt"},{"location":"user-guide/core-concepts/#quick-reference","title":"Quick Reference","text":"Concept What It Represents Real-World Example Bus Connection point Heat network, electrical grid Flow Energy/material movement Heat delivery, gas consumption LinearConverter Transformation equipment Boiler, heat pump, turbine Storage Time-shifting capability Battery, thermal tank, warehouse Source/Sink System boundary Grid connection, demand Effect Metric to track/optimize Costs, emissions, energy use FlowSystem Complete model Your entire system"},{"location":"user-guide/core-concepts/#flowsystem-api-at-a-glance","title":"FlowSystem API at a Glance","text":"<p>The <code>FlowSystem</code> is the central object in flixOpt. After building your model, all operations are accessed through the FlowSystem and its accessors:</p> <pre><code>flow_system = fx.FlowSystem(timesteps)\nflow_system.add_elements(...)\n\n# Optimize\nflow_system.optimize(solver)\n\n# Access results\nflow_system.solution                    # Raw xarray Dataset\nflow_system.statistics.flow_hours       # Aggregated statistics\nflow_system.statistics.plot.balance()   # Visualization\n\n# Transform (returns new FlowSystem)\nfs_subset = flow_system.transform.sel(time=slice(...))\n\n# Inspect structure\nflow_system.topology.plot()\n</code></pre>"},{"location":"user-guide/core-concepts/#accessor-overview","title":"Accessor Overview","text":"Accessor Purpose Key Methods <code>solution</code> Raw optimization results xarray Dataset with all variables <code>statistics</code> Aggregated data <code>flow_rates</code>, <code>flow_hours</code>, <code>sizes</code>, <code>charge_states</code>, <code>total_effects</code> <code>statistics.plot</code> Visualization <code>balance()</code>, <code>heatmap()</code>, <code>sankey()</code>, <code>effects()</code>, <code>storage()</code> <code>transform</code> Create modified copies <code>sel()</code>, <code>isel()</code>, <code>resample()</code>, <code>cluster()</code> <code>topology</code> Network structure <code>plot()</code>, <code>start_app()</code>, <code>infos()</code>"},{"location":"user-guide/core-concepts/#element-access","title":"Element Access","text":"<p>Access elements directly from the FlowSystem:</p> <pre><code># Access by label\nflow_system.components['Boiler']        # Get a component\nflow_system.buses['Heat']               # Get a bus\nflow_system.flows['Boiler(Q_th)']       # Get a flow\nflow_system.effects['costs']            # Get an effect\n\n# Element-specific solutions\nflow_system.components['Boiler'].solution\nflow_system.flows['Boiler(Q_th)'].solution\n</code></pre>"},{"location":"user-guide/core-concepts/#beyond-energy-systems","title":"Beyond Energy Systems","text":"<p>While our example used a heating system, flixOpt works for any flow-based optimization:</p> Domain Buses Components Effects District Heating Heat, Gas, Electricity Boilers, CHPs, Heat Pumps Costs, CO\u2082 Manufacturing Raw Materials, Products Machines, Assembly Lines Costs, Time, Labor Supply Chain Warehouses, Locations Transport, Storage Costs, Distance Water Networks Reservoirs, Treatment Pumps, Pipes Costs, Energy"},{"location":"user-guide/core-concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Building Models \u2014 Step-by-step guide to constructing models</li> <li>Examples \u2014 Working code for common scenarios</li> <li>Mathematical Notation \u2014 Detailed constraint formulations</li> </ul>"},{"location":"user-guide/core-concepts/#advanced-extending-with-linopy","title":"Advanced: Extending with linopy","text":"<p>flixOpt is built on linopy. You can access and extend the underlying optimization model for custom constraints:</p> <pre><code># Build the model (without solving)\nflow_system.build_model()\n\n# Access the linopy model\nmodel = flow_system.model\n\n# Add custom constraints using linopy API\nmodel.add_constraints(...)\n\n# Then solve\nflow_system.solve(fx.solvers.HighsSolver())\n</code></pre> <p>This allows advanced users to add domain-specific constraints while keeping flixOpt's convenience for standard modeling.</p>"},{"location":"user-guide/faq/","title":"Frequently Asked Questions","text":""},{"location":"user-guide/faq/#what-is-flixopt","title":"What is flixOpt?","text":"<p>flixOpt is a Python framework for modeling and optimizing energy and material flow systems. It handles both operational optimization (dispatch) and investment optimization (capacity expansion).</p>"},{"location":"user-guide/faq/#which-solvers-does-flixopt-support","title":"Which solvers does flixOpt support?","text":"<ul> <li>HiGHS (default, included)</li> <li>Gurobi (commercial, academic licenses available)</li> </ul>"},{"location":"user-guide/faq/#how-do-i-install-flixopt","title":"How do I install flixOpt?","text":"<pre><code>pip install flixopt\n</code></pre> <p>For full features: <pre><code>pip install \"flixopt[full]\"\n</code></pre></p>"},{"location":"user-guide/faq/#do-i-need-to-install-a-solver-separately","title":"Do I need to install a solver separately?","text":"<p>No. HiGHS is included and works out of the box.</p>"},{"location":"user-guide/faq/#can-i-add-custom-constraints","title":"Can I add custom constraints?","text":"<p>Yes. You can add custom constraints directly to the optimization model using linopy.</p>"},{"location":"user-guide/faq/#where-can-i-get-help","title":"Where can I get help?","text":"<ul> <li>Check Troubleshooting</li> <li>Open an issue on GitHub</li> </ul>"},{"location":"user-guide/glossary/","title":"Glossary","text":"<p>Key concepts and terminology used throughout flixOpt.</p>"},{"location":"user-guide/glossary/#system-elements","title":"System Elements","text":"Concept Description Bus A connection point where energy or material flows meet. Acts as a junction that enforces flow balance (inputs = outputs). Examples: heat network, electricity grid, gas bus. Flow Movement of energy or material between a component and a bus. Has a direction (into or out of component), a size (capacity), and a flow_rate (actual power at each timestep). Component Physical or logical element that transforms, stores, or transfers flows. Connects to buses via flows. Carrier Type of energy or material (electricity, heat, gas, water). Assigned to buses for semantic organization and automatic plot coloring. Effect Any measurable metric to track or optimize (costs, CO2 emissions, energy use). One effect is the objective (minimized/maximized), others can be constrained or tracked. FlowSystem The complete model container. Holds all buses, components, flows, effects, and the time definition. Entry point for optimization and result access."},{"location":"user-guide/glossary/#component-types","title":"Component Types","text":"Concept Description LinearConverter Transforms input flows to output flows via linear conversion factors. Examples: boiler (gas \u2192 heat), heat pump (electricity \u2192 heat), turbine. Storage Accumulates and releases energy over time. Tracks charge state evolution. Examples: battery, thermal tank, reservoir. Source System boundary providing supply from outside. Examples: grid connection, fuel supplier, well. Sink System boundary consuming demand. Examples: building load, export, waste disposal. SourceAndSink Combined source and sink at the same bus. Used when both import and export are possible. Transmission Transports flows between locations with optional efficiency losses. Example: district heating pipe, power line."},{"location":"user-guide/glossary/#time-and-dimensions","title":"Time and Dimensions","text":"Concept Description timesteps The basic time resolution of the model. A sequence of time points (e.g., hourly for one year = 8760 timesteps). All variables are indexed over timesteps. timestep_duration Length of each timestep in hours. Used to convert between power (kW) and energy (kWh). Inferred from the datetime index if not specified. period Long-term planning horizon dimension. Multiple periods enable multi-year investment planning (e.g., 2025, 2030, 2035). Each period has its own investment decisions. scenario Uncertainty dimension representing different futures (e.g., weather scenarios, price scenarios). Operations vary per scenario; investments are typically shared across scenarios. cluster Aggregation dimension used when time-series clustering is applied. Represents typical periods that stand in for many similar original periods."},{"location":"user-guide/glossary/#time-series-clustering","title":"Time-Series Clustering","text":"Concept Description typical period A representative time segment (e.g., typical day) selected or computed to represent a cluster of similar original periods. <code>n_clusters</code> Number of clusters (typical periods) to create. Each cluster represents multiple similar original periods. Example: 12 typical days for a year. <code>cluster_duration</code> Length of each cluster period. Accepts int/float (hours) or pandas Timedelta strings (e.g., <code>24</code>, <code>'24h'</code>, <code>'1D'</code>). <code>cluster_weight</code> How many original periods each cluster represents. Used to scale results back to full resolution. <code>cluster_mode</code> Storage behavior during clustering: <code>'intercluster_cyclic'</code> (seasonal storage), <code>'cyclic'</code> (daily cycling), <code>'independent'</code> (no linking). expand() Transform method to restore full time resolution after clustered optimization. Maps cluster solutions back to all original timesteps."},{"location":"user-guide/glossary/#variables-and-parameters","title":"Variables and Parameters","text":"Concept Description flow_rate Decision variable: actual power/flow at each timestep [kW, m3/h]. Bounded by the flow's size. size Capacity or nominal rating of a flow [kW, m3/h]. Can be fixed (scalar), unbounded (None), or an investment decision (<code>InvestParameters</code>). In the solution, all investment variables use the <code>|size</code> suffix. capacity_in_flow_hours Storage capacity parameter [kWh, m3]. Distinct from flow <code>size</code> (which is power-based). In the solution, storage capacity is also accessed via <code>|size</code> for consistency with other investment variables. charge_state Storage variable: current amount stored [kWh, m3]. Evolves based on charging/discharging flows. Also called SOC (State of Charge) in energy system contexts. status Binary variable indicating whether equipment is operating (1) or off (0) at each timestep. Enabled via <code>StatusParameters</code>. conversion_factor Linear multiplier between input and output flows in a LinearConverter. Can be time-varying. Related to but not identical to efficiency. efficiency Ratio of useful output to input. For LinearConverter: output = efficiency * input. For Storage: <code>eta_charge</code> and <code>eta_discharge</code>."},{"location":"user-guide/glossary/#feature-parameters","title":"Feature Parameters","text":"Concept Description InvestParameters Configuration for investment sizing decisions. Defines sizing bounds (<code>minimum_size</code>, <code>maximum_size</code>, <code>fixed_size</code>) and investment-related effects (capex). StatusParameters Configuration for binary on/off modeling. Enables startup effects, minimum uptime/downtime constraints, and operational mode tracking. Piece Single segment of a piecewise linear function, defined by start and end points. Piecewise Collection of pieces forming a piecewise linear approximation. Used for non-linear relationships like efficiency curves. PiecewiseConversion Multi-flow piecewise relationships where all flows change together based on operating point. PiecewiseEffects Piecewise relationship mapping a variable (origin) to effect contributions at varying rates."},{"location":"user-guide/glossary/#effects-system","title":"Effects System","text":"Concept Description temporal effect Effect accumulated over timesteps from operations (e.g., fuel costs, emissions per MWh). Formula: <code>effect(t) = flow_rate(t) * cost_per_unit * dt</code>. periodic effect Time-independent effect per period (e.g., investment costs, fixed fees). Independent of operational decisions. total effect Sum of temporal and periodic effects: <code>E_total = E_periodic + sum(E_temporal(t))</code>. effects_per_flow_hour Cost/impact per unit of flow-hours. Parameter on Flow for operational costs (e.g., <code>{'costs': 50}</code> for 50 EUR/MWh). effects_of_investment_per_size Cost/impact per unit of installed capacity. Parameter on InvestParameters (e.g., <code>{'costs': 800}</code> for 800 EUR/kW). share_from_temporal Cross-effect linking where one effect contributes to another (e.g., CO2 \u2192 costs via carbon pricing). Penalty Built-in effect for soft constraints. Excess/shortage penalties on buses contribute to Penalty, which is added to the objective."},{"location":"user-guide/glossary/#operational-constraints","title":"Operational Constraints","text":"Concept Description startup Transition from off (status=0) to on (status=1). Can incur costs via <code>effects_per_startup</code>. uptime Continuous duration equipment operates. Can be constrained with <code>min_uptime</code>, <code>max_uptime</code> in StatusParameters. downtime Continuous duration equipment is off. Can be constrained with <code>min_downtime</code>, <code>max_downtime</code> in StatusParameters. flow_hours Total energy delivered by a flow: sum of flow_rate * timestep_duration. Can be constrained with <code>flow_hours_min</code>, <code>flow_hours_max</code>. excess_penalty Penalty applied when bus has more supply than demand. Soft constraint alternative to strict balance. shortage_penalty Penalty applied when bus has more demand than supply (unmet demand)."},{"location":"user-guide/glossary/#weights-and-aggregation","title":"Weights and Aggregation","text":"Concept Description scenario_weight Probability or importance of each scenario. Temporal effects are weighted by scenario weight in the objective. Default: equal weights, normalized to sum to 1. period_weight Importance/duration of each period. Computed automatically from period index intervals. Used for multi-year cost aggregation. cluster_weight Number of original periods each cluster represents. Used to scale clustered results to full resolution."},{"location":"user-guide/glossary/#solution-and-results","title":"Solution and Results","text":"Concept Description solution xarray Dataset containing all optimization results. Access via <code>flow_system.solution</code> or element-specific <code>.solution</code> attributes. statistics Accessor providing aggregated result analysis. Methods: <code>flow_rates</code>, <code>flow_hours</code>, <code>sizes</code>, <code>charge_states</code>, <code>total_effects</code>. statistics.plot Visualization accessor. Methods: <code>balance()</code>, <code>heatmap()</code>, <code>sankey()</code>, <code>effects()</code>, <code>storage()</code>."},{"location":"user-guide/glossary/#optimization","title":"Optimization","text":"Concept Description optimize() Main entry point to build and solve the optimization model. Returns solution status. build_model() Build the linopy optimization model without solving. Allows adding custom constraints before solving. solve() Solve a previously built model. segmented optimization Rolling horizon approach that solves the problem in overlapping time windows. Useful for large problems or online optimization."},{"location":"user-guide/glossary/#transform-methods","title":"Transform Methods","text":"Concept Description transform.sel() Select a subset of the FlowSystem along dimensions (time, period, scenario). Returns a new FlowSystem. transform.cluster() Apply time-series clustering to reduce problem size. Returns a clustered FlowSystem. transform.expand() Restore full time resolution from a clustered solution. Reconstructs original timesteps from typical periods. transform.resample() Change time resolution (e.g., hourly to 4-hourly). Returns a resampled FlowSystem."},{"location":"user-guide/glossary/#mathematical-notation","title":"Mathematical Notation","text":"Symbol Type Description \\(p(t)\\) Variable Flow rate at timestep \\(t\\) \\(P\\) Variable/Parameter Size (capacity) of flow or storage \\(E(t)\\) Variable Charge state of storage at timestep \\(t\\) \\(s(t)\\) Variable Binary status (on/off) at timestep \\(t\\) \\(s^{start}(t)\\) Variable Binary startup indicator at timestep \\(t\\) \\(\\eta\\) Parameter Efficiency factor \\(\\Delta t\\) Parameter Timestep duration (hours) \\(w_s\\) Parameter Scenario weight \\(w_y\\) Parameter Period weight"},{"location":"user-guide/migration-guide-v3/","title":"Migration Guide: v2.x \u2192 v3.0.0","text":"<p>Quick Start</p> <p><pre><code>pip install --upgrade flixopt\n</code></pre> Review breaking changes, update deprecated parameters, test thoroughly.</p>"},{"location":"user-guide/migration-guide-v3/#breaking-changes","title":"\ud83d\udca5 Breaking Changes","text":""},{"location":"user-guide/migration-guide-v3/#effect-system-redesign","title":"Effect System Redesign","text":"<p>Terminology changed and sharing system inverted: effects now \"pull\" shares.</p> Concept Old (v2.x) New (v3.0.0) Time-varying effects <code>operation</code> <code>temporal</code> Investment effects <code>invest</code> / <code>investment</code> <code>periodic</code> Share to other effects (operation) <code>specific_share_to_other_effects_operation</code> <code>share_from_temporal</code> Share to other effects (invest) <code>specific_share_to_other_effects_invest</code> <code>share_from_periodic</code> v2.xv3.0.0 <pre><code>CO2 = fx.Effect('CO2', 'kg', 'CO2',\n    specific_share_to_other_effects_operation={'costs': 0.2})\ncosts = fx.Effect('costs', '\u20ac', 'Total')\n</code></pre> <pre><code>CO2 = fx.Effect('CO2', 'kg', 'CO2')\ncosts = fx.Effect('costs', '\u20ac', 'Total',\n    share_from_temporal={'CO2': 0.2})  # Pull from CO2\n</code></pre> <p>No deprecation warning</p> <p>Move shares to receiving effect and update parameter names throughout your code.</p>"},{"location":"user-guide/migration-guide-v3/#variable-names","title":"Variable Names","text":"Category Old (v2.x) New (v3.0.0) Investment <code>is_invested</code> <code>invested</code> Switching <code>switch_on</code> <code>switch|on</code> Switching <code>switch_off</code> <code>switch|off</code> Switching <code>switch_on_nr</code> <code>switch|count</code> Effects <code>Effect(invest)|total</code> <code>Effect(periodic)</code> Effects <code>Effect(operation)|total</code> <code>Effect(temporal)</code> Effects <code>Effect(operation)|total_per_timestep</code> <code>Effect(temporal)|per_timestep</code> Effects <code>Effect|total</code> <code>Effect</code>"},{"location":"user-guide/migration-guide-v3/#string-labels","title":"String Labels","text":"What Old (v2.x) New (v3.0.0) Bus assignment <code>bus=my_bus</code> (object) <code>bus='electricity'</code> (string) Effect shares <code>{CO2: 0.2}</code> (object key) <code>{'CO2': 0.2}</code> (string key) v2.xv3.0.0 <pre><code>flow = fx.Flow('P_el', bus=my_bus)  # \u274c Object\ncosts = fx.Effect('costs', '\u20ac', share_from_temporal={CO2: 0.2})  # \u274c\n</code></pre> <pre><code>flow = fx.Flow('P_el', bus='electricity')  # \u2705 String\ncosts = fx.Effect('costs', '\u20ac', share_from_temporal={'CO2': 0.2})  # \u2705\n</code></pre>"},{"location":"user-guide/migration-guide-v3/#flowsystem-optimization","title":"FlowSystem &amp; Optimization","text":"Change Description FlowSystem copying Each <code>Optimization</code> gets its own copy (independent) do_modeling() return Returns <code>Optimization</code> object (access model via <code>.model</code> property) Storage arrays Arrays match timestep count (no extra element) Final charge state Use <code>relative_minimum_final_charge_state</code> / <code>relative_maximum_final_charge_state</code>"},{"location":"user-guide/migration-guide-v3/#other-changes","title":"Other Changes","text":"Category Old (v2.x) New (v3.0.0+) System model class <code>SystemModel</code> <code>FlowSystemModel</code> Element submodel <code>Model</code> <code>Submodel</code> Logging default Enabled Disabled (silent) Enable console logging (default) <code>fx.CONFIG.Logging.enable_console('INFO')</code> or <code>fx.CONFIG.exploring()</code>"},{"location":"user-guide/migration-guide-v3/#deprecated-parameters","title":"\ud83d\uddd1\ufe0f Deprecated Parameters","text":"InvestParameters Old (v2.x) New (v3.0.0) <code>fix_effects</code> <code>effects_of_investment</code> <code>specific_effects</code> <code>effects_of_investment_per_size</code> <code>divest_effects</code> <code>effects_of_retirement</code> <code>piecewise_effects</code> <code>piecewise_effects_of_investment</code> Effect Old (v2.x) New (v3.0.0) <code>minimum_investment</code> <code>minimum_periodic</code> <code>maximum_investment</code> <code>maximum_periodic</code> <code>minimum_operation</code> <code>minimum_temporal</code> <code>maximum_operation</code> <code>maximum_temporal</code> <code>minimum_operation_per_hour</code> <code>minimum_per_hour</code> <code>maximum_operation_per_hour</code> <code>maximum_per_hour</code> Components Old (v2.x) New (v3.0.0) <code>source</code> (parameter) <code>outputs</code> <code>sink</code> (parameter) <code>inputs</code> <code>prevent_simultaneous_sink_and_source</code> <code>prevent_simultaneous_flow_rates</code> TimeSeriesData Old (v2.x) New (v3.0.0) <code>agg_group</code> <code>aggregation_group</code> <code>agg_weight</code> <code>aggregation_weight</code> Optimization Old (v2.x) New (v3.0.0) <code>active_timesteps=[0, 1, 2]</code> Use <code>flow_system.sel()</code> or <code>flow_system.isel()</code>"},{"location":"user-guide/migration-guide-v3/#new-features","title":"\u2728 New Features","text":"Multi-Period Investments <pre><code>periods = pd.Index(['2020', '2030'])\nflow_system = fx.FlowSystem(time=timesteps, periods=periods)\n</code></pre> Scenario-Based Optimization Parameter Description Example <code>scenarios</code> Scenario index <code>pd.Index(['low', 'base', 'high'], name='scenario')</code> <code>scenario_weights</code> Probabilities <code>[0.2, 0.6, 0.2]</code> <code>scenario_independent_sizes</code> Separate capacities per scenario <code>True</code> / <code>False</code> (default) <pre><code>flow_system = fx.FlowSystem(\n    time=timesteps,\n    scenarios=scenarios,\n    scenario_weights=[0.2, 0.6, 0.2],\n    scenario_independent_sizes=True\n)\n</code></pre> Enhanced I/O Method Description <code>flow_system.to_netcdf('file.nc')</code> Save FlowSystem <code>fx.FlowSystem.from_netcdf('file.nc')</code> Load FlowSystem <code>flow_system.sel(time=slice(...))</code> Select by label <code>flow_system.isel(time=slice(...))</code> Select by index <code>flow_system.resample(time='D')</code> Resample timeseries <code>flow_system.copy()</code> Deep copy <code>results.flow_system</code> Access from results Effects Per Component <pre><code>effects_ds = results.effects_per_component\n\n# Access effect contributions by component\nprint(effects_ds['total'].sel(effect='costs'))      # Total effects\nprint(effects_ds['temporal'].sel(effect='CO2'))     # Temporal effects\nprint(effects_ds['periodic'].sel(effect='costs'))   # Periodic effects\n</code></pre> Storage Features Feature Parameter Description Balanced storage <code>balanced=True</code> Ensures charge_size == discharge_size Final state min <code>relative_minimum_final_charge_state=0.5</code> End at least 50% charged Final state max <code>relative_maximum_final_charge_state=0.8</code> End at most 80% charged"},{"location":"user-guide/migration-guide-v3/#common-issues","title":"\ud83d\udd27 Common Issues","text":"Issue Solution Effect shares not working See Effect System Redesign Storage dimensions wrong See FlowSystem &amp; Optimization Bus assignment error See String Labels KeyError in results See Variable Names <code>AttributeError: model</code> Rename <code>.model</code> \u2192 <code>.submodel</code> No logging See Other Changes"},{"location":"user-guide/migration-guide-v3/#checklist","title":"\u2705 Checklist","text":"Category Tasks Install \u2022 <code>pip install --upgrade flixopt</code> Breaking changes \u2022 Update effect sharing\u2022 Update variable names\u2022 Update string labels\u2022 Fix storage arrays\u2022 Update Optimization API\u2022 Update class names Configuration \u2022 Enable logging if needed Deprecated \u2022 Update deprecated parameters (recommended) Testing \u2022 Test thoroughly\u2022 Validate results match v2.x <p> Docs \u2022  Issues \u2022  Changelog</p> <p>Welcome to flixopt v3.0.0! \ud83c\udf89</p>"},{"location":"user-guide/migration-guide-v5/","title":"Migration Guide: v4.x \u2192 v5.0.0","text":"<p>Quick Start</p> <p><pre><code>pip install --upgrade flixopt\n</code></pre> The new API is simpler and more intuitive. Review this guide to update your code.</p>"},{"location":"user-guide/migration-guide-v5/#overview","title":"Overview","text":"<p>v5.0.0 introduces a streamlined API for optimization and results access. The key changes are:</p> Aspect Old API (v4.x) New API (v5.0.0) Optimization <code>fx.Optimization</code> class <code>FlowSystem.optimize()</code> method Results access <code>element.submodel.variable.solution</code> <code>flow_system.solution['variable_name']</code> Results storage <code>Results</code> class <code>xarray.Dataset</code> on <code>flow_system.solution</code>"},{"location":"user-guide/migration-guide-v5/#breaking-changes-in-v500","title":"\ud83d\udca5 Breaking Changes in v5.0.0","text":""},{"location":"user-guide/migration-guide-v5/#optimization-api","title":"Optimization API","text":"<p>The <code>Optimization</code> class is deprecated and will be removed in v6.0.0. Use <code>FlowSystem.optimize()</code> directly.</p> v4.x (Old)v5.0.0 (New) <pre><code>import flixopt as fx\n\n# Create flow system\nflow_system = fx.FlowSystem(timesteps)\nflow_system.add_elements(...)\n\n# Create Optimization object\noptimization = fx.Optimization('my_model', flow_system)\noptimization.do_modeling()\noptimization.solve(fx.solvers.HighsSolver())\n\n# Access results via Optimization object\nresults = optimization.results\ncosts = results.model['costs'].solution.item()\n</code></pre> <pre><code>import flixopt as fx\n\n# Create flow system\nflow_system = fx.FlowSystem(timesteps)\nflow_system.add_elements(...)\n\n# Optimize directly on FlowSystem\nflow_system.optimize(fx.solvers.HighsSolver())\n\n# Access results via flow_system.solution\ncosts = flow_system.solution['costs'].item()\n</code></pre> <p>Two-step alternative</p> <p>If you need access to the model before solving: <pre><code>flow_system.build_model()  # Creates flow_system.model\nflow_system.solve(fx.solvers.HighsSolver())\n</code></pre></p>"},{"location":"user-guide/migration-guide-v5/#results-access","title":"Results Access","text":"<p>Results are now accessed via <code>flow_system.solution</code>, which is an <code>xarray.Dataset</code>.</p>"},{"location":"user-guide/migration-guide-v5/#effect-values","title":"Effect Values","text":"v4.x (Old)v5.0.0 (New) <pre><code># Via element reference\ncosts = flow_system.effects['costs']\ntotal_costs = costs.submodel.total.solution.item()\n\n# Or via results object\ntotal_costs = optimization.results.model['costs'].solution.item()\n</code></pre> <pre><code># Direct access via solution Dataset\ntotal_costs = flow_system.solution['costs'].item()\n\n# Temporal and periodic components\ntemporal_costs = flow_system.solution['costs(temporal)'].values\nperiodic_costs = flow_system.solution['costs(periodic)'].values\nper_timestep = flow_system.solution['costs(temporal)|per_timestep'].values\n</code></pre>"},{"location":"user-guide/migration-guide-v5/#flow-rates","title":"Flow Rates","text":"v4.x (Old)v5.0.0 (New) <pre><code>boiler = flow_system.components['Boiler']\nflow_rate = boiler.thermal_flow.submodel.flow_rate.solution.values\n</code></pre> <pre><code>flow_rate = flow_system.solution['Boiler(Q_th)|flow_rate'].values\n</code></pre>"},{"location":"user-guide/migration-guide-v5/#investment-variables","title":"Investment Variables","text":"v4.x (Old)v5.0.0 (New) <pre><code>boiler = flow_system.components['Boiler']\nsize = boiler.thermal_flow.submodel.investment.size.solution.item()\ninvested = boiler.thermal_flow.submodel.investment.invested.solution.item()\n</code></pre> <pre><code>size = flow_system.solution['Boiler(Q_th)|size'].item()\ninvested = flow_system.solution['Boiler(Q_th)|invested'].item()\n</code></pre>"},{"location":"user-guide/migration-guide-v5/#status-variables","title":"Status Variables","text":"v4.x (Old)v5.0.0 (New) <pre><code>boiler = flow_system.components['Boiler']\nstatus = boiler.thermal_flow.submodel.status.status.solution.values\nstartup = boiler.thermal_flow.submodel.status.startup.solution.values\nshutdown = boiler.thermal_flow.submodel.status.shutdown.solution.values\n</code></pre> <pre><code>status = flow_system.solution['Boiler(Q_th)|status'].values\nstartup = flow_system.solution['Boiler(Q_th)|startup'].values\nshutdown = flow_system.solution['Boiler(Q_th)|shutdown'].values\n</code></pre>"},{"location":"user-guide/migration-guide-v5/#storage-variables","title":"Storage Variables","text":"v4.x (Old)v5.0.0 (New) <pre><code>storage = flow_system.components['Speicher']\ncharge_state = storage.submodel.charge_state.solution.values\nnetto_discharge = storage.submodel.netto_discharge.solution.values\n</code></pre> <pre><code>charge_state = flow_system.solution['Speicher|charge_state'].values\nnetto_discharge = flow_system.solution['Speicher|netto_discharge'].values\nfinal_charge = flow_system.solution['Speicher|charge_state|final'].item()\n</code></pre>"},{"location":"user-guide/migration-guide-v5/#variable-naming-convention","title":"Variable Naming Convention","text":"<p>The new API uses a consistent naming pattern:</p> <pre><code>ComponentLabel(FlowLabel)|variable_name\n</code></pre>"},{"location":"user-guide/migration-guide-v5/#pattern-reference","title":"Pattern Reference","text":"Variable Type Pattern Example Flow rate <code>Component(Flow)\\|flow_rate</code> <code>Boiler(Q_th)\\|flow_rate</code> Size <code>Component(Flow)\\|size</code> <code>Boiler(Q_th)\\|size</code> Invested <code>Component(Flow)\\|invested</code> <code>Boiler(Q_th)\\|invested</code> Status <code>Component(Flow)\\|status</code> <code>Boiler(Q_th)\\|status</code> Startup <code>Component(Flow)\\|startup</code> <code>Boiler(Q_th)\\|startup</code> Shutdown <code>Component(Flow)\\|shutdown</code> <code>Boiler(Q_th)\\|shutdown</code> Inactive <code>Component(Flow)\\|inactive</code> <code>Boiler(Q_th)\\|inactive</code> Active hours <code>Component(Flow)\\|active_hours</code> <code>Boiler(Q_th)\\|active_hours</code> Total flow <code>Component(Flow)\\|total_flow_hours</code> <code>Boiler(Q_th)\\|total_flow_hours</code> Storage charge <code>Storage\\|charge_state</code> <code>Speicher\\|charge_state</code> Storage final <code>Storage\\|charge_state\\|final</code> <code>Speicher\\|charge_state\\|final</code> Netto discharge <code>Storage\\|netto_discharge</code> <code>Speicher\\|netto_discharge</code>"},{"location":"user-guide/migration-guide-v5/#effects-pattern","title":"Effects Pattern","text":"Variable Type Pattern Example Total <code>effect_label</code> <code>costs</code> Temporal <code>effect_label(temporal)</code> <code>costs(temporal)</code> Periodic <code>effect_label(periodic)</code> <code>costs(periodic)</code> Per timestep <code>effect_label(temporal)\\|per_timestep</code> <code>costs(temporal)\\|per_timestep</code> Contribution <code>Component(Flow)-&gt;effect(temporal)</code> <code>Gastarif(Q_Gas)-&gt;costs(temporal)</code>"},{"location":"user-guide/migration-guide-v5/#discovering-variable-names","title":"Discovering Variable Names","text":"<p>Use these methods to find available variable names:</p> <pre><code># List all variables in the solution\nprint(list(flow_system.solution.data_vars))\n\n# Filter for specific patterns\ncosts_vars = [v for v in flow_system.solution.data_vars if 'costs' in v]\nboiler_vars = [v for v in flow_system.solution.data_vars if 'Boiler' in v]\n</code></pre>"},{"location":"user-guide/migration-guide-v5/#results-io","title":"Results I/O","text":""},{"location":"user-guide/migration-guide-v5/#saving-results","title":"Saving Results","text":"v4.x (Old)v5.0.0 (New) <pre><code>optimization.results.to_file(folder='results', name='my_model')\n</code></pre> <pre><code># Save entire FlowSystem with solution\nflow_system.to_netcdf('results/my_model.nc4')\n\n# Or save just the solution Dataset\nflow_system.solution.to_netcdf('results/solution.nc4')\n</code></pre>"},{"location":"user-guide/migration-guide-v5/#loading-results","title":"Loading Results","text":"v4.x (Old)v5.0.0 (New) <pre><code>results = fx.results.Results.from_file('results', 'my_model')\n</code></pre> <pre><code>import xarray as xr\n\n# Load FlowSystem with solution\nflow_system = fx.FlowSystem.from_netcdf('results/my_model.nc4')\n\n# Or load just the solution\nsolution = xr.open_dataset('results/solution.nc4')\n</code></pre>"},{"location":"user-guide/migration-guide-v5/#migrating-old-result-files","title":"Migrating Old Result Files","text":"<p>If you have result files saved with the old API (v4.x), you can migrate them to the new format using <code>FlowSystem.from_old_results()</code>. This method:</p> <ul> <li>Loads the old multi-file format (<code>*--flow_system.nc4</code>, <code>*--solution.nc4</code>)</li> <li>Renames deprecated parameters in the FlowSystem structure (e.g., <code>on_off_parameters</code> \u2192 <code>status_parameters</code>)</li> <li>Attaches the solution data to the FlowSystem</li> </ul> <pre><code># Load old results\nflow_system = fx.FlowSystem.from_old_results('results_folder', 'my_model')\n\n# Access basic solution data (flow rates, sizes, charge states, etc.)\nflow_system.solution['Boiler(Q_th)|flow_rate'].plot()\n\n# Save in new single-file format\nflow_system.to_netcdf('results/my_model_migrated.nc4')\n</code></pre> <p>Limitations</p> <p>This is a best-effort migration for accessing old results:</p> <ul> <li>Solution variable names are NOT renamed - only basic variables work   (flow rates, sizes, charge states, effect totals)</li> <li>Advanced variable access may require using the original variable names</li> <li>Summary metadata (solver info, timing) is not loaded</li> </ul> <p>For full compatibility, re-run optimizations with the new API.</p>"},{"location":"user-guide/migration-guide-v5/#working-with-xarray-dataset","title":"Working with xarray Dataset","text":"<p>The <code>flow_system.solution</code> is an <code>xarray.Dataset</code>, giving you powerful data manipulation:</p> <pre><code># Access a single variable\ncosts = flow_system.solution['costs']\n\n# Get values as numpy array\nvalues = flow_system.solution['Boiler(Q_th)|flow_rate'].values\n\n# Get scalar value\ntotal = flow_system.solution['costs'].item()\n\n# Sum over time dimension\ntotal_flow = flow_system.solution['Boiler(Q_th)|flow_rate'].sum(dim='time')\n\n# Select by time\nsubset = flow_system.solution.sel(time=slice('2020-01-01', '2020-01-02'))\n\n# Convert to DataFrame\ndf = flow_system.solution.to_dataframe()\n</code></pre>"},{"location":"user-guide/migration-guide-v5/#segmented-clustered-optimization","title":"Segmented &amp; Clustered Optimization","text":""},{"location":"user-guide/migration-guide-v5/#clustered-optimization-migrated","title":"Clustered Optimization (Migrated)","text":"<p>Clustered optimization uses the new transform accessor:</p> v4.x (Old)v5.0.0 (New) <pre><code>calc = fx.ClusteredOptimization('model', flow_system,\n                                 fx.ClusteringParameters(...))\ncalc.do_modeling_and_solve(solver)\nresults = calc.results\n</code></pre> <pre><code># Use transform accessor for clustering\nclustered_fs = flow_system.transform.cluster(fx.ClusteringParameters(...))\nclustered_fs.optimize(solver)\n# Results in clustered_fs.solution\n</code></pre>"},{"location":"user-guide/migration-guide-v5/#segmented-rolling-horizon-optimization","title":"Segmented / Rolling Horizon Optimization","text":"v4.x (Old)v5.0.0 (New) <pre><code>calc = fx.SegmentedOptimization('model', flow_system,\n                                 timesteps_per_segment=96)\ncalc.do_modeling_and_solve(solver)\nresults = calc.results  # Returns SegmentedResults\n</code></pre> <pre><code># Use optimize.rolling_horizon() method\nsegments = flow_system.optimize.rolling_horizon(\n    solver,\n    horizon=96,  # Timesteps per segment\n    overlap=12,  # Lookahead for storage optimization\n)\n# Combined solution on original FlowSystem\nflow_system.solution['costs'].item()\n</code></pre>"},{"location":"user-guide/migration-guide-v5/#statistics-accessor","title":"Statistics Accessor","text":"<p>The new <code>statistics</code> accessor provides convenient aggregated data:</p> <pre><code>stats = flow_system.statistics\n\n# Flow data (clean labels, no |flow_rate suffix)\nstats.flow_rates['Boiler(Q_th)']  # Not 'Boiler(Q_th)|flow_rate'\nstats.flow_hours['Boiler(Q_th)']\nstats.sizes['Boiler(Q_th)']\nstats.charge_states['Battery']\n\n# Effect breakdown by contributor (replaces effects_per_component)\nstats.temporal_effects['costs']  # Per timestep, per contributor\nstats.periodic_effects['costs']  # Investment costs per contributor\nstats.total_effects['costs']     # Total per contributor\n\n# Group by component or component type\nstats.total_effects['costs'].groupby('component').sum()\nstats.total_effects['costs'].groupby('component_type').sum()\n</code></pre>"},{"location":"user-guide/migration-guide-v5/#quick-reference","title":"\ud83d\udd27 Quick Reference","text":""},{"location":"user-guide/migration-guide-v5/#common-conversions","title":"Common Conversions","text":"Old Pattern New Pattern <code>optimization.results.model['costs'].solution.item()</code> <code>flow_system.solution['costs'].item()</code> <code>comp.flow.submodel.flow_rate.solution.values</code> <code>flow_system.solution['Comp(Flow)\\|flow_rate'].values</code> <code>comp.flow.submodel.investment.size.solution.item()</code> <code>flow_system.solution['Comp(Flow)\\|size'].item()</code> <code>comp.flow.submodel.status.status.solution.values</code> <code>flow_system.solution['Comp(Flow)\\|status'].values</code> <code>storage.submodel.charge_state.solution.values</code> <code>flow_system.solution['Storage\\|charge_state'].values</code> <code>effects['CO2'].submodel.total.solution.item()</code> <code>flow_system.solution['CO2'].item()</code>"},{"location":"user-guide/migration-guide-v5/#migration-checklist","title":"\u2705 Migration Checklist","text":"Task Description Replace Optimization class Use <code>flow_system.optimize(solver)</code> instead Update results access Use <code>flow_system.solution['var_name']</code> pattern Update I/O code Use <code>to_netcdf()</code> / <code>from_netcdf()</code> Migrate old result files Use <code>FlowSystem.from_old_results(folder, name)</code> Update transform methods Use <code>flow_system.transform.sel/isel/resample()</code> instead Test thoroughly Verify results match v4.x outputs Remove deprecated imports Remove <code>fx.Optimization</code>, <code>fx.Results</code>"},{"location":"user-guide/migration-guide-v5/#transform-methods-moved-to-accessor","title":"Transform Methods Moved to Accessor","text":"<p>The <code>sel()</code>, <code>isel()</code>, and <code>resample()</code> methods have been moved from <code>FlowSystem</code> to the <code>TransformAccessor</code>:</p> Old (deprecated)New (recommended) <pre><code># These still work but emit deprecation warnings\nfs_subset = flow_system.sel(time=slice('2023-01-01', '2023-06-30'))\nfs_indexed = flow_system.isel(time=slice(0, 24))\nfs_resampled = flow_system.resample(time='4h', method='mean')\n</code></pre> <pre><code># Use the transform accessor\nfs_subset = flow_system.transform.sel(time=slice('2023-01-01', '2023-06-30'))\nfs_indexed = flow_system.transform.isel(time=slice(0, 24))\nfs_resampled = flow_system.transform.resample(time='4h', method='mean')\n</code></pre> <p>Solution is dropped</p> <p>All transform methods return a new FlowSystem without a solution. You must re-optimize the transformed system: <pre><code>fs_subset = flow_system.transform.sel(time=slice('2023-01-01', '2023-01-31'))\nfs_subset.optimize(solver)  # Re-optimize the subset\n</code></pre></p>"},{"location":"user-guide/migration-guide-v5/#deprecation-timeline","title":"Deprecation Timeline","text":"Version Status v4.x <code>Optimization</code> and <code>Results</code> classes available v5.0.0 <code>Optimization</code> and <code>Results</code> deprecated, new API available <p>Update your code</p> <p>The <code>Optimization</code> and <code>Results</code> classes are deprecated and will be removed in a future version. The <code>flow_system.sel()</code>, <code>flow_system.isel()</code>, and <code>flow_system.resample()</code> methods are deprecated in favor of <code>flow_system.transform.sel/isel/resample()</code>. Update your code to the new API to avoid breaking changes when upgrading.</p> <p> Docs \u2022  Issues</p> <p>Welcome to the new flixopt API! \ud83c\udf89</p>"},{"location":"user-guide/migration-guide-v6/","title":"Migration Guide: v5.x \u2192 v6.0.0","text":"<p>Quick Start</p> <p><pre><code>pip install --upgrade flixopt\n</code></pre> v6.0.0 brings tsam v3 integration, faster I/O, and new clustering features. Review this guide to update your code.</p>"},{"location":"user-guide/migration-guide-v6/#overview","title":"Overview","text":"<p>v6.0.0 introduces major improvements to clustering and I/O performance. The key changes are:</p> Aspect Old API (v5.x) New API (v6.0.0) Clustering config Individual parameters <code>ClusterConfig</code>, <code>ExtremeConfig</code> objects Peak forcing <code>time_series_for_high_peaks</code> <code>extremes=ExtremeConfig(max_value=[...])</code> Clustering class <code>ClusteredOptimization</code> (deprecated) <code>flow_system.transform.cluster()</code>"},{"location":"user-guide/migration-guide-v6/#breaking-changes-in-v600","title":"\ud83d\udca5 Breaking Changes in v6.0.0","text":""},{"location":"user-guide/migration-guide-v6/#tsam-v3-api-migration","title":"tsam v3 API Migration","text":"<p>The clustering API now uses tsam v3's configuration objects instead of individual parameters.</p> v5.x (Old)v6.0.0 (New) <pre><code>import flixopt as fx\n\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n    cluster_method='hierarchical',\n    representation_method='medoid',\n    time_series_for_high_peaks=['HeatDemand(Q)|fixed_relative_profile'],\n    time_series_for_low_peaks=['SolarThermal(Q)|fixed_relative_profile'],\n    extreme_period_method='new_cluster',\n)\n</code></pre> <pre><code>import flixopt as fx\nfrom tsam import ClusterConfig, ExtremeConfig\n\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n    cluster=ClusterConfig(\n        method='hierarchical',\n        representation='medoid',\n    ),\n    extremes=ExtremeConfig(\n        method='new_cluster',\n        max_value=['HeatDemand(Q)|fixed_relative_profile'],\n        min_value=['SolarThermal(Q)|fixed_relative_profile'],\n    ),\n)\n</code></pre>"},{"location":"user-guide/migration-guide-v6/#parameter-mapping","title":"Parameter Mapping","text":"Old Parameter (v5.x) New Parameter (v6.0.0) <code>cluster_method</code> <code>cluster=ClusterConfig(method=...)</code> <code>representation_method</code> <code>cluster=ClusterConfig(representation=...)</code> <code>time_series_for_high_peaks</code> <code>extremes=ExtremeConfig(max_value=[...])</code> <code>time_series_for_low_peaks</code> <code>extremes=ExtremeConfig(min_value=[...])</code> <code>extreme_period_method</code> <code>extremes=ExtremeConfig(method=...)</code> <code>predef_cluster_order</code> <code>predef_cluster_assignments</code> <p>tsam Installation</p> <p>v6.0.0 requires tsam with <code>SegmentConfig</code> and <code>ExtremeConfig</code> support. Install with: <pre><code>pip install \"flixopt[full]\"\n</code></pre> This installs the compatible tsam version from the VCS dependency.</p>"},{"location":"user-guide/migration-guide-v6/#removed-clusteredoptimization","title":"Removed: ClusteredOptimization","text":"<p><code>ClusteredOptimization</code> and <code>ClusteringParameters</code> were deprecated in v5.0.0 and are now removed.</p> v4.x/v5.x (Old)v6.0.0 (New) <pre><code>from flixopt import ClusteredOptimization, ClusteringParameters\n\nparams = ClusteringParameters(\n    n_clusters=8,\n    hours_per_cluster=24,\n    cluster_method='hierarchical',\n)\noptimization = ClusteredOptimization('clustered', flow_system, params)\noptimization.do_modeling_and_solve(solver)\n</code></pre> <pre><code>import flixopt as fx\nfrom tsam import ClusterConfig, ExtremeConfig\n\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n    cluster=ClusterConfig(method='hierarchical'),\n    extremes=ExtremeConfig(method='new_cluster', max_value=['Demand|profile']),\n)\nfs_clustered.optimize(solver)\n\n# Expand back to full resolution\nfs_expanded = fs_clustered.transform.expand()\n</code></pre>"},{"location":"user-guide/migration-guide-v6/#scenario-weights-normalization","title":"Scenario Weights Normalization","text":"<p><code>FlowSystem.scenario_weights</code> are now always normalized to sum to 1 when set, including after <code>.sel()</code> subsetting.</p> v5.x (Old)v6.0.0 (New) <pre><code># Weights could be any values\nflow_system.scenario_weights = {'low': 0.3, 'high': 0.7}\n\n# After subsetting, weights were unchanged\nfs_subset = flow_system.sel(scenario='low')\n# fs_subset.scenario_weights might be {'low': 0.3}\n</code></pre> <pre><code># Weights are normalized to sum to 1\nflow_system.scenario_weights = {'low': 0.3, 'high': 0.7}\n\n# After subsetting, weights are renormalized\nfs_subset = flow_system.sel(scenario='low')\n# fs_subset.scenario_weights = {'low': 1.0}\n</code></pre>"},{"location":"user-guide/migration-guide-v6/#new-features-in-v600","title":"\u2728 New Features in v6.0.0","text":""},{"location":"user-guide/migration-guide-v6/#time-series-segmentation","title":"Time-Series Segmentation","text":"<p>New intra-period segmentation reduces timesteps within each cluster:</p> <pre><code>from tsam import SegmentConfig, ExtremeConfig\n\nfs_segmented = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n    segments=SegmentConfig(n_segments=6),  # 6 segments per day instead of 24 hours\n    extremes=ExtremeConfig(method='new_cluster', max_value=['Demand|profile']),\n)\n\n# Variable timestep durations\nprint(fs_segmented.timestep_duration)  # Different duration per segment\n\n# Expand back to original resolution\nfs_expanded = fs_segmented.transform.expand()\n</code></pre> <p>See 08f-Segmentation notebook for details.</p>"},{"location":"user-guide/migration-guide-v6/#io-performance","title":"I/O Performance","text":"<p>2-3x faster NetCDF I/O for large systems:</p> <pre><code># Save - now faster with variable stacking\nflow_system.to_netcdf('system.nc')\n\n# Load - faster DataArray construction\nfs_loaded = fx.FlowSystem.from_netcdf('system.nc')\n\n# Version tracking\nds = flow_system.to_dataset()\nprint(ds.attrs['flixopt_version'])  # e.g., '6.0.0'\n</code></pre>"},{"location":"user-guide/migration-guide-v6/#clustering-inspection","title":"Clustering Inspection","text":"<p>New methods to inspect clustering data before and after:</p> <pre><code># Before clustering: see what data will be used\nclustering_data = flow_system.transform.clustering_data()\nprint(list(clustering_data.data_vars))\n\n# After clustering: access metadata\nfs_clustered.clustering.n_clusters\nfs_clustered.clustering.cluster_assignments\nfs_clustered.clustering.cluster_occurrences\nfs_clustered.clustering.metrics.to_dataframe()\n\n# Visualize\nfs_clustered.clustering.plot.compare()\nfs_clustered.clustering.plot.heatmap()\n</code></pre>"},{"location":"user-guide/migration-guide-v6/#apply-existing-clustering","title":"Apply Existing Clustering","text":"<p>Reuse clustering from one FlowSystem on another:</p> <pre><code># Create reference clustering\nfs_reference = flow_system.transform.cluster(n_clusters=8, cluster_duration='1D')\n\n# Apply same clustering to modified system\nflow_system_modified = flow_system.copy()\nflow_system_modified.components['Storage'].capacity_in_flow_hours.maximum_size = 2000\n\nfs_modified = flow_system_modified.transform.apply_clustering(fs_reference.clustering)\n</code></pre>"},{"location":"user-guide/migration-guide-v6/#migration-checklist","title":"Migration Checklist","text":"<ul> <li> Update <code>transform.cluster()</code> calls to use <code>ClusterConfig</code> and <code>ExtremeConfig</code></li> <li> Replace <code>ClusteredOptimization</code> with <code>transform.cluster()</code> + <code>optimize()</code></li> <li> Replace <code>time_series_for_high_peaks</code> with <code>extremes=ExtremeConfig(max_value=[...])</code></li> <li> Replace <code>cluster_method</code> with <code>cluster=ClusterConfig(method=...)</code></li> <li> Review code that depends on <code>scenario_weights</code> not being normalized</li> <li> Test clustering workflows with new API</li> </ul>"},{"location":"user-guide/migration-guide-v6/#need-help","title":"Need Help?","text":"<ul> <li>Clustering User Guide</li> <li>Clustering Notebooks</li> <li>CHANGELOG</li> <li>GitHub Issues</li> </ul>"},{"location":"user-guide/plotly-customization/","title":"Plotly Customization","text":"<p>flixOpt's plotting is built on Plotly Express. This page covers flixopt-specific customization. For general Plotly knowledge, see:</p> <ul> <li>Plotly Express documentation</li> <li>xarray-plotly package - the <code>.plotly</code> accessor used internally</li> </ul>"},{"location":"user-guide/plotly-customization/#flixopts-theme","title":"flixOpt's Theme","text":"<p>flixOpt registers a <code>'flixopt'</code> Plotly template on import, but doesn't activate it by default:</p> <pre><code>import plotly.io as pio\nimport flixopt as fx\n\n# Template is registered but not active\n'flixopt' in pio.templates  # True\npio.templates.default       # Still 'plotly'\n\n# Activate manually\nfx.CONFIG.use_theme()       # Sets 'plotly_white+flixopt'\n\n# Or via presets (recommended)\nfx.CONFIG.notebook()        # Activates theme + notebook settings\n</code></pre>"},{"location":"user-guide/plotly-customization/#default-slot-assignments","title":"Default Slot Assignments","text":"<p>flixOpt pre-assigns Plotly slots to provide sensible defaults:</p> Plot Type Defaults Balance (bar) <code>x='time'</code>, <code>color='variable'</code> Flows (line) <code>x='time'</code>, <code>color='variable'</code> Comparison <code>facet_col='case'</code> or <code>line_dash='case'</code> <p>Override any default by passing the parameter explicitly:</p> <pre><code># Use animation instead of faceting\nflow_system.statistics.plot.balance('Heat', animation_frame='case', facet_col=None)\n</code></pre>"},{"location":"user-guide/plotly-customization/#common-customizations","title":"Common Customizations","text":""},{"location":"user-guide/plotly-customization/#update-layout","title":"Update Layout","text":"<pre><code>result = flow_system.statistics.plot.balance('Heat')\nresult.figure.update_layout(\n    title='Custom Title',\n    xaxis_title='Time',\n    yaxis_title='Power [kW]',\n    height=500,\n)\n</code></pre>"},{"location":"user-guide/plotly-customization/#update-traces","title":"Update Traces","text":"<pre><code>result.figure.update_traces(opacity=0.8, line_width=2)\n\n# Or target specific traces\nfor trace in result.figure.data:\n    if 'Boiler' in trace.name:\n        trace.line.width = 3\n</code></pre>"},{"location":"user-guide/plotly-customization/#combine-figures","title":"Combine Figures","text":"<pre><code>from plotly.subplots import make_subplots\n\nfig = make_subplots(rows=2, cols=1, shared_xaxes=True)\n\nbalance = flow_system.statistics.plot.balance('Heat', show=False)\nstorage = flow_system.statistics.plot.storage('Tank', show=False)\n\nfor trace in balance.figure.data:\n    fig.add_trace(trace, row=1, col=1)\nfor trace in storage.figure.data:\n    fig.add_trace(trace, row=2, col=1)\n\nfig.show()\n</code></pre>"},{"location":"user-guide/plotly-customization/#plotly-express-parameters","title":"Plotly Express Parameters","text":"<p>These work with most flixOpt plot methods:</p> Parameter Description <code>title</code> Plot title <code>height</code>, <code>width</code> Figure dimensions <code>facet_col_wrap</code> Max columns before wrapping <code>color_discrete_map</code> Dict mapping labels to colors <code>template</code> Plotly template name <pre><code>flow_system.statistics.plot.balance(\n    'Heat',\n    title='Heat Balance',\n    height=400,\n    color_discrete_map={'Boiler(Q_th)': 'red'},\n)\n</code></pre>"},{"location":"user-guide/plotly-customization/#display-control","title":"Display Control","text":"<pre><code># Don't show automatically\nresult = flow_system.statistics.plot.balance('Bus', show=False)\n\n# Show later\nresult.show()\n</code></pre> <p>The default is controlled by <code>CONFIG.Plotting.default_show</code>.</p>"},{"location":"user-guide/results-plotting/","title":"Plotting Results","text":"<p>After solving an optimization, flixOpt provides a plotting API to visualize and analyze your results. The API is designed to be intuitive and chainable, giving you quick access to common plots while still allowing customization.</p> <p>Related Guides</p> <ul> <li>Color Management - Configure colors for components and carriers</li> <li>Plotly Customization - Advanced figure customization</li> <li>Plotting Custom Data - Plot arbitrary xarray data with the <code>.plotly</code> accessor</li> </ul>"},{"location":"user-guide/results-plotting/#quick-start","title":"Quick Start","text":"<p>All plotting is accessed through the <code>statistics.plot</code> accessor:</p> <pre><code>flow_system.optimize(fx.solvers.HighsSolver())\n\nflow_system.statistics.plot.balance('ElectricityBus')\nflow_system.statistics.plot.sankey.flows()\nflow_system.statistics.plot.heatmap('Boiler(Q_th)|flow_rate')\n</code></pre>"},{"location":"user-guide/results-plotting/#plotresult-data-figure","title":"PlotResult: Data + Figure","text":"<p>Every plot method returns a <code>PlotResult</code> containing:</p> <ul> <li><code>data</code>: An xarray Dataset with the prepared data</li> <li><code>figure</code>: A Plotly Figure object</li> </ul> <pre><code>result = flow_system.statistics.plot.balance('Bus')\n\n# Access the data\nresult.data.to_dataframe()\nresult.data.to_netcdf('balance_data.nc')\n\n# Access the figure\nresult.figure.update_layout(title='Custom Title')\nresult.figure.show()\n</code></pre>"},{"location":"user-guide/results-plotting/#method-chaining","title":"Method Chaining","text":"<p>All <code>PlotResult</code> methods return <code>self</code>, enabling fluent chaining:</p> <pre><code>flow_system.statistics.plot.balance('Bus') \\\n    .update(title='Custom Title', height=600) \\\n    .to_html('plot.html') \\\n    .show()\n</code></pre> Method Description <code>.show()</code> Display the figure <code>.update(**kwargs)</code> Update figure layout <code>.update_traces(**kwargs)</code> Update trace properties <code>.to_html(path)</code> Save as interactive HTML <code>.to_image(path)</code> Save as static image (png, svg, pdf) <code>.to_csv(path)</code> Export data to CSV <code>.to_netcdf(path)</code> Export data to netCDF"},{"location":"user-guide/results-plotting/#available-plot-methods","title":"Available Plot Methods","text":""},{"location":"user-guide/results-plotting/#balance-plot","title":"Balance Plot","text":"<p>Plot the energy/material balance at a Bus or Component:</p> <pre><code>flow_system.statistics.plot.balance('ElectricityBus')\nflow_system.statistics.plot.balance('Boiler', mode='area')\n</code></pre> Parameter Type Description <code>node</code> str Label of the Bus or Component <code>mode</code> <code>'bar'</code>, <code>'line'</code>, <code>'area'</code> Visual style (default: <code>'bar'</code>) <code>unit</code> <code>'flow_rate'</code>, <code>'flow_hours'</code> Power (kW) or energy (kWh) <code>include</code> / <code>exclude</code> str or list Filter flows by exact label <code>aggregate</code> <code>'sum'</code>, <code>'mean'</code>, <code>'max'</code>, <code>'min'</code> Aggregate over time <code>select</code> dict xarray-style data selection"},{"location":"user-guide/results-plotting/#storage-plot","title":"Storage Plot","text":"<p>Visualize storage components with charge state and flow balance:</p> <pre><code>flow_system.statistics.plot.storage('Battery')\nflow_system.statistics.plot.storage('ThermalStorage', mode='line')\n</code></pre>"},{"location":"user-guide/results-plotting/#heatmap","title":"Heatmap","text":"<p>Create heatmaps of time series data with automatic time reshaping:</p> <pre><code>flow_system.statistics.plot.heatmap('Boiler(Q_th)|flow_rate')\nflow_system.statistics.plot.heatmap(['CHP|on', 'Boiler|on'], facet_col='variable')\n</code></pre> Parameter Type Description <code>variables</code> str or list Variable name(s) to plot <code>reshape</code> tuple Time pattern: <code>('D', 'h')</code> days\u00d7hours, <code>('W', 'D')</code> weeks\u00d7days <code>colorscale</code> str Plotly colorscale name"},{"location":"user-guide/results-plotting/#flows-plot","title":"Flows Plot","text":"<p>Plot flow rates filtered by nodes or components:</p> <pre><code>flow_system.statistics.plot.flows(component='Boiler')\nflow_system.statistics.plot.flows(start='ElectricityBus')\nflow_system.statistics.plot.flows(unit='flow_hours', aggregate='sum')\n</code></pre>"},{"location":"user-guide/results-plotting/#compare-plot","title":"Compare Plot","text":"<p>Compare multiple elements side-by-side:</p> <pre><code>flow_system.statistics.plot.compare(['Boiler', 'CHP', 'HeatPump'], variable='flow_rate')\nflow_system.statistics.plot.compare(['Battery1', 'Battery2'], variable='charge_state')\n</code></pre>"},{"location":"user-guide/results-plotting/#sankey-diagram","title":"Sankey Diagram","text":"<p>Visualize energy/material flows as a Sankey diagram:</p> <pre><code>flow_system.statistics.plot.sankey.flows()           # Energy amounts\nflow_system.statistics.plot.sankey.sizes()           # Investment sizes\nflow_system.statistics.plot.sankey.peak_flow()       # Maximum rates\nflow_system.statistics.plot.sankey.effects()         # Cost/emission breakdown\n</code></pre> <p>Filter with <code>select</code>:</p> <pre><code>flow_system.statistics.plot.sankey.flows(select={'bus': 'HeatBus'})\nflow_system.statistics.plot.sankey.effects(select={'effect': 'costs'})\n</code></pre>"},{"location":"user-guide/results-plotting/#effects-plot","title":"Effects Plot","text":"<p>Plot cost, emissions, or other effect breakdowns:</p> <pre><code>flow_system.statistics.plot.effects()                          # Total by component\nflow_system.statistics.plot.effects(effect='costs')            # Just costs\nflow_system.statistics.plot.effects(by='contributor')          # By individual flows\nflow_system.statistics.plot.effects(aspect='temporal')         # Over time\n</code></pre> Parameter Type Description <code>aspect</code> <code>'total'</code>, <code>'temporal'</code>, <code>'periodic'</code> Which aspect to plot <code>effect</code> str or None Specific effect (e.g., <code>'costs'</code>) or all <code>by</code> <code>'component'</code>, <code>'contributor'</code>, <code>'time'</code> Grouping dimension"},{"location":"user-guide/results-plotting/#variable-plot","title":"Variable Plot","text":"<p>Plot the same variable type across multiple elements:</p> <pre><code>flow_system.statistics.plot.variable('on')              # All binary states\nflow_system.statistics.plot.variable('flow_rate', include='Boiler')\nflow_system.statistics.plot.variable('charge_state')    # All storage states\n</code></pre>"},{"location":"user-guide/results-plotting/#duration-curve","title":"Duration Curve","text":"<p>Plot load duration curves (sorted time series):</p> <pre><code>flow_system.statistics.plot.duration_curve('Boiler(Q_th)')\nflow_system.statistics.plot.duration_curve(['CHP(Q_th)', 'HeatPump(Q_th)'])\nflow_system.statistics.plot.duration_curve('Demand(in)', normalize=True)\n</code></pre>"},{"location":"user-guide/results-plotting/#common-parameters","title":"Common Parameters","text":""},{"location":"user-guide/results-plotting/#data-selection","title":"Data Selection","text":"<p>Use xarray-style selection to filter data:</p> <pre><code># Single value\nflow_system.statistics.plot.balance('Bus', select={'scenario': 'base'})\n\n# Time slice\nflow_system.statistics.plot.balance('Bus', select={'time': slice('2024-01', '2024-06')})\n\n# Combined\nflow_system.statistics.plot.balance('Bus', select={\n    'scenario': 'base',\n    'time': slice('2024-01-01', '2024-01-07')\n})\n</code></pre>"},{"location":"user-guide/results-plotting/#faceting-and-animation","title":"Faceting and Animation","text":"<p>Control how multi-dimensional data is displayed:</p> <pre><code>flow_system.statistics.plot.balance('Bus', facet_col='scenario')\nflow_system.statistics.plot.balance('Bus', animate_by='period')\n</code></pre>"},{"location":"user-guide/results-plotting/#includeexclude-filtering","title":"Include/Exclude Filtering","text":"<p>Filter flows by exact label:</p> <pre><code># Include only specific flows\nflow_system.statistics.plot.balance('Bus', include=['Boiler(Q_th)', 'CHP(Q_th)'])\n\n# Exclude specific flows\nflow_system.statistics.plot.balance('Bus', exclude='GridImport(P_el)')\n</code></pre>"},{"location":"user-guide/results-plotting/#colors","title":"Colors","text":"<p>Override colors using a dictionary:</p> <pre><code>flow_system.statistics.plot.balance('Bus', colors={\n    'Boiler(Q_th)': '#ff6b6b',\n    'CHP(Q_th)': '#4ecdc4',\n})\n</code></pre> <p>See Color Management for configuring colors system-wide.</p>"},{"location":"user-guide/results-plotting/#examples","title":"Examples","text":""},{"location":"user-guide/results-plotting/#analyzing-a-bus-balance","title":"Analyzing a Bus Balance","text":"<pre><code># Quick overview\nflow_system.statistics.plot.balance('ElectricityBus')\n\n# Detailed analysis with exports\nresult = flow_system.statistics.plot.balance(\n    'ElectricityBus',\n    mode='area',\n    unit='flow_hours',\n    select={'time': slice('2024-06-01', '2024-06-07')},\n    show=False\n)\n\n# Export data\nresult.to_netcdf('electricity_balance.nc')\nresult.to_csv('electricity_balance.csv')\n\n# Customize and display\nresult.update(\n    title='Electricity Balance - First Week of June',\n    yaxis_title='Energy [kWh]'\n).show()\n</code></pre>"},{"location":"user-guide/results-plotting/#creating-a-report","title":"Creating a Report","text":"<pre><code>plots = {\n    'balance': flow_system.statistics.plot.balance('HeatBus', show=False),\n    'storage': flow_system.statistics.plot.storage('ThermalStorage', show=False),\n    'sankey': flow_system.statistics.plot.sankey.flows(show=False),\n    'costs': flow_system.statistics.plot.effects(effect='costs', show=False),\n}\n\nfor name, plot in plots.items():\n    plot.to_html(f'report_{name}.html')\n</code></pre>"},{"location":"user-guide/results-plotting/#working-with-xarray-data","title":"Working with xarray Data","text":"<pre><code>result = flow_system.statistics.plot.balance('Bus', show=False)\nds = result.data\n\n# Use xarray operations\nds.mean(dim='time')\nds.sel(time='2024-06')\nds.to_dataframe()\n</code></pre>"},{"location":"user-guide/support/","title":"Support","text":""},{"location":"user-guide/support/#getting-help","title":"Getting Help","text":"<p>GitHub Issues \u2014 Report bugs or ask questions</p> <p>When opening an issue, include:</p> <ul> <li>Minimal reproducible example</li> <li>flixOpt version: <code>python -c \"import flixopt; print(flixopt.__version__)\"</code></li> <li>Python version and OS</li> <li>Full error message</li> </ul>"},{"location":"user-guide/support/#resources","title":"Resources","text":"<ul> <li>FAQ \u2014 Common questions</li> <li>Troubleshooting \u2014 Common issues</li> <li>Examples \u2014 Working code</li> <li>API Reference \u2014 Technical docs</li> </ul>"},{"location":"user-guide/support/#contributing","title":"Contributing","text":"<p>See our Contributing Guide for how to help improve flixOpt.</p>"},{"location":"user-guide/troubleshooting/","title":"Troubleshooting","text":""},{"location":"user-guide/troubleshooting/#infeasible-model","title":"Infeasible Model","text":"<p>Problem: Solver reports the model is infeasible.</p> <p>Solutions:</p> <ol> <li>Check that supply can meet demand at all timesteps</li> <li>Verify capacity limits are sufficient</li> <li>Review storage initial/final states</li> </ol>"},{"location":"user-guide/troubleshooting/#unbounded-model","title":"Unbounded Model","text":"<p>Problem: Solver reports the model is unbounded.</p> <p>Solutions:</p> <ol> <li>Add upper bounds to all flows</li> <li>Ensure investment parameters have maximum sizes</li> <li>Verify effect coefficients have correct signs</li> </ol>"},{"location":"user-guide/troubleshooting/#unexpected-results","title":"Unexpected Results","text":"<p>Debugging Steps:</p> <ol> <li> <p>Enable logging:    <pre><code>from flixopt import CONFIG\nCONFIG.exploring()\n</code></pre></p> </li> <li> <p>Start with a minimal model and add complexity incrementally</p> </li> <li> <p>Check units are consistent</p> </li> <li> <p>Visualize results to verify energy balances</p> </li> </ol>"},{"location":"user-guide/troubleshooting/#slow-solve-times","title":"Slow Solve Times","text":"<p>Solutions:</p> <ol> <li>Use longer timesteps or aggregate time periods</li> <li>Use Gurobi instead of HiGHS for large models</li> <li>Set solver options:    <pre><code>solver = fx.solvers.GurobiSolver(\n    time_limit_seconds=3600,\n    mip_gap=0.01\n)\n</code></pre></li> </ol>"},{"location":"user-guide/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're stuck:</p> <ol> <li>Search GitHub Issues</li> <li>Open a new issue with:</li> <li>Minimal reproducible example</li> <li>flixopt and Python version</li> <li>Full error message</li> </ol>"},{"location":"user-guide/building-models/","title":"Building Models","text":"<p>This guide walks you through constructing FlowSystem models step by step. By the end, you'll understand how to translate real-world energy systems into flixOpt models.</p>"},{"location":"user-guide/building-models/#overview","title":"Overview","text":"<p>Building a model follows a consistent pattern:</p> <pre><code>import pandas as pd\nimport flixopt as fx\n\n# 1. Define time horizon\ntimesteps = pd.date_range('2024-01-01', periods=24, freq='h')\n\n# 2. Create the FlowSystem\nflow_system = fx.FlowSystem(timesteps)\n\n# 3. Add elements\nflow_system.add_elements(\n    # Buses, Components, Effects...\n)\n\n# 4. Optimize\nflow_system.optimize(fx.solvers.HighsSolver())\n</code></pre>"},{"location":"user-guide/building-models/#step-1-define-your-time-horizon","title":"Step 1: Define Your Time Horizon","text":"<p>Every FlowSystem needs a time definition. Use pandas DatetimeIndex:</p> <pre><code># Hourly data for one week\ntimesteps = pd.date_range('2024-01-01', periods=168, freq='h')\n\n# 15-minute intervals for one day\ntimesteps = pd.date_range('2024-01-01', periods=96, freq='15min')\n\n# Custom timestamps (e.g., from your data)\ntimesteps = pd.DatetimeIndex(your_data.index)\n</code></pre> <p>Time Resolution</p> <p>Higher resolution (more timesteps) gives more accurate results but increases computation time. Start with hourly data and refine if needed.</p>"},{"location":"user-guide/building-models/#step-2-create-buses","title":"Step 2: Create Buses","text":"<p>Buses are connection points where energy flows meet. Every bus enforces a balance: inputs = outputs.</p> <pre><code># Basic buses\nheat_bus = fx.Bus('Heat')\nelectricity_bus = fx.Bus('Electricity')\n\n# With carrier (enables automatic coloring in plots)\nheat_bus = fx.Bus('Heat', carrier='heat')\ngas_bus = fx.Bus('Gas', carrier='gas')\n</code></pre>"},{"location":"user-guide/building-models/#when-to-create-a-bus","title":"When to Create a Bus","text":"Scenario Bus Needed? Multiple components share a resource Yes Need to track balance at a location Yes Component has external input (grid, fuel) Often no - use <code>bus=None</code> Component transforms A \u2192 B Yes, one bus per carrier"},{"location":"user-guide/building-models/#bus-balance-modes","title":"Bus Balance Modes","text":"<p>By default, buses require exact balance. For systems with unavoidable imbalances:</p> <pre><code># Allow small imbalances with penalty\nheat_bus = fx.Bus(\n    'Heat',\n    imbalance_penalty_per_flow_hour=1000,  # High cost discourages imbalance\n)\n</code></pre>"},{"location":"user-guide/building-models/#step-3-add-components","title":"Step 3: Add Components","text":"<p>Components are the equipment in your system. Choose based on function:</p>"},{"location":"user-guide/building-models/#sources-external-inputs","title":"Sources \u2014 External Inputs","text":"<p>Use for purchasing energy or materials from outside:</p> <pre><code># Grid electricity with time-varying price\ngrid = fx.Source(\n    'Grid',\n    outputs=[fx.Flow('Elec', bus='Electricity', size=1000, effects_per_flow_hour=price_profile)]\n)\n\n# Natural gas with fixed price\ngas_supply = fx.Source(\n    'GasSupply',\n    outputs=[fx.Flow('Gas', bus='Gas', size=500, effects_per_flow_hour=0.05)]\n)\n</code></pre>"},{"location":"user-guide/building-models/#sinks-demands","title":"Sinks \u2014 Demands","text":"<p>Use for consuming energy or materials (demands, exports):</p> <pre><code># Heat demand (must be met exactly)\nbuilding = fx.Sink(\n    'Building',\n    inputs=[fx.Flow('Heat', bus='Heat', size=1, fixed_relative_profile=demand_profile)]\n)\n\n# Optional export (can sell but not required)\nexport = fx.Sink(\n    'Export',\n    inputs=[fx.Flow('Elec', bus='Electricity', size=100, effects_per_flow_hour=-0.15)]  # Negative = revenue\n)\n</code></pre>"},{"location":"user-guide/building-models/#linearconverter-transformations","title":"LinearConverter \u2014 Transformations","text":"<p>Use for converting one form of energy to another:</p> <pre><code># Gas boiler: Gas \u2192 Heat\nboiler = fx.LinearConverter(\n    'Boiler',\n    inputs=[fx.Flow('Gas', bus='Gas', size=500)],\n    outputs=[fx.Flow('Heat', bus='Heat', size=450)],\n    conversion_factors=[{'Gas': 1, 'Heat': 0.9}],  # 90% efficiency\n)\n\n# Heat pump: Electricity \u2192 Heat\nheat_pump = fx.LinearConverter(\n    'HeatPump',\n    inputs=[fx.Flow('Elec', bus='Electricity', size=100)],\n    outputs=[fx.Flow('Heat', bus='Heat', size=350)],\n    conversion_factors=[{'Elec': 1, 'Heat': 3.5}],  # COP = 3.5\n)\n\n# CHP: Gas \u2192 Electricity + Heat (multiple outputs)\nchp = fx.LinearConverter(\n    'CHP',\n    inputs=[fx.Flow('Gas', bus='Gas', size=300)],\n    outputs=[\n        fx.Flow('Elec', bus='Electricity', size=100),\n        fx.Flow('Heat', bus='Heat', size=150),\n    ],\n    conversion_factors=[{'Gas': 1, 'Elec': 0.35, 'Heat': 0.50}],\n)\n</code></pre>"},{"location":"user-guide/building-models/#storage-time-shifting","title":"Storage \u2014 Time-Shifting","text":"<p>Use for storing energy or materials:</p> <pre><code># Thermal storage\ntank = fx.Storage(\n    'ThermalTank',\n    charging=fx.Flow('charge', bus='Heat', size=200),\n    discharging=fx.Flow('discharge', bus='Heat', size=200),\n    capacity_in_flow_hours=10,  # 10 hours at full charge/discharge rate\n    eta_charge=0.95,\n    eta_discharge=0.95,\n    relative_loss_per_hour=0.01,  # 1% loss per hour\n    initial_charge_state=0.5,  # Start 50% full\n)\n</code></pre>"},{"location":"user-guide/building-models/#transmission-transport-between-locations","title":"Transmission \u2014 Transport Between Locations","text":"<p>Use for connecting different locations:</p> <pre><code># District heating pipe\npipe = fx.Transmission(\n    'HeatPipe',\n    in1=fx.Flow('from_A', bus='Heat_A', size=200),\n    out1=fx.Flow('to_B', bus='Heat_B', size=200),\n    relative_losses=0.05,  # 5% loss\n)\n</code></pre>"},{"location":"user-guide/building-models/#step-4-configure-effects","title":"Step 4: Configure Effects","text":"<p>Effects track metrics like costs, emissions, or energy use. One must be the objective:</p> <pre><code># Operating costs (minimize this)\ncosts = fx.Effect(\n    'costs',\n    '\u20ac',\n    'Operating Costs',\n    is_standard=True,  # Included by default in all effect allocations\n    is_objective=True,  # This is what we minimize\n)\n\n# CO2 emissions (track or constrain)\nco2 = fx.Effect(\n    'CO2',\n    'kg',\n    'CO2 Emissions',\n    maximum_temporal=1000,  # Constraint: max 1000 kg total\n)\n</code></pre>"},{"location":"user-guide/building-models/#linking-effects-to-flows","title":"Linking Effects to Flows","text":"<p>Effects are typically assigned per flow hour:</p> <pre><code># Gas costs 0.05 \u20ac/kWh\nfx.Flow('Gas', bus='Gas', size=500, effects_per_flow_hour={'costs': 0.05, 'CO2': 0.2})\n\n# Shorthand when only one effect (the standard one)\nfx.Flow('Gas', bus='Gas', size=500, effects_per_flow_hour=0.05)\n</code></pre>"},{"location":"user-guide/building-models/#step-5-add-everything-to-flowsystem","title":"Step 5: Add Everything to FlowSystem","text":"<p>Use <code>add_elements()</code> with all elements:</p> <pre><code>flow_system = fx.FlowSystem(timesteps)\n\nflow_system.add_elements(\n    # Buses\n    fx.Bus('Heat', carrier='heat'),\n    fx.Bus('Gas', carrier='gas'),\n\n    # Effects\n    fx.Effect('costs', '\u20ac', is_standard=True, is_objective=True),\n\n    # Components\n    fx.Source('GasGrid', outputs=[fx.Flow('Gas', bus='Gas', size=500, effects_per_flow_hour=0.05)]),\n    fx.LinearConverter(\n        'Boiler',\n        inputs=[fx.Flow('Gas', bus='Gas', size=500)],\n        outputs=[fx.Flow('Heat', bus='Heat', size=450)],\n        conversion_factors=[{'Gas': 1, 'Heat': 0.9}],\n    ),\n    fx.Sink('Building', inputs=[fx.Flow('Heat', bus='Heat', size=1, fixed_relative_profile=demand)]),\n)\n</code></pre>"},{"location":"user-guide/building-models/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/building-models/#pattern-1-simple-conversion-system","title":"Pattern 1: Simple Conversion System","text":"<p>Gas \u2192 Boiler \u2192 Heat</p> <pre><code>flow_system.add_elements(\n    fx.Bus('Heat'),\n    fx.Effect('costs', '\u20ac', is_standard=True, is_objective=True),\n    fx.Source('Gas', outputs=[fx.Flow('gas', bus=None, size=500, effects_per_flow_hour=0.05)]),\n    fx.LinearConverter(\n        'Boiler',\n        inputs=[fx.Flow('gas', bus=None, size=500)],  # Inline source\n        outputs=[fx.Flow('heat', bus='Heat', size=450)],\n        conversion_factors=[{'gas': 1, 'heat': 0.9}],\n    ),\n    fx.Sink('Demand', inputs=[fx.Flow('heat', bus='Heat', size=1, fixed_relative_profile=demand)]),\n)\n</code></pre>"},{"location":"user-guide/building-models/#pattern-2-multiple-generation-options","title":"Pattern 2: Multiple Generation Options","text":"<p>Choose between boiler, heat pump, or both:</p> <pre><code>flow_system.add_elements(\n    fx.Bus('Heat'),\n    fx.Effect('costs', '\u20ac', is_standard=True, is_objective=True),\n\n    # Option 1: Gas boiler (cheap gas, moderate efficiency)\n    fx.LinearConverter('Boiler', ...),\n\n    # Option 2: Heat pump (expensive electricity, high efficiency)\n    fx.LinearConverter('HeatPump', ...),\n\n    # Demand\n    fx.Sink('Building', ...),\n)\n</code></pre> <p>The optimizer chooses the cheapest mix at each timestep.</p>"},{"location":"user-guide/building-models/#pattern-3-system-with-storage","title":"Pattern 3: System with Storage","text":"<p>Add flexibility through storage:</p> <pre><code>flow_system.add_elements(\n    fx.Bus('Heat'),\n    fx.Effect('costs', '\u20ac', is_standard=True, is_objective=True),\n\n    # Generation\n    fx.LinearConverter('Boiler', ...),\n\n    # Storage (can shift load in time)\n    fx.Storage('Tank', ...),\n\n    # Demand\n    fx.Sink('Building', ...),\n)\n</code></pre>"},{"location":"user-guide/building-models/#component-selection-guide","title":"Component Selection Guide","text":"I need to... Use this component Buy/import energy <code>Source</code> Sell/export energy <code>Sink</code> with negative effects Meet a demand <code>Sink</code> with <code>fixed_relative_profile</code> Convert energy type <code>LinearConverter</code> Store energy <code>Storage</code> Transport between sites <code>Transmission</code> Model combined heat &amp; power <code>LinearConverter</code> with multiple outputs <p>For detailed component selection, see Choosing Components.</p>"},{"location":"user-guide/building-models/#input-data-types","title":"Input Data Types","text":"<p>flixOpt accepts various data formats for parameters:</p> Input Type Example Use Case Scalar <code>0.05</code> Constant value NumPy array <code>np.array([...])</code> Time-varying, matches timesteps Pandas Series <code>pd.Series([...], index=timesteps)</code> Time-varying with labels TimeSeriesData <code>fx.TimeSeriesData(...)</code> Advanced: aggregation metadata <pre><code># All equivalent for a constant efficiency\nefficiency = 0.9\nefficiency = np.full(len(timesteps), 0.9)\nefficiency = pd.Series(0.9, index=timesteps)\n\n# Time-varying price\nprice = np.where(hour_of_day &gt;= 8, 0.25, 0.10)\n</code></pre>"},{"location":"user-guide/building-models/#debugging-tips","title":"Debugging Tips","text":""},{"location":"user-guide/building-models/#check-bus-balance","title":"Check Bus Balance","text":"<p>If optimization fails with infeasibility:</p> <ol> <li>Ensure demands can be met by available generation</li> <li>Check that flow sizes are large enough</li> <li>Add <code>imbalance_penalty_per_flow_hour</code> to identify problematic buses</li> </ol>"},{"location":"user-guide/building-models/#verify-element-registration","title":"Verify Element Registration","text":"<pre><code># List all elements\nprint(flow_system.components.keys())\nprint(flow_system.buses.keys())\nprint(flow_system.effects.keys())\n</code></pre>"},{"location":"user-guide/building-models/#inspect-model-before-solving","title":"Inspect Model Before Solving","text":"<pre><code>flow_system.build_model()\nprint(f\"Variables: {len(flow_system.model.variables)}\")\nprint(f\"Constraints: {len(flow_system.model.constraints)}\")\n</code></pre>"},{"location":"user-guide/building-models/#next-steps","title":"Next Steps","text":"<ul> <li>Choosing Components \u2014 Decision tree for component selection</li> <li>Core Concepts \u2014 Deeper understanding of fundamentals</li> <li>Examples \u2014 Working code examples</li> <li>Mathematical Notation \u2014 Detailed constraint formulations</li> </ul>"},{"location":"user-guide/building-models/choosing-components/","title":"Choosing Components","text":"<p>This guide helps you select the right flixOpt component for your modeling needs.</p>"},{"location":"user-guide/building-models/choosing-components/#decision-tree","title":"Decision Tree","text":"<pre><code>graph TD\n    A[What does this element do?] --&gt; B{Brings energy INTO system?}\n    B --&gt;|Yes| C[Source]\n    B --&gt;|No| D{Takes energy OUT of system?}\n    D --&gt;|Yes| E[Sink]\n    D --&gt;|No| F{Converts energy type?}\n    F --&gt;|Yes| G[LinearConverter]\n    F --&gt;|No| H{Stores energy?}\n    H --&gt;|Yes| I[Storage]\n    H --&gt;|No| J{Transports between locations?}\n    J --&gt;|Yes| K[Transmission]\n    J --&gt;|No| L[Consider custom constraints]</code></pre>"},{"location":"user-guide/building-models/choosing-components/#component-comparison","title":"Component Comparison","text":"Component Purpose Inputs Outputs Key Parameters Source External supply None 1+ flows <code>effects_per_flow_hour</code> Sink Demand/export 1+ flows None <code>fixed_relative_profile</code> SourceAndSink Bidirectional exchange 1+ flows 1+ flows Both input and output LinearConverter Transform energy 1+ flows 1+ flows <code>conversion_factors</code> Storage Time-shift energy charge flow discharge flow <code>capacity_in_flow_hours</code> Transmission Transport energy in1, in2 out1, out2 <code>relative_losses</code>"},{"location":"user-guide/building-models/choosing-components/#detailed-component-guide","title":"Detailed Component Guide","text":""},{"location":"user-guide/building-models/choosing-components/#source","title":"Source","text":"<p>Use when: Purchasing or importing energy/material from outside your system boundary.</p> <pre><code>fx.Source(\n    'GridElectricity',\n    outputs=[fx.Flow('Elec', bus='Electricity', size=1000, effects_per_flow_hour=0.25)]\n)\n</code></pre> <p>Typical applications: - Grid electricity connection - Natural gas supply - Raw material supply - Fuel delivery</p> <p>Key parameters:</p> Parameter Purpose <code>outputs</code> List of flows leaving this source <code>effects_per_flow_hour</code> Cost/emissions per unit <code>invest_parameters</code> For optimizing connection capacity"},{"location":"user-guide/building-models/choosing-components/#sink","title":"Sink","text":"<p>Use when: Energy/material leaves your system (demand, export, waste).</p> <pre><code># Fixed demand (must be met)\nfx.Sink(\n    'Building',\n    inputs=[fx.Flow('Heat', bus='Heat', size=1, fixed_relative_profile=demand)]\n)\n\n# Optional export (can sell if profitable)\nfx.Sink(\n    'Export',\n    inputs=[fx.Flow('Elec', bus='Electricity', size=100, effects_per_flow_hour=-0.15)]\n)\n</code></pre> <p>Typical applications: - Heat/electricity demand - Product output - Grid export - Waste disposal</p> <p>Key parameters:</p> Parameter Purpose <code>inputs</code> List of flows entering this sink <code>fixed_relative_profile</code> Demand profile (on flow) <code>effects_per_flow_hour</code> Negative = revenue"},{"location":"user-guide/building-models/choosing-components/#sourceandsink","title":"SourceAndSink","text":"<p>Use when: Bidirectional exchange at a single point (buy AND sell from same connection).</p> <pre><code>fx.SourceAndSink(\n    'GridConnection',\n    inputs=[fx.Flow('import', bus='Electricity', size=500, effects_per_flow_hour=0.25)],\n    outputs=[fx.Flow('export', bus='Electricity', size=500, effects_per_flow_hour=-0.15)],\n    prevent_simultaneous_flow_rates=True,  # Can't buy and sell at same time\n)\n</code></pre> <p>Typical applications: - Electricity grid (buy/sell) - Gas grid with injection capability - Material exchange with warehouse</p>"},{"location":"user-guide/building-models/choosing-components/#linearconverter","title":"LinearConverter","text":"<p>Use when: Transforming one energy type to another with a linear relationship.</p> <pre><code># Single input, single output\nfx.LinearConverter(\n    'Boiler',\n    inputs=[fx.Flow('Gas', bus='Gas', size=500)],\n    outputs=[fx.Flow('Heat', bus='Heat', size=450)],\n    conversion_factors=[{'Gas': 1, 'Heat': 0.9}],\n)\n\n# Multiple outputs (CHP)\nfx.LinearConverter(\n    'CHP',\n    inputs=[fx.Flow('Gas', bus='Gas', size=300)],\n    outputs=[\n        fx.Flow('Elec', bus='Electricity', size=100),\n        fx.Flow('Heat', bus='Heat', size=150),\n    ],\n    conversion_factors=[{'Gas': 1, 'Elec': 0.35, 'Heat': 0.50}],\n)\n\n# Multiple inputs\nfx.LinearConverter(\n    'CoFiringBoiler',\n    inputs=[\n        fx.Flow('Gas', bus='Gas', size=200),\n        fx.Flow('Biomass', bus='Biomass', size=100),\n    ],\n    outputs=[fx.Flow('Heat', bus='Heat', size=270)],\n    conversion_factors=[{'Gas': 1, 'Biomass': 1, 'Heat': 0.9}],\n)\n</code></pre> <p>Typical applications: - Boilers (fuel \u2192 heat) - Heat pumps (electricity \u2192 heat) - Chillers (electricity \u2192 cooling) - Turbines (fuel \u2192 electricity) - CHPs (fuel \u2192 electricity + heat) - Electrolyzers (electricity \u2192 hydrogen)</p> <p>Key parameters:</p> Parameter Purpose <code>conversion_factors</code> Efficiency relationship <code>piecewise_conversion</code> Non-linear efficiency curve <code>status_parameters</code> On/off behavior, startup costs"},{"location":"user-guide/building-models/choosing-components/#pre-built-converters","title":"Pre-built Converters","text":"<p>flixOpt includes ready-to-use converters in <code>flixopt.linear_converters</code>:</p> Class Description Key Parameters <code>Boiler</code> Fuel \u2192 Heat <code>thermal_efficiency</code> <code>HeatPump</code> Electricity \u2192 Heat <code>cop</code> <code>HeatPumpWithSource</code> Elec + Ambient \u2192 Heat <code>cop</code>, source flow <code>CHP</code> Fuel \u2192 Elec + Heat <code>electrical_efficiency</code>, <code>thermal_efficiency</code> <code>Chiller</code> Electricity \u2192 Cooling <code>cop</code> <pre><code>from flixopt.linear_converters import Boiler, HeatPump\n\nboiler = Boiler(\n    'GasBoiler',\n    thermal_efficiency=0.92,\n    fuel_flow=fx.Flow('gas', bus='Gas', size=500, effects_per_flow_hour=0.05),\n    thermal_flow=fx.Flow('heat', bus='Heat', size=460),\n)\n</code></pre>"},{"location":"user-guide/building-models/choosing-components/#storage","title":"Storage","text":"<p>Use when: Storing energy for later use.</p> <pre><code>fx.Storage(\n    'Battery',\n    charging=fx.Flow('charge', bus='Electricity', size=100),\n    discharging=fx.Flow('discharge', bus='Electricity', size=100),\n    capacity_in_flow_hours=4,  # 4 hours at full rate = 400 kWh\n    eta_charge=0.95,\n    eta_discharge=0.95,\n    relative_loss_per_hour=0.001,\n    initial_charge_state=0.5,\n)\n</code></pre> <p>Typical applications: - Batteries (electrical) - Thermal tanks (heat/cold) - Hydrogen storage - Material buffers</p> <p>Key parameters:</p> Parameter Purpose <code>charging</code>, <code>discharging</code> Flows for in/out <code>capacity_in_flow_hours</code> Size (or use <code>InvestParameters</code>) <code>eta_charge</code>, <code>eta_discharge</code> Round-trip efficiency <code>relative_loss_per_hour</code> Standing losses <code>initial_charge_state</code> Starting level (0-1 or <code>'equals_final'</code>)"},{"location":"user-guide/building-models/choosing-components/#transmission","title":"Transmission","text":"<p>Use when: Transporting energy between different locations.</p> <pre><code># Unidirectional\nfx.Transmission(\n    'HeatPipe',\n    in1=fx.Flow('from_A', bus='Heat_A', size=200),\n    out1=fx.Flow('to_B', bus='Heat_B', size=200),\n    relative_losses=0.05,\n)\n\n# Bidirectional\nfx.Transmission(\n    'PowerLine',\n    in1=fx.Flow('A_to_B', bus='Elec_A', size=100),\n    out1=fx.Flow('at_B', bus='Elec_B', size=100),\n    in2=fx.Flow('B_to_A', bus='Elec_B', size=100),\n    out2=fx.Flow('at_A', bus='Elec_A', size=100),\n    relative_losses=0.03,\n    prevent_simultaneous_flows_in_both_directions=True,\n)\n</code></pre> <p>Typical applications: - District heating pipes - Power transmission lines - Gas pipelines - Conveyor belts</p> <p>Key parameters:</p> Parameter Purpose <code>in1</code>, <code>out1</code> Primary direction flows <code>in2</code>, <code>out2</code> Reverse direction (optional) <code>relative_losses</code> Proportional losses <code>absolute_losses</code> Fixed losses when active <code>balanced</code> Same capacity both ways"},{"location":"user-guide/building-models/choosing-components/#feature-combinations","title":"Feature Combinations","text":""},{"location":"user-guide/building-models/choosing-components/#investment-optimization","title":"Investment Optimization","text":"<p>Add <code>InvestParameters</code> to flows to let the optimizer choose sizes:</p> <pre><code>fx.Flow(\n    'Heat',\n    bus='Heat',\n    invest_parameters=fx.InvestParameters(\n        effects_of_investment_per_size={'costs': 100},  # \u20ac/kW\n        minimum_size=0,\n        maximum_size=1000,\n    )\n)\n</code></pre> <p>Works with: Source, Sink, LinearConverter, Storage, Transmission</p>"},{"location":"user-guide/building-models/choosing-components/#operational-constraints","title":"Operational Constraints","text":"<p>Add <code>StatusParameters</code> to flows for on/off behavior:</p> <pre><code>fx.Flow(\n    'Heat',\n    bus='Heat',\n    size=500,\n    status_parameters=fx.StatusParameters(\n        effects_per_switch_on={'costs': 50},  # Startup cost\n        on_hours_min=2,  # Minimum runtime\n        off_hours_min=1,  # Minimum downtime\n    )\n)\n</code></pre> <p>Works with: All components with flows</p>"},{"location":"user-guide/building-models/choosing-components/#non-linear-efficiency","title":"Non-Linear Efficiency","text":"<p>Use <code>PiecewiseConversion</code> for load-dependent efficiency:</p> <pre><code>fx.LinearConverter(\n    'GasEngine',\n    inputs=[fx.Flow('Fuel', bus='Gas')],\n    outputs=[fx.Flow('Elec', bus='Electricity')],\n    piecewise_conversion=fx.PiecewiseConversion({\n        'Fuel': fx.Piecewise([fx.Piece(100, 200), fx.Piece(200, 300)]),\n        'Elec': fx.Piecewise([fx.Piece(35, 80), fx.Piece(80, 110)]),\n    }),\n)\n</code></pre> <p>Works with: LinearConverter</p>"},{"location":"user-guide/building-models/choosing-components/#common-modeling-patterns","title":"Common Modeling Patterns","text":""},{"location":"user-guide/building-models/choosing-components/#pattern-parallel-redundant-units","title":"Pattern: Parallel Redundant Units","text":"<p>Model N identical units that can operate independently:</p> <pre><code>for i in range(3):\n    flow_system.add_elements(\n        fx.LinearConverter(\n            f'Boiler_{i}',\n            inputs=[fx.Flow('Gas', bus='Gas', size=100)],\n            outputs=[fx.Flow('Heat', bus='Heat', size=90)],\n            conversion_factors=[{'Gas': 1, 'Heat': 0.9}],\n        )\n    )\n</code></pre>"},{"location":"user-guide/building-models/choosing-components/#pattern-heat-recovery","title":"Pattern: Heat Recovery","text":"<p>Model waste heat recovery from one process to another:</p> <pre><code># Process that generates waste heat\nprocess = fx.LinearConverter(\n    'Process',\n    inputs=[fx.Flow('Elec', bus='Electricity', size=100)],\n    outputs=[\n        fx.Flow('Product', bus='Products', size=80),\n        fx.Flow('WasteHeat', bus='Heat', size=20),  # Recovered heat\n    ],\n    conversion_factors=[{'Elec': 1, 'Product': 0.8, 'WasteHeat': 0.2}],\n)\n</code></pre>"},{"location":"user-guide/building-models/choosing-components/#pattern-fuel-switching","title":"Pattern: Fuel Switching","text":"<p>Model a component that can use multiple fuels:</p> <pre><code>flex_boiler = fx.LinearConverter(\n    'FlexBoiler',\n    inputs=[\n        fx.Flow('Gas', bus='Gas', size=200, effects_per_flow_hour=0.05),\n        fx.Flow('Oil', bus='Oil', size=200, effects_per_flow_hour=0.08),\n    ],\n    outputs=[fx.Flow('Heat', bus='Heat', size=180)],\n    conversion_factors=[{'Gas': 1, 'Oil': 1, 'Heat': 0.9}],\n)\n</code></pre>"},{"location":"user-guide/building-models/choosing-components/#next-steps","title":"Next Steps","text":"<ul> <li>Building Models \u2014 Step-by-step modeling guide</li> <li>Examples \u2014 Working code examples</li> <li>Mathematical Notation \u2014 Constraint formulations</li> </ul>"},{"location":"user-guide/mathematical-notation/","title":"Mathematical Notation","text":"<p>This section provides the detailed mathematical formulations behind flixOpt. It expands on the concepts introduced in Core Concepts with precise equations, variables, and constraints.</p> <p>When to read this</p> <p>You don't need this section to use flixOpt effectively. It's here for:</p> <ul> <li>Understanding exactly what the solver is optimizing</li> <li>Debugging unexpected model behavior</li> <li>Extending flixOpt with custom constraints</li> <li>Academic work requiring formal notation</li> </ul>"},{"location":"user-guide/mathematical-notation/#structure","title":"Structure","text":"<p>The documentation follows the same structure as Core Concepts:</p> Core Concept Mathematical Details Buses \u2014 where things connect Bus \u2014 balance equations, penalty terms Flows \u2014 what moves Flow \u2014 capacity bounds, load factors, profiles Converters \u2014 transform things LinearConverter \u2014 conversion ratios Storages \u2014 save for later Storage \u2014 charge dynamics, efficiency losses Effects \u2014 what you track Effects &amp; Dimensions \u2014 objectives, costs, scenarios, periods"},{"location":"user-guide/mathematical-notation/#notation-conventions","title":"Notation Conventions","text":""},{"location":"user-guide/mathematical-notation/#variables-what-the-optimizer-decides","title":"Variables (What the optimizer decides)","text":"<p>Optimization variables are shown in italic:</p> Symbol Meaning Example \\(p(t)\\) Flow rate at time \\(t\\) Heat output of a boiler \\(c(t)\\) Charge state at time \\(t\\) Energy stored in a battery \\(P\\) Size/capacity (when optimized) Installed capacity of a heat pump \\(s(t)\\) Binary on/off state Whether a generator is running"},{"location":"user-guide/mathematical-notation/#parameters-what-you-provide","title":"Parameters (What you provide)","text":"<p>Parameters and constants are shown in upright text:</p> Symbol Meaning Example \\(\\eta\\) Efficiency Boiler thermal efficiency (0.9) \\(\\Delta t\\) Timestep duration 1 hour \\(p_{min}\\), \\(p_{max}\\) Flow bounds Min/max operating power"},{"location":"user-guide/mathematical-notation/#sets-and-indices","title":"Sets and Indices","text":"Symbol Meaning \\(t \\in \\mathcal{T}\\) Time steps \\(f \\in \\mathcal{F}\\) Flows \\(e \\in \\mathcal{E}\\) Effects"},{"location":"user-guide/mathematical-notation/#the-optimization-problem","title":"The Optimization Problem","text":"<p>At its core, flixOpt solves:</p> \\[ \\min \\quad objective + penalty \\] <p>Subject to:</p> <ul> <li>Balance constraints at each bus</li> <li>Capacity bounds on each flow</li> <li>Storage dynamics over time</li> <li>Conversion relationships in converters</li> <li>Any additional effect constraints</li> </ul> <p>The following pages detail each of these components.</p>"},{"location":"user-guide/mathematical-notation/#quick-example","title":"Quick Example","text":"<p>Consider a simple system: a gas boiler connected to a heat bus serving a demand.</p> <p>Variables:</p> <ul> <li>\\(p_{gas}(t)\\) \u2014 gas consumption at each timestep</li> <li>\\(p_{heat}(t)\\) \u2014 heat production at each timestep</li> </ul> <p>Constraints:</p> <ol> <li> <p>Conversion (boiler efficiency 90%):    $\\(p_{heat}(t) = 0.9 \\cdot p_{gas}(t)\\)$</p> </li> <li> <p>Capacity bounds (boiler max 100 kW):    $\\(0 \\leq p_{heat}(t) \\leq 100\\)$</p> </li> <li> <p>Balance (meet demand):    $\\(p_{heat}(t) = demand(t)\\)$</p> </li> </ol> <p>Objective (minimize gas cost at \u20ac50/MWh): $\\(\\min \\sum_t p_{gas}(t) \\cdot \\Delta t \\cdot 50\\)$</p> <p>This simple example shows how the concepts combine. Real models have many more components, but the principles remain the same.</p>"},{"location":"user-guide/mathematical-notation/#next-steps","title":"Next Steps","text":"<p>Start with the element that's most relevant to your question:</p> <ul> <li>Why isn't my demand being met? \u2192 Bus (balance constraints)</li> <li>Why is my component not running? \u2192 Flow (capacity bounds)</li> <li>How does storage charge/discharge? \u2192 Storage (charge dynamics)</li> <li>How are efficiencies handled? \u2192 LinearConverter (conversion)</li> <li>How are costs calculated? \u2192 Effects &amp; Dimensions</li> </ul>"},{"location":"user-guide/mathematical-notation/effects-and-dimensions/","title":"Effects &amp; Dimensions","text":"<p>Effects track metrics (costs, CO\u2082, energy). Dimensions define the structure over which effects aggregate.</p>"},{"location":"user-guide/mathematical-notation/effects-and-dimensions/#defining-effects","title":"Defining Effects","text":"<pre><code>costs = fx.Effect(label='costs', unit='\u20ac', is_objective=True)\nco2 = fx.Effect(label='co2', unit='kg')\n\nflow_system.add_elements(costs, co2)\n</code></pre> <p>One effect is the objective (minimized). Others are tracked or constrained.</p>"},{"location":"user-guide/mathematical-notation/effects-and-dimensions/#effect-types","title":"Effect Types","text":"TemporalPeriodicTotal <p>Accumulated over timesteps \u2014 operational costs, emissions, energy:</p> <ul> <li>Per flow hour: \\(E(t) = p(t) \\cdot c \\cdot \\Delta t\\)</li> <li>Per event (startup): \\(E(t) = s^{start}(t) \\cdot c\\)</li> </ul> <pre><code>fx.Flow(..., effects_per_flow_hour={'costs': 50})  # \u20ac50/MWh\n</code></pre> <p>Time-independent \u2014 investment costs, fixed fees:</p> <p>\\(E_{per} = P \\cdot c_{inv}\\)</p> <pre><code>fx.InvestParameters(effects_of_investment_per_size={'costs': 200})  # \u20ac200/kW\n</code></pre> <p>Sum of periodic and temporal components.</p>"},{"location":"user-guide/mathematical-notation/effects-and-dimensions/#where-effects-are-contributed","title":"Where Effects Are Contributed","text":"FlowStatusInvestmentBus <pre><code>fx.Flow(\n    effects_per_flow_hour={'costs': 50, 'co2': 0.2},  # Per MWh\n)\n</code></pre> <pre><code>fx.StatusParameters(\n    effects_per_startup={'costs': 1000},      # Per startup event\n    effects_per_active_hour={'costs': 10},    # Per hour while running\n)\n</code></pre> <pre><code>fx.InvestParameters(\n    effects_of_investment={'costs': 50000},           # Fixed if investing\n    effects_of_investment_per_size={'costs': 800},    # Per kW installed\n    effects_of_retirement={'costs': 10000},           # If NOT investing\n)\n</code></pre> <pre><code>fx.Bus(\n    excess_penalty_per_flow_hour=1e6,    # Penalty for excess\n    shortage_penalty_per_flow_hour=1e6,  # Penalty for shortage\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/effects-and-dimensions/#dimensions","title":"Dimensions","text":"<p>The model operates across three dimensions:</p> TimestepsScenariosPeriods <p>The basic time resolution \u2014 always required:</p> <pre><code>flow_system = fx.FlowSystem(\n    timesteps=pd.date_range('2024-01-01', periods=8760, freq='h'),\n)\n</code></pre> <p>All variables and constraints are indexed by time. Temporal effects sum over timesteps.</p> <p>Represent uncertainty (weather, prices). Operations vary per scenario, investments are shared:</p> <pre><code>flow_system = fx.FlowSystem(\n    timesteps=pd.date_range('2024-01-01', periods=8760, freq='h'),\n    scenarios=pd.Index(['sunny_year', 'cloudy_year']),\n    scenario_weights=[0.7, 0.3],\n)\n</code></pre> <p>Scenarios are independent \u2014 no energy or information exchange between them.</p> <p>Sequential time blocks (years) for multi-period planning:</p> <pre><code>flow_system = fx.FlowSystem(\n    timesteps=pd.date_range('2024-01-01', periods=8760, freq='h'),\n    periods=pd.Index([2025, 2030]),\n)\n</code></pre> <p>Periods are independent \u2014 each has its own investment decisions.</p>"},{"location":"user-guide/mathematical-notation/effects-and-dimensions/#objective-function","title":"Objective Function","text":"<p>The objective aggregates effects across all dimensions with weights:</p> BasicWith ScenariosWith PeriodsFull <p>Single period, no scenarios:</p> \\[\\min \\quad E_{per} + \\sum_t E_{temp}(t)\\] <p>Investment decided once, operations weighted by probability:</p> \\[\\min \\quad E_{per} + \\sum_s w_s \\cdot \\sum_t E_{temp}(t, s)\\] <ul> <li>\\(w_s\\) \u2014 scenario weight (probability)</li> </ul> <p>Multi-year planning with discounting:</p> \\[\\min \\quad \\sum_y w_y \\cdot \\left( E_{per}(y) + \\sum_t E_{temp}(t, y) \\right)\\] <ul> <li>\\(w_y\\) \u2014 period weight (duration or discount factor)</li> </ul> <p>Periods \u00d7 Scenarios:</p> \\[\\min \\quad \\sum_y w_y \\cdot \\left( E_{per}(y) + \\sum_s w_s \\cdot \\sum_t E_{temp}(t, y, s) \\right)\\] <p>The penalty effect is always included: \\(\\min \\quad E_{objective} + E_{penalty}\\)</p>"},{"location":"user-guide/mathematical-notation/effects-and-dimensions/#weights","title":"Weights","text":"Scenario WeightsPeriod WeightsCombined <p>Provided explicitly \u2014 typically probabilities:</p> <pre><code>scenario_weights=[0.6, 0.4]\n</code></pre> <p>Default: equal weights, normalized to sum to 1.</p> <p>Computed automatically from period index (interval sizes):</p> <pre><code>periods = pd.Index([2020, 2025, 2030])\n# \u2192 weights: [5, 5, 5] (5-year intervals)\n</code></pre> <p>When both present:</p> <p>\\(w_{y,s} = w_y \\cdot w_s\\)</p>"},{"location":"user-guide/mathematical-notation/effects-and-dimensions/#constraints-on-effects","title":"Constraints on Effects","text":"Total LimitPer-Timestep LimitPeriodic LimitTemporal LimitOver All Periods <p>Bound on aggregated effect (temporal + periodic) per period:</p> <pre><code>fx.Effect(label='co2', unit='kg', maximum_total=100_000)\n</code></pre> <p>Bound at each timestep:</p> <pre><code>fx.Effect(label='peak', unit='kW', maximum_per_hour=500)\n</code></pre> <p>Bound on periodic component only:</p> <pre><code>fx.Effect(label='capex', unit='\u20ac', maximum_periodic=1_000_000)\n</code></pre> <p>Bound on temporal component only:</p> <pre><code>fx.Effect(label='opex', unit='\u20ac', maximum_temporal=500_000)\n</code></pre> <p>Bound across all periods (weighted sum):</p> <pre><code>fx.Effect(label='co2', unit='kg', maximum_over_periods=1_000_000)\n</code></pre>"},{"location":"user-guide/mathematical-notation/effects-and-dimensions/#cross-effects","title":"Cross-Effects","text":"<p>Effects can contribute to each other (e.g., carbon pricing):</p> <pre><code>co2 = fx.Effect(label='co2', unit='kg')\n\ncosts = fx.Effect(\n    label='costs', unit='\u20ac', is_objective=True,\n    share_from_temporal={'co2': 0.08},  # \u20ac80/tonne\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/effects-and-dimensions/#penalty-effect","title":"Penalty Effect","text":"<p>A built-in <code>Penalty</code> effect enables soft constraints and prevents infeasibility:</p> <pre><code>fx.StatusParameters(effects_per_startup={'Penalty': 1})\nfx.Bus(label='heat', excess_penalty_per_flow_hour=1e5)\n</code></pre> <p>Penalty is weighted identically to the objective effect across all dimensions.</p>"},{"location":"user-guide/mathematical-notation/effects-and-dimensions/#shared-vs-independent-decisions","title":"Shared vs Independent Decisions","text":"Investments (Sizes)Operations (Flows) <p>By default, investment decisions are shared across scenarios within a period:</p> <ul> <li>Build capacity once \u2192 operate differently per scenario</li> <li>Reflects real-world investment under uncertainty</li> </ul> \\[P(y) \\quad \\text{(one decision per period, used in all scenarios)}\\] <p>By default, operational decisions are independent per scenario:</p> \\[p(t, y, s) \\quad \\text{(different for each scenario)}\\]"},{"location":"user-guide/mathematical-notation/effects-and-dimensions/#use-cases","title":"Use Cases","text":"Carbon BudgetInvestment BudgetPeak Demand ChargeCarbon PricingLand Use ConstraintMulti-Criteria Optimization <p>Limit total CO\u2082 emissions across all years:</p> <pre><code>co2 = fx.Effect(\n    label='co2', unit='kg',\n    maximum_over_periods=1_000_000,  # 1000 tonnes total\n)\n\n# Contribute emissions from gas consumption\ngas_flow = fx.Flow(\n    label='gas', bus=gas_bus,\n    effects_per_flow_hour={'co2': 0.2},  # 0.2 kg/kWh\n)\n</code></pre> <p>Cap annual investment spending:</p> <pre><code>capex = fx.Effect(\n    label='capex', unit='\u20ac',\n    maximum_periodic=5_000_000,  # \u20ac5M per period\n)\n\nbattery = fx.Storage(\n    ...,\n    capacity=fx.InvestParameters(\n        effects_of_investment_per_size={'capex': 600},  # \u20ac600/kWh\n    ),\n)\n</code></pre> <p>Track and limit peak power:</p> <pre><code>peak = fx.Effect(\n    label='peak', unit='kW',\n    maximum_per_hour=1000,  # Grid connection limit\n)\n\ngrid_import = fx.Flow(\n    label='import', bus=elec_bus,\n    effects_per_flow_hour={'peak': 1},  # Track instantaneous power\n)\n</code></pre> <p>Add CO\u2082 cost to objective automatically:</p> <pre><code>co2 = fx.Effect(label='co2', unit='kg')\n\ncosts = fx.Effect(\n    label='costs', unit='\u20ac', is_objective=True,\n    share_from_temporal={'co2': 0.08},  # \u20ac80/tonne carbon price\n)\n\n# Now any CO\u2082 contribution automatically adds to costs\n</code></pre> <p>Limit total land area for installations:</p> <pre><code>land = fx.Effect(\n    label='land', unit='m\u00b2',\n    maximum_periodic=50_000,  # 5 hectares max\n)\n\npv = fx.Source(\n    ...,\n    output=fx.Flow(\n        ...,\n        invest_parameters=fx.InvestParameters(\n            effects_of_investment_per_size={'land': 5},  # 5 m\u00b2/kWp\n        ),\n    ),\n)\n</code></pre> <p>Track multiple objectives, optimize one:</p> <pre><code>costs = fx.Effect(label='costs', unit='\u20ac', is_objective=True)\nco2 = fx.Effect(label='co2', unit='kg')\nprimary_energy = fx.Effect(label='PE', unit='kWh')\n\n# All are tracked, costs is minimized\n# Use maximum_total on co2 for \u03b5-constraint method\n</code></pre>"},{"location":"user-guide/mathematical-notation/effects-and-dimensions/#reference","title":"Reference","text":"Symbol Type Description \\(E_{temp}(t)\\) \\(\\mathbb{R}\\) Temporal effect at timestep \\(t\\) \\(E_{per}\\) \\(\\mathbb{R}\\) Periodic effect (per period) \\(E\\) \\(\\mathbb{R}\\) Total effect (\\(E_{per} + \\sum_t E_{temp}(t)\\)) \\(w_s\\) \\(\\mathbb{R}_{\\geq 0}\\) Scenario weight (probability) \\(w_y\\) \\(\\mathbb{R}_{&gt; 0}\\) Period weight (duration/discount) \\(p(t)\\) \\(\\mathbb{R}_{\\geq 0}\\) Flow rate at timestep \\(t\\) \\(s^{start}(t)\\) \\(\\{0, 1\\}\\) Startup indicator \\(P\\) \\(\\mathbb{R}_{\\geq 0}\\) Investment size \\(c\\) \\(\\mathbb{R}\\) Effect coefficient \\(\\Delta t\\) \\(\\mathbb{R}_{&gt; 0}\\) Timestep duration (hours) Constraint Python Scope Total limit <code>maximum_total</code> Per period Timestep limit <code>maximum_per_hour</code> Each timestep Periodic limit <code>maximum_periodic</code> Per period (periodic only) Temporal limit <code>maximum_temporal</code> Per period (temporal only) Global limit <code>maximum_over_periods</code> Across all periods <p>Classes: <code>Effect</code>, <code>EffectCollection</code></p>"},{"location":"user-guide/mathematical-notation/elements/Bus/","title":"Bus","text":"<p>A Bus is where flows meet and must balance \u2014 inputs equal outputs at every timestep.</p>"},{"location":"user-guide/mathematical-notation/elements/Bus/#carriers","title":"Carriers","text":"<p>Buses can optionally be assigned a carrier \u2014 a type of energy or material (e.g., electricity, heat, gas). Carriers enable:</p> <ul> <li>Automatic coloring in plots based on energy type</li> <li>Unit tracking for better result visualization</li> <li>Semantic grouping of buses by type</li> </ul> <pre><code># Assign a carrier by name (uses CONFIG.Carriers defaults)\nheat_bus = fx.Bus('HeatNetwork', carrier='heat')\nelec_bus = fx.Bus('Grid', carrier='electricity')\n\n# Or register custom carriers on the FlowSystem\nbiogas = fx.Carrier('biogas', color='#228B22', unit='kW', description='Biogas fuel')\nflow_system.add_carrier(biogas)\ngas_bus = fx.Bus('BiogasNetwork', carrier='biogas')\n</code></pre> <p>See Color Management for more on how carriers affect visualization.</p>"},{"location":"user-guide/mathematical-notation/elements/Bus/#basic-balance-equation","title":"Basic: Balance Equation","text":"\\[ \\sum_{in} p(t) = \\sum_{out} p(t) \\] <pre><code>heat_bus = fx.Bus(label='heat')\n# All flows connected to this bus must balance\n</code></pre> <p>If balance can't be achieved \u2192 model is infeasible.</p>"},{"location":"user-guide/mathematical-notation/elements/Bus/#with-imbalance-penalty","title":"With Imbalance Penalty","text":"<p>Allow imbalance for debugging or soft constraints:</p> \\[ \\sum_{in} p(t) + \\phi_{in}(t) = \\sum_{out} p(t) + \\phi_{out}(t) \\] <p>The slack variables \\(\\phi\\) are penalized: \\((\\phi_{in} + \\phi_{out}) \\cdot \\Delta t \\cdot c_\\phi\\)</p> <pre><code>heat_bus = fx.Bus(\n    label='heat',\n    imbalance_penalty_per_flow_hour=1e5  # High penalty for imbalance\n)\n</code></pre> <p>Debugging</p> <p>If you see a <code>virtual_demand</code> or <code>virtual_supply</code> and its non zero in results \u2192 your system couldn't meet demand. Check capacities and connections.</p>"},{"location":"user-guide/mathematical-notation/elements/Bus/#reference","title":"Reference","text":"Symbol Type Description \\(p(t)\\) \\(\\mathbb{R}_{\\geq 0}\\) Flow rate of connected flows \\(\\phi_{in}(t)\\) \\(\\mathbb{R}_{\\geq 0}\\) Slack: virtual supply (covers shortages) \\(\\phi_{out}(t)\\) \\(\\mathbb{R}_{\\geq 0}\\) Slack: virtual demand (absorbs surplus) \\(c_\\phi\\) \\(\\mathbb{R}_{\\geq 0}\\) Penalty factor (<code>imbalance_penalty_per_flow_hour</code>) \\(\\Delta t\\) \\(\\mathbb{R}_{&gt; 0}\\) Timestep duration (hours) <p>Classes: <code>Bus</code>, <code>BusModel</code></p>"},{"location":"user-guide/mathematical-notation/elements/Flow/","title":"Flow","text":"<p>A Flow is the primary optimization variable \u2014 the solver decides how much flows at each timestep.</p>"},{"location":"user-guide/mathematical-notation/elements/Flow/#basic-bounded-flow-rate","title":"Basic: Bounded Flow Rate","text":"<p>Every flow has a size \\(P\\) (capacity) and a flow rate \\(p(t)\\) (what the solver optimizes):</p> \\[ P \\cdot p_{rel}^{min} \\leq p(t) \\leq P \\cdot p_{rel}^{max} \\] <pre><code># 100 kW boiler, minimum 30% when running\nheat = fx.Flow(label='heat', bus=heat_bus, size=100, relative_minimum=0.3)\n# \u2192 30 \u2264 p(t) \u2264 100\n</code></pre> <p>Cannot be zero</p> <p>With <code>relative_minimum &gt; 0</code>, the flow cannot be zero. Use <code>status_parameters</code> to allow shutdown.</p>"},{"location":"user-guide/mathematical-notation/elements/Flow/#adding-features","title":"Adding Features","text":"StatusVariable SizeFlow EffectsFixed Profile <p>Allow the flow to be zero with <code>status_parameters</code>:</p> <p>\\(s(t) \\cdot P \\cdot p_{rel}^{min} \\leq p(t) \\leq s(t) \\cdot P \\cdot p_{rel}^{max}\\)</p> <p>Where \\(s(t) \\in \\{0, 1\\}\\): inactive or active.</p> <pre><code>generator = fx.Flow(\n    label='power', bus=elec_bus, size=50,\n    relative_minimum=0.4,\n    status_parameters=fx.StatusParameters(\n        effects_per_startup={'costs': 500},\n        min_uptime=2,\n    ),\n)\n</code></pre> <p>See StatusParameters.</p> <p>Optimize the capacity with <code>InvestParameters</code>:</p> <p>\\(P^{min} \\leq P \\leq P^{max}\\)</p> <pre><code>battery = fx.Flow(\n    label='power', bus=elec_bus,\n    size=fx.InvestParameters(\n        minimum_size=0,\n        maximum_size=1000,\n        specific_effects={'costs': 100_000},\n    ),\n)\n</code></pre> <p>See InvestParameters.</p> <p>Add effects per energy (flow hours) moved:</p> <pre><code>gas = fx.Flow(\n    label='gas', bus=gas_bus, size=150,\n    effects_per_flow_hour={'costs': 50},  # \u20ac50/MWh\n)\n</code></pre> <p>Flow hours: \\(h(t) = p(t) \\cdot \\Delta t\\)</p> <p>Lock the flow to a time series (demands, renewables):</p> <p>\\(p(t) = P \\cdot \\pi(t)\\)</p> <pre><code>demand = fx.Flow(\n    label='demand', bus=heat_bus, size=100,\n    fixed_relative_profile=[0.5, 0.8, 1.0, 0.6]  # \u03c0(t)\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/elements/Flow/#optional-constraints","title":"Optional Constraints","text":"Load FactorFlow Hours <p>Constrain average utilization:</p> <p>\\(\\lambda_{min} \\leq \\frac{\\sum_t p(t)}{P \\cdot n_t} \\leq \\lambda_{max}\\)</p> <pre><code>fx.Flow(..., load_factor_min=0.5, load_factor_max=0.9)\n</code></pre> <p>Constrain total energy:</p> <p>\\(h_{min} \\leq \\sum_t p(t) \\cdot \\Delta t \\leq h_{max}\\)</p> <pre><code>fx.Flow(..., flow_hours_min=1000, flow_hours_max=5000)\n</code></pre>"},{"location":"user-guide/mathematical-notation/elements/Flow/#reference","title":"Reference","text":"Symbol Type Description \\(p(t)\\) \\(\\mathbb{R}_{\\geq 0}\\) Flow rate at timestep \\(t\\) \\(P\\) \\(\\mathbb{R}_{\\geq 0}\\) Size (capacity) \u2014 fixed or optimized \\(s(t)\\) \\(\\{0, 1\\}\\) Binary status (with <code>status_parameters</code>) \\(p_{rel}^{min}\\) \\(\\mathbb{R}_{\\geq 0}\\) Minimum relative flow (<code>relative_minimum</code>) \\(p_{rel}^{max}\\) \\(\\mathbb{R}_{\\geq 0}\\) Maximum relative flow (<code>relative_maximum</code>) \\(\\pi(t)\\) \\(\\mathbb{R}_{\\geq 0}\\) Fixed profile (<code>fixed_relative_profile</code>) \\(\\Delta t\\) \\(\\mathbb{R}_{&gt; 0}\\) Timestep duration (hours) <p>Classes: <code>Flow</code>, <code>FlowModel</code></p>"},{"location":"user-guide/mathematical-notation/elements/LinearConverter/","title":"LinearConverter","text":"<p>A LinearConverter transforms inputs into outputs with fixed ratios.</p>"},{"location":"user-guide/mathematical-notation/elements/LinearConverter/#basic-conversion-equation","title":"Basic: Conversion Equation","text":"\\[ \\sum_{in} a_f \\cdot p_f(t) = \\sum_{out} b_f \\cdot p_f(t) \\] Boiler (\u03b7 = 90%)Heat Pump (COP = 3.5)CHP (35% el, 50% th) <p>\\(0.9 \\cdot p_{gas}(t) = p_{heat}(t)\\)</p> <pre><code>boiler = fx.LinearConverter(\n    label='boiler',\n    inputs=[fx.Flow(label='gas', bus=gas_bus, size=111)],\n    outputs=[fx.Flow(label='heat', bus=heat_bus, size=100)],\n    conversion_factors=[{'gas': 0.9, 'heat': 1}],\n)\n</code></pre> <p>\\(3.5 \\cdot p_{el}(t) = p_{heat}(t)\\)</p> <pre><code>hp = fx.LinearConverter(\n    label='hp',\n    inputs=[fx.Flow(label='el', bus=elec_bus, size=100)],\n    outputs=[fx.Flow(label='heat', bus=heat_bus, size=350)],\n    conversion_factors=[{'el': 3.5, 'heat': 1}],\n)\n</code></pre> <p>Two constraints linking fuel to outputs:</p> <pre><code>chp = fx.LinearConverter(\n    label='chp',\n    inputs=[fx.Flow(label='fuel', bus=gas_bus, size=100)],\n    outputs=[\n        fx.Flow(label='el', bus=elec_bus, size=35),\n        fx.Flow(label='heat', bus=heat_bus, size=50),\n    ],\n    conversion_factors=[\n        {'fuel': 0.35, 'el': 1},\n        {'fuel': 0.50, 'heat': 1},\n    ],\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/elements/LinearConverter/#time-varying-efficiency","title":"Time-Varying Efficiency","text":"<p>Pass a list for time-dependent conversion:</p> <pre><code>cop = np.array([3.0, 3.2, 3.5, 4.0, 3.8, ...])  # Varies with ambient temperature\n\nhp = fx.LinearConverter(\n    ...,\n    conversion_factors=[{'el': cop, 'heat': 1}],\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/elements/LinearConverter/#convenience-classes","title":"Convenience Classes","text":"<pre><code># Boiler\nboiler = fx.linear_converters.Boiler(\n    label='boiler', eta=0.9,\n    Q_th=fx.Flow(label='heat', bus=heat_bus, size=100),\n    Q_fu=fx.Flow(label='fuel', bus=gas_bus),\n)\n\n# Heat Pump\nhp = fx.linear_converters.HeatPump(\n    label='hp', COP=3.5,\n    P_el=fx.Flow(label='el', bus=elec_bus, size=100),\n    Q_th=fx.Flow(label='heat', bus=heat_bus),\n)\n\n# CHP\nchp = fx.linear_converters.CHP(\n    label='chp', eta_el=0.35, eta_th=0.50,\n    P_el=fx.Flow(...), Q_th=fx.Flow(...), Q_fu=fx.Flow(...),\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/elements/LinearConverter/#adding-features","title":"Adding Features","text":"StatusPiecewise Conversion <p>A component is active when any of its flows is non-zero. Add startup costs, minimum run times:</p> <pre><code>gen = fx.LinearConverter(\n    ...,\n    status_parameters=fx.StatusParameters(\n        effects_per_startup={'costs': 1000},\n        min_uptime=4,\n    ),\n)\n</code></pre> <p>See StatusParameters.</p> <p>For variable efficiency \u2014 all flows change together based on operating point:</p> <pre><code>chp = fx.LinearConverter(\n    label='CHP',\n    inputs=[fx.Flow('fuel', bus=gas_bus)],\n    outputs=[\n        fx.Flow('el', bus=elec_bus, size=60),\n        fx.Flow('heat', bus=heat_bus),\n    ],\n    piecewise_conversion=fx.PiecewiseConversion({\n        'el':   fx.Piecewise([fx.Piece(5, 30), fx.Piece(40, 60)]),\n        'heat': fx.Piecewise([fx.Piece(6, 35), fx.Piece(45, 100)]),\n        'fuel': fx.Piecewise([fx.Piece(12, 70), fx.Piece(90, 200)]),\n    }),\n)\n</code></pre> <p>See Piecewise.</p>"},{"location":"user-guide/mathematical-notation/elements/LinearConverter/#reference","title":"Reference","text":"<p>The converter creates constraints linking flows, not new variables.</p> Symbol Type Description \\(p_f(t)\\) \\(\\mathbb{R}_{\\geq 0}\\) Flow rate of flow \\(f\\) at timestep \\(t\\) \\(a_f\\) \\(\\mathbb{R}\\) Conversion factor for input flow \\(f\\) \\(b_f\\) \\(\\mathbb{R}\\) Conversion factor for output flow \\(f\\) <p>Classes: <code>LinearConverter</code>, <code>LinearConverterModel</code></p>"},{"location":"user-guide/mathematical-notation/elements/Storage/","title":"Storage","text":"<p>A Storage accumulates energy over time \u2014 charge now, discharge later.</p>"},{"location":"user-guide/mathematical-notation/elements/Storage/#basic-charge-dynamics","title":"Basic: Charge Dynamics","text":"\\[ c(t+1) = c(t) \\cdot (1 - \\dot{c}_{loss})^{\\Delta t} + p_{in}(t) \\cdot \\Delta t \\cdot \\eta_{in} - p_{out}(t) \\cdot \\Delta t / \\eta_{out} \\] <pre><code>battery = fx.Storage(\n    label='battery',\n    charging=fx.Flow(label='charge', bus=elec_bus, size=50),\n    discharging=fx.Flow(label='discharge', bus=elec_bus, size=50),\n    capacity_in_flow_hours=200,  # 200 kWh\n    eta_charge=0.95,\n    eta_discharge=0.95,\n)\n# Round-trip efficiency: 95% \u00d7 95% = 90.25%\n</code></pre>"},{"location":"user-guide/mathematical-notation/elements/Storage/#charge-state-bounds","title":"Charge State Bounds","text":"\\[ C \\cdot c_{rel}^{min} \\leq c(t) \\leq C \\cdot c_{rel}^{max} \\] <pre><code>fx.Storage(...,\n    relative_minimum_charge_state=0.2,  # Min 20% SOC\n    relative_maximum_charge_state=0.8,  # Max 80% SOC\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/elements/Storage/#initial-final-conditions","title":"Initial &amp; Final Conditions","text":"Fixed StartCyclicFinal Bounds <pre><code>fx.Storage(..., initial_charge_state=100)  # Start at 100 kWh\n</code></pre> <p>Must end where it started (prevents \"cheating\"):</p> <pre><code>fx.Storage(..., initial_charge_state='equals_final')\n</code></pre> <pre><code>fx.Storage(...,\n    minimal_final_charge_state=50,\n    maximal_final_charge_state=150,\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/elements/Storage/#adding-features","title":"Adding Features","text":"Self-DischargeVariable CapacityAsymmetric Power <pre><code>tank = fx.Storage(...,\n    relative_loss_per_hour=0.02,  # 2%/hour loss\n)\n</code></pre> <p>Optimize storage size:</p> <pre><code>battery = fx.Storage(...,\n    capacity_in_flow_hours=fx.InvestParameters(\n        minimum_size=0,\n        maximum_size=1000,\n        specific_effects={'costs': 200},  # \u20ac/kWh\n    ),\n)\n</code></pre> <p>Different charge/discharge rates:</p> <pre><code>fx.Storage(\n    charging=fx.Flow(..., size=100),     # 100 MW pump\n    discharging=fx.Flow(..., size=120),  # 120 MW turbine\n    ...\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/elements/Storage/#reference","title":"Reference","text":"Symbol Type Description \\(c(t)\\) \\(\\mathbb{R}_{\\geq 0}\\) Charge state at timestep \\(t\\) \\(C\\) \\(\\mathbb{R}_{\\geq 0}\\) Capacity (<code>capacity_in_flow_hours</code>) \\(p_{in}(t)\\) \\(\\mathbb{R}_{\\geq 0}\\) Charging power (from <code>charging</code> flow) \\(p_{out}(t)\\) \\(\\mathbb{R}_{\\geq 0}\\) Discharging power (from <code>discharging</code> flow) \\(\\eta_{in}\\) \\(\\mathbb{R}_{\\geq 0}\\) Charge efficiency (<code>eta_charge</code>) \\(\\eta_{out}\\) \\(\\mathbb{R}_{\\geq 0}\\) Discharge efficiency (<code>eta_discharge</code>) \\(\\dot{c}_{loss}\\) \\(\\mathbb{R}_{\\geq 0}\\) Self-discharge rate (<code>relative_loss_per_hour</code>) \\(c_{rel}^{min}\\) \\(\\mathbb{R}_{\\geq 0}\\) Min charge state (<code>relative_minimum_charge_state</code>) \\(c_{rel}^{max}\\) \\(\\mathbb{R}_{\\geq 0}\\) Max charge state (<code>relative_maximum_charge_state</code>) \\(\\Delta t\\) \\(\\mathbb{R}_{&gt; 0}\\) Timestep duration (hours) <p>Classes: <code>Storage</code>, <code>StorageModel</code></p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/","title":"InvestParameters","text":"<p>InvestParameters make capacity a decision variable \u2014 should we build this? How big?</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#basic-size-as-variable","title":"Basic: Size as Variable","text":"\\[ P^{min} \\leq P \\leq P^{max} \\] <pre><code>battery = fx.Storage(\n    ...,\n    capacity_in_flow_hours=fx.InvestParameters(\n        minimum_size=10,\n        maximum_size=1000,\n        specific_effects={'costs': 600},  # \u20ac600/kWh\n    ),\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#investment-modes","title":"Investment Modes","text":"<p>By default, investment is optional \u2014 the optimizer can choose \\(P = 0\\) (don't invest).</p> ContinuousBinaryMandatory <p>Choose size within range (or zero):</p> <pre><code>fx.InvestParameters(\n    minimum_size=10,\n    maximum_size=1000,\n)\n# \u2192 P = 0  OR  10 \u2264 P \u2264 1000\n</code></pre> <p>Fixed size or nothing:</p> <pre><code>fx.InvestParameters(\n    fixed_size=100,  # 100 kW or 0\n)\n# \u2192 P \u2208 {0, 100}\n</code></pre> <p>Force investment with <code>mandatory=True</code> \u2014 zero not allowed:</p> <pre><code>fx.InvestParameters(\n    minimum_size=50,\n    maximum_size=200,\n    mandatory=True,\n)\n# \u2192 50 \u2264 P \u2264 200 (no zero option)\n</code></pre>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#investment-effects","title":"Investment Effects","text":"Per-Size CostFixed CostRetirement CostPiecewise Cost <p>Cost proportional to capacity (\u20ac/kW):</p> <p>\\(E = P \\cdot c_{spec}\\)</p> <pre><code>fx.InvestParameters(\n    specific_effects={'costs': 1200},  # \u20ac1200/kW\n)\n</code></pre> <p>One-time cost if investing:</p> <p>\\(E = s_{inv} \\cdot c_{fix}\\)</p> <pre><code>fx.InvestParameters(\n    effects_of_investment={'costs': 25000},  # \u20ac25k\n)\n</code></pre> <p>Cost if NOT investing:</p> <p>\\(E = (1 - s_{inv}) \\cdot c_{ret}\\)</p> <pre><code>fx.InvestParameters(\n    effects_of_retirement={'costs': 8000},  # Demolition\n)\n</code></pre> <p>Non-linear cost curves (e.g., economies of scale):</p> <p>\\(E = f_{piecewise}(P)\\)</p> <pre><code>fx.InvestParameters(\n    piecewise_effects_of_investment=fx.PiecewiseEffects(\n        piecewise_origin=fx.Piecewise([\n            fx.Piece(0, 100),\n            fx.Piece(100, 500),\n        ]),\n        piecewise_shares={\n            'costs': fx.Piecewise([\n                fx.Piece(0, 80_000),      # \u20ac800/kW for 0-100\n                fx.Piece(80_000, 280_000), # \u20ac500/kW for 100-500\n            ])\n        },\n    ),\n)\n</code></pre> <p>See Piecewise for details on the formulation.</p>"},{"location":"user-guide/mathematical-notation/features/InvestParameters/#reference","title":"Reference","text":"Symbol Type Description \\(P\\) \\(\\mathbb{R}_{\\geq 0}\\) Investment size (capacity) \\(s_{inv}\\) \\(\\{0, 1\\}\\) Binary investment decision (0=no, 1=yes) \\(P^{min}\\) \\(\\mathbb{R}_{\\geq 0}\\) Minimum size (<code>minimum_size</code>) \\(P^{max}\\) \\(\\mathbb{R}_{\\geq 0}\\) Maximum size (<code>maximum_size</code>) \\(c_{spec}\\) \\(\\mathbb{R}\\) Per-size effect (<code>effects_of_investment_per_size</code>) \\(c_{fix}\\) \\(\\mathbb{R}\\) Fixed effect (<code>effects_of_investment</code>) \\(c_{ret}\\) \\(\\mathbb{R}\\) Retirement effect (<code>effects_of_retirement</code>) <p>Classes: <code>InvestParameters</code>, <code>InvestmentModel</code></p>"},{"location":"user-guide/mathematical-notation/features/Piecewise/","title":"Piecewise","text":"<p>Piecewise linearization approximates non-linear relationships using connected linear segments.</p>"},{"location":"user-guide/mathematical-notation/features/Piecewise/#mathematical-formulation","title":"Mathematical Formulation","text":"<p>A piecewise linear function with \\(n\\) segments uses per-segment interpolation:</p> \\[ x = \\sum_{i=1}^{n} \\left( \\lambda_i^0 \\cdot x_i^{start} + \\lambda_i^1 \\cdot x_i^{end} \\right) \\] <p>Each segment \\(i\\) has:</p> <ul> <li>\\(s_i \\in \\{0, 1\\}\\) \u2014 binary indicating if segment is active</li> <li>\\(\\lambda_i^0, \\lambda_i^1 \\geq 0\\) \u2014 interpolation weights for segment endpoints</li> </ul> <p>Constraints ensure valid interpolation:</p> \\[ \\lambda_i^0 + \\lambda_i^1 = s_i \\quad \\forall i \\] \\[ \\sum_{i=1}^{n} s_i \\leq 1 \\] <p>When segment \\(i\\) is active (\\(s_i = 1\\)), the lambdas interpolate between \\(x_i^{start}\\) and \\(x_i^{end}\\). When inactive (\\(s_i = 0\\)), both lambdas are zero.</p> <p>Implementation Note</p> <p>This formulation is an explicit binary reformulation of SOS2 (Special Ordered Set Type 2) constraints. It produces identical results but uses more variables. We will migrate to native SOS2 constraints once linopy supports them.</p>"},{"location":"user-guide/mathematical-notation/features/Piecewise/#building-blocks","title":"Building Blocks","text":"PiecePiecewisePiecewiseConversionPiecewiseEffects <p>A linear segment from start to end value:</p> <pre><code>fx.Piece(start=10, end=50)  # Linear from 10 to 50\n</code></pre> <p>Values can be time-varying:</p> <pre><code>fx.Piece(\n    start=np.linspace(5, 6, n_timesteps),\n    end=np.linspace(30, 35, n_timesteps)\n)\n</code></pre> <p>Multiple segments forming a piecewise linear function:</p> <pre><code>fx.Piecewise([\n    fx.Piece(0, 30),   # Segment 1: 0 \u2192 30\n    fx.Piece(30, 60),  # Segment 2: 30 \u2192 60\n])\n</code></pre> <p>Synchronizes multiple flows \u2014 all interpolate at the same relative position:</p> <pre><code>fx.PiecewiseConversion({\n    'input_flow':  fx.Piecewise([...]),\n    'output_flow': fx.Piecewise([...]),\n})\n</code></pre> <p>All piecewise functions must have the same number of segments.</p> <p>Maps a size/capacity variable to effects (costs, emissions):</p> <pre><code>fx.PiecewiseEffects(\n    piecewise_origin=fx.Piecewise([...]),  # Size segments\n    piecewise_shares={'costs': fx.Piecewise([...])},  # Effect segments\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/features/Piecewise/#usage","title":"Usage","text":"Variable EfficiencyEconomies of ScaleForbidden Operating Region <p>Converter efficiency that varies with load:</p> <pre><code>chp = fx.LinearConverter(\n    ...,\n    piecewise_conversion=fx.PiecewiseConversion({\n        'el':   fx.Piecewise([fx.Piece(5, 30), fx.Piece(40, 60)]),\n        'heat': fx.Piecewise([fx.Piece(6, 35), fx.Piece(45, 100)]),\n        'fuel': fx.Piecewise([fx.Piece(12, 70), fx.Piece(90, 200)]),\n    }),\n)\n</code></pre> <p>Investment cost per unit decreases with size:</p> <pre><code>fx.InvestParameters(\n    piecewise_effects_of_investment=fx.PiecewiseEffects(\n        piecewise_origin=fx.Piecewise([\n            fx.Piece(0, 100),\n            fx.Piece(100, 500),\n        ]),\n        piecewise_shares={\n            'costs': fx.Piecewise([\n                fx.Piece(0, 80_000),\n                fx.Piece(80_000, 280_000),\n            ])\n        },\n    ),\n)\n</code></pre> <p>Equipment cannot operate in certain ranges:</p> <pre><code>fx.PiecewiseConversion({\n    'fuel':  fx.Piecewise([fx.Piece(0, 0), fx.Piece(40, 100)]),\n    'power': fx.Piecewise([fx.Piece(0, 0), fx.Piece(35, 95)]),\n})\n# Either off (0,0) or operating above 40%\n</code></pre>"},{"location":"user-guide/mathematical-notation/features/Piecewise/#reference","title":"Reference","text":"Symbol Type Description \\(x\\) \\(\\mathbb{R}\\) Interpolated variable value \\(s_i\\) \\(\\{0, 1\\}\\) Binary: segment \\(i\\) is active \\(\\lambda_i^0\\) \\([0, 1]\\) Interpolation weight for segment start \\(\\lambda_i^1\\) \\([0, 1]\\) Interpolation weight for segment end \\(x_i^{start}\\) \\(\\mathbb{R}\\) Start value of segment \\(i\\) \\(x_i^{end}\\) \\(\\mathbb{R}\\) End value of segment \\(i\\) \\(n\\) \\(\\mathbb{Z}_{&gt; 0}\\) Number of segments <p>Classes: <code>Piecewise</code>, <code>Piece</code>, <code>PiecewiseConversion</code>, <code>PiecewiseEffects</code></p>"},{"location":"user-guide/mathematical-notation/features/StatusParameters/","title":"StatusParameters","text":"<p>StatusParameters add on/off behavior to flows \u2014 startup costs, minimum run times, cycling limits.</p>"},{"location":"user-guide/mathematical-notation/features/StatusParameters/#basic-binary-status","title":"Basic: Binary Status","text":"<p>A status variable \\(s(t) \\in \\{0, 1\\}\\) controls whether equipment is active:</p> <pre><code>generator = fx.Flow(\n    label='power', bus=elec_bus, size=100,\n    relative_minimum=0.4,  # 40% min when ON\n    status_parameters=fx.StatusParameters(\n        effects_per_startup={'costs': 25000},  # \u20ac25k per startup\n    ),\n)\n</code></pre> <p>When \\(s(t) = 0\\): flow is zero. When \\(s(t) = 1\\): flow bounds apply.</p>"},{"location":"user-guide/mathematical-notation/features/StatusParameters/#startup-tracking","title":"Startup Tracking","text":"<p>Detect transitions: \\(s^{start}(t) - s^{stop}(t) = s(t) - s(t-1)\\)</p> Startup CostsRunning CostsStartup Limit <pre><code>fx.StatusParameters(\n    effects_per_startup={'costs': 25000},\n)\n</code></pre> <pre><code>fx.StatusParameters(\n    effects_per_active_hour={'costs': 100},  # \u20ac/h while on\n)\n</code></pre> <pre><code>fx.StatusParameters(\n    startup_limit=20,  # Max 20 starts per period\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/features/StatusParameters/#duration-constraints","title":"Duration Constraints","text":"Min UptimeMin DowntimeMax UptimeTotal Hours <p>Once on, must stay on for minimum duration:</p> <p>\\(s^{start}(t) = 1 \\Rightarrow \\sum_{j=t}^{t+k} s(j) \\geq T_{up}^{min}\\)</p> <pre><code>fx.StatusParameters(min_uptime=8)  # 8 hours minimum\n</code></pre> <p>Once off, must stay off for minimum duration:</p> <p>\\(s^{stop}(t) = 1 \\Rightarrow \\sum_{j=t}^{t+k} (1 - s(j)) \\geq T_{down}^{min}\\)</p> <pre><code>fx.StatusParameters(min_downtime=4)  # 4 hours cooling\n</code></pre> <p>Force shutdown after limit:</p> <p>\\(\\sum_{j=t-k}^{t} s(j) \\leq T_{up}^{max}\\)</p> <pre><code>fx.StatusParameters(max_uptime=18)  # Max 18h continuous\n</code></pre> <p>Limit total operating hours per period:</p> <p>\\(H^{min} \\leq \\sum_t s(t) \\cdot \\Delta t \\leq H^{max}\\)</p> <pre><code>fx.StatusParameters(\n    active_hours_min=2000,\n    active_hours_max=5000,\n)\n</code></pre>"},{"location":"user-guide/mathematical-notation/features/StatusParameters/#reference","title":"Reference","text":"Symbol Type Description \\(s(t)\\) \\(\\{0, 1\\}\\) Binary status (0=off, 1=on) \\(s^{start}(t)\\) \\(\\{0, 1\\}\\) Startup indicator \\(s^{stop}(t)\\) \\(\\{0, 1\\}\\) Shutdown indicator \\(T_{up}^{min}\\) \\(\\mathbb{R}_{\\geq 0}\\) Min uptime in hours (<code>min_uptime</code>) \\(T_{up}^{max}\\) \\(\\mathbb{R}_{\\geq 0}\\) Max uptime in hours (<code>max_uptime</code>) \\(T_{down}^{min}\\) \\(\\mathbb{R}_{\\geq 0}\\) Min downtime in hours (<code>min_downtime</code>) \\(H^{min}\\) \\(\\mathbb{R}_{\\geq 0}\\) Min total active hours (<code>active_hours_min</code>) \\(H^{max}\\) \\(\\mathbb{R}_{\\geq 0}\\) Max total active hours (<code>active_hours_max</code>) \\(\\Delta t\\) \\(\\mathbb{R}_{&gt; 0}\\) Timestep duration (hours) <p>Classes: <code>StatusParameters</code>, <code>StatusModel</code></p>"},{"location":"user-guide/optimization/","title":"Running Optimizations","text":"<p>This section covers how to run optimizations in flixOpt, including different optimization modes and solver configuration.</p>"},{"location":"user-guide/optimization/#verifying-your-model","title":"Verifying Your Model","text":"<p>Before running an optimization, it's helpful to visualize your system structure:</p> <pre><code># Generate an interactive network diagram\nflow_system.topology.plot(path='my_system.html')\n\n# Or get structure info programmatically\nnodes, edges = flow_system.topology.infos()\nprint(f\"Components: {[n for n, d in nodes.items() if d['class'] == 'Component']}\")\nprint(f\"Buses: {[n for n, d in nodes.items() if d['class'] == 'Bus']}\")\nprint(f\"Flows: {list(edges.keys())}\")\n</code></pre>"},{"location":"user-guide/optimization/#standard-optimization","title":"Standard Optimization","text":"<p>The recommended way to run an optimization is directly on the <code>FlowSystem</code>:</p> <pre><code>import flixopt as fx\n\n# Simple one-liner\nflow_system.optimize(fx.solvers.HighsSolver())\n\n# Access results directly\nprint(flow_system.solution['Boiler(Q_th)|flow_rate'])\nprint(flow_system.components['Boiler'].solution)\n</code></pre> <p>For more control over the optimization process, you can split model building and solving:</p> <pre><code># Build the model first\nflow_system.build_model()\n\n# Optionally inspect or modify the model\nprint(flow_system.model.constraints)\n\n# Then solve\nflow_system.solve(fx.solvers.HighsSolver())\n</code></pre> <p>Best for:</p> <ul> <li>Small to medium problems</li> <li>When you need the globally optimal solution</li> <li>Problems without time-coupling simplifications</li> </ul>"},{"location":"user-guide/optimization/#clustered-optimization","title":"Clustered Optimization","text":"<p>For large problems, use time series clustering to reduce computational complexity:</p> <pre><code>from tsam import ExtremeConfig\n\n# Cluster to 12 typical days\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=12,\n    cluster_duration='1D',\n    extremes=ExtremeConfig(method='new_cluster', max_value=['HeatDemand(Q)|fixed_relative_profile']),\n)\n\n# Optimize the clustered system\nfs_clustered.optimize(fx.solvers.HighsSolver())\n\n# Expand back to full resolution\nfs_expanded = fs_clustered.transform.expand()\n</code></pre> <p>Best for:</p> <ul> <li>Investment planning problems</li> <li>Year-long optimizations</li> <li>When computational speed is critical</li> </ul> <p>Trade-offs:</p> <ul> <li>Much faster solve times</li> <li>Approximates the full problem</li> <li>Best when patterns repeat (e.g., typical days)</li> </ul> <p>See the Clustering Guide for details on storage modes, peak selection, and multi-dimensional support.</p>"},{"location":"user-guide/optimization/#choosing-an-optimization-mode","title":"Choosing an Optimization Mode","text":"Mode Problem Size Solve Time Solution Quality Standard Small-Medium Slow Optimal Clustered Very Large Fast Approximate"},{"location":"user-guide/optimization/#transform-accessor","title":"Transform Accessor","text":"<p>The <code>transform</code> accessor provides methods to create modified copies of your FlowSystem. All transform methods return a new FlowSystem without a solution \u2014 you must re-optimize the transformed system.</p>"},{"location":"user-guide/optimization/#selecting-subsets","title":"Selecting Subsets","text":"<p>Select a subset of your data by label or index:</p> <pre><code># Select by label (like xarray.sel)\nfs_january = flow_system.transform.sel(time=slice('2024-01-01', '2024-01-31'))\nfs_scenario = flow_system.transform.sel(scenario='base')\n\n# Select by integer index (like xarray.isel)\nfs_first_week = flow_system.transform.isel(time=slice(0, 168))\nfs_first_scenario = flow_system.transform.isel(scenario=0)\n\n# Re-optimize the subset\nfs_january.optimize(fx.solvers.HighsSolver())\n</code></pre>"},{"location":"user-guide/optimization/#resampling-time-series","title":"Resampling Time Series","text":"<p>Change the temporal resolution of your FlowSystem:</p> <pre><code># Resample to 4-hour intervals\nfs_4h = flow_system.transform.resample(time='4h', method='mean')\n\n# Resample to daily\nfs_daily = flow_system.transform.resample(time='1D', method='mean')\n\n# Re-optimize with new resolution\nfs_4h.optimize(fx.solvers.HighsSolver())\n</code></pre> <p>Available resampling methods: <code>'mean'</code>, <code>'sum'</code>, <code>'max'</code>, <code>'min'</code>, <code>'first'</code>, <code>'last'</code></p>"},{"location":"user-guide/optimization/#clustering","title":"Clustering","text":"<p>See the Clustering Guide for comprehensive documentation.</p>"},{"location":"user-guide/optimization/#use-cases","title":"Use Cases","text":"Method Use Case <code>sel()</code> / <code>isel()</code> Analyze specific time periods, scenarios, or periods <code>resample()</code> Reduce problem size, test at lower resolution <code>cluster()</code> Investment planning with typical periods"},{"location":"user-guide/optimization/#custom-constraints","title":"Custom Constraints","text":"<p>flixOpt is built on linopy, allowing you to add custom constraints beyond what's available through the standard API.</p>"},{"location":"user-guide/optimization/#adding-custom-constraints","title":"Adding Custom Constraints","text":"<p>To add custom constraints, build the model first, then access the underlying linopy model:</p> <pre><code># Build the model (without solving)\nflow_system.build_model()\n\n# Access the linopy model\nmodel = flow_system.model\n\n# Access variables from the solution namespace\n# Variables are named: \"ElementLabel|variable_name\"\nboiler_flow = model.variables['Boiler(Q_th)|flow_rate']\nchp_flow = model.variables['CHP(Q_th)|flow_rate']\n\n# Add a custom constraint: Boiler must produce at least as much as CHP\nmodel.add_constraints(\n    boiler_flow &gt;= chp_flow,\n    name='boiler_min_chp'\n)\n\n# Solve with the custom constraint\nflow_system.solve(fx.solvers.HighsSolver())\n</code></pre>"},{"location":"user-guide/optimization/#common-use-cases","title":"Common Use Cases","text":"<p>Minimum runtime constraint: <pre><code># Require component to run at least 100 hours total\non_var = model.variables['CHP|on']  # Binary on/off variable\nhours = flow_system.timestep_duration  # DataArray with duration per timestep\nmodel.add_constraints(\n    (on_var * hours).sum() &gt;= 100,\n    name='chp_min_runtime'\n)\n</code></pre></p> <p>Linking flows across components: <pre><code># Heat pump and boiler combined must meet minimum base load\nhp_flow = model.variables['HeatPump(Q_th)|flow_rate']\nboiler_flow = model.variables['Boiler(Q_th)|flow_rate']\nmodel.add_constraints(\n    hp_flow + boiler_flow &gt;= 50,  # At least 50 kW combined\n    name='min_heat_supply'\n)\n</code></pre></p> <p>Seasonal constraints: <pre><code>import pandas as pd\n\n# Different constraints for summer vs winter\nsummer_mask = flow_system.timesteps.month.isin([6, 7, 8])\nwinter_mask = flow_system.timesteps.month.isin([12, 1, 2])\n\nflow_var = model.variables['Boiler(Q_th)|flow_rate']\n\n# Lower capacity in summer\nmodel.add_constraints(\n    flow_var.sel(time=flow_system.timesteps[summer_mask]) &lt;= 100,\n    name='summer_limit'\n)\n</code></pre></p>"},{"location":"user-guide/optimization/#inspecting-the-model","title":"Inspecting the Model","text":"<p>Before adding constraints, inspect available variables and existing constraints:</p> <pre><code>flow_system.build_model()\nmodel = flow_system.model\n\n# List all variables\nprint(model.variables)\n\n# List all constraints\nprint(model.constraints)\n\n# Get details about a specific variable\nprint(model.variables['Boiler(Q_th)|flow_rate'])\n</code></pre>"},{"location":"user-guide/optimization/#variable-naming-convention","title":"Variable Naming Convention","text":"<p>Variables follow this naming pattern:</p> Element Type Pattern Example Flow rate <code>Component(FlowLabel)\\|flow_rate</code> <code>Boiler(Q_th)\\|flow_rate</code> Flow size <code>Component(FlowLabel)\\|size</code> <code>Boiler(Q_th)\\|size</code> On/off status <code>Component\\|on</code> <code>CHP\\|on</code> Charge state <code>Storage\\|charge_state</code> <code>Battery\\|charge_state</code> Effect totals <code>effect_name\\|total</code> <code>costs\\|total</code>"},{"location":"user-guide/optimization/#solver-configuration","title":"Solver Configuration","text":""},{"location":"user-guide/optimization/#available-solvers","title":"Available Solvers","text":"Solver Type Speed License HiGHS Open-source Fast Free Gurobi Commercial Fastest Academic/Commercial CPLEX Commercial Fastest Academic/Commercial GLPK Open-source Slower Free <p>Recommendation: Start with HiGHS (included by default). Use Gurobi/CPLEX for large models or when speed matters.</p>"},{"location":"user-guide/optimization/#solver-options","title":"Solver Options","text":"<pre><code># Basic usage with defaults\nflow_system.optimize(fx.solvers.HighsSolver())\n\n# With custom options\nflow_system.optimize(\n    fx.solvers.GurobiSolver(\n        time_limit_seconds=3600,\n        mip_gap=0.01,\n        extra_options={\n            'Threads': 4,\n            'Presolve': 2\n        }\n    )\n)\n</code></pre> <p>Common solver parameters:</p> <ul> <li><code>time_limit_seconds</code> - Maximum solve time</li> <li><code>mip_gap</code> - Acceptable optimality gap (0.01 = 1%)</li> <li><code>log_to_console</code> - Show solver output</li> </ul>"},{"location":"user-guide/optimization/#performance-tips","title":"Performance Tips","text":""},{"location":"user-guide/optimization/#model-size-reduction","title":"Model Size Reduction","text":"<ul> <li>Use longer timesteps where acceptable</li> <li>Use <code>flow_system.transform.cluster()</code> for long horizons</li> <li>Remove unnecessary components</li> <li>Simplify constraint formulations</li> </ul>"},{"location":"user-guide/optimization/#solver-tuning","title":"Solver Tuning","text":"<ul> <li>Enable presolve and cuts</li> <li>Adjust optimality tolerances for faster (approximate) solutions</li> <li>Use parallel threads when available</li> </ul>"},{"location":"user-guide/optimization/#problem-formulation","title":"Problem Formulation","text":"<ul> <li>Avoid unnecessary binary variables</li> <li>Use continuous investment sizes when possible</li> <li>Tighten variable bounds</li> <li>Remove redundant constraints</li> </ul>"},{"location":"user-guide/optimization/#debugging","title":"Debugging","text":""},{"location":"user-guide/optimization/#infeasibility","title":"Infeasibility","text":"<p>If your model has no feasible solution:</p> <ol> <li> <p>Enable excess penalties on buses to allow balance violations:    <pre><code># Allow imbalance with high penalty cost (default is 1e5)\nheat_bus = fx.Bus('Heat', excess_penalty_per_flow_hour=1e5)\n\n# Or disable penalty to enforce strict balance\nelectricity_bus = fx.Bus('Electricity', excess_penalty_per_flow_hour=None)\n</code></pre>    When <code>excess_penalty_per_flow_hour</code> is set, the optimization can violate bus balance constraints by paying a penalty, helping identify which constraints cause infeasibility.</p> </li> <li> <p>Use Gurobi for infeasibility analysis - When using GurobiSolver and the model is infeasible, flixOpt automatically extracts and logs the Irreducible Inconsistent Subsystem (IIS):    <pre><code># Gurobi provides detailed infeasibility analysis\nflow_system.optimize(fx.solvers.GurobiSolver())\n# If infeasible, check the model documentation file for IIS details\n</code></pre>    The infeasible constraints are saved to the model documentation file in the results folder.</p> </li> <li> <p>Check balance constraints - can supply meet demand?</p> </li> <li>Verify capacity limits are consistent</li> <li>Review storage state requirements</li> <li>Simplify model to isolate the issue</li> </ol> <p>See Troubleshooting for more details.</p>"},{"location":"user-guide/optimization/#unexpected-results","title":"Unexpected Results","text":"<p>If solutions don't match expectations:</p> <ol> <li>Verify input data (units, scales)</li> <li>Enable logging: <code>fx.CONFIG.exploring()</code></li> <li>Visualize intermediate results</li> <li>Start with a simpler model</li> <li>Check constraint formulations</li> </ol>"},{"location":"user-guide/optimization/#next-steps","title":"Next Steps","text":"<ul> <li>See Examples for working code</li> <li>Learn about Mathematical Notation</li> <li>Explore Recipes for common patterns</li> </ul>"},{"location":"user-guide/optimization/clustering/","title":"Time-Series Clustering","text":"<p>Time-series clustering reduces large optimization problems by aggregating timesteps into representative typical periods. This enables fast investment optimization while preserving key system dynamics.</p>"},{"location":"user-guide/optimization/clustering/#when-to-use-clustering","title":"When to Use Clustering","text":"<p>Use clustering when:</p> <ul> <li>Optimizing over a full year or longer</li> <li>Investment sizing is the primary goal (not detailed dispatch)</li> <li>You need faster solve times and can accept approximation</li> <li>The system has repeating patterns (daily, weekly, seasonal)</li> </ul> <p>Skip clustering for:</p> <ul> <li>Short optimization horizons (days to weeks)</li> <li>Dispatch-only problems without investments</li> <li>Systems requiring exact temporal sequences</li> </ul>"},{"location":"user-guide/optimization/clustering/#two-stage-workflow","title":"Two-Stage Workflow","text":"<p>The recommended approach: cluster for fast sizing, then validate at full resolution.</p> <pre><code>import flixopt as fx\nfrom tsam import ExtremeConfig\n\n# Load or create your FlowSystem\nflow_system = fx.FlowSystem(timesteps)\nflow_system.add_elements(...)\n\n# Stage 1: Cluster and optimize (fast)\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=12,\n    cluster_duration='1D',\n    extremes=ExtremeConfig(method='new_cluster', max_value=['HeatDemand(Q)|fixed_relative_profile']),\n)\nfs_clustered.optimize(fx.solvers.HighsSolver())\n\n# Stage 2: Expand back to full resolution\nfs_expanded = fs_clustered.transform.expand()\n\n# Access full-resolution results\ncharge_state = fs_expanded.solution['Storage|charge_state']\nflow_rates = fs_expanded.solution['Boiler(Q_th)|flow_rate']\n</code></pre>"},{"location":"user-guide/optimization/clustering/#clustering-parameters","title":"Clustering Parameters","text":"Parameter Description Example <code>n_clusters</code> Number of typical periods <code>12</code> (typical days for a year) <code>cluster_duration</code> Duration of each cluster <code>'1D'</code>, <code>'24h'</code>, or <code>24</code> (hours) <code>weights</code> Clustering weights per time series <code>{'demand': 2.0, 'solar': 1.0}</code> <code>cluster</code> tsam <code>ClusterConfig</code> for clustering options <code>ClusterConfig(method='k_medoids')</code> <code>extremes</code> tsam <code>ExtremeConfig</code> for peak preservation <code>ExtremeConfig(method='new_cluster', max_value=[...])</code> <code>predef_cluster_assignments</code> Manual cluster assignments Array of cluster indices"},{"location":"user-guide/optimization/clustering/#peak-selection-with-extremeconfig","title":"Peak Selection with ExtremeConfig","text":"<p>Use <code>ExtremeConfig</code> to ensure extreme conditions are represented:</p> <pre><code>from tsam import ExtremeConfig\n\n# Ensure the peak demand day is included\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n    extremes=ExtremeConfig(\n        method='new_cluster',  # Create new cluster for extremes\n        max_value=['HeatDemand(Q)|fixed_relative_profile'],  # Capture peak demand\n    ),\n)\n</code></pre> <p>Without peak selection, the clustering algorithm might average out extreme days, leading to undersized equipment.</p> <p>ExtremeConfig options:</p> Field Description <code>method</code> How extremes are handled: <code>'new_cluster'</code>, <code>'append'</code>, <code>'replace_cluster_center'</code> <code>max_value</code> Time series where maximum values should be preserved <code>min_value</code> Time series where minimum values should be preserved <code>max_period</code> Time series where period with maximum sum should be preserved <code>min_period</code> Time series where period with minimum sum should be preserved"},{"location":"user-guide/optimization/clustering/#advanced-clustering-options-with-clusterconfig","title":"Advanced Clustering Options with ClusterConfig","text":"<p>Fine-tune the clustering algorithm with <code>ClusterConfig</code>:</p> <pre><code>from tsam import ClusterConfig, ExtremeConfig\n\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n    cluster=ClusterConfig(\n        method='hierarchical',  # Clustering algorithm\n        representation='medoid',  # Use actual periods, not averages\n    ),\n    extremes=ExtremeConfig(method='new_cluster', max_value=['demand']),\n)\n</code></pre> <p>Available clustering algorithms (<code>ClusterConfig.method</code>):</p> Method Description <code>'hierarchical'</code> Produces consistent hierarchical groupings (default) <code>'kmeans'</code> Fast, good for most cases <code>'kmedoids'</code> Uses actual periods as representatives <code>'kmaxoids'</code> Maximizes representativeness <code>'averaging'</code> Simple averaging of similar periods <p>Representation methods (<code>ClusterConfig.representation</code>):</p> Method Description <code>'medoid'</code> Use actual periods as representatives (default) <code>'mean'</code> Average of all periods in cluster <code>'distribution'</code> Preserve value distribution (duration curves) <p>For additional tsam parameters, pass them as keyword arguments:</p> <pre><code># Pass any tsam.aggregate() parameter\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n    normalize_column_means=True,  # Normalize all time series to same mean\n    preserve_column_means=True,  # Rescale results to match original means\n)\n</code></pre>"},{"location":"user-guide/optimization/clustering/#clustering-quality-metrics","title":"Clustering Quality Metrics","text":"<p>After clustering, access quality metrics to evaluate the aggregation accuracy:</p> <pre><code>fs_clustered = flow_system.transform.cluster(n_clusters=8, cluster_duration='1D')\n\n# Access clustering metrics (xr.Dataset)\nmetrics = fs_clustered.clustering.metrics\nprint(metrics)  # Shows RMSE, MAE, etc. per time series\n\n# Access specific metric\nrmse = metrics['RMSE']  # xr.DataArray with dims [time_series, period?, scenario?]\n</code></pre>"},{"location":"user-guide/optimization/clustering/#storage-modes","title":"Storage Modes","text":"<p>Storage behavior during clustering is controlled via the <code>cluster_mode</code> parameter:</p> <pre><code>storage = fx.Storage(\n    'SeasonalPit',\n    capacity_in_flow_hours=5000,\n    cluster_mode='intercluster_cyclic',  # Default\n    ...\n)\n</code></pre>"},{"location":"user-guide/optimization/clustering/#available-modes","title":"Available Modes","text":"Mode Behavior Best For <code>'intercluster_cyclic'</code> Links storage across clusters + yearly cycling Seasonal storage (pit, underground) <code>'intercluster'</code> Links storage across clusters, free start/end Multi-year optimization <code>'cyclic'</code> Each cluster independent, but start = end Daily storage (battery, hot water tank) <code>'independent'</code> Each cluster fully independent Quick estimates, debugging"},{"location":"user-guide/optimization/clustering/#how-inter-cluster-linking-works","title":"How Inter-Cluster Linking Works","text":"<p>For <code>'intercluster'</code> and <code>'intercluster_cyclic'</code> modes, the optimizer tracks:</p> <ol> <li><code>SOC_boundary</code>: Absolute state-of-charge at the start of each original period</li> <li><code>charge_state</code>: Relative change (\u0394E) within each typical period</li> </ol> <p>During expansion, these combine with self-discharge decay:</p> <pre><code>actual_SOC(t) = SOC_boundary[period] \u00d7 (1 - loss)^t + \u0394E(t)\n</code></pre> <p>This enables accurate modeling of seasonal storage that charges in summer and discharges in winter.</p>"},{"location":"user-guide/optimization/clustering/#choosing-the-right-mode","title":"Choosing the Right Mode","text":"<pre><code># Seasonal pit storage - needs yearly linking\npit_storage = fx.Storage(\n    'SeasonalPit',\n    cluster_mode='intercluster_cyclic',\n    capacity_in_flow_hours=10000,\n    relative_loss_per_hour=0.0001,\n    ...\n)\n\n# Daily hot water tank - only needs daily cycling\ntank = fx.Storage(\n    'HotWaterTank',\n    cluster_mode='cyclic',\n    capacity_in_flow_hours=50,\n    ...\n)\n\n# Battery with quick estimate\nbattery = fx.Storage(\n    'Battery',\n    cluster_mode='independent',  # Fastest, ignores long-term effects\n    ...\n)\n</code></pre>"},{"location":"user-guide/optimization/clustering/#multi-dimensional-support","title":"Multi-Dimensional Support","text":"<p>Clustering works with periods and scenarios:</p> <pre><code># FlowSystem with multiple periods and scenarios\nflow_system = fx.FlowSystem(\n    timesteps,\n    periods=pd.Index([2025, 2030, 2035], name='period'),\n    scenarios=pd.Index(['low', 'base', 'high'], name='scenario'),\n)\n\n# Cluster - dimensions are preserved\nfs_clustered = flow_system.transform.cluster(\n    n_clusters=8,\n    cluster_duration='1D',\n)\n\n# Solution has all dimensions\n# Dims: (time, cluster, period, scenario)\nflow_rate = fs_clustered.solution['Boiler(Q_th)|flow_rate']\n</code></pre>"},{"location":"user-guide/optimization/clustering/#expanding-solutions","title":"Expanding Solutions","text":"<p>After optimization, expand results back to full resolution:</p> <pre><code>fs_expanded = fs_clustered.transform.expand()\n\n# Full timesteps are restored\nprint(f\"Original: {len(flow_system.timesteps)} timesteps\")\nprint(f\"Clustered: {len(fs_clustered.timesteps)} timesteps\")\nprint(f\"Expanded: {len(fs_expanded.timesteps)} timesteps\")\n\n# Storage charge state correctly reconstructed\ncharge_state = fs_expanded.solution['Storage|charge_state']\n</code></pre> <p>The expansion:</p> <ol> <li>Maps each original timestep to its assigned cluster</li> <li>For storage with inter-cluster linking, combines <code>SOC_boundary</code> with within-cluster <code>charge_state</code></li> <li>Applies self-discharge decay factors</li> </ol>"},{"location":"user-guide/optimization/clustering/#performance-tips","title":"Performance Tips","text":""},{"location":"user-guide/optimization/clustering/#cluster-count-selection","title":"Cluster Count Selection","text":"Time Horizon Cluster Duration Suggested n_clusters 1 year 1 day 8-16 1 year 1 week 4-8 Multiple years 1 day 12-24"},{"location":"user-guide/optimization/clustering/#speed-vs-accuracy-trade-off","title":"Speed vs Accuracy Trade-off","text":"<pre><code># Fast (less accurate) - for quick estimates\nfs_fast = flow_system.transform.cluster(n_clusters=4, cluster_duration='1D')\n\n# Balanced - typical production use\nfs_balanced = flow_system.transform.cluster(n_clusters=12, cluster_duration='1D')\n\n# Accurate (slower) - for final results\nfs_accurate = flow_system.transform.cluster(n_clusters=24, cluster_duration='1D')\n</code></pre>"},{"location":"user-guide/optimization/clustering/#see-also","title":"See Also","text":"<ul> <li>Storage Component - Storage mathematical formulation</li> <li>Notebooks: Clustering - Interactive examples</li> <li>Notebooks: Storage Modes - Storage mode comparison</li> </ul>"},{"location":"user-guide/recipes/","title":"Recipes","text":"<p>Short, focused code snippets showing how to do specific things in FlixOpt. Unlike full examples, recipes focus on a single concept.</p>"},{"location":"user-guide/recipes/#available-recipes","title":"Available Recipes","text":"<ul> <li>Plotting Custom Data - Create faceted plots with your own xarray data using Plotly Express</li> </ul>"},{"location":"user-guide/recipes/#planned-topics","title":"Planned Topics","text":"<ul> <li>Storage Patterns - Batteries, thermal storage, seasonal storage</li> <li>Multi-Criteria Optimization - Balance multiple objectives</li> <li>Data I/O - Loading time series from CSV, databases, APIs</li> <li>Data Manipulation - Common xarray operations for parameterization and analysis</li> <li>Investment Optimization - Size optimization strategies</li> <li>Renewable Integration - Solar, wind capacity optimization</li> <li>Status Constraints - Minimum runtime, startup costs</li> <li>Large-Scale Problems - Segmented and aggregated calculations</li> <li>Custom Constraints - Extend models with linopy</li> <li>Domain-Specific Patterns - District heating, microgrids, industrial processes</li> </ul>"},{"location":"user-guide/recipes/#want-to-contribute","title":"Want to Contribute?","text":"<p>If you have recurring modeling patterns or clever solutions to share, please contribute via GitHub issues or pull requests.</p> <p>Guidelines:</p> <ol> <li>Keep it short (&lt; 100 lines of code)</li> <li>Focus on one specific technique</li> <li>Add brief explanation and when to use it</li> </ol> <p>Check the contribution guide for details.</p>"},{"location":"user-guide/recipes/plotting-custom-data/","title":"Plotting Custom Data","text":"<p>While the plot accessor (<code>flow_system.statistics.plot</code>) is designed for optimization results, you often need to plot custom xarray data. The <code>.plotly</code> accessor provides the same convenience for any <code>xr.Dataset</code> or <code>xr.DataArray</code>.</p> <p>Accessor Registration</p> <p>The <code>.plotly</code> and <code>.fxstats</code> accessors are automatically registered when you import flixopt. Just <code>import flixopt</code> and they become available on all xarray objects.</p>"},{"location":"user-guide/recipes/plotting-custom-data/#quick-example","title":"Quick Example","text":"<pre><code>import flixopt as fx  # Registers .plotly and .fxstats accessors\nimport xarray as xr\n\nds = xr.Dataset({\n    'Solar': (['time'], solar_values),\n    'Wind': (['time'], wind_values),\n})\n\n# Plot directly - no conversion needed!\nds.plotly.line(title='Energy Generation')\nds.plotly.bar(title='Stacked Generation')\n</code></pre>"},{"location":"user-guide/recipes/plotting-custom-data/#full-documentation","title":"Full Documentation","text":"<p>The <code>.plotly</code> accessor is provided by the xarray_plotly package. See the full documentation for:</p> <ul> <li>All available plot methods (line, bar, area, scatter, imshow, pie, box)</li> <li>Automatic dimension assignment</li> <li>Custom colors and styling</li> <li>Combining with xarray operations</li> </ul> <p>For duration curves, use <code>.fxstats.to_duration_curve()</code> before plotting.</p>"},{"location":"user-guide/results/","title":"Analyzing Results","text":"<p>After running an optimization, flixOpt provides powerful tools to access, analyze, and visualize your results.</p>"},{"location":"user-guide/results/#accessing-solution-data","title":"Accessing Solution Data","text":""},{"location":"user-guide/results/#raw-solution","title":"Raw Solution","text":"<p>The <code>solution</code> property contains all optimization variables as an xarray Dataset:</p> <pre><code># Run optimization\nflow_system.optimize(fx.solvers.HighsSolver())\n\n# Access the full solution dataset\nsolution = flow_system.solution\nprint(solution)\n\n# Access specific variables\nprint(solution['Boiler(Q_th)|flow_rate'])\nprint(solution['Battery|charge_state'])\n</code></pre>"},{"location":"user-guide/results/#element-specific-solutions","title":"Element-Specific Solutions","text":"<p>Access solution data for individual elements:</p> <pre><code># Component solutions\nboiler = flow_system.components['Boiler']\nprint(boiler.solution)  # All variables for this component\n\n# Flow solutions\nflow = flow_system.flows['Boiler(Q_th)']\nprint(flow.solution)\n\n# Bus solutions (if imbalance is allowed)\nbus = flow_system.buses['Heat']\nprint(bus.solution)\n</code></pre>"},{"location":"user-guide/results/#statistics-accessor","title":"Statistics Accessor","text":"<p>The <code>statistics</code> accessor provides pre-computed aggregations for common analysis tasks:</p> <pre><code># Access via the statistics property\nstats = flow_system.statistics\n</code></pre>"},{"location":"user-guide/results/#available-data-properties","title":"Available Data Properties","text":"Property Description <code>flow_rates</code> All flow rate variables as xarray Dataset <code>flow_hours</code> Flow hours (flow_rate \u00d7 hours_per_timestep) <code>sizes</code> All size variables (fixed and optimized) <code>charge_states</code> Storage charge state variables <code>temporal_effects</code> Temporal effects per contributor per timestep <code>periodic_effects</code> Periodic (investment) effects per contributor <code>total_effects</code> Total effects (temporal + periodic) per contributor <code>effect_share_factors</code> Conversion factors between effects"},{"location":"user-guide/results/#examples","title":"Examples","text":"<pre><code># Get all flow rates\nflow_rates = flow_system.statistics.flow_rates\nprint(flow_rates)\n\n# Get flow hours (energy)\nflow_hours = flow_system.statistics.flow_hours\ntotal_heat = flow_hours['Boiler(Q_th)'].sum()\n\n# Get sizes (capacities)\nsizes = flow_system.statistics.sizes\nprint(f\"Boiler size: {sizes['Boiler(Q_th)'].values}\")\n\n# Get storage charge states\ncharge_states = flow_system.statistics.charge_states\n\n# Get effect breakdown by contributor\ntemporal = flow_system.statistics.temporal_effects\nprint(temporal['costs'])  # Costs per contributor per timestep\n\n# Group by component\ntemporal['costs'].groupby('component').sum()\n</code></pre>"},{"location":"user-guide/results/#effect-analysis","title":"Effect Analysis","text":"<p>Analyze how effects (costs, emissions, etc.) are distributed:</p> <pre><code># Access effects via the new properties\nstats = flow_system.statistics\n\n# Temporal effects per timestep (costs, CO2, etc. per contributor)\nstats.temporal_effects['costs']  # DataArray with dims [time, contributor]\nstats.temporal_effects['costs'].sum('contributor')  # Total per timestep\n\n# Periodic effects (investment costs, etc.)\nstats.periodic_effects['costs']  # DataArray with dim [contributor]\n\n# Total effects (temporal + periodic combined)\nstats.total_effects['costs'].sum('contributor')  # Grand total\n\n# Group by component or component type\nstats.total_effects['costs'].groupby('component').sum()\nstats.total_effects['costs'].groupby('component_type').sum()\n</code></pre> <p>Contributors</p> <p>Contributors are automatically detected from the optimization solution and include:</p> <ul> <li>Flows: Individual flows with <code>effects_per_flow_hour</code></li> <li>Components: Components with <code>effects_per_active_hour</code> or similar direct effects</li> </ul> <p>Each contributor has associated metadata (<code>component</code> and <code>component_type</code> coordinates) for flexible groupby operations.</p>"},{"location":"user-guide/results/#plotting-results","title":"Plotting Results","text":"<p>The <code>statistics.plot</code> accessor provides visualization methods:</p> <pre><code># Balance plots\nflow_system.statistics.plot.balance('HeatBus')\nflow_system.statistics.plot.balance('Boiler')\n\n# Heatmaps\nflow_system.statistics.plot.heatmap('Boiler(Q_th)|flow_rate')\n\n# Duration curves\nflow_system.statistics.plot.duration_curve('Boiler(Q_th)')\n\n# Sankey diagrams\nflow_system.statistics.plot.sankey()\n\n# Effects breakdown\nflow_system.statistics.plot.effects()  # Total costs by component\nflow_system.statistics.plot.effects(effect='costs', by='contributor')  # By individual flows\nflow_system.statistics.plot.effects(aspect='temporal', by='time')  # Over time\n</code></pre> <p>See Plotting Results for comprehensive plotting documentation.</p>"},{"location":"user-guide/results/#network-visualization","title":"Network Visualization","text":"<p>The <code>topology</code> accessor lets you visualize and inspect your system structure:</p>"},{"location":"user-guide/results/#static-html-visualization","title":"Static HTML Visualization","text":"<p>Generate an interactive network diagram using PyVis:</p> <pre><code># Default: saves to 'flow_system.html' and opens in browser\nflow_system.topology.plot()\n\n# Custom options\nflow_system.topology.plot(\n    path='output/my_network.html',\n    controls=['nodes', 'layout', 'physics'],\n    show=True\n)\n</code></pre> <p>Parameters:</p> Parameter Type Default Description <code>path</code> str, Path, or False <code>'flow_system.html'</code> Where to save the HTML file <code>controls</code> bool or list <code>True</code> UI controls to show <code>show</code> bool <code>None</code> Whether to open in browser"},{"location":"user-guide/results/#interactive-app","title":"Interactive App","text":"<p>Launch a Dash/Cytoscape application for exploring the network:</p> <pre><code># Start the visualization server\nflow_system.topology.start_app()\n\n# ... interact with the visualization in your browser ...\n\n# Stop when done\nflow_system.topology.stop_app()\n</code></pre> <p>Optional Dependencies</p> <p>The interactive app requires additional packages: <pre><code>pip install flixopt[network_viz]\n</code></pre></p>"},{"location":"user-guide/results/#network-structure-info","title":"Network Structure Info","text":"<p>Get node and edge information programmatically:</p> <pre><code>nodes, edges = flow_system.topology.infos()\n\n# nodes: dict mapping labels to properties\n# {'Boiler': {'label': 'Boiler', 'class': 'Component', 'infos': '...'}, ...}\n\n# edges: dict mapping flow labels to properties\n# {'Boiler(Q_th)': {'label': 'Q_th', 'start': 'Boiler', 'end': 'Heat', ...}, ...}\n\nprint(f\"Components and buses: {list(nodes.keys())}\")\nprint(f\"Flows: {list(edges.keys())}\")\n</code></pre>"},{"location":"user-guide/results/#saving-and-loading","title":"Saving and Loading","text":"<p>Save the FlowSystem (including solution) for later analysis:</p> <pre><code># Save to NetCDF (recommended for large datasets)\nflow_system.to_netcdf('results/my_system.nc')\n\n# Load later\nloaded_fs = fx.FlowSystem.from_netcdf('results/my_system.nc')\nprint(loaded_fs.solution)\n\n# Save to JSON (human-readable, smaller datasets)\nflow_system.to_json('results/my_system.json')\nloaded_fs = fx.FlowSystem.from_json('results/my_system.json')\n</code></pre>"},{"location":"user-guide/results/#working-with-xarray","title":"Working with xarray","text":"<p>All result data uses xarray, giving you powerful data manipulation:</p> <pre><code>solution = flow_system.solution\n\n# Select specific times\nsummer = solution.sel(time=slice('2024-06-01', '2024-08-31'))\n\n# Aggregate over dimensions\ndaily_avg = solution.resample(time='D').mean()\n\n# Convert to pandas\ndf = solution['Boiler(Q_th)|flow_rate'].to_dataframe()\n\n# Export to various formats\nsolution.to_netcdf('full_solution.nc')\ndf.to_csv('boiler_flow.csv')\n</code></pre>"},{"location":"user-guide/results/#complete-example","title":"Complete Example","text":"<pre><code>import flixopt as fx\nimport pandas as pd\n\n# Build and optimize\ntimesteps = pd.date_range('2024-01-01', periods=168, freq='h')\nflow_system = fx.FlowSystem(timesteps)\n# ... add elements ...\nflow_system.optimize(fx.solvers.HighsSolver())\n\n# Visualize network structure\nflow_system.topology.plot(path='system_network.html')\n\n# Analyze results\nprint(\"=== Flow Statistics ===\")\nprint(flow_system.statistics.flow_hours)\n\nprint(\"\\n=== Effect Breakdown ===\")\nprint(flow_system.statistics.total_effects)\n\n# Create plots\nflow_system.statistics.plot.balance('HeatBus')\nflow_system.statistics.plot.heatmap('Boiler(Q_th)|flow_rate')\n\n# Save for later\nflow_system.to_netcdf('results/optimized_system.nc')\n</code></pre>"},{"location":"user-guide/results/#comparing-multiple-systems","title":"Comparing Multiple Systems","text":"<p>Use the <code>Comparison</code> class to analyze and visualize multiple FlowSystems side-by-side. This is useful for:</p> <ul> <li>Comparing different design alternatives (with/without CHP, different storage sizes)</li> <li>Analyzing optimization method trade-offs (full vs. two-stage, different aggregation levels)</li> <li>Sensitivity analysis (different scenarios, parameter variations)</li> </ul>"},{"location":"user-guide/results/#basic-usage","title":"Basic Usage","text":"<pre><code>import flixopt as fx\n\n# Optimize two system variants\nfs_baseline = create_system()\nfs_baseline.name = 'Baseline'\nfs_baseline.optimize(solver)\n\nfs_with_storage = create_system_with_storage()\nfs_with_storage.name = 'With Storage'\nfs_with_storage.optimize(solver)\n\n# Create comparison\ncomp = fx.Comparison([fs_baseline, fs_with_storage])\n\n# Side-by-side balance plots (auto-faceted by 'case' dimension)\ncomp.statistics.plot.balance('Heat')\n\n# Access combined data with 'case' dimension\ncomp.statistics.flow_rates  # xr.Dataset with dims: (time, case)\ncomp.solution  # Combined solution dataset\n</code></pre>"},{"location":"user-guide/results/#requirements","title":"Requirements","text":"<p>All FlowSystems must have matching core dimensions (<code>time</code>, <code>period</code>, <code>scenario</code>). Auxiliary dimensions like <code>cluster_boundary</code> are ignored. If core dimensions differ, use <code>.transform.sel()</code> to align them first:</p> <pre><code># Systems with different scenarios\nfs_both = flow_system  # Has 'Mild Winter' and 'Harsh Winter' scenarios\nfs_mild = flow_system.transform.sel(scenario='Mild Winter')  # Single scenario\n\n# Cannot compare directly - scenario dimension mismatch!\n# fx.Comparison([fs_both, fs_mild])  # Raises ValueError\n\n# Instead, select matching dimensions\nfs_both_mild = fs_both.transform.sel(scenario='Mild Winter')\ncomp = fx.Comparison([fs_both_mild, fs_mild])  # Works!\n\n# Auxiliary dimensions are OK (e.g., expanded clustered solutions)\nfs_expanded = fs_clustered.transform.expand()  # Has cluster_boundary dim\ncomp = fx.Comparison([fs_full, fs_expanded])  # Works! cluster_boundary is ignored\n</code></pre> <p>Component Differences</p> <p>Systems can have different components. The Comparison aligns data where possible, and variables unique to specific systems will be <code>NaN</code> for others. This is useful for comparing scenarios like \"with vs. without storage\" where one system has Storage components and the other doesn't.</p>"},{"location":"user-guide/results/#available-properties","title":"Available Properties","text":"<p>The <code>Comparison.statistics</code> accessor mirrors all <code>StatisticsAccessor</code> properties, returning combined datasets with an added <code>'case'</code> dimension:</p> Property Description <code>flow_rates</code> All flow rate variables <code>flow_hours</code> Flow hours (energy) <code>sizes</code> Component sizes <code>storage_sizes</code> Storage capacities <code>charge_states</code> Storage charge states <code>temporal_effects</code> Effects per timestep <code>periodic_effects</code> Investment effects <code>total_effects</code> Combined effects"},{"location":"user-guide/results/#available-plot-methods","title":"Available Plot Methods","text":"<p>All standard plot methods work on the comparison, with the <code>'case'</code> dimension automatically used for faceting:</p> <pre><code>comp = fx.Comparison([fs_baseline, fs_modified])\n\n# Balance plots - faceted by case\ncomp.statistics.plot.balance('Heat')\ncomp.statistics.plot.balance('Electricity', mode='area')\n\n# Flow plots\ncomp.statistics.plot.flows(component='CHP')\n\n# Effect breakdowns\ncomp.statistics.plot.effects()\n\n# Heatmaps\ncomp.statistics.plot.heatmap('Boiler(Q_th)')\n\n# Duration curves\ncomp.statistics.plot.duration_curve('CHP(Q_th)')\n\n# Storage plots\ncomp.statistics.plot.storage('Battery')\n</code></pre>"},{"location":"user-guide/results/#computing-differences","title":"Computing Differences","text":"<p>Use the <code>diff()</code> method to compute differences relative to a reference case:</p> <pre><code># Differences relative to first case (default)\ndifferences = comp.diff()\n\n# Differences relative to specific case\ndifferences = comp.diff(reference='Baseline')\ndifferences = comp.diff(reference=0)  # By index\n\n# Analyze differences\nprint(differences['costs'])  # Cost difference per case\n</code></pre>"},{"location":"user-guide/results/#naming-systems","title":"Naming Systems","text":"<p>System names come from <code>FlowSystem.name</code> by default. Override with the <code>names</code> parameter:</p> <pre><code># Using FlowSystem.name (default)\nfs1.name = 'Scenario A'\nfs2.name = 'Scenario B'\ncomp = fx.Comparison([fs1, fs2])\n\n# Or override explicitly\ncomp = fx.Comparison([fs1, fs2], names=['Base Case', 'Alternative'])\n</code></pre>"},{"location":"user-guide/results/#example-comparing-optimization-methods","title":"Example: Comparing Optimization Methods","text":"<pre><code># Full optimization\nfs_full = flow_system.copy()\nfs_full.name = 'Full Optimization'\nfs_full.optimize(solver)\n\n# Two-stage optimization\nfs_sizing = flow_system.transform.resample('4h')\nfs_sizing.optimize(solver)\nfs_dispatch = flow_system.transform.fix_sizes(fs_sizing.statistics.sizes)\nfs_dispatch.name = 'Two-Stage'\nfs_dispatch.optimize(solver)\n\n# Compare results\ncomp = fx.Comparison([fs_full, fs_dispatch])\ncomp.statistics.plot.balance('Heat')\n\n# Check cost difference\ndiff = comp.diff()\nprint(f\"Cost difference: {diff['costs'].sel(case='Two-Stage').item():.0f} \u20ac\")\n</code></pre>"},{"location":"user-guide/results/#next-steps","title":"Next Steps","text":"<ul> <li>Plotting Results - Detailed plotting documentation</li> <li>Examples - Working code examples</li> </ul>"}]}