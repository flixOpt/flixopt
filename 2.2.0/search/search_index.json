{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FlixOpt","text":"<p>FlixOpt is a Python-based optimization framework designed to tackle energy and material flow problems using mixed-integer linear programming (MILP).</p> <p>It borrows concepts from both FINE and oemof.solph.</p>"},{"location":"#why-flixopt","title":"Why FlixOpt?","text":"<p>FlixOpt is designed as a general-purpose optimization framework to get your model running quickly, without sacrificing flexibility down the road:</p> <ul> <li> <p>Easy to Use API: FlixOpt provides a Pythonic, object-oriented interface that makes mathematical optimization more accessible to Python developers.</p> </li> <li> <p>Approachable Learning Curve: Designed to be accessible from the start, with options for more detailed models down the road.</p> </li> <li> <p>Domain Independence: While frameworks like oemof and FINE excel at energy system modeling with domain-specific components, FlixOpt offers a more general mathematical approach that can be applied across different fields.</p> </li> <li> <p>Extensibility: Easily add custom constraints or variables to any FlixOpt Model using linopy. Tailor any FlixOpt model to your specific needs without loosing the convenience of the framework.</p> </li> <li> <p>Solver Agnostic: Work with different solvers through a consistent interface.</p> </li> <li> <p>Results File I/O: Built to analyze results independent of running the optimization.</p> </li> </ul> <p> </p> Conceptual Usage and IO operations of FlixOpt"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install flixopt\n</code></pre> <p>For more detailed installation options, see the Getting Started guide.</p>"},{"location":"#license","title":"License","text":"<p>FlixOpt is released under the MIT License. See LICENSE for details.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use FlixOpt in your research or project, please cite:</p> <ul> <li>Main Citation: DOI:10.18086/eurosun.2022.04.07</li> <li>Short Overview: DOI:10.13140/RG.2.2.14948.24969</li> </ul> <p>A more sophisticated paper is in progress</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Getting Started</li> <li>User Guide</li> <li>Examples</li> <li>Contribute</li> <li>API Reference</li> <li>Release Notes</li> </ul>"},{"location":"contribute/","title":"Contributing to the Project","text":"<p>We warmly welcome contributions from the community! This guide will help you get started with contributing to our project.</p>"},{"location":"contribute/#development-setup","title":"Development Setup","text":"<ol> <li>Clone the repository <code>git clone https://github.com/flixOpt/flixopt.git</code></li> <li>Install the development dependencies <code>pip install -e \".[dev]\"</code></li> <li>Install pre-commit hooks <code>pre-commit install</code> (one-time setup)</li> <li>Run <code>pytest</code> to ensure your code passes all tests</li> </ol>"},{"location":"contribute/#code-quality","title":"Code Quality","text":"<p>We use Ruff for linting and formatting. After the one-time setup above, code quality checks run automatically on every commit.</p> <p>To run manually: - <code>ruff check --fix .</code> to check and fix linting issues - <code>ruff format .</code> to format code or - <code>pre-commit run</code> or <code>pre-commit run --all-files</code> to trigger all checks</p>"},{"location":"contribute/#documentation-optional","title":"Documentation (Optional)","text":"<p>FlixOpt uses mkdocs to generate documentation. To work on documentation: <pre><code>pip install -e \".[docs]\"\nmkdocs serve\n</code></pre> Then navigate to http://127.0.0.1:8000/</p>"},{"location":"contribute/#testing","title":"Testing","text":"<ul> <li><code>pytest</code> to run the test suite</li> <li>You can also run the provided python script <code>run_all_test.py</code></li> </ul>"},{"location":"contribute/#best-practices","title":"Best practices","text":""},{"location":"contribute/#coding-guidelines","title":"Coding Guidelines","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Write clear, commented code</li> <li>Include type hints</li> <li>Create or update tests for new functionality</li> <li>Ensure 100% test coverage for new code</li> </ul>"},{"location":"contribute/#branches-releases","title":"Branches &amp; Releases","text":"<p>New features should be branched from <code>main</code> into <code>feature/*</code> As stated, we follow Semantic Versioning. Releases are created manually from the <code>main</code> branch.</p>"},{"location":"getting-started/","title":"Getting Started with FlixOpt","text":"<p>This guide will help you install FlixOpt, understand its basic concepts, and run your first optimization model.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#basic-installation","title":"Basic Installation","text":"<p>Install FlixOpt directly into your environment using pip:</p> <pre><code>pip install flixopt\n</code></pre> <p>This provides the core functionality with the HiGHS solver included.</p>"},{"location":"getting-started/#full-installation","title":"Full Installation","text":"<p>For all features including interactive network visualizations and time series aggregation:</p> <pre><code>pip install \"flixopt[full]\"\n</code></pre>"},{"location":"getting-started/#basic-workflow","title":"Basic Workflow","text":"<p>Working with FlixOpt follows a general pattern:</p> <ol> <li>Create a <code>FlowSystem</code> with a time series</li> <li>Define <code>Effects</code> (costs, emissions, etc.)</li> <li>Define <code>Buses</code> as connection points in your system</li> <li>Add <code>Components</code> like converters, storage, sources/sinks with their Flows</li> <li>Run <code>Calculations</code> to optimize your system</li> <li>Analyze <code>Results</code> using built-in or external visualization tools</li> </ol>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you've installed FlixOpt and understand the basic workflow, you can:</p> <ul> <li>Learn about the core concepts of FlixOpt</li> <li>Explore some examples</li> <li>Check the API reference for detailed documentation</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>This section contains the documentation for all modules and classes in flixopt. For more information on how to use the classes and functions, see the User Guide section.</p>"},{"location":"api-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>aggregation</li> <li>calculation</li> <li>commons</li> <li>components</li> <li>config</li> <li>core</li> <li>effects</li> <li>elements</li> <li>features</li> <li>flow_system</li> <li>interface</li> <li>io</li> <li>linear_converters</li> <li>network_app</li> <li>plotting</li> <li>results</li> <li>solvers</li> <li>structure</li> <li>utils</li> </ul>"},{"location":"api-reference/aggregation/","title":"aggregation","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation","title":"flixopt.aggregation","text":"<p>This module contains the Aggregation functionality for the flixopt framework. Through this, aggregating TimeSeriesData is possible.</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation-attributes","title":"Attributes","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation-classes","title":"Classes","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation","title":"Aggregation","text":"<pre><code>Aggregation(original_data: DataFrame, hours_per_time_step: Scalar, hours_per_period: Scalar, nr_of_periods: int = 8, weights: dict[str, float] | None = None, time_series_for_high_peaks: list[str] | None = None, time_series_for_low_peaks: list[str] | None = None)\n</code></pre> <p>aggregation organizing class</p> <p>Parameters:</p> Name Type Description Default <code>original_data</code> <code>DataFrame</code> <p>The original data to aggregate</p> required <code>hours_per_time_step</code> <code>Scalar</code> <p>The duration of each timestep in hours.</p> required <code>hours_per_period</code> <code>Scalar</code> <p>The duration of each period in hours.</p> required <code>nr_of_periods</code> <code>int</code> <p>The number of typical periods to use in the aggregation.</p> <code>8</code> <code>weights</code> <code>dict[str, float] | None</code> <p>The weights for aggregation. If None, all time series are equally weighted.</p> <code>None</code> <code>time_series_for_high_peaks</code> <code>list[str] | None</code> <p>List of time series to use for explicitly selecting periods with high values.</p> <code>None</code> <code>time_series_for_low_peaks</code> <code>list[str] | None</code> <p>List of time series to use for explicitly selecting periods with low values.</p> <code>None</code>"},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation-functions","title":"Functions","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation.cluster","title":"cluster","text":"<pre><code>cluster() -&gt; None\n</code></pre> <p>Durchf\u00fchrung der Zeitreihenaggregation</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation.get_cluster_indices","title":"get_cluster_indices","text":"<pre><code>get_cluster_indices() -&gt; dict[str, list[np.ndarray]]\n</code></pre> <p>Generates a dictionary that maps each cluster to a list of index vectors representing the time steps assigned to that cluster for each period.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, list[ndarray]]</code> <p>{cluster_0: [index_vector_3, index_vector_7, ...],    cluster_1: [index_vector_1],    ...}</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.Aggregation.get_equation_indices","title":"get_equation_indices","text":"<pre><code>get_equation_indices(skip_first_index_of_period: bool = True) -&gt; tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Generates pairs of indices for the equations by comparing index vectors of the same cluster. If <code>skip_first_index_of_period</code> is True, the first index of each period is skipped.</p> <p>Parameters:</p> Name Type Description Default <code>skip_first_index_of_period</code> <code>bool</code> <p>Whether to include or skip the first index of each period.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>tuple[np.ndarray, np.ndarray]: Two arrays of indices.</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationParameters","title":"AggregationParameters","text":"<pre><code>AggregationParameters(hours_per_period: float, nr_of_periods: int, fix_storage_flows: bool, aggregate_data_and_fix_non_binary_vars: bool, percentage_of_period_freedom: float = 0, penalty_of_period_freedom: float = 0, time_series_for_high_peaks: list[TimeSeriesData] | None = None, time_series_for_low_peaks: list[TimeSeriesData] | None = None)\n</code></pre> <p>Initializes aggregation parameters for time series data</p> <p>Parameters:</p> Name Type Description Default <code>hours_per_period</code> <code>float</code> <p>Duration of each period in hours.</p> required <code>nr_of_periods</code> <code>int</code> <p>Number of typical periods to use in the aggregation.</p> required <code>fix_storage_flows</code> <code>bool</code> <p>Whether to aggregate storage flows (load/unload); if other flows are fixed, fixing storage flows is usually not required.</p> required <code>aggregate_data_and_fix_non_binary_vars</code> <code>bool</code> <p>Whether to aggregate all time series data, which allows to fix all time series variables (like flow_rate), or only fix binary variables. If False non time_series data is changed!! If True, the mathematical Problem is simplified even further.</p> required <code>percentage_of_period_freedom</code> <code>float</code> <p>Specifies the maximum percentage (0\u2013100) of binary values within each period that can deviate as \"free variables\", chosen by the solver (default is 0). This allows binary variables to be 'partly equated' between aggregated periods.</p> <code>0</code> <code>penalty_of_period_freedom</code> <code>float</code> <p>The penalty associated with each \"free variable\"; defaults to 0. Added to Penalty</p> <code>0</code> <code>time_series_for_high_peaks</code> <code>list[TimeSeriesData] | None</code> <p>List of TimeSeriesData to use for explicitly selecting periods with high values.</p> <code>None</code> <code>time_series_for_low_peaks</code> <code>list[TimeSeriesData] | None</code> <p>List of TimeSeriesData to use for explicitly selecting periods with low values.</p> <code>None</code>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationParameters-functions","title":"Functions","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel","title":"AggregationModel","text":"<pre><code>AggregationModel(model: SystemModel, aggregation_parameters: AggregationParameters, flow_system: FlowSystem, aggregation_data: Aggregation, components_to_clusterize: list[Component] | None)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>The AggregationModel holds equations and variables related to the Aggregation of a FLowSystem. It creates Equations that equates indices of variables, and introduces penalties related to binary variables, that escape the equation to their related binaries in other periods</p> <p>Modeling-Element for \"index-equating\"-equations</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel-attributes","title":"Attributes","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel-functions","title":"Functions","text":""},{"location":"api-reference/aggregation/#flixopt.aggregation.AggregationModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/calculation/","title":"calculation","text":""},{"location":"api-reference/calculation/#flixopt.calculation","title":"flixopt.calculation","text":"<p>This module contains the Calculation functionality for the flixopt framework. It is used to calculate a SystemModel for a given FlowSystem through a solver. There are three different Calculation types:     1. FullCalculation: Calculates the SystemModel for the full FlowSystem     2. AggregatedCalculation: Calculates the SystemModel for the full FlowSystem, but aggregates the TimeSeriesData.         This simplifies the mathematical model and usually speeds up the solving process.     3. SegmentedCalculation: Solves a SystemModel for each individual Segment of the FlowSystem.</p>"},{"location":"api-reference/calculation/#flixopt.calculation-attributes","title":"Attributes","text":""},{"location":"api-reference/calculation/#flixopt.calculation-classes","title":"Classes","text":""},{"location":"api-reference/calculation/#flixopt.calculation.Calculation","title":"Calculation","text":"<pre><code>Calculation(name: str, flow_system: FlowSystem, active_timesteps: DatetimeIndex | None = None, folder: Path | None = None)\n</code></pre> <p>class for defined way of solving a flow_system optimization</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>active_timesteps</code> <code>DatetimeIndex | None</code> <p>list with indices, which should be used for calculation. If None, then all timesteps are used.</p> <code>None</code> <code>folder</code> <code>Path | None</code> <p>folder where results should be saved. If None, then the current working directory is used.</p> <code>None</code>"},{"location":"api-reference/calculation/#flixopt.calculation.Calculation-functions","title":"Functions","text":""},{"location":"api-reference/calculation/#flixopt.calculation.FullCalculation","title":"FullCalculation","text":"<pre><code>FullCalculation(name: str, flow_system: FlowSystem, active_timesteps: DatetimeIndex | None = None, folder: Path | None = None)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>FullCalculation solves the complete optimization problem using all time steps.</p> <p>This is the most comprehensive calculation type that considers every time step in the optimization, providing the most accurate but computationally intensive solution.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>active_timesteps</code> <code>DatetimeIndex | None</code> <p>list with indices, which should be used for calculation. If None, then all timesteps are used.</p> <code>None</code> <code>folder</code> <code>Path | None</code> <p>folder where results should be saved. If None, then the current working directory is used.</p> <code>None</code>"},{"location":"api-reference/calculation/#flixopt.calculation.FullCalculation-functions","title":"Functions","text":""},{"location":"api-reference/calculation/#flixopt.calculation.AggregatedCalculation","title":"AggregatedCalculation","text":"<pre><code>AggregatedCalculation(name: str, flow_system: FlowSystem, aggregation_parameters: AggregationParameters, components_to_clusterize: list[Component] | None = None, active_timesteps: DatetimeIndex | None = None, folder: Path | None = None)\n</code></pre> <p>               Bases: <code>FullCalculation</code></p> <p>AggregatedCalculation reduces computational complexity by clustering time series into typical periods.</p> <p>This calculation approach aggregates time series data using clustering techniques (tsam) to identify representative time periods, significantly reducing computation time while maintaining solution accuracy.</p> Note <p>The quality of the solution depends on the choice of aggregation parameters. The optimal parameters depend on the specific problem and the characteristics of the time series data. For more information, refer to the tsam documentation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>FlowSystem to be optimized</p> required <code>aggregation_parameters</code> <code>AggregationParameters</code> <p>Parameters for aggregation. See AggregationParameters class documentation</p> required <code>components_to_clusterize</code> <code>list[Component] | None</code> <p>list of Components to perform aggregation on. If None, all components are aggregated. This equalizes variables in the components according to the typical periods computed in the aggregation</p> <code>None</code> <code>active_timesteps</code> <code>DatetimeIndex | None</code> <p>DatetimeIndex of timesteps to use for calculation. If None, all timesteps are used</p> <code>None</code> <code>folder</code> <code>Path | None</code> <p>Folder where results should be saved. If None, current working directory is used</p> <code>None</code> <code>aggregation</code> <p>contains the aggregation model</p> required"},{"location":"api-reference/calculation/#flixopt.calculation.SegmentedCalculation","title":"SegmentedCalculation","text":"<pre><code>SegmentedCalculation(name: str, flow_system: FlowSystem, timesteps_per_segment: int, overlap_timesteps: int, nr_of_previous_values: int = 1, folder: Path | None = None)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>Solve large optimization problems by dividing time horizon into (overlapping) segments.</p> <p>This class addresses memory and computational limitations of large-scale optimization problems by decomposing the time horizon into smaller overlapping segments that are solved sequentially. Each segment uses final values from the previous segment as initial conditions, ensuring dynamic continuity across the solution.</p> Key Concepts <p>Temporal Decomposition: Divides long time horizons into manageable segments Overlapping Windows: Segments share timesteps to improve storage dynamics Value Transfer: Final states of one segment become initial states of the next Sequential Solving: Each segment solved independently but with coupling</p> Limitations and Constraints <p>Investment Parameters: InvestParameters are not supported in segmented calculations as investment decisions must be made for the entire time horizon, not per segment.</p> <p>Global Constraints: Time-horizon-wide constraints (flow_hours_total_min/max, load_factor_min/max) may produce suboptimal results as they cannot be enforced globally across segments.</p> <p>Storage Dynamics: While overlap helps, storage optimization may be suboptimal compared to full-horizon solutions due to limited foresight in each segment.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the calculation, used in result files and logging.</p> required <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to optimize, containing all components, flows, and buses.</p> required <code>timesteps_per_segment</code> <code>int</code> <p>Number of timesteps in each segment (excluding overlap). Must be &gt; 2 to avoid internal side effects. Larger values provide better optimization at the cost of memory and computation time.</p> required <code>overlap_timesteps</code> <code>int</code> <p>Number of additional timesteps added to each segment. Improves storage optimization by providing lookahead. Higher values improve solution quality but increase computational cost.</p> required <code>nr_of_previous_values</code> <code>int</code> <p>Number of previous timestep values to transfer between segments for initialization. Typically 1 is sufficient.</p> <code>1</code> <code>folder</code> <code>Path | None</code> <p>Directory for saving results. Defaults to current working directory + 'results'.</p> <code>None</code> <p>Examples:</p> <p>Annual optimization with monthly segments:</p> <pre><code># 8760 hours annual data with monthly segments (730 hours) and 48-hour overlap\nsegmented_calc = SegmentedCalculation(\n    name='annual_energy_system',\n    flow_system=energy_system,\n    timesteps_per_segment=730,  # ~1 month\n    overlap_timesteps=48,  # 2 days overlap\n    folder=Path('results/segmented'),\n)\nsegmented_calc.do_modeling_and_solve(solver='gurobi')\n</code></pre> <p>Weekly optimization with daily overlap:</p> <pre><code># Weekly segments for detailed operational planning\nweekly_calc = SegmentedCalculation(\n    name='weekly_operations',\n    flow_system=industrial_system,\n    timesteps_per_segment=168,  # 1 week (hourly data)\n    overlap_timesteps=24,  # 1 day overlap\n    nr_of_previous_values=1,\n)\n</code></pre> <p>Large-scale system with minimal overlap:</p> <pre><code># Large system with minimal overlap for computational efficiency\nlarge_calc = SegmentedCalculation(\n    name='large_scale_grid',\n    flow_system=grid_system,\n    timesteps_per_segment=100,  # Shorter segments\n    overlap_timesteps=5,  # Minimal overlap\n)\n</code></pre> Design Considerations <p>Segment Size: Balance between solution quality and computational efficiency. Larger segments provide better optimization but require more memory and time.</p> <p>Overlap Duration: More overlap improves storage dynamics and reduces end-effects but increases computational cost. Typically 5-10% of segment length.</p> <p>Storage Systems: Systems with large storage components benefit from longer overlaps to capture charge/discharge cycles effectively.</p> <p>Investment Decisions: Use FullCalculation for problems requiring investment optimization, as SegmentedCalculation cannot handle investment parameters.</p> Common Use Cases <ul> <li>Annual Planning: Long-term planning with seasonal variations</li> <li>Large Networks: Spatially or temporally large energy systems</li> <li>Memory-Limited Systems: When full optimization exceeds available memory</li> <li>Operational Planning: Detailed short-term optimization with limited foresight</li> <li>Sensitivity Analysis: Quick approximate solutions for parameter studies</li> </ul> Performance Tips <ul> <li>Start with FullCalculation and use this class if memory issues occur</li> <li>Use longer overlaps for systems with significant storage</li> <li>Monitor solution quality at segment boundaries for discontinuities</li> </ul> Warning <p>The evaluation of the solution is a bit more complex than FullCalculation or AggregatedCalculation due to the overlapping individual solutions.</p>"},{"location":"api-reference/calculation/#flixopt.calculation.SegmentedCalculation-attributes","title":"Attributes","text":""},{"location":"api-reference/calculation/#flixopt.calculation.SegmentedCalculation.start_values_of_segments","title":"start_values_of_segments  <code>property</code>","text":"<pre><code>start_values_of_segments: dict[int, dict[str, Any]]\n</code></pre> <p>Gives an overview of the start values of all Segments</p>"},{"location":"api-reference/commons/","title":"commons","text":""},{"location":"api-reference/commons/#flixopt.commons","title":"flixopt.commons","text":"<p>This module makes the commonly used classes and functions available in the flixopt framework.</p>"},{"location":"api-reference/commons/#flixopt.commons-classes","title":"Classes","text":""},{"location":"api-reference/commons/#flixopt.commons.AggregationParameters","title":"AggregationParameters","text":"<pre><code>AggregationParameters(hours_per_period: float, nr_of_periods: int, fix_storage_flows: bool, aggregate_data_and_fix_non_binary_vars: bool, percentage_of_period_freedom: float = 0, penalty_of_period_freedom: float = 0, time_series_for_high_peaks: list[TimeSeriesData] | None = None, time_series_for_low_peaks: list[TimeSeriesData] | None = None)\n</code></pre> <p>Initializes aggregation parameters for time series data</p> <p>Parameters:</p> Name Type Description Default <code>hours_per_period</code> <code>float</code> <p>Duration of each period in hours.</p> required <code>nr_of_periods</code> <code>int</code> <p>Number of typical periods to use in the aggregation.</p> required <code>fix_storage_flows</code> <code>bool</code> <p>Whether to aggregate storage flows (load/unload); if other flows are fixed, fixing storage flows is usually not required.</p> required <code>aggregate_data_and_fix_non_binary_vars</code> <code>bool</code> <p>Whether to aggregate all time series data, which allows to fix all time series variables (like flow_rate), or only fix binary variables. If False non time_series data is changed!! If True, the mathematical Problem is simplified even further.</p> required <code>percentage_of_period_freedom</code> <code>float</code> <p>Specifies the maximum percentage (0\u2013100) of binary values within each period that can deviate as \"free variables\", chosen by the solver (default is 0). This allows binary variables to be 'partly equated' between aggregated periods.</p> <code>0</code> <code>penalty_of_period_freedom</code> <code>float</code> <p>The penalty associated with each \"free variable\"; defaults to 0. Added to Penalty</p> <code>0</code> <code>time_series_for_high_peaks</code> <code>list[TimeSeriesData] | None</code> <p>List of TimeSeriesData to use for explicitly selecting periods with high values.</p> <code>None</code> <code>time_series_for_low_peaks</code> <code>list[TimeSeriesData] | None</code> <p>List of TimeSeriesData to use for explicitly selecting periods with low values.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.AggregationParameters-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.AggregatedCalculation","title":"AggregatedCalculation","text":"<pre><code>AggregatedCalculation(name: str, flow_system: FlowSystem, aggregation_parameters: AggregationParameters, components_to_clusterize: list[Component] | None = None, active_timesteps: DatetimeIndex | None = None, folder: Path | None = None)\n</code></pre> <p>               Bases: <code>FullCalculation</code></p> <p>AggregatedCalculation reduces computational complexity by clustering time series into typical periods.</p> <p>This calculation approach aggregates time series data using clustering techniques (tsam) to identify representative time periods, significantly reducing computation time while maintaining solution accuracy.</p> Note <p>The quality of the solution depends on the choice of aggregation parameters. The optimal parameters depend on the specific problem and the characteristics of the time series data. For more information, refer to the tsam documentation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>FlowSystem to be optimized</p> required <code>aggregation_parameters</code> <code>AggregationParameters</code> <p>Parameters for aggregation. See AggregationParameters class documentation</p> required <code>components_to_clusterize</code> <code>list[Component] | None</code> <p>list of Components to perform aggregation on. If None, all components are aggregated. This equalizes variables in the components according to the typical periods computed in the aggregation</p> <code>None</code> <code>active_timesteps</code> <code>DatetimeIndex | None</code> <p>DatetimeIndex of timesteps to use for calculation. If None, all timesteps are used</p> <code>None</code> <code>folder</code> <code>Path | None</code> <p>Folder where results should be saved. If None, current working directory is used</p> <code>None</code> <code>aggregation</code> <p>contains the aggregation model</p> required"},{"location":"api-reference/commons/#flixopt.commons.FullCalculation","title":"FullCalculation","text":"<pre><code>FullCalculation(name: str, flow_system: FlowSystem, active_timesteps: DatetimeIndex | None = None, folder: Path | None = None)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>FullCalculation solves the complete optimization problem using all time steps.</p> <p>This is the most comprehensive calculation type that considers every time step in the optimization, providing the most accurate but computationally intensive solution.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of calculation</p> required <code>flow_system</code> <code>FlowSystem</code> <p>flow_system which should be calculated</p> required <code>active_timesteps</code> <code>DatetimeIndex | None</code> <p>list with indices, which should be used for calculation. If None, then all timesteps are used.</p> <code>None</code> <code>folder</code> <code>Path | None</code> <p>folder where results should be saved. If None, then the current working directory is used.</p> <code>None</code>"},{"location":"api-reference/commons/#flixopt.commons.FullCalculation-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.SegmentedCalculation","title":"SegmentedCalculation","text":"<pre><code>SegmentedCalculation(name: str, flow_system: FlowSystem, timesteps_per_segment: int, overlap_timesteps: int, nr_of_previous_values: int = 1, folder: Path | None = None)\n</code></pre> <p>               Bases: <code>Calculation</code></p> <p>Solve large optimization problems by dividing time horizon into (overlapping) segments.</p> <p>This class addresses memory and computational limitations of large-scale optimization problems by decomposing the time horizon into smaller overlapping segments that are solved sequentially. Each segment uses final values from the previous segment as initial conditions, ensuring dynamic continuity across the solution.</p> Key Concepts <p>Temporal Decomposition: Divides long time horizons into manageable segments Overlapping Windows: Segments share timesteps to improve storage dynamics Value Transfer: Final states of one segment become initial states of the next Sequential Solving: Each segment solved independently but with coupling</p> Limitations and Constraints <p>Investment Parameters: InvestParameters are not supported in segmented calculations as investment decisions must be made for the entire time horizon, not per segment.</p> <p>Global Constraints: Time-horizon-wide constraints (flow_hours_total_min/max, load_factor_min/max) may produce suboptimal results as they cannot be enforced globally across segments.</p> <p>Storage Dynamics: While overlap helps, storage optimization may be suboptimal compared to full-horizon solutions due to limited foresight in each segment.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the calculation, used in result files and logging.</p> required <code>flow_system</code> <code>FlowSystem</code> <p>The FlowSystem to optimize, containing all components, flows, and buses.</p> required <code>timesteps_per_segment</code> <code>int</code> <p>Number of timesteps in each segment (excluding overlap). Must be &gt; 2 to avoid internal side effects. Larger values provide better optimization at the cost of memory and computation time.</p> required <code>overlap_timesteps</code> <code>int</code> <p>Number of additional timesteps added to each segment. Improves storage optimization by providing lookahead. Higher values improve solution quality but increase computational cost.</p> required <code>nr_of_previous_values</code> <code>int</code> <p>Number of previous timestep values to transfer between segments for initialization. Typically 1 is sufficient.</p> <code>1</code> <code>folder</code> <code>Path | None</code> <p>Directory for saving results. Defaults to current working directory + 'results'.</p> <code>None</code> <p>Examples:</p> <p>Annual optimization with monthly segments:</p> <pre><code># 8760 hours annual data with monthly segments (730 hours) and 48-hour overlap\nsegmented_calc = SegmentedCalculation(\n    name='annual_energy_system',\n    flow_system=energy_system,\n    timesteps_per_segment=730,  # ~1 month\n    overlap_timesteps=48,  # 2 days overlap\n    folder=Path('results/segmented'),\n)\nsegmented_calc.do_modeling_and_solve(solver='gurobi')\n</code></pre> <p>Weekly optimization with daily overlap:</p> <pre><code># Weekly segments for detailed operational planning\nweekly_calc = SegmentedCalculation(\n    name='weekly_operations',\n    flow_system=industrial_system,\n    timesteps_per_segment=168,  # 1 week (hourly data)\n    overlap_timesteps=24,  # 1 day overlap\n    nr_of_previous_values=1,\n)\n</code></pre> <p>Large-scale system with minimal overlap:</p> <pre><code># Large system with minimal overlap for computational efficiency\nlarge_calc = SegmentedCalculation(\n    name='large_scale_grid',\n    flow_system=grid_system,\n    timesteps_per_segment=100,  # Shorter segments\n    overlap_timesteps=5,  # Minimal overlap\n)\n</code></pre> Design Considerations <p>Segment Size: Balance between solution quality and computational efficiency. Larger segments provide better optimization but require more memory and time.</p> <p>Overlap Duration: More overlap improves storage dynamics and reduces end-effects but increases computational cost. Typically 5-10% of segment length.</p> <p>Storage Systems: Systems with large storage components benefit from longer overlaps to capture charge/discharge cycles effectively.</p> <p>Investment Decisions: Use FullCalculation for problems requiring investment optimization, as SegmentedCalculation cannot handle investment parameters.</p> Common Use Cases <ul> <li>Annual Planning: Long-term planning with seasonal variations</li> <li>Large Networks: Spatially or temporally large energy systems</li> <li>Memory-Limited Systems: When full optimization exceeds available memory</li> <li>Operational Planning: Detailed short-term optimization with limited foresight</li> <li>Sensitivity Analysis: Quick approximate solutions for parameter studies</li> </ul> Performance Tips <ul> <li>Start with FullCalculation and use this class if memory issues occur</li> <li>Use longer overlaps for systems with significant storage</li> <li>Monitor solution quality at segment boundaries for discontinuities</li> </ul> Warning <p>The evaluation of the solution is a bit more complex than FullCalculation or AggregatedCalculation due to the overlapping individual solutions.</p>"},{"location":"api-reference/commons/#flixopt.commons.SegmentedCalculation-attributes","title":"Attributes","text":""},{"location":"api-reference/commons/#flixopt.commons.SegmentedCalculation.start_values_of_segments","title":"start_values_of_segments  <code>property</code>","text":"<pre><code>start_values_of_segments: dict[int, dict[str, Any]]\n</code></pre> <p>Gives an overview of the start values of all Segments</p>"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter","title":"LinearConverter","text":"<pre><code>LinearConverter(label: str, inputs: list[Flow], outputs: list[Flow], on_off_parameters: OnOffParameters | None = None, conversion_factors: list[dict[str, NumericDataTS]] | None = None, piecewise_conversion: PiecewiseConversion | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Converts input-Flows into output-Flows via linear conversion factors.</p> <p>LinearConverter models equipment that transforms one or more input flows into one or more output flows through linear relationships. This includes heat exchangers, electrical converters, chemical reactors, and other equipment where the relationship between inputs and outputs can be expressed as linear equations.</p> <p>The component supports two modeling approaches: simple conversion factors for straightforward linear relationships, or piecewise conversion for complex non-linear behavior approximated through piecewise linear segments.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow]</code> <p>list of input Flows that feed into the converter.</p> required <code>outputs</code> <code>list[Flow]</code> <p>list of output Flows that are produced by the converter.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Information about on and off state of LinearConverter. Component is On/Off if all connected Flows are On/Off. This induces an On-Variable (binary) in all Flows! If possible, use OnOffParameters in a single Flow instead to keep the number of binary variables low.</p> <code>None</code> <code>conversion_factors</code> <code>list[dict[str, NumericDataTS]] | None</code> <p>Linear relationships between flows expressed as a list of dictionaries. Each dictionary maps flow labels to their coefficients in one linear equation. The number of conversion factors must be less than the total number of flows to ensure degrees of freedom &gt; 0. Either 'conversion_factors' OR 'piecewise_conversion' can be used, but not both. For examples also look into the linear_converters.py file.</p> <code>None</code> <code>piecewise_conversion</code> <code>PiecewiseConversion | None</code> <p>Define piecewise linear relationships between flow rates of different flows. Enables modeling of non-linear conversion behavior through linear approximation. Either 'conversion_factors' or 'piecewise_conversion' can be used, but not both.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally, but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Simple 1:1 heat exchanger with 95% efficiency:</p> <pre><code>heat_exchanger = LinearConverter(\n    label='primary_hx',\n    inputs=[hot_water_in],\n    outputs=[hot_water_out],\n    conversion_factors=[{'hot_water_in': 0.95, 'hot_water_out': 1}],\n)\n</code></pre> <p>Multi-input heat pump with COP=3:</p> <pre><code>heat_pump = LinearConverter(\n    label='air_source_hp',\n    inputs=[electricity_in],\n    outputs=[heat_output],\n    conversion_factors=[{'electricity_in': 3, 'heat_output': 1}],\n)\n</code></pre> <p>Combined heat and power (CHP) unit with multiple outputs:</p> <pre><code>chp_unit = LinearConverter(\n    label='gas_chp',\n    inputs=[natural_gas],\n    outputs=[electricity_out, heat_out],\n    conversion_factors=[\n        {'natural_gas': 0.35, 'electricity_out': 1},\n        {'natural_gas': 0.45, 'heat_out': 1},\n    ],\n)\n</code></pre> <p>Electrolyzer with multiple conversion relationships:</p> <pre><code>electrolyzer = LinearConverter(\n    label='pem_electrolyzer',\n    inputs=[electricity_in, water_in],\n    outputs=[hydrogen_out, oxygen_out],\n    conversion_factors=[\n        {'electricity_in': 1, 'hydrogen_out': 50},  # 50 kWh/kg H2\n        {'water_in': 1, 'hydrogen_out': 9},  # 9 kg H2O/kg H2\n        {'hydrogen_out': 8, 'oxygen_out': 1},  # Mass balance\n    ],\n)\n</code></pre> <p>Complex converter with piecewise efficiency:</p> <pre><code>variable_efficiency_converter = LinearConverter(\n    label='variable_converter',\n    inputs=[fuel_in],\n    outputs=[power_out],\n    piecewise_conversion=PiecewiseConversion(\n        {\n            'fuel_in': Piecewise(\n                [\n                    Piece(0, 10),  # Low load operation\n                    Piece(10, 25),  # High load operation\n                ]\n            ),\n            'power_out': Piecewise(\n                [\n                    Piece(0, 3.5),  # Lower efficiency at part load\n                    Piece(3.5, 10),  # Higher efficiency at full load\n                ]\n            ),\n        }\n    ),\n)\n</code></pre> Note <p>Conversion factors define linear relationships where the sum of (coefficient \u00d7 flow_rate) equals zero for each equation: factor1\u00d7flow1 + factor2\u00d7flow2 + ... = 0 Conversion factors define linear relationships. <code>{flow1: a1, flow2: a2, ...}</code> leads to <code>a1\u00d7flow_rate1 + a2\u00d7flow_rate2 + ... = 0</code> Unfortunately the current input format doest read intuitively: {\"electricity\": 1, \"H2\": 50} means that the electricity_in flow rate is multiplied by 1 and the hydrogen_out flow rate is multiplied by 50. THis leads to 50 electricity --&gt; 1 H2.</p> <p>The system must have fewer conversion factors than total flows (degrees of freedom &gt; 0) to avoid over-constraining the problem. For n total flows, use at most n-1 conversion factors.</p> <p>When using piecewise_conversion, the converter operates on one piece at a time, with binary variables determining which piece is active.</p>"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.LinearConverter.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.LinearConverter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Sink","title":"Sink","text":"<pre><code>Sink(label: str, inputs: list[Flow] | None = None, meta_data: dict | None = None, prevent_simultaneous_flow_rates: bool = False, **kwargs)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Sink consumes energy or material flows from the system.</p> <p>Sinks represent demand points like electrical loads, heat demands, material consumption, or any system boundary where flows terminate. They provide unlimited consumption capability subject to flow constraints, demand patterns and effects.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>Input-flows into the sink. Can be single flow or list of flows for sinks consuming multiple commodities or services.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, only one input flow can be active at a time. Useful for modeling mutually exclusive consumption options. Default is False.</p> <code>False</code> <p>Examples:</p> <p>Simple electrical demand:</p> <pre><code>electrical_load = Sink(label='building_load', inputs=[electricity_demand_flow])\n</code></pre> <p>Heat demand with time-varying profile:</p> <pre><code>heat_demand = Sink(\n    label='district_heating_load',\n    inputs=[\n        Flow(\n            label='heat_consumption',\n            bus=heat_bus,\n            fixed_relative_profile=hourly_heat_profile,  # Demand profile\n            size=2000,  # Peak demand of 2000 kW\n        )\n    ],\n)\n</code></pre> <p>Multi-energy building with switching capabilities:</p> <pre><code>flexible_building = Sink(\n    label='smart_building',\n    inputs=[electricity_heating, gas_heating, heat_pump_heating],\n    prevent_simultaneous_flow_rates=True,  # Can only use one heating mode\n)\n</code></pre> <p>Industrial process with variable demand:</p> <pre><code>factory_load = Sink(\n    label='manufacturing_plant',\n    inputs=[\n        Flow(\n            label='electricity_process',\n            bus=electricity_bus,\n            size=5000,  # Base electrical load\n            effects_per_flow_hour={'cost': -0.1},  # Value of service (negative cost)\n        ),\n        Flow(\n            label='steam_process',\n            bus=steam_bus,\n            size=3000,  # Process steam demand\n            fixed_relative_profile=production_schedule,\n        ),\n    ],\n)\n</code></pre> Deprecated <p>The deprecated <code>sink</code> kwarg is accepted for compatibility but will be removed in future releases.</p> <p>Initialize a Sink (consumes flow from the system).</p> <p>Supports legacy <code>sink=</code> keyword for backward compatibility (deprecated): if <code>sink</code> is provided it is used as the single input flow and a DeprecationWarning is issued; specifying both <code>inputs</code> and <code>sink</code> raises ValueError.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Unique element label.</p> required <code>inputs</code> <code>list[Flow]</code> <p>Input flows for the sink.</p> <code>None</code> <code>meta_data</code> <code>dict</code> <p>Arbitrary metadata attached to the element.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, prevents simultaneous nonzero flow rates across the element's inputs by wiring that restriction into the base Component setup.</p> <code>False</code> Note <p>The deprecated <code>sink</code> kwarg is accepted for compatibility but will be removed in future releases.</p>"},{"location":"api-reference/commons/#flixopt.commons.Sink-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Sink.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Sink.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Sink.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Source","title":"Source","text":"<pre><code>Source(label: str, outputs: list[Flow] | None = None, meta_data: dict | None = None, prevent_simultaneous_flow_rates: bool = False, **kwargs)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Source generates or provides energy or material flows into the system.</p> <p>Sources represent supply points like power plants, fuel suppliers, renewable energy sources, or any system boundary where flows originate. They provide unlimited supply capability subject to flow constraints, demand patterns and effects.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>outputs</code> <code>list[Flow] | None</code> <p>Output-flows from the source. Can be single flow or list of flows for sources providing multiple commodities or services.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, only one output flow can be active at a time. Useful for modeling mutually exclusive supply options. Default is False.</p> <code>False</code> <p>Examples:</p> <p>Simple electricity grid connection:</p> <pre><code>grid_source = Source(label='electrical_grid', outputs=[grid_electricity_flow])\n</code></pre> <p>Natural gas supply with cost and capacity constraints:</p> <pre><code>gas_supply = Source(\n    label='gas_network',\n    outputs=[\n        Flow(\n            label='natural_gas_flow',\n            bus=gas_bus,\n            size=1000,  # Maximum 1000 kW supply capacity\n            effects_per_flow_hour={'cost': 0.04},  # \u20ac0.04/kWh gas cost\n        )\n    ],\n)\n</code></pre> <p>Multi-fuel power plant with switching constraints:</p> <pre><code>multi_fuel_plant = Source(\n    label='flexible_generator',\n    outputs=[coal_electricity, gas_electricity, biomass_electricity],\n    prevent_simultaneous_flow_rates=True,  # Can only use one fuel at a time\n)\n</code></pre> <p>Renewable energy source with investment optimization:</p> <pre><code>solar_farm = Source(\n    label='solar_pv',\n    outputs=[\n        Flow(\n            label='solar_power',\n            bus=electricity_bus,\n            size=InvestParameters(\n                minimum_size=0,\n                maximum_size=50000,  # Up to 50 MW\n                specific_effects={'cost': 800},  # \u20ac800/kW installed\n                fix_effects={'cost': 100000},  # \u20ac100k development costs\n            ),\n            fixed_relative_profile=solar_profile,  # Hourly generation profile\n        )\n    ],\n)\n</code></pre> Deprecated <p>The deprecated <code>source</code> kwarg is accepted for compatibility but will be removed in future releases.</p>"},{"location":"api-reference/commons/#flixopt.commons.Source-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Source.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Source.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Source.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink","title":"SourceAndSink","text":"<pre><code>SourceAndSink(label: str, inputs: list[Flow] | None = None, outputs: list[Flow] | None = None, prevent_simultaneous_flow_rates: bool = True, meta_data: dict | None = None, **kwargs)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A SourceAndSink combines both supply and demand capabilities in a single component.</p> <p>SourceAndSink components can both consume AND provide energy or material flows from and to the system, making them ideal for modeling markets, (simple) storage facilities, or bidirectional grid connections where buying and selling occur at the same location.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>Input-flows into the SourceAndSink representing consumption/demand side.</p> <code>None</code> <code>outputs</code> <code>list[Flow] | None</code> <p>Output-flows from the SourceAndSink representing supply/generation side.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, prevents simultaneous input and output flows. This enforces that the component operates either as a source OR sink at any given time, but not both simultaneously. Default is True.</p> <code>True</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Electricity market connection (buy/sell to grid):</p> <pre><code>electricity_market = SourceAndSink(\n    label='grid_connection',\n    inputs=[electricity_purchase],  # Buy from grid\n    outputs=[electricity_sale],  # Sell to grid\n    prevent_simultaneous_flow_rates=True,  # Can't buy and sell simultaneously\n)\n</code></pre> <p>Natural gas storage facility:</p> <pre><code>gas_storage_facility = SourceAndSink(\n    label='underground_gas_storage',\n    inputs=[gas_injection_flow],  # Inject gas into storage\n    outputs=[gas_withdrawal_flow],  # Withdraw gas from storage\n    prevent_simultaneous_flow_rates=True,  # Injection or withdrawal, not both\n)\n</code></pre> <p>District heating network connection:</p> <pre><code>dh_connection = SourceAndSink(\n    label='district_heating_tie',\n    inputs=[heat_purchase_flow],  # Purchase heat from network\n    outputs=[heat_sale_flow],  # Sell excess heat to network\n    prevent_simultaneous_flow_rates=False,  # May allow simultaneous flows\n)\n</code></pre> <p>Industrial waste heat exchange:</p> <pre><code>waste_heat_exchange = SourceAndSink(\n    label='industrial_heat_hub',\n    inputs=[\n        waste_heat_input_a,  # Receive waste heat from process A\n        waste_heat_input_b,  # Receive waste heat from process B\n    ],\n    outputs=[\n        useful_heat_supply_c,  # Supply heat to process C\n        useful_heat_supply_d,  # Supply heat to process D\n    ],\n    prevent_simultaneous_flow_rates=False,  # Multiple simultaneous flows allowed\n)\n</code></pre> Note <p>When prevent_simultaneous_flow_rates is True, binary variables are created to ensure mutually exclusive operation between input and output flows, which increases computational complexity but reflects realistic market or storage operation constraints.</p> <p>SourceAndSink is particularly useful for modeling: - Energy markets with bidirectional trading - Storage facilities with injection/withdrawal operations - Grid tie points with import/export capabilities - Waste exchange networks with multiple participants</p> Deprecated <p>The deprecated <code>sink</code> and <code>source</code> kwargs are accepted for compatibility but will be removed in future releases.</p>"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.SourceAndSink.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Storage","title":"Storage","text":"<pre><code>Storage(label: str, charging: Flow, discharging: Flow, capacity_in_flow_hours: Scalar | InvestParameters, relative_minimum_charge_state: NumericData = 0, relative_maximum_charge_state: NumericData = 1, initial_charge_state: Scalar | Literal['lastValueOfSim'] = 0, minimal_final_charge_state: Scalar | None = None, maximal_final_charge_state: Scalar | None = None, eta_charge: NumericData = 1, eta_discharge: NumericData = 1, relative_loss_per_hour: NumericData = 0, prevent_simultaneous_charge_and_discharge: bool = True, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Storage models the temporary storage and release of energy or material.</p> <p>Storages have one incoming and one outgoing Flow, each with configurable efficiency factors. They maintain a charge state variable that represents the stored amount, bounded by capacity limits and evolving over time based on charging, discharging, and self-discharge losses.</p> <p>The storage model handles complex temporal dynamics including initial conditions, final state constraints, and time-varying parameters. It supports both fixed-size and investment-optimized storage systems with comprehensive techno-economic modeling.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>charging</code> <code>Flow</code> <p>Incoming flow for loading the storage. Represents energy or material flowing into the storage system.</p> required <code>discharging</code> <code>Flow</code> <p>Outgoing flow for unloading the storage. Represents energy or material flowing out of the storage system.</p> required <code>capacity_in_flow_hours</code> <code>Scalar | InvestParameters</code> <p>Nominal capacity/size of the storage in flow-hours (e.g., kWh for electrical storage, m\u00b3 or kg for material storage). Can be a scalar for fixed capacity or InvestParameters for optimization.</p> required <code>relative_minimum_charge_state</code> <code>NumericData</code> <p>Minimum relative charge state (0-1 range). Prevents deep discharge that could damage equipment. Default is 0.</p> <code>0</code> <code>relative_maximum_charge_state</code> <code>NumericData</code> <p>Maximum relative charge state (0-1 range). Accounts for practical capacity limits, safety margins or temperature impacts. Default is 1.</p> <code>1</code> <code>initial_charge_state</code> <code>Scalar | Literal['lastValueOfSim']</code> <p>Storage charge state at the beginning of the time horizon. Can be numeric value or 'lastValueOfSim', which is recommended for if the initial start state is not known. Default is 0.</p> <code>0</code> <code>minimal_final_charge_state</code> <code>Scalar | None</code> <p>Minimum absolute charge state required at the end of the time horizon. Useful for ensuring energy security or meeting contracts.</p> <code>None</code> <code>maximal_final_charge_state</code> <code>Scalar | None</code> <p>Maximum absolute charge state allowed at the end of the time horizon. Useful for preventing overcharge or managing inventory.</p> <code>None</code> <code>eta_charge</code> <code>NumericData</code> <p>Charging efficiency factor (0-1 range). Accounts for conversion losses during charging. Default is 1 (perfect efficiency).</p> <code>1</code> <code>eta_discharge</code> <code>NumericData</code> <p>Discharging efficiency factor (0-1 range). Accounts for conversion losses during discharging. Default is 1 (perfect efficiency).</p> <code>1</code> <code>relative_loss_per_hour</code> <code>NumericData</code> <p>Self-discharge rate per hour (typically 0-0.1 range). Represents standby losses, leakage, or degradation. Default is 0.</p> <code>0</code> <code>prevent_simultaneous_charge_and_discharge</code> <code>bool</code> <p>If True, prevents charging and discharging simultaneously. Increases binary variables but improves model realism and solution interpretation. Default is True.</p> <code>True</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally, but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Battery energy storage system:</p> <pre><code>battery = Storage(\n    label='lithium_battery',\n    charging=battery_charge_flow,\n    discharging=battery_discharge_flow,\n    capacity_in_flow_hours=100,  # 100 kWh capacity\n    eta_charge=0.95,  # 95% charging efficiency\n    eta_discharge=0.95,  # 95% discharging efficiency\n    relative_loss_per_hour=0.001,  # 0.1% loss per hour\n    relative_minimum_charge_state=0.1,  # Never below 10% SOC\n    relative_maximum_charge_state=0.9,  # Never above 90% SOC\n)\n</code></pre> <p>Thermal storage with cycling constraints:</p> <pre><code>thermal_storage = Storage(\n    label='hot_water_tank',\n    charging=heat_input,\n    discharging=heat_output,\n    capacity_in_flow_hours=500,  # 500 kWh thermal capacity\n    initial_charge_state=250,  # Start half full\n    # Impact of temperature on energy capacity\n    relative_maximum_charge_state=water_temperature_spread / rated_temeprature_spread,\n    eta_charge=0.90,  # Heat exchanger losses\n    eta_discharge=0.85,  # Distribution losses\n    relative_loss_per_hour=0.02,  # 2% thermal loss per hour\n    prevent_simultaneous_charge_and_discharge=True,\n)\n</code></pre> <p>Pumped hydro storage with investment optimization:</p> <pre><code>pumped_hydro = Storage(\n    label='pumped_hydro',\n    charging=pump_flow,\n    discharging=turbine_flow,\n    capacity_in_flow_hours=InvestParameters(\n        minimum_size=1000,  # Minimum economic scale\n        maximum_size=10000,  # Site constraints\n        specific_effects={'cost': 150},  # \u20ac150/MWh capacity\n        fix_effects={'cost': 50_000_000},  # \u20ac50M fixed costs\n    ),\n    eta_charge=0.85,  # Pumping efficiency\n    eta_discharge=0.90,  # Turbine efficiency\n    initial_charge_state='lastValueOfSim',  # Ensuring no deficit compared to start\n    relative_loss_per_hour=0.0001,  # Minimal evaporation\n)\n</code></pre> <p>Material storage with inventory management:</p> <pre><code>fuel_storage = Storage(\n    label='natural_gas_storage',\n    charging=gas_injection,\n    discharging=gas_withdrawal,\n    capacity_in_flow_hours=10000,  # 10,000 m\u00b3 storage volume\n    initial_charge_state=3000,  # Start with 3,000 m\u00b3\n    minimal_final_charge_state=1000,  # Strategic reserve\n    maximal_final_charge_state=9000,  # Prevent overflow\n    eta_charge=0.98,  # Compression losses\n    eta_discharge=0.95,  # Pressure reduction losses\n    relative_loss_per_hour=0.0005,  # 0.05% leakage per hour\n    prevent_simultaneous_charge_and_discharge=False,  # Allow flow-through\n)\n</code></pre> Note <p>Charge state evolution follows the equation: charge[t+1] = charge[t] \u00d7 (1-loss_rate)^hours_per_step +               charge_flow[t] \u00d7 eta_charge \u00d7 hours_per_step -               discharge_flow[t] \u00d7 hours_per_step / eta_discharge</p> <p>All efficiency parameters (eta_charge, eta_discharge) are dimensionless (0-1 range). The relative_loss_per_hour parameter represents exponential decay per hour.</p> <p>When prevent_simultaneous_charge_and_discharge is True, binary variables are created to enforce mutual exclusivity, which increases solution time but prevents unrealistic simultaneous charging and discharging.</p> <p>Initial and final charge state constraints use absolute values (not relative), matching the capacity_in_flow_hours units.</p>"},{"location":"api-reference/commons/#flixopt.commons.Storage-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Storage.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Storage.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Storage.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Transmission","title":"Transmission","text":"<pre><code>Transmission(label: str, in1: Flow, out1: Flow, in2: Flow | None = None, out2: Flow | None = None, relative_losses: NumericDataTS = 0, absolute_losses: NumericDataTS | None = None, on_off_parameters: OnOffParameters | None = None, prevent_simultaneous_flows_in_both_directions: bool = True, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Models transmission infrastructure that transports flows between two locations with losses.</p> <p>Transmission components represent physical infrastructure like pipes, cables, transmission lines, or conveyor systems that transport energy or materials between two points. They can model both unidirectional and bidirectional flow with configurable loss mechanisms and operational constraints.</p> <p>The component supports complex transmission scenarios including relative losses (proportional to flow), absolute losses (fixed when active), and bidirectional operation with flow direction constraints.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>in1</code> <code>Flow</code> <p>The primary inflow (side A). Pass InvestParameters here for capacity optimization.</p> required <code>out1</code> <code>Flow</code> <p>The primary outflow (side B).</p> required <code>in2</code> <code>Flow | None</code> <p>Optional secondary inflow (side B) for bidirectional operation. If in1 has InvestParameters, in2 will automatically have matching capacity.</p> <code>None</code> <code>out2</code> <code>Flow | None</code> <p>Optional secondary outflow (side A) for bidirectional operation.</p> <code>None</code> <code>relative_losses</code> <code>NumericDataTS</code> <p>Proportional losses as fraction of throughput (e.g., 0.02 for 2% loss). Applied as: output = input \u00d7 (1 - relative_losses)</p> <code>0</code> <code>absolute_losses</code> <code>NumericDataTS | None</code> <p>Fixed losses that occur when transmission is active. Automatically creates binary variables for on/off states.</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>prevent_simultaneous_flows_in_both_directions</code> <code>bool</code> <p>If True, prevents simultaneous flow in both directions. Increases binary variables but reflects physical reality for most transmission systems. Default is True.</p> <code>True</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Simple electrical transmission line:</p> <pre><code>power_line = Transmission(\n    label='110kv_line',\n    in1=substation_a_out,\n    out1=substation_b_in,\n    relative_losses=0.03,  # 3% line losses\n)\n</code></pre> <p>Bidirectional natural gas pipeline:</p> <pre><code>gas_pipeline = Transmission(\n    label='interstate_pipeline',\n    in1=compressor_station_a,\n    out1=distribution_hub_b,\n    in2=compressor_station_b,\n    out2=distribution_hub_a,\n    relative_losses=0.005,  # 0.5% friction losses\n    absolute_losses=50,  # 50 kW compressor power when active\n    prevent_simultaneous_flows_in_both_directions=True,\n)\n</code></pre> <p>District heating network with investment optimization:</p> <pre><code>heating_network = Transmission(\n    label='dh_main_line',\n    in1=Flow(\n        label='heat_supply',\n        bus=central_plant_bus,\n        size=InvestParameters(\n            minimum_size=1000,  # Minimum 1 MW capacity\n            maximum_size=10000,  # Maximum 10 MW capacity\n            specific_effects={'cost': 200},  # \u20ac200/kW capacity\n            fix_effects={'cost': 500000},  # \u20ac500k fixed installation\n        ),\n    ),\n    out1=district_heat_demand,\n    relative_losses=0.15,  # 15% thermal losses in distribution\n)\n</code></pre> <p>Material conveyor with on/off operation:</p> <pre><code>conveyor_belt = Transmission(\n    label='material_transport',\n    in1=loading_station,\n    out1=unloading_station,\n    absolute_losses=25,  # 25 kW motor power when running\n    on_off_parameters=OnOffParameters(\n        effects_per_switch_on={'maintenance': 0.1},\n        consecutive_on_hours_min=2,  # Minimum 2-hour operation\n        switch_on_total_max=10,  # Maximum 10 starts per day\n    ),\n)\n</code></pre> Note <p>The transmission equation balances flows with losses: output_flow = input_flow \u00d7 (1 - relative_losses) - absolute_losses</p> <p>For bidirectional transmission, each direction has independent loss calculations.</p> <p>When using InvestParameters on in1, the capacity automatically applies to in2 to maintain consistent bidirectional capacity without additional investment variables.</p> <p>Absolute losses force the creation of binary on/off variables, which increases computational complexity but enables realistic modeling of equipment with standby power consumption.</p>"},{"location":"api-reference/commons/#flixopt.commons.Transmission-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Transmission.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Transmission.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Transmission.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.CONFIG","title":"CONFIG","text":"<p>Configuration for flixopt library.</p> <p>The CONFIG class provides centralized configuration for logging and modeling parameters. All changes require calling <code>CONFIG.apply()</code> to take effect.</p> <p>By default, logging outputs to both console and file ('flixopt.log').</p> <p>Attributes:</p> Name Type Description <code>Logging</code> <p>Nested class containing all logging configuration options. Colors: Nested subclass under Logging containing ANSI color codes for log levels.</p> <code>Modeling</code> <p>Nested class containing optimization modeling parameters.</p> <code>config_name</code> <code>str</code> <p>Name of the configuration (default: 'flixopt').</p> Logging Attributes <p>level (str): Logging level: 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'.     Default: 'INFO' file (str | None): Log file path. Default: 'flixopt.log'.     Set to None to disable file logging. console (bool): Enable console (stdout) logging. Default: True rich (bool): Use Rich library for enhanced console output. Default: False max_file_size (int): Maximum log file size in bytes before rotation.     Default: 10485760 (10MB) backup_count (int): Number of backup log files to keep. Default: 5 date_format (str): Date/time format for log messages.     Default: '%Y-%m-%d %H:%M:%S' format (str): Log message format string. Default: '%(message)s' console_width (int): Console width for Rich handler. Default: 120 show_path (bool): Show file paths in log messages. Default: False</p> Colors Attributes <p>DEBUG (str): ANSI color code for DEBUG level. Default: '\\033[32m' (green) INFO (str): ANSI color code for INFO level. Default: '\\033[34m' (blue) WARNING (str): ANSI color code for WARNING level. Default: '\\033[33m' (yellow) ERROR (str): ANSI color code for ERROR level. Default: '\\033[31m' (red) CRITICAL (str): ANSI color code for CRITICAL level. Default: '\\033[1m\\033[31m' (bold red)</p> <p>Works with both Rich and standard console handlers. Rich automatically converts ANSI codes using Style.from_ansi().</p> <p>Common ANSI codes:</p> <ul> <li>'\\033[30m' - Black</li> <li>'\\033[31m' - Red</li> <li>'\\033[32m' - Green</li> <li>'\\033[33m' - Yellow</li> <li>'\\033[34m' - Blue</li> <li>'\\033[35m' - Magenta</li> <li>'\\033[36m' - Cyan</li> <li>'\\033[37m' - White</li> <li>'\\033[1m\\033[3Xm' - Bold color (replace X with color code 0-7)</li> <li>'\\033[2m\\033[3Xm' - Dim color (replace X with color code 0-7)</li> </ul> <p>Examples:</p> <ul> <li>Magenta: '\\033[35m'</li> <li>Bold cyan: '\\033[1m\\033[36m'</li> <li>Dim green: '\\033[2m\\033[32m'</li> </ul> Modeling Attributes <p>big (int): Large number for optimization constraints. Default: 10000000 epsilon (float): Small tolerance value. Default: 1e-5 big_binary_bound (int): Upper bound for binary variable constraints.     Default: 100000</p> <p>Examples:</p> <p>Basic configuration::</p> <pre><code>from flixopt import CONFIG\n\nCONFIG.Logging.console = True\nCONFIG.Logging.level = 'DEBUG'\nCONFIG.apply()\n</code></pre> <p>Configure log file rotation::</p> <pre><code>CONFIG.Logging.file = 'myapp.log'\nCONFIG.Logging.max_file_size = 5_242_880  # 5 MB\nCONFIG.Logging.backup_count = 3\nCONFIG.apply()\n</code></pre> <p>Customize log colors::</p> <pre><code>CONFIG.Logging.Colors.INFO = '\\033[35m'  # Magenta\nCONFIG.Logging.Colors.DEBUG = '\\033[36m'  # Cyan\nCONFIG.Logging.Colors.ERROR = '\\033[1m\\033[31m'  # Bold red\nCONFIG.apply()\n</code></pre> <p>Use Rich handler with custom colors::</p> <pre><code>CONFIG.Logging.console = True\nCONFIG.Logging.rich = True\nCONFIG.Logging.console_width = 100\nCONFIG.Logging.show_path = True\nCONFIG.Logging.Colors.INFO = '\\033[36m'  # Cyan\nCONFIG.apply()\n</code></pre> <p>Load from YAML file::</p> <pre><code>CONFIG.load_from_file('config.yaml')\n</code></pre> <p>Example YAML config file:</p> <p>.. code-block:: yaml</p> <pre><code>logging:\n  level: DEBUG\n  console: true\n  file: app.log\n  rich: true\n  max_file_size: 5242880  # 5MB\n  backup_count: 3\n  date_format: '%H:%M:%S'\n  console_width: 100\n  show_path: true\n  colors:\n    DEBUG: \"\\033[36m\"              # Cyan\n    INFO: \"\\033[32m\"               # Green\n    WARNING: \"\\033[33m\"            # Yellow\n    ERROR: \"\\033[31m\"              # Red\n    CRITICAL: \"\\033[1m\\033[31m\"   # Bold red\n\nmodeling:\n  big: 20000000\n  epsilon: 1e-6\n  big_binary_bound: 200000\n</code></pre> <p>Reset to defaults::</p> <pre><code>CONFIG.reset()\n</code></pre> <p>Export current configuration::</p> <pre><code>config_dict = CONFIG.to_dict()\nimport yaml\n\nwith open('my_config.yaml', 'w') as f:\n    yaml.dump(config_dict, f)\n</code></pre>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.CONFIG.reset","title":"reset  <code>classmethod</code>","text":"<pre><code>reset()\n</code></pre> <p>Reset all configuration values to defaults.</p>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG.apply","title":"apply  <code>classmethod</code>","text":"<pre><code>apply()\n</code></pre> <p>Apply current configuration to logging system.</p>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG.load_from_file","title":"load_from_file  <code>classmethod</code>","text":"<pre><code>load_from_file(config_file: str | Path)\n</code></pre> <p>Load configuration from YAML file and apply it.</p>"},{"location":"api-reference/commons/#flixopt.commons.CONFIG.to_dict","title":"to_dict  <code>classmethod</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the configuration class into a dictionary for JSON serialization.</p>"},{"location":"api-reference/commons/#flixopt.commons.TimeSeriesData","title":"TimeSeriesData","text":"<pre><code>TimeSeriesData(data: NumericData, agg_group: str | None = None, agg_weight: float | None = None)\n</code></pre> <p>TimeSeriesData wraps time series data with aggregation metadata for optimization.</p> <p>This class combines time series data with special characteristics needed for aggregated calculations. It allows grouping related time series to prevent overweighting in optimization models.</p> Example <p>When you have multiple solar time series, they should share aggregation weight: <pre><code>solar1 = TimeSeriesData(sol_array_1, agg_group='solar')\nsolar2 = TimeSeriesData(sol_array_2, agg_group='solar')\nsolar3 = TimeSeriesData(sol_array_3, agg_group='solar')\n# These 3 series share one weight (each gets weight = 1/3 instead of 1)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NumericData</code> <p>The timeseries data, which can be a scalar, array, or numpy array.</p> required <code>agg_group</code> <code>str | None</code> <p>The group this TimeSeriesData belongs to. agg_weight is split between group members. Default is None.</p> <code>None</code> <code>agg_weight</code> <code>float | None</code> <p>The weight for calculation_type 'aggregated', should be between 0 and 1. Default is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both agg_group and agg_weight are set.</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect","title":"Effect","text":"<pre><code>Effect(label: str, unit: str, description: str, meta_data: dict | None = None, is_standard: bool = False, is_objective: bool = False, specific_share_to_other_effects_operation: EffectValuesUser | None = None, specific_share_to_other_effects_invest: EffectValuesUser | None = None, minimum_operation: Scalar | None = None, maximum_operation: Scalar | None = None, minimum_invest: Scalar | None = None, maximum_invest: Scalar | None = None, minimum_operation_per_hour: NumericDataTS | None = None, maximum_operation_per_hour: NumericDataTS | None = None, minimum_total: Scalar | None = None, maximum_total: Scalar | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Represents system-wide impacts like costs, emissions, resource consumption, or other effects.</p> <p>Effects capture the broader impacts of system operation and investment decisions beyond the primary energy/material flows. Each Effect accumulates contributions from Components, Flows, and other system elements. One Effect is typically chosen as the optimization objective, while others can serve as constraints or tracking metrics.</p> <p>Effects support comprehensive modeling including operational and investment contributions, cross-effect relationships (e.g., carbon pricing), and flexible constraint formulation.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>unit</code> <code>str</code> <p>The unit of the effect (e.g., '\u20ac', 'kg_CO2', 'kWh_primary', 'm\u00b2'). This is informative only and does not affect optimization calculations.</p> required <code>description</code> <code>str</code> <p>Descriptive name explaining what this effect represents.</p> required <code>is_standard</code> <code>bool</code> <p>If True, this is a standard effect allowing direct value input without effect dictionaries. Used for simplified effect specification (and less boilerplate code).</p> <code>False</code> <code>is_objective</code> <code>bool</code> <p>If True, this effect serves as the optimization objective function. Only one effect can be marked as objective per optimization.</p> <code>False</code> <code>specific_share_to_other_effects_operation</code> <code>EffectValuesUser | None</code> <p>Operational cross-effect contributions. Maps this effect's operational values to contributions to other effects</p> <code>None</code> <code>specific_share_to_other_effects_invest</code> <code>EffectValuesUser | None</code> <p>Investment cross-effect contributions. Maps this effect's investment values to contributions to other effects.</p> <code>None</code> <code>minimum_operation</code> <code>Scalar | None</code> <p>Minimum allowed total operational contribution across all timesteps.</p> <code>None</code> <code>maximum_operation</code> <code>Scalar | None</code> <p>Maximum allowed total operational contribution across all timesteps.</p> <code>None</code> <code>minimum_operation_per_hour</code> <code>NumericDataTS | None</code> <p>Minimum allowed operational contribution per timestep.</p> <code>None</code> <code>maximum_operation_per_hour</code> <code>NumericDataTS | None</code> <p>Maximum allowed operational contribution per timestep.</p> <code>None</code> <code>minimum_invest</code> <code>Scalar | None</code> <p>Minimum allowed total investment contribution.</p> <code>None</code> <code>maximum_invest</code> <code>Scalar | None</code> <p>Maximum allowed total investment contribution.</p> <code>None</code> <code>minimum_total</code> <code>Scalar | None</code> <p>Minimum allowed total effect (operation + investment combined).</p> <code>None</code> <code>maximum_total</code> <code>Scalar | None</code> <p>Maximum allowed total effect (operation + investment combined).</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Basic cost objective:</p> <pre><code>cost_effect = Effect(label='system_costs', unit='\u20ac', description='Total system costs', is_objective=True)\n</code></pre> <p>CO2 emissions with carbon pricing:</p> <pre><code>co2_effect = Effect(\n    label='co2_emissions',\n    unit='kg_CO2',\n    description='Carbon dioxide emissions',\n    specific_share_to_other_effects_operation={'costs': 50},  # \u20ac50/t_CO2\n    maximum_total=1_000_000,  # 1000 t CO2 annual limit\n)\n</code></pre> <p>Land use constraint:</p> <pre><code>land_use = Effect(\n    label='land_usage',\n    unit='m\u00b2',\n    description='Land area requirement',\n    maximum_total=50_000,  # Maximum 5 hectares available\n)\n</code></pre> <p>Primary energy tracking:</p> <pre><code>primary_energy = Effect(\n    label='primary_energy',\n    unit='kWh_primary',\n    description='Primary energy consumption',\n    specific_share_to_other_effects_operation={'costs': 0.08},  # \u20ac0.08/kWh\n)\n</code></pre> <p>Water consumption with tiered constraints:</p> <pre><code>water_usage = Effect(\n    label='water_consumption',\n    unit='m\u00b3',\n    description='Industrial water usage',\n    minimum_operation_per_hour=10,  # Minimum 10 m\u00b3/h for process stability\n    maximum_operation_per_hour=500,  # Maximum 500 m\u00b3/h capacity limit\n    maximum_total=100_000,  # Annual permit limit: 100,000 m\u00b3\n)\n</code></pre> Note <p>Effect bounds can be None to indicate no constraint in that direction.</p> <p>Cross-effect relationships enable sophisticated modeling like carbon pricing, resource valuation, or multi-criteria optimization with weighted objectives.</p> <p>The unit field is purely informational - ensure dimensional consistency across all contributions to each effect manually.</p> <p>Effects are accumulated as: - Total = \u03a3(operational contributions) + \u03a3(investment contributions) - Cross-effects add to target effects based on specific_share ratios</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Effect.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Effect.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Effect.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Bus","title":"Bus","text":"<pre><code>Bus(label: str, excess_penalty_per_flow_hour: NumericData | NumericDataTS | None = 100000.0, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Buses represent nodal balances between flow rates, serving as connection points.</p> <p>A Bus enforces energy or material balance constraints where the sum of all incoming flows must equal the sum of all outgoing flows at each time step. Buses represent physical or logical connection points for energy carriers (electricity, heat, gas) or material flows between different Components.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>excess_penalty_per_flow_hour</code> <code>NumericData | NumericDataTS | None</code> <p>Penalty costs for bus balance violations. When None, no excess/deficit is allowed (hard constraint). When set to a value &gt; 0, allows bus imbalances at penalty cost. Default is 1e5 (high penalty).</p> <code>100000.0</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Electrical bus with strict balance:</p> <pre><code>electricity_bus = Bus(\n    label='main_electrical_bus',\n    excess_penalty_per_flow_hour=None,  # No imbalance allowed\n)\n</code></pre> <p>Heat network with penalty for imbalances:</p> <pre><code>heat_network = Bus(\n    label='district_heating_network',\n    excess_penalty_per_flow_hour=1000,  # \u20ac1000/MWh penalty for imbalance\n)\n</code></pre> <p>Material flow with time-varying penalties:</p> <pre><code>material_hub = Bus(\n    label='material_processing_hub',\n    excess_penalty_per_flow_hour=waste_disposal_costs,  # Time series\n)\n</code></pre> Note <p>The bus balance equation enforced is: \u03a3(inflows) = \u03a3(outflows) + excess - deficit</p> <p>When excess_penalty_per_flow_hour is None, excess and deficit are forced to zero. When a penalty cost is specified, the optimization can choose to violate the balance if economically beneficial, paying the penalty. The penalty is added to the objective directly.</p> <p>Empty <code>inputs</code> and <code>outputs</code> lists are initialized and populated automatically by the FlowSystem during system setup.</p>"},{"location":"api-reference/commons/#flixopt.commons.Bus-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Bus.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.Bus.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Bus.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Bus.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Flow","title":"Flow","text":"<pre><code>Flow(label: str, bus: str, size: Scalar | InvestParameters | None = None, fixed_relative_profile: NumericDataTS | None = None, relative_minimum: NumericDataTS = 0, relative_maximum: NumericDataTS = 1, effects_per_flow_hour: EffectValuesUser | None = None, on_off_parameters: OnOffParameters | None = None, flow_hours_total_max: Scalar | None = None, flow_hours_total_min: Scalar | None = None, load_factor_min: Scalar | None = None, load_factor_max: Scalar | None = None, previous_flow_rate: NumericData | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Define a directed flow of energy or material between bus and component.</p> <p>A Flow represents the transfer of energy (electricity, heat, fuel) or material between a Bus and a Component in a specific direction. The flow rate is the primary optimization variable, with constraints and costs defined through various parameters. Flows can have fixed or variable sizes, operational constraints, and complex on/off behavior.</p> Key Concepts <p>Flow Rate: The instantaneous rate of energy/material transfer (optimization variable) [kW, m\u00b3/h, kg/h] Flow Hours: Amount of energy/material transferred per timestep. [kWh, m\u00b3, kg] Flow Size: The maximum capacity or nominal rating of the flow [kW, m\u00b3/h, kg/h] Relative Bounds: Flow rate limits expressed as fractions of flow size</p> Integration with Parameter Classes <ul> <li>InvestParameters: Used for <code>size</code> when flow Size is an investment decision</li> <li>OnOffParameters: Used for <code>on_off_parameters</code> when flow has discrete states</li> </ul> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Unique identifier for the flow within its component. The full label combines component and flow labels.</p> required <code>bus</code> <code>str</code> <p>Label of the bus this flow connects to. Must match a bus in the FlowSystem.</p> required <code>size</code> <code>Scalar | InvestParameters | None</code> <p>Flow capacity or nominal rating. Can be: - Scalar value for fixed capacity - InvestParameters for investment-based sizing decisions - None to use large default value (CONFIG.Modeling.big)</p> <code>None</code> <code>relative_minimum</code> <code>NumericDataTS</code> <p>Minimum flow rate as fraction of size. Example: 0.2 means flow cannot go below 20% of rated capacity.</p> <code>0</code> <code>relative_maximum</code> <code>NumericDataTS</code> <p>Maximum flow rate as fraction of size (typically 1.0). Values &gt;1.0 allow temporary overload operation.</p> <code>1</code> <code>load_factor_min</code> <code>Scalar | None</code> <p>Minimum average utilization over the time horizon (0-1). Calculated as total flow hours divided by (size \u00d7 total time).</p> <code>None</code> <code>load_factor_max</code> <code>Scalar | None</code> <p>Maximum average utilization over the time horizon (0-1). Useful for equipment duty cycle limits or maintenance scheduling.</p> <code>None</code> <code>effects_per_flow_hour</code> <code>EffectValuesUser | None</code> <p>Operational costs and impacts per unit of flow-time. Dictionary mapping effect names to unit costs (e.g., fuel costs, emissions).</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Binary operation constraints using OnOffParameters. Enables modeling of startup costs, minimum run times, cycling limits. Only relevant when relative_minimum &gt; 0 or discrete operation is required.</p> <code>None</code> <code>flow_hours_total_max</code> <code>Scalar | None</code> <p>Maximum cumulative flow-hours over time horizon. Alternative to load_factor_max for absolute energy/material limits.</p> <code>None</code> <code>flow_hours_total_min</code> <code>Scalar | None</code> <p>Minimum cumulative flow-hours over time horizon. Alternative to load_factor_min for contractual or operational requirements.</p> <code>None</code> <code>fixed_relative_profile</code> <code>NumericDataTS | None</code> <p>Predetermined flow pattern as fraction of size. When specified, flow rate becomes: size \u00d7 fixed_relative_profile(t). Used for: demand profiles, renewable generation, fixed schedules.</p> <code>None</code> <code>previous_flow_rate</code> <code>NumericData | None</code> <p>Initial flow state for startup/shutdown dynamics. Used with on_off_parameters to determine initial on/off status. If None, assumes flow was off in previous time period.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Additional information stored with results but not used in optimization. Must contain only Python native types (dict, list, str, int, float, bool).</p> <code>None</code> <p>Examples:</p> <p>Basic power flow with fixed capacity:</p> <pre><code>generator_output = Flow(\n    label='electricity_out',\n    bus='electricity_grid',\n    size=100,  # 100 MW capacity\n    relative_minimum=0.4,  # Cannot operate below 40 MW\n    effects_per_flow_hour={'fuel_cost': 45, 'co2_emissions': 0.8},\n)\n</code></pre> <p>Investment decision for battery capacity:</p> <pre><code>battery_flow = Flow(\n    label='electricity_storage',\n    bus='electricity_grid',\n    size=InvestParameters(\n        minimum_size=10,  # Minimum 10 MWh\n        maximum_size=100,  # Maximum 100 MWh\n        specific_effects={'cost': 150_000},  # \u20ac150k/MWh annualized\n    ),\n)\n</code></pre> <p>Heat pump with startup costs and minimum run times:</p> <pre><code>heat_pump = Flow(\n    label='heat_output',\n    bus='heating_network',\n    size=50,  # 50 kW thermal\n    relative_minimum=0.3,  # Minimum 15 kW output when on\n    effects_per_flow_hour={'electricity_cost': 25, 'maintenance': 2},\n    on_off_parameters=OnOffParameters(\n        effects_per_switch_on={'startup_cost': 100, 'wear': 0.1},\n        consecutive_on_hours_min=2,  # Must run at least 2 hours\n        consecutive_off_hours_min=1,  # Must stay off at least 1 hour\n        switch_on_total_max=200,  # Maximum 200 starts per year\n    ),\n)\n</code></pre> <p>Fixed renewable generation profile:</p> <pre><code>solar_generation = Flow(\n    label='solar_power',\n    bus='electricity_grid',\n    size=25,  # 25 MW installed capacity\n    fixed_relative_profile=np.array([0, 0.1, 0.4, 0.8, 0.9, 0.7, 0.3, 0.1, 0]),\n    effects_per_flow_hour={'maintenance_costs': 5},  # \u20ac5/MWh maintenance\n)\n</code></pre> <p>Industrial process with annual utilization limits:</p> <pre><code>production_line = Flow(\n    label='product_output',\n    bus='product_market',\n    size=1000,  # 1000 units/hour capacity\n    load_factor_min=0.6,  # Must achieve 60% annual utilization\n    load_factor_max=0.85,  # Cannot exceed 85% for maintenance\n    effects_per_flow_hour={'variable_cost': 12, 'quality_control': 0.5},\n)\n</code></pre> Design Considerations <p>Size vs Load Factors: Use <code>flow_hours_total_min/max</code> for absolute limits, <code>load_factor_min/max</code> for utilization-based constraints.</p> <p>Relative Bounds: Set <code>relative_minimum &gt; 0</code> only when equipment cannot operate below that level. Use <code>on_off_parameters</code> for discrete on/off behavior.</p> <p>Fixed Profiles: Use <code>fixed_relative_profile</code> for known exact patterns, <code>relative_maximum</code> for upper bounds on optimization variables.</p> Notes <ul> <li>Default size (CONFIG.Modeling.big) is used when size=None</li> <li>list inputs for previous_flow_rate are converted to NumPy arrays</li> <li>Flow direction is determined by component input/output designation</li> </ul> Deprecated <p>Passing Bus objects to <code>bus</code> parameter. Use bus label strings instead.</p>"},{"location":"api-reference/commons/#flixopt.commons.Flow-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Flow.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Flow.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem","title":"FlowSystem","text":"<pre><code>FlowSystem(timesteps: DatetimeIndex, hours_of_last_timestep: float | None = None, hours_of_previous_timesteps: int | float | ndarray | None = None)\n</code></pre> <p>A FlowSystem organizes the high level Elements (Components, Buses &amp; Effects).</p> <p>This is the main container class that users work with to build and manage their System.</p> <p>Parameters:</p> Name Type Description Default <code>timesteps</code> <code>DatetimeIndex</code> <p>The timesteps of the model.</p> required <code>hours_of_last_timestep</code> <code>float | None</code> <p>The duration of the last time step. Uses the last time interval if not specified</p> <code>None</code> <code>hours_of_previous_timesteps</code> <code>int | float | ndarray | None</code> <p>The duration of previous timesteps. If None, the first time increment of time_series is used. This is needed to calculate previous durations (for example consecutive_on_hours). If you use an array, take care that its long enough to cover all previous values!</p> <code>None</code> Notes <ul> <li>Creates an empty registry for components and buses, an empty EffectCollection, and a placeholder for a SystemModel.</li> <li>The instance starts disconnected (self._connected == False) and will be connected automatically when trying to solve a calculation.</li> </ul> <p>Initialize a FlowSystem that manages components, buses, effects, and their time-series.</p> <p>Parameters:</p> Name Type Description Default <code>timesteps</code> <code>DatetimeIndex</code> <p>DatetimeIndex defining the primary timesteps for the system's TimeSeriesCollection.</p> required <code>hours_of_last_timestep</code> <code>float | None</code> <p>Duration (in hours) of the final timestep; if None, inferred from timesteps or defaults in TimeSeriesCollection.</p> <code>None</code> <code>hours_of_previous_timesteps</code> <code>int | float | ndarray | None</code> <p>Scalar or array-like durations (in hours) for the preceding timesteps; used to configure non-uniform timestep lengths.</p> <code>None</code> Notes <p>Creates an empty registry for components and buses, an empty EffectCollection, and a placeholder for a SystemModel. The instance starts disconnected (self._connected == False) and with no active network visualization app. This can also be triggered manually with <code>_connect_network()</code>.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; FlowSystem\n</code></pre> <p>Load a FlowSystem from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the FlowSystem data.</p> required"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path)\n</code></pre> <p>Load a FlowSystem from a netcdf file</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.add_elements","title":"add_elements","text":"<pre><code>add_elements(*elements: Element) -&gt; None\n</code></pre> <p>Add Components(Storages, Boilers, Heatpumps, ...), Buses or Effects to the FlowSystem</p> <p>Parameters:</p> Name Type Description Default <code>*elements</code> <code>Element</code> <p>childs of  Element like Boiler, HeatPump, Bus,... modeling Elements</p> <code>()</code>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the flow system to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the flow_system to others.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.as_dict","title":"as_dict","text":"<pre><code>as_dict(data_mode: Literal['data', 'name', 'stats'] = 'data') -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.as_dataset","title":"as_dataset","text":"<pre><code>as_dataset(constants_in_dataset: bool = False) -&gt; xr.Dataset\n</code></pre> <p>Convert the FlowSystem to a xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>constants_in_dataset</code> <code>bool</code> <p>If True, constants are included as Dataset variables.</p> <code>False</code>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 0, constants_in_dataset: bool = True) -&gt; None\n</code></pre> <p>Saves the FlowSystem to a netCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the netCDF file.</p> required <code>compression</code> <code>int</code> <p>The compression level to use when saving the file.</p> <code>0</code> <code>constants_in_dataset</code> <code>bool</code> <p>If True, constants are included as Dataset variables.</p> <code>True</code>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.plot_network","title":"plot_network","text":"<pre><code>plot_network(path: bool | str | Path = 'flow_system.html', controls: bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']] = True, show: bool = False) -&gt; pyvis.network.Network | None\n</code></pre> <p>Visualizes the network structure of a FlowSystem using PyVis, saving it as an interactive HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>bool | str | Path</code> <p>Path to save the HTML visualization. - <code>False</code>: Visualization is created but not saved. - <code>str</code> or <code>Path</code>: Specifies file path (default: 'flow_system.html').</p> <code>'flow_system.html'</code> <code>controls</code> <code>bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]</code> <p>UI controls to add to the visualization. - <code>True</code>: Enables all available controls. - <code>List</code>: Specify controls, e.g., ['nodes', 'layout']. - Options: 'nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer'.</p> <code>True</code> <code>show</code> <code>bool</code> <p>Whether to open the visualization in the web browser.</p> <code>False</code> <p>Returns: - 'pyvis.network.Network' | None: The <code>Network</code> instance representing the visualization, or <code>None</code> if <code>pyvis</code> is not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.plot_network()\n&gt;&gt;&gt; flow_system.plot_network(show=False)\n&gt;&gt;&gt; flow_system.plot_network(path='output/custom_network.html', controls=['nodes', 'layout'])\n</code></pre> <p>Notes: - This function requires <code>pyvis</code>. If not installed, the function prints a warning and returns <code>None</code>. - Nodes are styled based on type (e.g., circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.start_network_app","title":"start_network_app","text":"<pre><code>start_network_app()\n</code></pre> <p>Visualizes the network structure of a FlowSystem using Dash, Cytoscape, and networkx. Requires optional dependencies: dash, dash-cytoscape, dash-daq, networkx, flask, werkzeug.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.stop_network_app","title":"stop_network_app","text":"<pre><code>stop_network_app()\n</code></pre> <p>Stop the network visualization server.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.create_time_series","title":"create_time_series","text":"<pre><code>create_time_series(name: str, data: NumericData | TimeSeriesData | TimeSeries | None, needs_extra_timestep: bool = False) -&gt; TimeSeries | None\n</code></pre> <p>Tries to create a TimeSeries from NumericData Data and adds it to the time_series_collection If the data already is a TimeSeries, nothing happens and the TimeSeries gets reset and returned If the data is a TimeSeriesData, it is converted to a TimeSeries, and the aggregation weights are applied. If the data is None, nothing happens.</p>"},{"location":"api-reference/commons/#flixopt.commons.FlowSystem.create_effect_time_series","title":"create_effect_time_series","text":"<pre><code>create_effect_time_series(label_prefix: str | None, effect_values: EffectValuesUser, label_suffix: str | None = None) -&gt; EffectTimeSeries | None\n</code></pre> <p>Transform EffectValues to EffectTimeSeries. Creates a TimeSeries for each key in the nested_values dictionary, using the value as the data.</p> <p>The resulting label of the TimeSeries is the label of the parent_element, followed by the label of the Effect in the nested_values and the label_suffix. If the key in the EffectValues is None, the alias 'Standard_Effect' is used</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters","title":"InvestParameters","text":"<pre><code>InvestParameters(fixed_size: int | float | None = None, minimum_size: int | float | None = None, maximum_size: int | float | None = None, optional: bool = True, fix_effects: EffectValuesUserScalar | None = None, specific_effects: EffectValuesUserScalar | None = None, piecewise_effects: PiecewiseEffects | None = None, divest_effects: EffectValuesUserScalar | None = None)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define investment decision parameters with flexible sizing and effect modeling.</p> <p>This class models investment decisions in optimization problems, supporting both binary (invest/don't invest) and continuous sizing choices with comprehensive cost structures. It enables realistic representation of investment economics including fixed costs, scale effects, and divestment penalties.</p> Investment Decision Types <p>Binary Investments: Fixed size investments creating yes/no decisions (e.g., install a specific generator, build a particular facility)</p> <p>Continuous Sizing: Variable size investments with minimum/maximum bounds (e.g., battery capacity from 10-1000 kWh, pipeline diameter optimization)</p> Cost Modeling Approaches <ul> <li>Fixed Effects: One-time costs independent of size (permits, connections)</li> <li>Specific Effects: Linear costs proportional to size (\u20ac/kW, \u20ac/m\u00b2)</li> <li>Piecewise Effects: Non-linear relationships (bulk discounts, learning curves)</li> <li>Divestment Effects: Penalties for not investing (demolition, opportunity costs)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>fixed_size</code> <code>int | float | None</code> <p>When specified, creates a binary investment decision at exactly this size. When None, allows continuous sizing between minimum and maximum bounds.</p> <code>None</code> <code>minimum_size</code> <code>int | float | None</code> <p>Lower bound for continuous sizing decisions. Defaults to a small positive value (CONFIG.Modeling.epsilon) to avoid numerical issues. Ignored when fixed_size is specified.</p> <code>None</code> <code>maximum_size</code> <code>int | float | None</code> <p>Upper bound for continuous sizing decisions. Defaults to a large value (CONFIG.Modeling.big) representing unlimited capacity. Ignored when fixed_size is specified.</p> <code>None</code> <code>optional</code> <code>bool</code> <p>Controls whether investment is required. When True (default), optimization can choose not to invest. When False, forces investment to occur (useful for mandatory upgrades or replacement decisions).</p> <code>True</code> <code>fix_effects</code> <code>EffectValuesUserScalar | None</code> <p>Fixed costs incurred once if investment is made, regardless of size. Dictionary mapping effect names to values (e.g., {'cost': 10000, 'CO2_construction': 500}).</p> <code>None</code> <code>specific_effects</code> <code>EffectValuesUserScalar | None</code> <p>Variable costs proportional to investment size, representing per-unit costs (\u20ac/kW, \u20ac/m\u00b2). Dictionary mapping effect names to unit values (e.g., {'cost': 1200, 'steel_required': 0.5}).</p> <code>None</code> <code>piecewise_effects</code> <code>PiecewiseEffects | None</code> <p>Non-linear cost relationships using PiecewiseEffects for economies of scale, learning curves, or threshold effects. Can be combined with fix_effects and specific_effects.</p> <code>None</code> <code>divest_effects</code> <code>EffectValuesUserScalar | None</code> <p>Costs incurred if the investment is NOT made, such as demolition of existing equipment, contractual penalties, or lost opportunities. Dictionary mapping effect names to values.</p> <code>None</code> Cost Annualization Requirements <p>All cost values must be properly weighted to match the optimization model's time horizon. For long-term investments, the cost values should be annualized to the corresponding operation time (annuity).</p> <ul> <li>Use equivalent annual cost (capital cost / equipment lifetime)</li> <li>Apply appropriate discount rates for present value calculations</li> <li>Account for inflation, escalation, and financing costs</li> </ul> <p>Example: \u20ac1M equipment with 20-year life \u2192 \u20ac50k/year fixed cost</p> <p>Examples:</p> <p>Simple binary investment (solar panels):</p> <pre><code>solar_investment = InvestParameters(\n    fixed_size=100,  # 100 kW system (binary decision)\n    optional=True,\n    fix_effects={\n        'cost': 25000,  # Installation and permitting costs\n        'CO2': -50000,  # Avoided emissions over lifetime\n    },\n    specific_effects={\n        'cost': 1200,  # \u20ac1200/kW for panels (annualized)\n        'CO2': -800,  # kg CO2 avoided per kW annually\n    },\n)\n</code></pre> <p>Flexible sizing with economies of scale:</p> <pre><code>battery_investment = InvestParameters(\n    minimum_size=10,  # Minimum viable system size (kWh)\n    maximum_size=1000,  # Maximum installable capacity\n    optional=True,\n    fix_effects={\n        'cost': 5000,  # Grid connection and control system\n        'installation_time': 2,  # Days for fixed components\n    },\n    piecewise_effects=PiecewiseEffects(\n        piecewise_origin=Piecewise(\n            [\n                Piece(0, 100),  # Small systems\n                Piece(100, 500),  # Medium systems\n                Piece(500, 1000),  # Large systems\n            ]\n        ),\n        piecewise_shares={\n            'cost': Piecewise(\n                [\n                    Piece(800, 750),  # High cost/kWh for small systems\n                    Piece(750, 600),  # Medium cost/kWh\n                    Piece(600, 500),  # Bulk discount for large systems\n                ]\n            )\n        },\n    ),\n)\n</code></pre> <p>Mandatory replacement with divestment costs:</p> <pre><code>boiler_replacement = InvestParameters(\n    minimum_size=50,\n    maximum_size=200,\n    optional=True,  # Can choose not to replace\n    fix_effects={\n        'cost': 15000,  # Installation costs\n        'disruption': 3,  # Days of downtime\n    },\n    specific_effects={\n        'cost': 400,  # \u20ac400/kW capacity\n        'maintenance': 25,  # Annual maintenance per kW\n    },\n    divest_effects={\n        'cost': 8000,  # Demolition if not replaced\n        'environmental': 100,  # Disposal fees\n    },\n)\n</code></pre> <p>Multi-technology comparison:</p> <pre><code># Gas turbine option\ngas_turbine = InvestParameters(\n    fixed_size=50,  # MW\n    fix_effects={'cost': 2500000, 'CO2': 1250000},\n    specific_effects={'fuel_cost': 45, 'maintenance': 12},\n)\n\n# Wind farm option\nwind_farm = InvestParameters(\n    minimum_size=20,\n    maximum_size=100,\n    fix_effects={'cost': 1000000, 'CO2': -5000000},\n    specific_effects={'cost': 1800000, 'land_use': 0.5},\n)\n</code></pre> <p>Technology learning curve:</p> <pre><code>hydrogen_electrolyzer = InvestParameters(\n    minimum_size=1,\n    maximum_size=50,  # MW\n    piecewise_effects=PiecewiseEffects(\n        piecewise_origin=Piecewise(\n            [\n                Piece(0, 5),  # Small scale: early adoption\n                Piece(5, 20),  # Medium scale: cost reduction\n                Piece(20, 50),  # Large scale: mature technology\n            ]\n        ),\n        piecewise_shares={\n            'capex': Piecewise(\n                [\n                    Piece(2000, 1800),  # Learning reduces costs\n                    Piece(1800, 1400),  # Continued cost reduction\n                    Piece(1400, 1200),  # Technology maturity\n                ]\n            ),\n            'efficiency': Piecewise(\n                [\n                    Piece(65, 68),  # Improving efficiency\n                    Piece(68, 72),  # with scale and experience\n                    Piece(72, 75),  # Best efficiency at scale\n                ]\n            ),\n        },\n    ),\n)\n</code></pre> Common Use Cases <ul> <li>Power generation: Plant sizing, technology selection, retrofit decisions</li> <li>Industrial equipment: Capacity expansion, efficiency upgrades, replacements</li> <li>Infrastructure: Network expansion, facility construction, system upgrades</li> <li>Energy storage: Battery sizing, pumped hydro, compressed air systems</li> <li>Transportation: Fleet expansion, charging infrastructure, modal shifts</li> <li>Buildings: HVAC systems, insulation upgrades, renewable integration</li> </ul>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.InvestParameters.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters","title":"OnOffParameters","text":"<pre><code>OnOffParameters(effects_per_switch_on: EffectValuesUser | None = None, effects_per_running_hour: EffectValuesUser | None = None, on_hours_total_min: int | None = None, on_hours_total_max: int | None = None, consecutive_on_hours_min: NumericData | None = None, consecutive_on_hours_max: NumericData | None = None, consecutive_off_hours_min: NumericData | None = None, consecutive_off_hours_max: NumericData | None = None, switch_on_total_max: int | None = None, force_switch_on: bool = False)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define operational constraints and effects for binary on/off equipment behavior.</p> <p>This class models equipment that operates in discrete states (on/off) rather than continuous operation, capturing realistic operational constraints and associated costs. It handles complex equipment behavior including startup costs, minimum run times, cycling limitations, and maintenance scheduling requirements.</p> Key Modeling Capabilities <p>Switching Costs: One-time costs for starting equipment (fuel, wear, labor) Runtime Constraints: Minimum and maximum continuous operation periods Cycling Limits: Maximum number of starts to prevent excessive wear Operating Hours: Total runtime limits and requirements over time horizon</p> Typical Equipment Applications <ul> <li>Power Plants: Combined cycle units, steam turbines with startup costs</li> <li>Industrial Processes: Batch reactors, furnaces with thermal cycling</li> <li>HVAC Systems: Chillers, boilers with minimum run times</li> <li>Backup Equipment: Emergency generators, standby systems</li> <li>Process Equipment: Compressors, pumps with operational constraints</li> </ul> <p>Parameters:</p> Name Type Description Default <code>effects_per_switch_on</code> <code>EffectValuesUser | None</code> <p>Costs or impacts incurred for each transition from off state (var_on=0) to on state (var_on=1). Represents startup costs, wear and tear, or other switching impacts. Dictionary mapping effect names to values (e.g., {'cost': 500, 'maintenance_hours': 2}).</p> <code>None</code> <code>effects_per_running_hour</code> <code>EffectValuesUser | None</code> <p>Ongoing costs or impacts while equipment operates in the on state. Includes fuel costs, labor, consumables, or emissions. Dictionary mapping effect names to hourly values (e.g., {'fuel_cost': 45}).</p> <code>None</code> <code>on_hours_total_min</code> <code>int | None</code> <p>Minimum total operating hours across the entire time horizon. Ensures equipment meets minimum utilization requirements or contractual obligations (e.g., power purchase agreements, maintenance schedules).</p> <code>None</code> <code>on_hours_total_max</code> <code>int | None</code> <p>Maximum total operating hours across the entire time horizon. Limits equipment usage due to maintenance schedules, fuel availability, environmental permits, or equipment lifetime constraints.</p> <code>None</code> <code>consecutive_on_hours_min</code> <code>NumericData | None</code> <p>Minimum continuous operating duration once started. Models minimum run times due to thermal constraints, process stability, or efficiency considerations. Can be time-varying to reflect different constraints across the planning horizon.</p> <code>None</code> <code>consecutive_on_hours_max</code> <code>NumericData | None</code> <p>Maximum continuous operating duration in one campaign. Models mandatory maintenance intervals, process batch sizes, or equipment thermal limits requiring periodic shutdowns.</p> <code>None</code> <code>consecutive_off_hours_min</code> <code>NumericData | None</code> <p>Minimum continuous shutdown duration between operations. Models cooling periods, maintenance requirements, or process constraints that prevent immediate restart after shutdown.</p> <code>None</code> <code>consecutive_off_hours_max</code> <code>NumericData | None</code> <p>Maximum continuous shutdown duration before mandatory restart. Models equipment preservation, process stability, or contractual requirements for minimum activity levels.</p> <code>None</code> <code>switch_on_total_max</code> <code>int | None</code> <p>Maximum number of startup operations across the time horizon. Limits equipment cycling to reduce wear, maintenance costs, or comply with operational constraints (e.g., grid stability requirements).</p> <code>None</code> <code>force_switch_on</code> <code>bool</code> <p>When True, creates switch-on variables even without explicit switch_on_total_max constraint. Useful for tracking or reporting startup events without enforcing limits.</p> <code>False</code> Note <p>Time Series Boundary Handling: The final time period constraints for consecutive_on_hours_min/max and consecutive_off_hours_min/max are not enforced, allowing the optimization to end with ongoing campaigns that may be shorter than the specified minimums or longer than maximums.</p> <p>Examples:</p> <p>Combined cycle power plant with startup costs and minimum run time:</p> <pre><code>power_plant_operation = OnOffParameters(\n    effects_per_switch_on={\n        'startup_cost': 25000,  # \u20ac25,000 per startup\n        'startup_fuel': 150,  # GJ natural gas for startup\n        'startup_time': 4,  # Hours to reach full output\n        'maintenance_impact': 0.1,  # Fractional life consumption\n    },\n    effects_per_running_hour={\n        'fixed_om': 125,  # Fixed O&amp;M costs while running\n        'auxiliary_power': 2.5,  # MW parasitic loads\n    },\n    consecutive_on_hours_min=8,  # Minimum 8-hour run once started\n    consecutive_off_hours_min=4,  # Minimum 4-hour cooling period\n    on_hours_total_max=6000,  # Annual operating limit\n)\n</code></pre> <p>Industrial batch process with cycling limits:</p> <pre><code>batch_reactor = OnOffParameters(\n    effects_per_switch_on={\n        'setup_cost': 1500,  # Labor and materials for startup\n        'catalyst_consumption': 5,  # kg catalyst per batch\n        'cleaning_chemicals': 200,  # L cleaning solution\n    },\n    effects_per_running_hour={\n        'steam': 2.5,  # t/h process steam\n        'electricity': 150,  # kWh electrical load\n        'cooling_water': 50,  # m\u00b3/h cooling water\n    },\n    consecutive_on_hours_min=12,  # Minimum batch size (12 hours)\n    consecutive_on_hours_max=24,  # Maximum batch size (24 hours)\n    consecutive_off_hours_min=6,  # Cleaning and setup time\n    switch_on_total_max=200,  # Maximum 200 batches per year\n    on_hours_total_max=4000,  # Maximum production time\n)\n</code></pre> <p>HVAC system with thermostat control and maintenance:</p> <pre><code>hvac_operation = OnOffParameters(\n    effects_per_switch_on={\n        'compressor_wear': 0.5,  # Hours of compressor life per start\n        'inrush_current': 15,  # kW peak demand on startup\n    },\n    effects_per_running_hour={\n        'electricity': 25,  # kW electrical consumption\n        'maintenance': 0.12,  # \u20ac/hour maintenance reserve\n    },\n    consecutive_on_hours_min=1,  # Minimum 1-hour run to avoid cycling\n    consecutive_off_hours_min=0.5,  # 30-minute minimum off time\n    switch_on_total_max=2000,  # Limit cycling for compressor life\n    on_hours_total_min=2000,  # Minimum operation for humidity control\n    on_hours_total_max=5000,  # Maximum operation for energy budget\n)\n</code></pre> <p>Backup generator with testing and maintenance requirements:</p> <pre><code>backup_generator = OnOffParameters(\n    effects_per_switch_on={\n        'fuel_priming': 50,  # L diesel for system priming\n        'wear_factor': 1.0,  # Start cycles impact on maintenance\n        'testing_labor': 2,  # Hours technician time per test\n    },\n    effects_per_running_hour={\n        'fuel_consumption': 180,  # L/h diesel consumption\n        'emissions_permit': 15,  # \u20ac emissions allowance cost\n        'noise_penalty': 25,  # \u20ac noise compliance cost\n    },\n    consecutive_on_hours_min=0.5,  # Minimum test duration (30 min)\n    consecutive_off_hours_max=720,  # Maximum 30 days between tests\n    switch_on_total_max=52,  # Weekly testing limit\n    on_hours_total_min=26,  # Minimum annual testing (0.5h \u00d7 52)\n    on_hours_total_max=200,  # Maximum runtime (emergencies + tests)\n)\n</code></pre> <p>Peak shaving battery with cycling degradation:</p> <pre><code>battery_cycling = OnOffParameters(\n    effects_per_switch_on={\n        'cycle_degradation': 0.01,  # % capacity loss per cycle\n        'inverter_startup': 0.5,  # kWh losses during startup\n    },\n    effects_per_running_hour={\n        'standby_losses': 2,  # kW standby consumption\n        'cooling': 5,  # kW thermal management\n        'inverter_losses': 8,  # kW conversion losses\n    },\n    consecutive_on_hours_min=1,  # Minimum discharge duration\n    consecutive_on_hours_max=4,  # Maximum continuous discharge\n    consecutive_off_hours_min=1,  # Minimum rest between cycles\n    switch_on_total_max=365,  # Daily cycling limit\n    force_switch_on=True,  # Track all cycling events\n)\n</code></pre> Common Use Cases <ul> <li>Power generation: Thermal plant cycling, renewable curtailment, grid services</li> <li>Industrial processes: Batch production, maintenance scheduling, equipment rotation</li> <li>Buildings: HVAC control, lighting systems, elevator operations</li> <li>Transportation: Fleet management, charging infrastructure, maintenance windows</li> <li>Storage systems: Battery cycling, pumped hydro, compressed air systems</li> <li>Emergency equipment: Backup generators, safety systems, emergency lighting</li> </ul>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters-attributes","title":"Attributes","text":""},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.use_off","title":"use_off  <code>property</code>","text":"<pre><code>use_off: bool\n</code></pre> <p>Proxy: whether OFF variable is required</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.use_consecutive_on_hours","title":"use_consecutive_on_hours  <code>property</code>","text":"<pre><code>use_consecutive_on_hours: bool\n</code></pre> <p>Determines whether a Variable for consecutive on hours is needed or not</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.use_consecutive_off_hours","title":"use_consecutive_off_hours  <code>property</code>","text":"<pre><code>use_consecutive_off_hours: bool\n</code></pre> <p>Determines whether a Variable for consecutive off hours is needed or not</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.use_switch_on","title":"use_switch_on  <code>property</code>","text":"<pre><code>use_switch_on: bool\n</code></pre> <p>Determines whether a Variable for SWITCH-ON is needed or not</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.OnOffParameters.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Piece","title":"Piece","text":"<pre><code>Piece(start: NumericData, end: NumericData)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a single linear segment with specified domain boundaries.</p> <p>This class represents one linear segment that will be combined with other pieces to form complete piecewise linear functions. Each piece defines a domain interval [start, end] where a linear relationship applies.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>NumericData</code> <p>Lower bound of the domain interval for this linear segment. Can be scalar values or time series arrays for time-varying boundaries.</p> required <code>end</code> <code>NumericData</code> <p>Upper bound of the domain interval for this linear segment. Can be scalar values or time series arrays for time-varying boundaries.</p> required <p>Examples:</p> <p>Basic piece for equipment efficiency curve:</p> <pre><code># Single segment from 40% to 80% load\nefficiency_segment = Piece(start=40, end=80)\n</code></pre> <p>Piece with time-varying boundaries:</p> <pre><code># Capacity limits that change seasonally\nseasonal_piece = Piece(\n    start=np.array([10, 20, 30, 25]),  # Minimum capacity by season\n    end=np.array([80, 100, 90, 70]),  # Maximum capacity by season\n)\n</code></pre> <p>Fixed operating point (start equals end):</p> <pre><code># Equipment that operates at exactly 50 MW\nfixed_output = Piece(start=50, end=50)\n</code></pre> Note <p>Individual pieces are building blocks that gain meaning when combined into Piecewise functions. See the Piecewise class for information about how pieces interact and relate to each other.</p>"},{"location":"api-reference/commons/#flixopt.commons.Piece-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Piece.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.Piece.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Piece.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Piece.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Piecewise","title":"Piecewise","text":"<pre><code>Piecewise(pieces: list[Piece])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a piecewise linear function by combining multiple <code>Piece</code>s together.</p> <p>This class creates complex non-linear relationships by combining multiple Piece objects into a single piecewise linear function.</p> <p>Parameters:</p> Name Type Description Default <code>pieces</code> <code>list[Piece]</code> <p>list of Piece objects defining the linear segments. The arrangement and relationships between pieces determine the function behavior: - Touching pieces (end of one = start of next) ensure continuity - Gaps between pieces create forbidden regions - Overlapping pieces provide an extra choice for the optimizer</p> required Piece Relationship Patterns <p>Touching Pieces (Continuous Function): Pieces that share boundary points create smooth, continuous functions without gaps or overlaps.</p> <p>Gaps Between Pieces (Forbidden Regions): Non-contiguous pieces with gaps represent forbidden regions. For example minimum load requirements or safety zones.</p> <p>Overlapping Pieces (Flexible Operation): Pieces with overlapping domains provide optimization flexibility, allowing the solver to choose which segment to operate in.</p> <p>Examples:</p> <p>Continuous efficiency curve (touching pieces):</p> <pre><code>efficiency_curve = Piecewise(\n    [\n        Piece(start=0, end=25),  # Low load: 0-25 MW\n        Piece(start=25, end=75),  # Medium load: 25-75 MW (touches at 25)\n        Piece(start=75, end=100),  # High load: 75-100 MW (touches at 75)\n    ]\n)\n</code></pre> <p>Equipment with forbidden operating range (gap):</p> <pre><code>turbine_operation = Piecewise(\n    [\n        Piece(start=0, end=0),  # Off state (point operation)\n        Piece(start=40, end=100),  # Operating range (gap: 0-40 forbidden)\n    ]\n)\n</code></pre> <p>Flexible operation with overlapping options:</p> <pre><code>flexible_operation = Piecewise(\n    [\n        Piece(start=20, end=60),  # Standard efficiency mode\n        Piece(start=50, end=90),  # High efficiency mode (overlap: 50-60)\n    ]\n)\n</code></pre> <p>Tiered pricing structure:</p> <pre><code>electricity_pricing = Piecewise(\n    [\n        Piece(start=0, end=100),  # Tier 1: 0-100 kWh\n        Piece(start=100, end=500),  # Tier 2: 100-500 kWh\n        Piece(start=500, end=1000),  # Tier 3: 500-1000 kWh\n    ]\n)\n</code></pre> <p>Seasonal capacity variation:</p> <pre><code>seasonal_capacity = Piecewise(\n    [\n        Piece(start=[10, 15, 20, 12], end=[80, 90, 85, 75]),  # Varies by time\n    ]\n)\n</code></pre> Container Operations <p>The Piecewise class supports standard Python container operations:</p> <pre><code>piecewise = Piecewise([piece1, piece2, piece3])\n\nlen(piecewise)  # Returns number of pieces (3)\npiecewise[0]  # Access first piece\nfor piece in piecewise:  # Iterate over all pieces\n    print(piece.start, piece.end)\n</code></pre> Validation Considerations <ul> <li>Pieces are typically ordered by their start values</li> <li>Check for unintended gaps that might create infeasible regions</li> <li>Consider whether overlaps provide desired flexibility or create ambiguity</li> <li>Ensure time-varying pieces have consistent dimensions</li> </ul> Common Use Cases <ul> <li>Power plants: Heat rate curves, efficiency vs load, emissions profiles</li> <li>HVAC systems: COP vs temperature, capacity vs conditions</li> <li>Industrial processes: Conversion rates vs throughput, quality vs speed</li> <li>Financial modeling: Tiered rates, progressive taxes, bulk discounts</li> <li>Transportation: Fuel efficiency curves, capacity vs speed</li> <li>Storage systems: Efficiency vs state of charge, power vs energy</li> <li>Renewable energy: Output vs weather conditions, curtailment strategies</li> </ul>"},{"location":"api-reference/commons/#flixopt.commons.Piecewise-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.Piecewise.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.Piecewise.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.Piecewise.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.Piecewise.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion","title":"PiecewiseConversion","text":"<pre><code>PiecewiseConversion(piecewises: dict[str, Piecewise])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define coordinated piecewise linear relationships between multiple flows.</p> <p>This class models conversion processes where multiple flows (inputs, outputs, auxiliaries) have synchronized piecewise relationships. All flows change together based on the same operating point, enabling accurate modeling of complex equipment with variable performance characteristics.</p> Multi-Flow Coordination <p>All piecewise functions must have matching piece structures (same number of pieces with compatible domains) to ensure synchronized operation. When the equipment operates at a given point, ALL flows scale proportionally within their respective pieces.</p> <p>Parameters:</p> Name Type Description Default <code>piecewises</code> <code>dict[str, Piecewise]</code> <p>Dictionary mapping flow labels to their Piecewise functions. Keys are flow identifiers (e.g., 'electricity_in', 'heat_out', 'fuel_consumed'). Values are Piecewise objects that define each flow's behavior. Critical Requirement: All Piecewise objects must have the same number of pieces with compatible domains to ensure consistent operation.</p> required Operating Point Coordination <p>When equipment operates at any point within a piece, all flows scale proportionally within their corresponding pieces. This ensures realistic equipment behavior where efficiency, consumption, and production rates all change together.</p> <p>Examples:</p> <p>Heat pump with coordinated efficiency changes:</p> <pre><code>heat_pump_pc = PiecewiseConversion(\n    {\n        'electricity_in': Piecewise(\n            [\n                Piece(0, 10),  # Low load: 0-10 kW electricity\n                Piece(10, 25),  # High load: 10-25 kW electricity\n            ]\n        ),\n        'heat_out': Piecewise(\n            [\n                Piece(0, 35),  # Low load COP=3.5: 0-35 kW heat\n                Piece(35, 75),  # High load COP=3.0: 35-75 kW heat\n            ]\n        ),\n        'cooling_water': Piecewise(\n            [\n                Piece(0, 2.5),  # Low load: 0-2.5 m\u00b3/h cooling\n                Piece(2.5, 6),  # High load: 2.5-6 m\u00b3/h cooling\n            ]\n        ),\n    }\n)\n# At 15 kW electricity \u2192 52.5 kW heat + 3.75 m\u00b3/h cooling water\n</code></pre> <p>Combined cycle power plant with synchronized flows:</p> <pre><code>power_plant_pc = PiecewiseConversion(\n    {\n        'natural_gas': Piecewise(\n            [\n                Piece(150, 300),  # Part load: 150-300 MW_th fuel\n                Piece(300, 500),  # Full load: 300-500 MW_th fuel\n            ]\n        ),\n        'electricity': Piecewise(\n            [\n                Piece(60, 135),  # Part load: 60-135 MW_e (45% efficiency)\n                Piece(135, 250),  # Full load: 135-250 MW_e (50% efficiency)\n            ]\n        ),\n        'steam_export': Piecewise(\n            [\n                Piece(20, 35),  # Part load: 20-35 MW_th steam\n                Piece(35, 50),  # Full load: 35-50 MW_th steam\n            ]\n        ),\n        'co2_emissions': Piecewise(\n            [\n                Piece(30, 60),  # Part load: 30-60 t/h CO2\n                Piece(60, 100),  # Full load: 60-100 t/h CO2\n            ]\n        ),\n    }\n)\n</code></pre> <p>Chemical reactor with multiple products and waste:</p> <pre><code>reactor_pc = PiecewiseConversion(\n    {\n        'feedstock': Piecewise(\n            [\n                Piece(10, 50),  # Small batch: 10-50 kg/h\n                Piece(50, 200),  # Large batch: 50-200 kg/h\n            ]\n        ),\n        'product_A': Piecewise(\n            [\n                Piece(7, 35),  # Small batch: 70% yield\n                Piece(35, 140),  # Large batch: 70% yield\n            ]\n        ),\n        'product_B': Piecewise(\n            [\n                Piece(2, 10),  # Small batch: 20% yield\n                Piece(10, 45),  # Large batch: 22.5% yield (improved)\n            ]\n        ),\n        'waste_stream': Piecewise(\n            [\n                Piece(1, 5),  # Small batch: 10% waste\n                Piece(5, 15),  # Large batch: 7.5% waste (efficiency)\n            ]\n        ),\n    }\n)\n</code></pre> <p>Equipment with discrete operating modes:</p> <pre><code>compressor_pc = PiecewiseConversion(\n    {\n        'electricity': Piecewise(\n            [\n                Piece(0, 0),  # Off mode: no consumption\n                Piece(45, 45),  # Low mode: fixed 45 kW\n                Piece(85, 85),  # High mode: fixed 85 kW\n            ]\n        ),\n        'compressed_air': Piecewise(\n            [\n                Piece(0, 0),  # Off mode: no production\n                Piece(250, 250),  # Low mode: 250 Nm\u00b3/h\n                Piece(500, 500),  # High mode: 500 Nm\u00b3/h\n            ]\n        ),\n    }\n)\n</code></pre> <p>Equipment with forbidden operating range:</p> <pre><code>steam_turbine_pc = PiecewiseConversion(\n    {\n        'steam_in': Piecewise(\n            [\n                Piece(0, 100),  # Low pressure operation\n                Piece(200, 500),  # High pressure (gap: 100-200 forbidden)\n            ]\n        ),\n        'electricity_out': Piecewise(\n            [\n                Piece(0, 30),  # Low pressure: poor efficiency\n                Piece(80, 220),  # High pressure: good efficiency\n            ]\n        ),\n        'condensate_out': Piecewise(\n            [\n                Piece(0, 100),  # Low pressure condensate\n                Piece(200, 500),  # High pressure condensate\n            ]\n        ),\n    }\n)\n</code></pre> Design Patterns <p>Forbidden Ranges: Use gaps between pieces to model equipment that cannot operate in certain ranges (e.g., minimum loads, unstable regions).</p> <p>Discrete Modes: Use pieces with identical start/end values to model equipment with fixed operating points (e.g., on/off, discrete speeds).</p> <p>Efficiency Changes: Coordinate input and output pieces to reflect changing conversion efficiency across operating ranges.</p> Common Use Cases <ul> <li>Power generation: Multi-fuel plants, cogeneration systems, renewable hybrids</li> <li>HVAC systems: Heat pumps, chillers with variable COP and auxiliary loads</li> <li>Industrial processes: Multi-product reactors, separation units, heat exchangers</li> <li>Transportation: Multi-modal systems, hybrid vehicles, charging infrastructure</li> <li>Water treatment: Multi-stage processes with varying energy and chemical needs</li> <li>Energy storage: Systems with efficiency changes and auxiliary power requirements</li> </ul>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseConversion.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Return an iterator over (flow_label, Piecewise) pairs stored in this PiecewiseConversion.</p> <p>This is a thin convenience wrapper around the internal mapping and yields the same view as dict.items(), where each key is a flow label (str) and each value is a Piecewise.</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects","title":"PiecewiseEffects","text":"<pre><code>PiecewiseEffects(piecewise_origin: Piecewise, piecewise_shares: dict[str, Piecewise])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define how a single decision variable contributes to system effects with piecewise rates.</p> <p>This class models situations where a decision variable (the origin) generates different types of system effects (costs, emissions, resource consumption) at rates that change non-linearly with the variable's operating level. Unlike PiecewiseConversion which coordinates multiple flows, PiecewiseEffects focuses on how one variable impacts multiple system-wide effects.</p> <p>Key Concept - Origin vs. Effects:     - Origin: The primary decision variable (e.g., production level, capacity, size)     - Shares: The amounts which this variable contributes to different system effects</p> Relationship to PiecewiseConversion <p>PiecewiseConversion: Models synchronized relationships between multiple flow variables (e.g., fuel_in, electricity_out, emissions_out all coordinated).</p> <p>PiecewiseEffects: Models how one variable contributes to system-wide effects at variable rates (e.g., production_level \u2192 costs, emissions, resources).</p> <p>Parameters:</p> Name Type Description Default <code>piecewise_origin</code> <code>Piecewise</code> <p>Piecewise function defining the behavior of the primary decision variable. This establishes the operating domain and ranges.</p> required <code>piecewise_shares</code> <code>dict[str, Piecewise]</code> <p>Dictionary mapping effect names to their rate functions. Keys are effect identifiers (e.g., 'cost_per_unit', 'CO2_intensity'). Values are Piecewise objects defining the contribution rate per unit of the origin variable at different operating levels.</p> required Mathematical Relationship <p>For each effect: Total_Effect = Origin_Variable \u00d7 Share_Rate(Origin_Level)</p> <p>This enables modeling of: - Economies of scale (decreasing unit costs with volume) - Learning curves (improving efficiency with experience) - Threshold effects (changing rates at different scales) - Progressive pricing (increasing rates with consumption)</p> <p>Examples:</p> <p>Manufacturing with economies of scale:</p> <pre><code>production_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(0, 1000),  # Small scale: 0-1000 units/month\n            Piece(1000, 5000),  # Medium scale: 1000-5000 units/month\n            Piece(5000, 10000),  # Large scale: 5000-10000 units/month\n        ]\n    ),\n    piecewise_shares={\n        'unit_cost': Piecewise(\n            [\n                Piece(50, 45),  # \u20ac50-45/unit (scale benefits)\n                Piece(45, 35),  # \u20ac45-35/unit (bulk materials)\n                Piece(35, 30),  # \u20ac35-30/unit (automation benefits)\n            ]\n        ),\n        'labor_hours': Piecewise(\n            [\n                Piece(2.5, 2.0),  # 2.5-2.0 hours/unit (learning curve)\n                Piece(2.0, 1.5),  # 2.0-1.5 hours/unit (efficiency gains)\n                Piece(1.5, 1.2),  # 1.5-1.2 hours/unit (specialization)\n            ]\n        ),\n        'CO2_intensity': Piecewise(\n            [\n                Piece(15, 12),  # 15-12 kg CO2/unit (process optimization)\n                Piece(12, 9),  # 12-9 kg CO2/unit (equipment efficiency)\n                Piece(9, 7),  # 9-7 kg CO2/unit (renewable energy)\n            ]\n        ),\n    },\n)\n</code></pre> <p>Power generation with load-dependent characteristics:</p> <pre><code>generator_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(50, 200),  # Part load operation: 50-200 MW\n            Piece(200, 350),  # Rated operation: 200-350 MW\n            Piece(350, 400),  # Overload operation: 350-400 MW\n        ]\n    ),\n    piecewise_shares={\n        'fuel_rate': Piecewise(\n            [\n                Piece(12.0, 10.5),  # Heat rate: 12.0-10.5 GJ/MWh (part load penalty)\n                Piece(10.5, 9.8),  # Heat rate: 10.5-9.8 GJ/MWh (optimal efficiency)\n                Piece(9.8, 11.2),  # Heat rate: 9.8-11.2 GJ/MWh (overload penalty)\n            ]\n        ),\n        'maintenance_factor': Piecewise(\n            [\n                Piece(0.8, 1.0),  # Low stress operation\n                Piece(1.0, 1.0),  # Design operation\n                Piece(1.0, 1.5),  # High stress operation\n            ]\n        ),\n        'NOx_rate': Piecewise(\n            [\n                Piece(0.20, 0.15),  # NOx: 0.20-0.15 kg/MWh\n                Piece(0.15, 0.12),  # NOx: 0.15-0.12 kg/MWh (optimal combustion)\n                Piece(0.12, 0.25),  # NOx: 0.12-0.25 kg/MWh (overload penalties)\n            ]\n        ),\n    },\n)\n</code></pre> <p>Progressive utility pricing structure:</p> <pre><code>electricity_billing = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(0, 200),  # Basic usage: 0-200 kWh/month\n            Piece(200, 800),  # Standard usage: 200-800 kWh/month\n            Piece(800, 2000),  # High usage: 800-2000 kWh/month\n        ]\n    ),\n    piecewise_shares={\n        'energy_rate': Piecewise(\n            [\n                Piece(0.12, 0.12),  # Basic rate: \u20ac0.12/kWh\n                Piece(0.18, 0.18),  # Standard rate: \u20ac0.18/kWh\n                Piece(0.28, 0.28),  # Premium rate: \u20ac0.28/kWh\n            ]\n        ),\n        'carbon_tax': Piecewise(\n            [\n                Piece(0.02, 0.02),  # Low carbon tax: \u20ac0.02/kWh\n                Piece(0.03, 0.03),  # Medium carbon tax: \u20ac0.03/kWh\n                Piece(0.05, 0.05),  # High carbon tax: \u20ac0.05/kWh\n            ]\n        ),\n    },\n)\n</code></pre> <p>Data center with capacity-dependent efficiency:</p> <pre><code>datacenter_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(100, 500),  # Low utilization: 100-500 servers\n            Piece(500, 2000),  # Medium utilization: 500-2000 servers\n            Piece(2000, 5000),  # High utilization: 2000-5000 servers\n        ]\n    ),\n    piecewise_shares={\n        'power_per_server': Piecewise(\n            [\n                Piece(0.8, 0.6),  # 0.8-0.6 kW/server (inefficient cooling)\n                Piece(0.6, 0.4),  # 0.6-0.4 kW/server (optimal efficiency)\n                Piece(0.4, 0.5),  # 0.4-0.5 kW/server (thermal limits)\n            ]\n        ),\n        'cooling_overhead': Piecewise(\n            [\n                Piece(0.4, 0.3),  # 40%-30% cooling overhead\n                Piece(0.3, 0.2),  # 30%-20% cooling overhead\n                Piece(0.2, 0.25),  # 20%-25% cooling overhead\n            ]\n        ),\n    },\n)\n</code></pre> Design Patterns <p>Economies of Scale: Decreasing unit costs/impacts with increased scale Learning Curves: Improving efficiency rates with experience/volume Threshold Effects: Step changes in rates at specific operating levels Progressive Pricing: Increasing rates for higher consumption levels Capacity Utilization: Optimal efficiency at design points, penalties at extremes</p> Common Use Cases <ul> <li>Manufacturing: Production scaling, learning effects, quality improvements</li> <li>Energy systems: Generator efficiency curves, renewable capacity factors</li> <li>Logistics: Transportation rates, warehouse utilization, delivery optimization</li> <li>Utilities: Progressive pricing, infrastructure cost allocation</li> <li>Financial services: Risk premiums, transaction fees, volume discounts</li> <li>Environmental modeling: Pollution intensity, resource consumption rates</li> </ul>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/commons/#flixopt.commons.PiecewiseEffects.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/commons/#flixopt.commons-functions","title":"Functions","text":""},{"location":"api-reference/commons/#flixopt.commons.change_logging_level","title":"change_logging_level","text":"<pre><code>change_logging_level(level_name: Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'])\n</code></pre> <p>Change the logging level for the flixopt logger and all its handlers.</p> <p>.. deprecated:: 2.1.11     Use <code>CONFIG.Logging.level = level_name</code> and <code>CONFIG.apply()</code> instead.     This function will be removed in version 3.0.0.</p>"},{"location":"api-reference/commons/#flixopt.commons.change_logging_level--parameters","title":"Parameters","text":"<p>level_name : {'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'}     The logging level to set.</p>"},{"location":"api-reference/commons/#flixopt.commons.change_logging_level--examples","title":"Examples","text":"<p>change_logging_level('DEBUG')  # deprecated</p>"},{"location":"api-reference/commons/#flixopt.commons.change_logging_level--use-this-instead","title":"Use this instead:","text":"<p>CONFIG.Logging.level = 'DEBUG' CONFIG.apply()</p>"},{"location":"api-reference/components/","title":"components","text":""},{"location":"api-reference/components/#flixopt.components","title":"flixopt.components","text":"<p>This module contains the basic components of the flixopt framework.</p>"},{"location":"api-reference/components/#flixopt.components-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components-classes","title":"Classes","text":""},{"location":"api-reference/components/#flixopt.components.LinearConverter","title":"LinearConverter","text":"<pre><code>LinearConverter(label: str, inputs: list[Flow], outputs: list[Flow], on_off_parameters: OnOffParameters | None = None, conversion_factors: list[dict[str, NumericDataTS]] | None = None, piecewise_conversion: PiecewiseConversion | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Converts input-Flows into output-Flows via linear conversion factors.</p> <p>LinearConverter models equipment that transforms one or more input flows into one or more output flows through linear relationships. This includes heat exchangers, electrical converters, chemical reactors, and other equipment where the relationship between inputs and outputs can be expressed as linear equations.</p> <p>The component supports two modeling approaches: simple conversion factors for straightforward linear relationships, or piecewise conversion for complex non-linear behavior approximated through piecewise linear segments.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow]</code> <p>list of input Flows that feed into the converter.</p> required <code>outputs</code> <code>list[Flow]</code> <p>list of output Flows that are produced by the converter.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Information about on and off state of LinearConverter. Component is On/Off if all connected Flows are On/Off. This induces an On-Variable (binary) in all Flows! If possible, use OnOffParameters in a single Flow instead to keep the number of binary variables low.</p> <code>None</code> <code>conversion_factors</code> <code>list[dict[str, NumericDataTS]] | None</code> <p>Linear relationships between flows expressed as a list of dictionaries. Each dictionary maps flow labels to their coefficients in one linear equation. The number of conversion factors must be less than the total number of flows to ensure degrees of freedom &gt; 0. Either 'conversion_factors' OR 'piecewise_conversion' can be used, but not both. For examples also look into the linear_converters.py file.</p> <code>None</code> <code>piecewise_conversion</code> <code>PiecewiseConversion | None</code> <p>Define piecewise linear relationships between flow rates of different flows. Enables modeling of non-linear conversion behavior through linear approximation. Either 'conversion_factors' or 'piecewise_conversion' can be used, but not both.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally, but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Simple 1:1 heat exchanger with 95% efficiency:</p> <pre><code>heat_exchanger = LinearConverter(\n    label='primary_hx',\n    inputs=[hot_water_in],\n    outputs=[hot_water_out],\n    conversion_factors=[{'hot_water_in': 0.95, 'hot_water_out': 1}],\n)\n</code></pre> <p>Multi-input heat pump with COP=3:</p> <pre><code>heat_pump = LinearConverter(\n    label='air_source_hp',\n    inputs=[electricity_in],\n    outputs=[heat_output],\n    conversion_factors=[{'electricity_in': 3, 'heat_output': 1}],\n)\n</code></pre> <p>Combined heat and power (CHP) unit with multiple outputs:</p> <pre><code>chp_unit = LinearConverter(\n    label='gas_chp',\n    inputs=[natural_gas],\n    outputs=[electricity_out, heat_out],\n    conversion_factors=[\n        {'natural_gas': 0.35, 'electricity_out': 1},\n        {'natural_gas': 0.45, 'heat_out': 1},\n    ],\n)\n</code></pre> <p>Electrolyzer with multiple conversion relationships:</p> <pre><code>electrolyzer = LinearConverter(\n    label='pem_electrolyzer',\n    inputs=[electricity_in, water_in],\n    outputs=[hydrogen_out, oxygen_out],\n    conversion_factors=[\n        {'electricity_in': 1, 'hydrogen_out': 50},  # 50 kWh/kg H2\n        {'water_in': 1, 'hydrogen_out': 9},  # 9 kg H2O/kg H2\n        {'hydrogen_out': 8, 'oxygen_out': 1},  # Mass balance\n    ],\n)\n</code></pre> <p>Complex converter with piecewise efficiency:</p> <pre><code>variable_efficiency_converter = LinearConverter(\n    label='variable_converter',\n    inputs=[fuel_in],\n    outputs=[power_out],\n    piecewise_conversion=PiecewiseConversion(\n        {\n            'fuel_in': Piecewise(\n                [\n                    Piece(0, 10),  # Low load operation\n                    Piece(10, 25),  # High load operation\n                ]\n            ),\n            'power_out': Piecewise(\n                [\n                    Piece(0, 3.5),  # Lower efficiency at part load\n                    Piece(3.5, 10),  # Higher efficiency at full load\n                ]\n            ),\n        }\n    ),\n)\n</code></pre> Note <p>Conversion factors define linear relationships where the sum of (coefficient \u00d7 flow_rate) equals zero for each equation: factor1\u00d7flow1 + factor2\u00d7flow2 + ... = 0 Conversion factors define linear relationships. <code>{flow1: a1, flow2: a2, ...}</code> leads to <code>a1\u00d7flow_rate1 + a2\u00d7flow_rate2 + ... = 0</code> Unfortunately the current input format doest read intuitively: {\"electricity\": 1, \"H2\": 50} means that the electricity_in flow rate is multiplied by 1 and the hydrogen_out flow rate is multiplied by 50. THis leads to 50 electricity --&gt; 1 H2.</p> <p>The system must have fewer conversion factors than total flows (degrees of freedom &gt; 0) to avoid over-constraining the problem. For n total flows, use at most n-1 conversion factors.</p> <p>When using piecewise_conversion, the converter operates on one piece at a time, with binary variables determining which piece is active.</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.LinearConverter.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/components/#flixopt.components.LinearConverter.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/components/#flixopt.components.LinearConverter.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/components/#flixopt.components.Storage","title":"Storage","text":"<pre><code>Storage(label: str, charging: Flow, discharging: Flow, capacity_in_flow_hours: Scalar | InvestParameters, relative_minimum_charge_state: NumericData = 0, relative_maximum_charge_state: NumericData = 1, initial_charge_state: Scalar | Literal['lastValueOfSim'] = 0, minimal_final_charge_state: Scalar | None = None, maximal_final_charge_state: Scalar | None = None, eta_charge: NumericData = 1, eta_discharge: NumericData = 1, relative_loss_per_hour: NumericData = 0, prevent_simultaneous_charge_and_discharge: bool = True, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Storage models the temporary storage and release of energy or material.</p> <p>Storages have one incoming and one outgoing Flow, each with configurable efficiency factors. They maintain a charge state variable that represents the stored amount, bounded by capacity limits and evolving over time based on charging, discharging, and self-discharge losses.</p> <p>The storage model handles complex temporal dynamics including initial conditions, final state constraints, and time-varying parameters. It supports both fixed-size and investment-optimized storage systems with comprehensive techno-economic modeling.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>charging</code> <code>Flow</code> <p>Incoming flow for loading the storage. Represents energy or material flowing into the storage system.</p> required <code>discharging</code> <code>Flow</code> <p>Outgoing flow for unloading the storage. Represents energy or material flowing out of the storage system.</p> required <code>capacity_in_flow_hours</code> <code>Scalar | InvestParameters</code> <p>Nominal capacity/size of the storage in flow-hours (e.g., kWh for electrical storage, m\u00b3 or kg for material storage). Can be a scalar for fixed capacity or InvestParameters for optimization.</p> required <code>relative_minimum_charge_state</code> <code>NumericData</code> <p>Minimum relative charge state (0-1 range). Prevents deep discharge that could damage equipment. Default is 0.</p> <code>0</code> <code>relative_maximum_charge_state</code> <code>NumericData</code> <p>Maximum relative charge state (0-1 range). Accounts for practical capacity limits, safety margins or temperature impacts. Default is 1.</p> <code>1</code> <code>initial_charge_state</code> <code>Scalar | Literal['lastValueOfSim']</code> <p>Storage charge state at the beginning of the time horizon. Can be numeric value or 'lastValueOfSim', which is recommended for if the initial start state is not known. Default is 0.</p> <code>0</code> <code>minimal_final_charge_state</code> <code>Scalar | None</code> <p>Minimum absolute charge state required at the end of the time horizon. Useful for ensuring energy security or meeting contracts.</p> <code>None</code> <code>maximal_final_charge_state</code> <code>Scalar | None</code> <p>Maximum absolute charge state allowed at the end of the time horizon. Useful for preventing overcharge or managing inventory.</p> <code>None</code> <code>eta_charge</code> <code>NumericData</code> <p>Charging efficiency factor (0-1 range). Accounts for conversion losses during charging. Default is 1 (perfect efficiency).</p> <code>1</code> <code>eta_discharge</code> <code>NumericData</code> <p>Discharging efficiency factor (0-1 range). Accounts for conversion losses during discharging. Default is 1 (perfect efficiency).</p> <code>1</code> <code>relative_loss_per_hour</code> <code>NumericData</code> <p>Self-discharge rate per hour (typically 0-0.1 range). Represents standby losses, leakage, or degradation. Default is 0.</p> <code>0</code> <code>prevent_simultaneous_charge_and_discharge</code> <code>bool</code> <p>If True, prevents charging and discharging simultaneously. Increases binary variables but improves model realism and solution interpretation. Default is True.</p> <code>True</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally, but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Battery energy storage system:</p> <pre><code>battery = Storage(\n    label='lithium_battery',\n    charging=battery_charge_flow,\n    discharging=battery_discharge_flow,\n    capacity_in_flow_hours=100,  # 100 kWh capacity\n    eta_charge=0.95,  # 95% charging efficiency\n    eta_discharge=0.95,  # 95% discharging efficiency\n    relative_loss_per_hour=0.001,  # 0.1% loss per hour\n    relative_minimum_charge_state=0.1,  # Never below 10% SOC\n    relative_maximum_charge_state=0.9,  # Never above 90% SOC\n)\n</code></pre> <p>Thermal storage with cycling constraints:</p> <pre><code>thermal_storage = Storage(\n    label='hot_water_tank',\n    charging=heat_input,\n    discharging=heat_output,\n    capacity_in_flow_hours=500,  # 500 kWh thermal capacity\n    initial_charge_state=250,  # Start half full\n    # Impact of temperature on energy capacity\n    relative_maximum_charge_state=water_temperature_spread / rated_temeprature_spread,\n    eta_charge=0.90,  # Heat exchanger losses\n    eta_discharge=0.85,  # Distribution losses\n    relative_loss_per_hour=0.02,  # 2% thermal loss per hour\n    prevent_simultaneous_charge_and_discharge=True,\n)\n</code></pre> <p>Pumped hydro storage with investment optimization:</p> <pre><code>pumped_hydro = Storage(\n    label='pumped_hydro',\n    charging=pump_flow,\n    discharging=turbine_flow,\n    capacity_in_flow_hours=InvestParameters(\n        minimum_size=1000,  # Minimum economic scale\n        maximum_size=10000,  # Site constraints\n        specific_effects={'cost': 150},  # \u20ac150/MWh capacity\n        fix_effects={'cost': 50_000_000},  # \u20ac50M fixed costs\n    ),\n    eta_charge=0.85,  # Pumping efficiency\n    eta_discharge=0.90,  # Turbine efficiency\n    initial_charge_state='lastValueOfSim',  # Ensuring no deficit compared to start\n    relative_loss_per_hour=0.0001,  # Minimal evaporation\n)\n</code></pre> <p>Material storage with inventory management:</p> <pre><code>fuel_storage = Storage(\n    label='natural_gas_storage',\n    charging=gas_injection,\n    discharging=gas_withdrawal,\n    capacity_in_flow_hours=10000,  # 10,000 m\u00b3 storage volume\n    initial_charge_state=3000,  # Start with 3,000 m\u00b3\n    minimal_final_charge_state=1000,  # Strategic reserve\n    maximal_final_charge_state=9000,  # Prevent overflow\n    eta_charge=0.98,  # Compression losses\n    eta_discharge=0.95,  # Pressure reduction losses\n    relative_loss_per_hour=0.0005,  # 0.05% leakage per hour\n    prevent_simultaneous_charge_and_discharge=False,  # Allow flow-through\n)\n</code></pre> Note <p>Charge state evolution follows the equation: charge[t+1] = charge[t] \u00d7 (1-loss_rate)^hours_per_step +               charge_flow[t] \u00d7 eta_charge \u00d7 hours_per_step -               discharge_flow[t] \u00d7 hours_per_step / eta_discharge</p> <p>All efficiency parameters (eta_charge, eta_discharge) are dimensionless (0-1 range). The relative_loss_per_hour parameter represents exponential decay per hour.</p> <p>When prevent_simultaneous_charge_and_discharge is True, binary variables are created to enforce mutual exclusivity, which increases solution time but prevents unrealistic simultaneous charging and discharging.</p> <p>Initial and final charge state constraints use absolute values (not relative), matching the capacity_in_flow_hours units.</p>"},{"location":"api-reference/components/#flixopt.components.Storage-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Storage.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/components/#flixopt.components.Storage.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/components/#flixopt.components.Storage.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/components/#flixopt.components.Transmission","title":"Transmission","text":"<pre><code>Transmission(label: str, in1: Flow, out1: Flow, in2: Flow | None = None, out2: Flow | None = None, relative_losses: NumericDataTS = 0, absolute_losses: NumericDataTS | None = None, on_off_parameters: OnOffParameters | None = None, prevent_simultaneous_flows_in_both_directions: bool = True, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>Models transmission infrastructure that transports flows between two locations with losses.</p> <p>Transmission components represent physical infrastructure like pipes, cables, transmission lines, or conveyor systems that transport energy or materials between two points. They can model both unidirectional and bidirectional flow with configurable loss mechanisms and operational constraints.</p> <p>The component supports complex transmission scenarios including relative losses (proportional to flow), absolute losses (fixed when active), and bidirectional operation with flow direction constraints.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>in1</code> <code>Flow</code> <p>The primary inflow (side A). Pass InvestParameters here for capacity optimization.</p> required <code>out1</code> <code>Flow</code> <p>The primary outflow (side B).</p> required <code>in2</code> <code>Flow | None</code> <p>Optional secondary inflow (side B) for bidirectional operation. If in1 has InvestParameters, in2 will automatically have matching capacity.</p> <code>None</code> <code>out2</code> <code>Flow | None</code> <p>Optional secondary outflow (side A) for bidirectional operation.</p> <code>None</code> <code>relative_losses</code> <code>NumericDataTS</code> <p>Proportional losses as fraction of throughput (e.g., 0.02 for 2% loss). Applied as: output = input \u00d7 (1 - relative_losses)</p> <code>0</code> <code>absolute_losses</code> <code>NumericDataTS | None</code> <p>Fixed losses that occur when transmission is active. Automatically creates binary variables for on/off states.</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>prevent_simultaneous_flows_in_both_directions</code> <code>bool</code> <p>If True, prevents simultaneous flow in both directions. Increases binary variables but reflects physical reality for most transmission systems. Default is True.</p> <code>True</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Simple electrical transmission line:</p> <pre><code>power_line = Transmission(\n    label='110kv_line',\n    in1=substation_a_out,\n    out1=substation_b_in,\n    relative_losses=0.03,  # 3% line losses\n)\n</code></pre> <p>Bidirectional natural gas pipeline:</p> <pre><code>gas_pipeline = Transmission(\n    label='interstate_pipeline',\n    in1=compressor_station_a,\n    out1=distribution_hub_b,\n    in2=compressor_station_b,\n    out2=distribution_hub_a,\n    relative_losses=0.005,  # 0.5% friction losses\n    absolute_losses=50,  # 50 kW compressor power when active\n    prevent_simultaneous_flows_in_both_directions=True,\n)\n</code></pre> <p>District heating network with investment optimization:</p> <pre><code>heating_network = Transmission(\n    label='dh_main_line',\n    in1=Flow(\n        label='heat_supply',\n        bus=central_plant_bus,\n        size=InvestParameters(\n            minimum_size=1000,  # Minimum 1 MW capacity\n            maximum_size=10000,  # Maximum 10 MW capacity\n            specific_effects={'cost': 200},  # \u20ac200/kW capacity\n            fix_effects={'cost': 500000},  # \u20ac500k fixed installation\n        ),\n    ),\n    out1=district_heat_demand,\n    relative_losses=0.15,  # 15% thermal losses in distribution\n)\n</code></pre> <p>Material conveyor with on/off operation:</p> <pre><code>conveyor_belt = Transmission(\n    label='material_transport',\n    in1=loading_station,\n    out1=unloading_station,\n    absolute_losses=25,  # 25 kW motor power when running\n    on_off_parameters=OnOffParameters(\n        effects_per_switch_on={'maintenance': 0.1},\n        consecutive_on_hours_min=2,  # Minimum 2-hour operation\n        switch_on_total_max=10,  # Maximum 10 starts per day\n    ),\n)\n</code></pre> Note <p>The transmission equation balances flows with losses: output_flow = input_flow \u00d7 (1 - relative_losses) - absolute_losses</p> <p>For bidirectional transmission, each direction has independent loss calculations.</p> <p>When using InvestParameters on in1, the capacity automatically applies to in2 to maintain consistent bidirectional capacity without additional investment variables.</p> <p>Absolute losses force the creation of binary on/off variables, which increases computational complexity but enables realistic modeling of equipment with standby power consumption.</p>"},{"location":"api-reference/components/#flixopt.components.Transmission-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Transmission.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/components/#flixopt.components.Transmission.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/components/#flixopt.components.Transmission.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/components/#flixopt.components.TransmissionModel","title":"TransmissionModel","text":"<pre><code>TransmissionModel(model: SystemModel, element: Transmission)\n</code></pre> <p>               Bases: <code>ComponentModel</code></p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.TransmissionModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.TransmissionModel.do_modeling","title":"do_modeling","text":"<pre><code>do_modeling()\n</code></pre> <p>Initiates all FlowModels</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.create_transmission_equation","title":"create_transmission_equation","text":"<pre><code>create_transmission_equation(name: str, in_flow: Flow, out_flow: Flow) -&gt; linopy.Constraint\n</code></pre> <p>Creates an Equation for the Transmission efficiency and adds it to the model</p>"},{"location":"api-reference/components/#flixopt.components.TransmissionModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/components/#flixopt.components.StorageModel","title":"StorageModel","text":"<pre><code>StorageModel(model: SystemModel, element: Storage)\n</code></pre> <p>               Bases: <code>ComponentModel</code></p> <p>Model of Storage</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel-attributes","title":"Attributes","text":""},{"location":"api-reference/components/#flixopt.components.StorageModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/components/#flixopt.components.StorageModel-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.StorageModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink","title":"SourceAndSink","text":"<pre><code>SourceAndSink(label: str, inputs: list[Flow] | None = None, outputs: list[Flow] | None = None, prevent_simultaneous_flow_rates: bool = True, meta_data: dict | None = None, **kwargs)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A SourceAndSink combines both supply and demand capabilities in a single component.</p> <p>SourceAndSink components can both consume AND provide energy or material flows from and to the system, making them ideal for modeling markets, (simple) storage facilities, or bidirectional grid connections where buying and selling occur at the same location.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>Input-flows into the SourceAndSink representing consumption/demand side.</p> <code>None</code> <code>outputs</code> <code>list[Flow] | None</code> <p>Output-flows from the SourceAndSink representing supply/generation side.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, prevents simultaneous input and output flows. This enforces that the component operates either as a source OR sink at any given time, but not both simultaneously. Default is True.</p> <code>True</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Electricity market connection (buy/sell to grid):</p> <pre><code>electricity_market = SourceAndSink(\n    label='grid_connection',\n    inputs=[electricity_purchase],  # Buy from grid\n    outputs=[electricity_sale],  # Sell to grid\n    prevent_simultaneous_flow_rates=True,  # Can't buy and sell simultaneously\n)\n</code></pre> <p>Natural gas storage facility:</p> <pre><code>gas_storage_facility = SourceAndSink(\n    label='underground_gas_storage',\n    inputs=[gas_injection_flow],  # Inject gas into storage\n    outputs=[gas_withdrawal_flow],  # Withdraw gas from storage\n    prevent_simultaneous_flow_rates=True,  # Injection or withdrawal, not both\n)\n</code></pre> <p>District heating network connection:</p> <pre><code>dh_connection = SourceAndSink(\n    label='district_heating_tie',\n    inputs=[heat_purchase_flow],  # Purchase heat from network\n    outputs=[heat_sale_flow],  # Sell excess heat to network\n    prevent_simultaneous_flow_rates=False,  # May allow simultaneous flows\n)\n</code></pre> <p>Industrial waste heat exchange:</p> <pre><code>waste_heat_exchange = SourceAndSink(\n    label='industrial_heat_hub',\n    inputs=[\n        waste_heat_input_a,  # Receive waste heat from process A\n        waste_heat_input_b,  # Receive waste heat from process B\n    ],\n    outputs=[\n        useful_heat_supply_c,  # Supply heat to process C\n        useful_heat_supply_d,  # Supply heat to process D\n    ],\n    prevent_simultaneous_flow_rates=False,  # Multiple simultaneous flows allowed\n)\n</code></pre> Note <p>When prevent_simultaneous_flow_rates is True, binary variables are created to ensure mutually exclusive operation between input and output flows, which increases computational complexity but reflects realistic market or storage operation constraints.</p> <p>SourceAndSink is particularly useful for modeling: - Energy markets with bidirectional trading - Storage facilities with injection/withdrawal operations - Grid tie points with import/export capabilities - Waste exchange networks with multiple participants</p> Deprecated <p>The deprecated <code>sink</code> and <code>source</code> kwargs are accepted for compatibility but will be removed in future releases.</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.SourceAndSink.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/components/#flixopt.components.SourceAndSink.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/components/#flixopt.components.Source","title":"Source","text":"<pre><code>Source(label: str, outputs: list[Flow] | None = None, meta_data: dict | None = None, prevent_simultaneous_flow_rates: bool = False, **kwargs)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Source generates or provides energy or material flows into the system.</p> <p>Sources represent supply points like power plants, fuel suppliers, renewable energy sources, or any system boundary where flows originate. They provide unlimited supply capability subject to flow constraints, demand patterns and effects.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>outputs</code> <code>list[Flow] | None</code> <p>Output-flows from the source. Can be single flow or list of flows for sources providing multiple commodities or services.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, only one output flow can be active at a time. Useful for modeling mutually exclusive supply options. Default is False.</p> <code>False</code> <p>Examples:</p> <p>Simple electricity grid connection:</p> <pre><code>grid_source = Source(label='electrical_grid', outputs=[grid_electricity_flow])\n</code></pre> <p>Natural gas supply with cost and capacity constraints:</p> <pre><code>gas_supply = Source(\n    label='gas_network',\n    outputs=[\n        Flow(\n            label='natural_gas_flow',\n            bus=gas_bus,\n            size=1000,  # Maximum 1000 kW supply capacity\n            effects_per_flow_hour={'cost': 0.04},  # \u20ac0.04/kWh gas cost\n        )\n    ],\n)\n</code></pre> <p>Multi-fuel power plant with switching constraints:</p> <pre><code>multi_fuel_plant = Source(\n    label='flexible_generator',\n    outputs=[coal_electricity, gas_electricity, biomass_electricity],\n    prevent_simultaneous_flow_rates=True,  # Can only use one fuel at a time\n)\n</code></pre> <p>Renewable energy source with investment optimization:</p> <pre><code>solar_farm = Source(\n    label='solar_pv',\n    outputs=[\n        Flow(\n            label='solar_power',\n            bus=electricity_bus,\n            size=InvestParameters(\n                minimum_size=0,\n                maximum_size=50000,  # Up to 50 MW\n                specific_effects={'cost': 800},  # \u20ac800/kW installed\n                fix_effects={'cost': 100000},  # \u20ac100k development costs\n            ),\n            fixed_relative_profile=solar_profile,  # Hourly generation profile\n        )\n    ],\n)\n</code></pre> Deprecated <p>The deprecated <code>source</code> kwarg is accepted for compatibility but will be removed in future releases.</p>"},{"location":"api-reference/components/#flixopt.components.Source-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Source.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/components/#flixopt.components.Source.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/components/#flixopt.components.Source.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/components/#flixopt.components.Sink","title":"Sink","text":"<pre><code>Sink(label: str, inputs: list[Flow] | None = None, meta_data: dict | None = None, prevent_simultaneous_flow_rates: bool = False, **kwargs)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>A Sink consumes energy or material flows from the system.</p> <p>Sinks represent demand points like electrical loads, heat demands, material consumption, or any system boundary where flows terminate. They provide unlimited consumption capability subject to flow constraints, demand patterns and effects.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>Input-flows into the sink. Can be single flow or list of flows for sinks consuming multiple commodities or services.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information about the Element. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, only one input flow can be active at a time. Useful for modeling mutually exclusive consumption options. Default is False.</p> <code>False</code> <p>Examples:</p> <p>Simple electrical demand:</p> <pre><code>electrical_load = Sink(label='building_load', inputs=[electricity_demand_flow])\n</code></pre> <p>Heat demand with time-varying profile:</p> <pre><code>heat_demand = Sink(\n    label='district_heating_load',\n    inputs=[\n        Flow(\n            label='heat_consumption',\n            bus=heat_bus,\n            fixed_relative_profile=hourly_heat_profile,  # Demand profile\n            size=2000,  # Peak demand of 2000 kW\n        )\n    ],\n)\n</code></pre> <p>Multi-energy building with switching capabilities:</p> <pre><code>flexible_building = Sink(\n    label='smart_building',\n    inputs=[electricity_heating, gas_heating, heat_pump_heating],\n    prevent_simultaneous_flow_rates=True,  # Can only use one heating mode\n)\n</code></pre> <p>Industrial process with variable demand:</p> <pre><code>factory_load = Sink(\n    label='manufacturing_plant',\n    inputs=[\n        Flow(\n            label='electricity_process',\n            bus=electricity_bus,\n            size=5000,  # Base electrical load\n            effects_per_flow_hour={'cost': -0.1},  # Value of service (negative cost)\n        ),\n        Flow(\n            label='steam_process',\n            bus=steam_bus,\n            size=3000,  # Process steam demand\n            fixed_relative_profile=production_schedule,\n        ),\n    ],\n)\n</code></pre> Deprecated <p>The deprecated <code>sink</code> kwarg is accepted for compatibility but will be removed in future releases.</p> <p>Initialize a Sink (consumes flow from the system).</p> <p>Supports legacy <code>sink=</code> keyword for backward compatibility (deprecated): if <code>sink</code> is provided it is used as the single input flow and a DeprecationWarning is issued; specifying both <code>inputs</code> and <code>sink</code> raises ValueError.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Unique element label.</p> required <code>inputs</code> <code>list[Flow]</code> <p>Input flows for the sink.</p> <code>None</code> <code>meta_data</code> <code>dict</code> <p>Arbitrary metadata attached to the element.</p> <code>None</code> <code>prevent_simultaneous_flow_rates</code> <code>bool</code> <p>If True, prevents simultaneous nonzero flow rates across the element's inputs by wiring that restriction into the base Component setup.</p> <code>False</code> Note <p>The deprecated <code>sink</code> kwarg is accepted for compatibility but will be removed in future releases.</p>"},{"location":"api-reference/components/#flixopt.components.Sink-functions","title":"Functions","text":""},{"location":"api-reference/components/#flixopt.components.Sink.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/components/#flixopt.components.Sink.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/components/#flixopt.components.Sink.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/components/#flixopt.components-functions","title":"Functions","text":""},{"location":"api-reference/config/","title":"config","text":""},{"location":"api-reference/config/#flixopt.config","title":"flixopt.config","text":""},{"location":"api-reference/config/#flixopt.config-classes","title":"Classes","text":""},{"location":"api-reference/config/#flixopt.config.CONFIG","title":"CONFIG","text":"<p>Configuration for flixopt library.</p> <p>The CONFIG class provides centralized configuration for logging and modeling parameters. All changes require calling <code>CONFIG.apply()</code> to take effect.</p> <p>By default, logging outputs to both console and file ('flixopt.log').</p> <p>Attributes:</p> Name Type Description <code>Logging</code> <p>Nested class containing all logging configuration options. Colors: Nested subclass under Logging containing ANSI color codes for log levels.</p> <code>Modeling</code> <p>Nested class containing optimization modeling parameters.</p> <code>config_name</code> <code>str</code> <p>Name of the configuration (default: 'flixopt').</p> Logging Attributes <p>level (str): Logging level: 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'.     Default: 'INFO' file (str | None): Log file path. Default: 'flixopt.log'.     Set to None to disable file logging. console (bool): Enable console (stdout) logging. Default: True rich (bool): Use Rich library for enhanced console output. Default: False max_file_size (int): Maximum log file size in bytes before rotation.     Default: 10485760 (10MB) backup_count (int): Number of backup log files to keep. Default: 5 date_format (str): Date/time format for log messages.     Default: '%Y-%m-%d %H:%M:%S' format (str): Log message format string. Default: '%(message)s' console_width (int): Console width for Rich handler. Default: 120 show_path (bool): Show file paths in log messages. Default: False</p> Colors Attributes <p>DEBUG (str): ANSI color code for DEBUG level. Default: '\\033[32m' (green) INFO (str): ANSI color code for INFO level. Default: '\\033[34m' (blue) WARNING (str): ANSI color code for WARNING level. Default: '\\033[33m' (yellow) ERROR (str): ANSI color code for ERROR level. Default: '\\033[31m' (red) CRITICAL (str): ANSI color code for CRITICAL level. Default: '\\033[1m\\033[31m' (bold red)</p> <p>Works with both Rich and standard console handlers. Rich automatically converts ANSI codes using Style.from_ansi().</p> <p>Common ANSI codes:</p> <ul> <li>'\\033[30m' - Black</li> <li>'\\033[31m' - Red</li> <li>'\\033[32m' - Green</li> <li>'\\033[33m' - Yellow</li> <li>'\\033[34m' - Blue</li> <li>'\\033[35m' - Magenta</li> <li>'\\033[36m' - Cyan</li> <li>'\\033[37m' - White</li> <li>'\\033[1m\\033[3Xm' - Bold color (replace X with color code 0-7)</li> <li>'\\033[2m\\033[3Xm' - Dim color (replace X with color code 0-7)</li> </ul> <p>Examples:</p> <ul> <li>Magenta: '\\033[35m'</li> <li>Bold cyan: '\\033[1m\\033[36m'</li> <li>Dim green: '\\033[2m\\033[32m'</li> </ul> Modeling Attributes <p>big (int): Large number for optimization constraints. Default: 10000000 epsilon (float): Small tolerance value. Default: 1e-5 big_binary_bound (int): Upper bound for binary variable constraints.     Default: 100000</p> <p>Examples:</p> <p>Basic configuration::</p> <pre><code>from flixopt import CONFIG\n\nCONFIG.Logging.console = True\nCONFIG.Logging.level = 'DEBUG'\nCONFIG.apply()\n</code></pre> <p>Configure log file rotation::</p> <pre><code>CONFIG.Logging.file = 'myapp.log'\nCONFIG.Logging.max_file_size = 5_242_880  # 5 MB\nCONFIG.Logging.backup_count = 3\nCONFIG.apply()\n</code></pre> <p>Customize log colors::</p> <pre><code>CONFIG.Logging.Colors.INFO = '\\033[35m'  # Magenta\nCONFIG.Logging.Colors.DEBUG = '\\033[36m'  # Cyan\nCONFIG.Logging.Colors.ERROR = '\\033[1m\\033[31m'  # Bold red\nCONFIG.apply()\n</code></pre> <p>Use Rich handler with custom colors::</p> <pre><code>CONFIG.Logging.console = True\nCONFIG.Logging.rich = True\nCONFIG.Logging.console_width = 100\nCONFIG.Logging.show_path = True\nCONFIG.Logging.Colors.INFO = '\\033[36m'  # Cyan\nCONFIG.apply()\n</code></pre> <p>Load from YAML file::</p> <pre><code>CONFIG.load_from_file('config.yaml')\n</code></pre> <p>Example YAML config file:</p> <p>.. code-block:: yaml</p> <pre><code>logging:\n  level: DEBUG\n  console: true\n  file: app.log\n  rich: true\n  max_file_size: 5242880  # 5MB\n  backup_count: 3\n  date_format: '%H:%M:%S'\n  console_width: 100\n  show_path: true\n  colors:\n    DEBUG: \"\\033[36m\"              # Cyan\n    INFO: \"\\033[32m\"               # Green\n    WARNING: \"\\033[33m\"            # Yellow\n    ERROR: \"\\033[31m\"              # Red\n    CRITICAL: \"\\033[1m\\033[31m\"   # Bold red\n\nmodeling:\n  big: 20000000\n  epsilon: 1e-6\n  big_binary_bound: 200000\n</code></pre> <p>Reset to defaults::</p> <pre><code>CONFIG.reset()\n</code></pre> <p>Export current configuration::</p> <pre><code>config_dict = CONFIG.to_dict()\nimport yaml\n\nwith open('my_config.yaml', 'w') as f:\n    yaml.dump(config_dict, f)\n</code></pre>"},{"location":"api-reference/config/#flixopt.config.CONFIG-functions","title":"Functions","text":""},{"location":"api-reference/config/#flixopt.config.CONFIG.reset","title":"reset  <code>classmethod</code>","text":"<pre><code>reset()\n</code></pre> <p>Reset all configuration values to defaults.</p>"},{"location":"api-reference/config/#flixopt.config.CONFIG.apply","title":"apply  <code>classmethod</code>","text":"<pre><code>apply()\n</code></pre> <p>Apply current configuration to logging system.</p>"},{"location":"api-reference/config/#flixopt.config.CONFIG.load_from_file","title":"load_from_file  <code>classmethod</code>","text":"<pre><code>load_from_file(config_file: str | Path)\n</code></pre> <p>Load configuration from YAML file and apply it.</p>"},{"location":"api-reference/config/#flixopt.config.CONFIG.to_dict","title":"to_dict  <code>classmethod</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the configuration class into a dictionary for JSON serialization.</p>"},{"location":"api-reference/config/#flixopt.config.MultilineFormater","title":"MultilineFormater","text":"<pre><code>MultilineFormater(fmt=None, datefmt=None)\n</code></pre> <p>               Bases: <code>Formatter</code></p> <p>Formatter that handles multi-line messages with consistent prefixes.</p>"},{"location":"api-reference/config/#flixopt.config.ColoredMultilineFormater","title":"ColoredMultilineFormater","text":"<pre><code>ColoredMultilineFormater(fmt=None, datefmt=None, colors=None)\n</code></pre> <p>               Bases: <code>MultilineFormater</code></p> <p>Formatter that adds ANSI colors to multi-line log messages.</p>"},{"location":"api-reference/config/#flixopt.config-functions","title":"Functions","text":""},{"location":"api-reference/config/#flixopt.config.change_logging_level","title":"change_logging_level","text":"<pre><code>change_logging_level(level_name: Literal['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'])\n</code></pre> <p>Change the logging level for the flixopt logger and all its handlers.</p> <p>.. deprecated:: 2.1.11     Use <code>CONFIG.Logging.level = level_name</code> and <code>CONFIG.apply()</code> instead.     This function will be removed in version 3.0.0.</p>"},{"location":"api-reference/config/#flixopt.config.change_logging_level--parameters","title":"Parameters","text":"<p>level_name : {'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'}     The logging level to set.</p>"},{"location":"api-reference/config/#flixopt.config.change_logging_level--examples","title":"Examples","text":"<p>change_logging_level('DEBUG')  # deprecated</p>"},{"location":"api-reference/config/#flixopt.config.change_logging_level--use-this-instead","title":"Use this instead:","text":"<p>CONFIG.Logging.level = 'DEBUG' CONFIG.apply()</p>"},{"location":"api-reference/core/","title":"core","text":""},{"location":"api-reference/core/#flixopt.core","title":"flixopt.core","text":"<p>This module contains the core functionality of the flixopt framework. It provides Datatypes, logging functionality, and some functions to transform data structures.</p>"},{"location":"api-reference/core/#flixopt.core-attributes","title":"Attributes","text":""},{"location":"api-reference/core/#flixopt.core.Scalar","title":"Scalar  <code>module-attribute</code>","text":"<pre><code>Scalar = int | float\n</code></pre> <p>A type representing a single number, either integer or float.</p>"},{"location":"api-reference/core/#flixopt.core.NumericData","title":"NumericData  <code>module-attribute</code>","text":"<pre><code>NumericData = int | float | integer | floating | ndarray | Series | DataFrame | DataArray\n</code></pre> <p>Represents any form of numeric data, from simple scalars to complex data structures.</p>"},{"location":"api-reference/core/#flixopt.core.NumericDataTS","title":"NumericDataTS  <code>module-attribute</code>","text":"<pre><code>NumericDataTS = NumericData | TimeSeriesData\n</code></pre> <p>Represents either standard numeric data or TimeSeriesData.</p>"},{"location":"api-reference/core/#flixopt.core-classes","title":"Classes","text":""},{"location":"api-reference/core/#flixopt.core.PlausibilityError","title":"PlausibilityError","text":"<p>               Bases: <code>Exception</code></p> <p>Error for a failing Plausibility check.</p>"},{"location":"api-reference/core/#flixopt.core.ConversionError","title":"ConversionError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for data conversion errors.</p>"},{"location":"api-reference/core/#flixopt.core.DataConverter","title":"DataConverter","text":"<p>Converts various data types into xarray.DataArray with a timesteps index.</p> <p>Supports: scalars, arrays, Series, DataFrames, and DataArrays.</p>"},{"location":"api-reference/core/#flixopt.core.DataConverter-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.DataConverter.as_dataarray","title":"as_dataarray  <code>staticmethod</code>","text":"<pre><code>as_dataarray(data: NumericData, timesteps: DatetimeIndex) -&gt; xr.DataArray\n</code></pre> <p>Convert data to xarray.DataArray with specified timesteps index.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesData","title":"TimeSeriesData","text":"<pre><code>TimeSeriesData(data: NumericData, agg_group: str | None = None, agg_weight: float | None = None)\n</code></pre> <p>TimeSeriesData wraps time series data with aggregation metadata for optimization.</p> <p>This class combines time series data with special characteristics needed for aggregated calculations. It allows grouping related time series to prevent overweighting in optimization models.</p> Example <p>When you have multiple solar time series, they should share aggregation weight: <pre><code>solar1 = TimeSeriesData(sol_array_1, agg_group='solar')\nsolar2 = TimeSeriesData(sol_array_2, agg_group='solar')\nsolar3 = TimeSeriesData(sol_array_3, agg_group='solar')\n# These 3 series share one weight (each gets weight = 1/3 instead of 1)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NumericData</code> <p>The timeseries data, which can be a scalar, array, or numpy array.</p> required <code>agg_group</code> <code>str | None</code> <p>The group this TimeSeriesData belongs to. agg_weight is split between group members. Default is None.</p> <code>None</code> <code>agg_weight</code> <code>float | None</code> <p>The weight for calculation_type 'aggregated', should be between 0 and 1. Default is None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both agg_group and agg_weight are set.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries","title":"TimeSeries","text":"<pre><code>TimeSeries(data: DataArray, name: str, aggregation_weight: float | None = None, aggregation_group: str | None = None, needs_extra_timestep: bool = False)\n</code></pre> <p>A class representing time series data with active and stored states.</p> <p>TimeSeries provides a way to store time-indexed data and work with temporal subsets. It supports arithmetic operations, aggregation, and JSON serialization.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the time series</p> <code>aggregation_weight</code> <code>Optional[float]</code> <p>Weight used for aggregation</p> <code>aggregation_group</code> <code>Optional[str]</code> <p>Group name for shared aggregation weighting</p> <code>needs_extra_timestep</code> <code>bool</code> <p>Whether this series needs an extra timestep</p> <p>Initialize a TimeSeries with a DataArray.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataArray</code> <p>The DataArray containing time series data</p> required <code>name</code> <code>str</code> <p>The name of the TimeSeries</p> required <code>aggregation_weight</code> <code>float | None</code> <p>The weight in aggregation calculations</p> <code>None</code> <code>aggregation_group</code> <code>str | None</code> <p>Group this TimeSeries belongs to for weight sharing</p> <code>None</code> <code>needs_extra_timestep</code> <code>bool</code> <p>Whether this series requires an extra timestep</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data doesn't have a 'time' index or has more than 1 dimension</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries-attributes","title":"Attributes","text":""},{"location":"api-reference/core/#flixopt.core.TimeSeries.stats","title":"stats  <code>property</code>","text":"<pre><code>stats: str\n</code></pre> <p>Return a statistical summary of the active data.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of data statistics</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.all_equal","title":"all_equal  <code>property</code>","text":"<pre><code>all_equal: bool\n</code></pre> <p>Check if all values in the series are equal.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.active_timesteps","title":"active_timesteps  <code>property</code> <code>writable</code>","text":"<pre><code>active_timesteps: DatetimeIndex\n</code></pre> <p>Get the current active timesteps.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.active_data","title":"active_data  <code>property</code>","text":"<pre><code>active_data: DataArray\n</code></pre> <p>Get a view of stored_data based on active_timesteps.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.stored_data","title":"stored_data  <code>property</code> <code>writable</code>","text":"<pre><code>stored_data: DataArray\n</code></pre> <p>Get a copy of the full stored data.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.TimeSeries.from_datasource","title":"from_datasource  <code>classmethod</code>","text":"<pre><code>from_datasource(data: NumericData, name: str, timesteps: DatetimeIndex, aggregation_weight: float | None = None, aggregation_group: str | None = None, needs_extra_timestep: bool = False) -&gt; TimeSeries\n</code></pre> <p>Initialize the TimeSeries from multiple data sources.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NumericData</code> <p>The time series data</p> required <code>name</code> <code>str</code> <p>The name of the TimeSeries</p> required <code>timesteps</code> <code>DatetimeIndex</code> <p>The timesteps of the TimeSeries</p> required <code>aggregation_weight</code> <code>float | None</code> <p>The weight in aggregation calculations</p> <code>None</code> <code>aggregation_group</code> <code>str | None</code> <p>Group this TimeSeries belongs to for aggregation weight sharing</p> <code>None</code> <code>needs_extra_timestep</code> <code>bool</code> <p>Whether this series requires an extra timestep</p> <code>False</code> <p>Returns:</p> Type Description <code>TimeSeries</code> <p>A new TimeSeries instance</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(data: dict[str, Any] | None = None, path: str | None = None) -&gt; TimeSeries\n</code></pre> <p>Load a TimeSeries from a dictionary or json file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any] | None</code> <p>Dictionary containing TimeSeries data</p> <code>None</code> <code>path</code> <code>str | None</code> <p>Path to a JSON file containing TimeSeries data</p> <code>None</code> <p>Returns:</p> Type Description <code>TimeSeries</code> <p>A new TimeSeries instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both path and data are provided or neither is provided</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset active timesteps to the full set of stored timesteps.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.restore_data","title":"restore_data","text":"<pre><code>restore_data()\n</code></pre> <p>Restore stored_data from the backup and reset active timesteps.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeries.to_json","title":"to_json","text":"<pre><code>to_json(path: Path | None = None) -&gt; dict[str, Any]\n</code></pre> <p>Save the TimeSeries to a dictionary or JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | None</code> <p>Optional path to save JSON file</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation of the TimeSeries</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection","title":"TimeSeriesCollection","text":"<pre><code>TimeSeriesCollection(timesteps: DatetimeIndex, hours_of_last_timestep: float | None = None, hours_of_previous_timesteps: float | ndarray | None = None)\n</code></pre> <p>Collection of TimeSeries objects with shared timestep management.</p> <p>TimeSeriesCollection handles multiple TimeSeries objects with synchronized timesteps, provides operations on collections, and manages extra timesteps.</p> <p>Parameters:</p> Name Type Description Default <code>timesteps</code> <code>DatetimeIndex</code> <p>The timesteps of the Collection.</p> required <code>hours_of_last_timestep</code> <code>float | None</code> <p>The duration of the last time step. Uses the last time interval if not specified</p> <code>None</code> <code>hours_of_previous_timesteps</code> <code>float | ndarray | None</code> <p>The duration of previous timesteps. If None, the first time increment of time_series is used. This is needed to calculate previous durations (for example consecutive_on_hours). If you use an array, take care that its long enough to cover all previous values!</p> <code>None</code>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection-attributes","title":"Attributes","text":""},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.non_constants","title":"non_constants  <code>property</code>","text":"<pre><code>non_constants: list[TimeSeries]\n</code></pre> <p>Get time series with varying values.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.constants","title":"constants  <code>property</code>","text":"<pre><code>constants: list[TimeSeries]\n</code></pre> <p>Get time series with constant values.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.timesteps","title":"timesteps  <code>property</code>","text":"<pre><code>timesteps: DatetimeIndex\n</code></pre> <p>Get the active timesteps.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.timesteps_extra","title":"timesteps_extra  <code>property</code>","text":"<pre><code>timesteps_extra: DatetimeIndex\n</code></pre> <p>Get the active timesteps with extra step.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.hours_per_timestep","title":"hours_per_timestep  <code>property</code>","text":"<pre><code>hours_per_timestep: DataArray\n</code></pre> <p>Get the duration of each active timestep.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.hours_of_last_timestep","title":"hours_of_last_timestep  <code>property</code>","text":"<pre><code>hours_of_last_timestep: float\n</code></pre> <p>Get the duration of the last timestep.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.with_uniform_timesteps","title":"with_uniform_timesteps  <code>classmethod</code>","text":"<pre><code>with_uniform_timesteps(start_time: Timestamp, periods: int, freq: str, hours_per_step: float | None = None) -&gt; TimeSeriesCollection\n</code></pre> <p>Create a collection with uniform timesteps.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.create_time_series","title":"create_time_series","text":"<pre><code>create_time_series(data: NumericData | TimeSeriesData, name: str, needs_extra_timestep: bool = False) -&gt; TimeSeries\n</code></pre> <p>Creates a TimeSeries from the given data and adds it to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NumericData | TimeSeriesData</code> <p>The data to create the TimeSeries from.</p> required <code>name</code> <code>str</code> <p>The name of the TimeSeries.</p> required <code>needs_extra_timestep</code> <code>bool</code> <p>Whether to create an additional timestep at the end of the timesteps.</p> <code>False</code> <p>Returns:</p> Type Description <code>TimeSeries</code> <p>The created TimeSeries.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.calculate_aggregation_weights","title":"calculate_aggregation_weights","text":"<pre><code>calculate_aggregation_weights() -&gt; dict[str, float]\n</code></pre> <p>Calculate and return aggregation weights for all time series.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.activate_timesteps","title":"activate_timesteps","text":"<pre><code>activate_timesteps(active_timesteps: DatetimeIndex | None = None)\n</code></pre> <p>Update active timesteps for the collection and all time series. If no arguments are provided, the active timesteps are reset.</p> <p>Parameters:</p> Name Type Description Default <code>active_timesteps</code> <code>DatetimeIndex | None</code> <p>The active timesteps of the model. If None, the all timesteps of the TimeSeriesCollection are taken.</p> <code>None</code>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset active timesteps to defaults for all time series.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.restore_data","title":"restore_data","text":"<pre><code>restore_data()\n</code></pre> <p>Restore original data for all time series.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.add_time_series","title":"add_time_series","text":"<pre><code>add_time_series(time_series: TimeSeries)\n</code></pre> <p>Add an existing TimeSeries to the collection.</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.insert_new_data","title":"insert_new_data","text":"<pre><code>insert_new_data(data: DataFrame, include_extra_timestep: bool = False)\n</code></pre> <p>Update time series with new data from a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame containing new data with timestamps as index</p> required <code>include_extra_timestep</code> <code>bool</code> <p>Whether the provided data already includes the extra timestep, by default False</p> <code>False</code>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.to_dataframe","title":"to_dataframe","text":"<pre><code>to_dataframe(filtered: Literal['all', 'constant', 'non_constant'] = 'non_constant', include_extra_timestep: bool = True) -&gt; pd.DataFrame\n</code></pre> <p>Convert collection to DataFrame with optional filtering and timestep control.</p> <p>Parameters:</p> Name Type Description Default <code>filtered</code> <code>Literal['all', 'constant', 'non_constant']</code> <p>Filter time series by variability, by default 'non_constant'</p> <code>'non_constant'</code> <code>include_extra_timestep</code> <code>bool</code> <p>Whether to include the extra timestep in the result, by default True</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame representation of the collection</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.to_dataset","title":"to_dataset","text":"<pre><code>to_dataset(include_constants: bool = True) -&gt; xr.Dataset\n</code></pre> <p>Combine all time series into a single Dataset with all timesteps.</p> <p>Parameters:</p> Name Type Description Default <code>include_constants</code> <code>bool</code> <p>Whether to include time series with constant values, by default True</p> <code>True</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>Dataset containing all selected time series with all timesteps</p>"},{"location":"api-reference/core/#flixopt.core.TimeSeriesCollection.calculate_hours_per_timestep","title":"calculate_hours_per_timestep  <code>staticmethod</code>","text":"<pre><code>calculate_hours_per_timestep(timesteps_extra: DatetimeIndex) -&gt; xr.DataArray\n</code></pre> <p>Calculate duration of each timestep.</p>"},{"location":"api-reference/core/#flixopt.core-functions","title":"Functions","text":""},{"location":"api-reference/core/#flixopt.core.get_numeric_stats","title":"get_numeric_stats","text":"<pre><code>get_numeric_stats(data: DataArray, decimals: int = 2, padd: int = 10) -&gt; str\n</code></pre> <p>Calculates the mean, median, min, max, and standard deviation of a numeric DataArray.</p>"},{"location":"api-reference/effects/","title":"effects","text":""},{"location":"api-reference/effects/#flixopt.effects","title":"flixopt.effects","text":"<p>This module contains the effects of the flixopt framework. Furthermore, it contains the EffectCollection, which is used to collect all effects of a system. Different Datatypes are used to represent the effects with assigned values by the user, which are then transformed into the internal data structure.</p>"},{"location":"api-reference/effects/#flixopt.effects-attributes","title":"Attributes","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectValuesUser","title":"EffectValuesUser  <code>module-attribute</code>","text":"<pre><code>EffectValuesUser = NumericDataTS | dict[str, NumericDataTS]\n</code></pre> <p>This datatype is used to define the share to an effect by a certain attribute.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectValuesUserScalar","title":"EffectValuesUserScalar  <code>module-attribute</code>","text":"<pre><code>EffectValuesUserScalar = Scalar | dict[str, Scalar]\n</code></pre> <p>This datatype is used to define the share to an effect by a certain attribute. Only scalars are allowed.</p>"},{"location":"api-reference/effects/#flixopt.effects-classes","title":"Classes","text":""},{"location":"api-reference/effects/#flixopt.effects.Effect","title":"Effect","text":"<pre><code>Effect(label: str, unit: str, description: str, meta_data: dict | None = None, is_standard: bool = False, is_objective: bool = False, specific_share_to_other_effects_operation: EffectValuesUser | None = None, specific_share_to_other_effects_invest: EffectValuesUser | None = None, minimum_operation: Scalar | None = None, maximum_operation: Scalar | None = None, minimum_invest: Scalar | None = None, maximum_invest: Scalar | None = None, minimum_operation_per_hour: NumericDataTS | None = None, maximum_operation_per_hour: NumericDataTS | None = None, minimum_total: Scalar | None = None, maximum_total: Scalar | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Represents system-wide impacts like costs, emissions, resource consumption, or other effects.</p> <p>Effects capture the broader impacts of system operation and investment decisions beyond the primary energy/material flows. Each Effect accumulates contributions from Components, Flows, and other system elements. One Effect is typically chosen as the optimization objective, while others can serve as constraints or tracking metrics.</p> <p>Effects support comprehensive modeling including operational and investment contributions, cross-effect relationships (e.g., carbon pricing), and flexible constraint formulation.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>unit</code> <code>str</code> <p>The unit of the effect (e.g., '\u20ac', 'kg_CO2', 'kWh_primary', 'm\u00b2'). This is informative only and does not affect optimization calculations.</p> required <code>description</code> <code>str</code> <p>Descriptive name explaining what this effect represents.</p> required <code>is_standard</code> <code>bool</code> <p>If True, this is a standard effect allowing direct value input without effect dictionaries. Used for simplified effect specification (and less boilerplate code).</p> <code>False</code> <code>is_objective</code> <code>bool</code> <p>If True, this effect serves as the optimization objective function. Only one effect can be marked as objective per optimization.</p> <code>False</code> <code>specific_share_to_other_effects_operation</code> <code>EffectValuesUser | None</code> <p>Operational cross-effect contributions. Maps this effect's operational values to contributions to other effects</p> <code>None</code> <code>specific_share_to_other_effects_invest</code> <code>EffectValuesUser | None</code> <p>Investment cross-effect contributions. Maps this effect's investment values to contributions to other effects.</p> <code>None</code> <code>minimum_operation</code> <code>Scalar | None</code> <p>Minimum allowed total operational contribution across all timesteps.</p> <code>None</code> <code>maximum_operation</code> <code>Scalar | None</code> <p>Maximum allowed total operational contribution across all timesteps.</p> <code>None</code> <code>minimum_operation_per_hour</code> <code>NumericDataTS | None</code> <p>Minimum allowed operational contribution per timestep.</p> <code>None</code> <code>maximum_operation_per_hour</code> <code>NumericDataTS | None</code> <p>Maximum allowed operational contribution per timestep.</p> <code>None</code> <code>minimum_invest</code> <code>Scalar | None</code> <p>Minimum allowed total investment contribution.</p> <code>None</code> <code>maximum_invest</code> <code>Scalar | None</code> <p>Maximum allowed total investment contribution.</p> <code>None</code> <code>minimum_total</code> <code>Scalar | None</code> <p>Minimum allowed total effect (operation + investment combined).</p> <code>None</code> <code>maximum_total</code> <code>Scalar | None</code> <p>Maximum allowed total effect (operation + investment combined).</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Basic cost objective:</p> <pre><code>cost_effect = Effect(label='system_costs', unit='\u20ac', description='Total system costs', is_objective=True)\n</code></pre> <p>CO2 emissions with carbon pricing:</p> <pre><code>co2_effect = Effect(\n    label='co2_emissions',\n    unit='kg_CO2',\n    description='Carbon dioxide emissions',\n    specific_share_to_other_effects_operation={'costs': 50},  # \u20ac50/t_CO2\n    maximum_total=1_000_000,  # 1000 t CO2 annual limit\n)\n</code></pre> <p>Land use constraint:</p> <pre><code>land_use = Effect(\n    label='land_usage',\n    unit='m\u00b2',\n    description='Land area requirement',\n    maximum_total=50_000,  # Maximum 5 hectares available\n)\n</code></pre> <p>Primary energy tracking:</p> <pre><code>primary_energy = Effect(\n    label='primary_energy',\n    unit='kWh_primary',\n    description='Primary energy consumption',\n    specific_share_to_other_effects_operation={'costs': 0.08},  # \u20ac0.08/kWh\n)\n</code></pre> <p>Water consumption with tiered constraints:</p> <pre><code>water_usage = Effect(\n    label='water_consumption',\n    unit='m\u00b3',\n    description='Industrial water usage',\n    minimum_operation_per_hour=10,  # Minimum 10 m\u00b3/h for process stability\n    maximum_operation_per_hour=500,  # Maximum 500 m\u00b3/h capacity limit\n    maximum_total=100_000,  # Annual permit limit: 100,000 m\u00b3\n)\n</code></pre> Note <p>Effect bounds can be None to indicate no constraint in that direction.</p> <p>Cross-effect relationships enable sophisticated modeling like carbon pricing, resource valuation, or multi-criteria optimization with weighted objectives.</p> <p>The unit field is purely informational - ensure dimensional consistency across all contributions to each effect manually.</p> <p>Effects are accumulated as: - Total = \u03a3(operational contributions) + \u03a3(investment contributions) - Cross-effects add to target effects based on specific_share ratios</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.Effect.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/effects/#flixopt.effects.Effect.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/effects/#flixopt.effects.Effect.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/effects/#flixopt.effects.EffectCollection","title":"EffectCollection","text":"<pre><code>EffectCollection(*effects: Effect)\n</code></pre> <p>Handling all Effects</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollection-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectCollection.create_effect_values_dict","title":"create_effect_values_dict","text":"<pre><code>create_effect_values_dict(effect_values_user: EffectValuesUser) -&gt; EffectValuesDict | None\n</code></pre> <p>Converts effect values into a dictionary. If a scalar is provided, it is associated with a default effect type.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollection.create_effect_values_dict--examples","title":"Examples","text":"<p>effect_values_user = 20                             -&gt; {None: 20} effect_values_user = None                           -&gt; None effect_values_user = {effect1: 20, effect2: 0.3}    -&gt; {effect1: 20, effect2: 0.3}</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollection.create_effect_values_dict--returns","title":"Returns","text":"<p>dict or None     A dictionary with None or Effect as the key, or None if input is None.</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel","title":"EffectCollectionModel","text":"<pre><code>EffectCollectionModel(model: SystemModel, effects: EffectCollection)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Handling all Effects</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel-attributes","title":"Attributes","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel-functions","title":"Functions","text":""},{"location":"api-reference/effects/#flixopt.effects.EffectCollectionModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/effects/#flixopt.effects-functions","title":"Functions","text":""},{"location":"api-reference/elements/","title":"elements","text":""},{"location":"api-reference/elements/#flixopt.elements","title":"flixopt.elements","text":"<p>This module contains the basic elements of the flixopt framework.</p>"},{"location":"api-reference/elements/#flixopt.elements-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements-classes","title":"Classes","text":""},{"location":"api-reference/elements/#flixopt.elements.Component","title":"Component","text":"<pre><code>Component(label: str, inputs: list[Flow] | None = None, outputs: list[Flow] | None = None, on_off_parameters: OnOffParameters | None = None, prevent_simultaneous_flows: list[Flow] | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Base class for all system components that transform, convert, or process flows.</p> <p>Components are the active elements in energy systems that define how input and output Flows interact with each other. They represent equipment, processes, or logical operations that transform energy or materials between different states, carriers, or locations.</p> <p>Components serve as connection points between Buses through their associated Flows, enabling the modeling of complex energy system topologies and operational constraints.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>inputs</code> <code>list[Flow] | None</code> <p>list of input Flows feeding into the component. These represent energy/material consumption by the component.</p> <code>None</code> <code>outputs</code> <code>list[Flow] | None</code> <p>list of output Flows leaving the component. These represent energy/material production by the component.</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Defines binary operation constraints and costs when the component has discrete on/off states. Creates binary variables for all connected Flows. For better performance, prefer defining OnOffParameters on individual Flows when possible.</p> <code>None</code> <code>prevent_simultaneous_flows</code> <code>list[Flow] | None</code> <p>list of Flows that cannot be active simultaneously. Creates binary variables to enforce mutual exclusivity. Use sparingly as it increases computational complexity.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> Note <p>Component operational state is determined by its connected Flows: - Component is \"on\" if ANY of its Flows is active (flow_rate &gt; 0) - Component is \"off\" only when ALL Flows are inactive (flow_rate = 0)</p> <p>Binary variables and constraints: - on_off_parameters creates binary variables for ALL connected Flows - prevent_simultaneous_flows creates binary variables for specified Flows - For better computational performance, prefer Flow-level OnOffParameters</p> <p>Component is an abstract base class. In practice, use specialized subclasses: - LinearConverter: Linear input/output relationships - Storage: Temporal energy/material storage - Transmission: Transport between locations - Source/Sink: System boundaries</p>"},{"location":"api-reference/elements/#flixopt.elements.Component-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Component.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/elements/#flixopt.elements.Component.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/elements/#flixopt.elements.Component.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/elements/#flixopt.elements.Bus","title":"Bus","text":"<pre><code>Bus(label: str, excess_penalty_per_flow_hour: NumericData | NumericDataTS | None = 100000.0, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Buses represent nodal balances between flow rates, serving as connection points.</p> <p>A Bus enforces energy or material balance constraints where the sum of all incoming flows must equal the sum of all outgoing flows at each time step. Buses represent physical or logical connection points for energy carriers (electricity, heat, gas) or material flows between different Components.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>excess_penalty_per_flow_hour</code> <code>NumericData | NumericDataTS | None</code> <p>Penalty costs for bus balance violations. When None, no excess/deficit is allowed (hard constraint). When set to a value &gt; 0, allows bus imbalances at penalty cost. Default is 1e5 (high penalty).</p> <code>100000.0</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Electrical bus with strict balance:</p> <pre><code>electricity_bus = Bus(\n    label='main_electrical_bus',\n    excess_penalty_per_flow_hour=None,  # No imbalance allowed\n)\n</code></pre> <p>Heat network with penalty for imbalances:</p> <pre><code>heat_network = Bus(\n    label='district_heating_network',\n    excess_penalty_per_flow_hour=1000,  # \u20ac1000/MWh penalty for imbalance\n)\n</code></pre> <p>Material flow with time-varying penalties:</p> <pre><code>material_hub = Bus(\n    label='material_processing_hub',\n    excess_penalty_per_flow_hour=waste_disposal_costs,  # Time series\n)\n</code></pre> Note <p>The bus balance equation enforced is: \u03a3(inflows) = \u03a3(outflows) + excess - deficit</p> <p>When excess_penalty_per_flow_hour is None, excess and deficit are forced to zero. When a penalty cost is specified, the optimization can choose to violate the balance if economically beneficial, paying the penalty. The penalty is added to the objective directly.</p> <p>Empty <code>inputs</code> and <code>outputs</code> lists are initialized and populated automatically by the FlowSystem during system setup.</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Bus.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/elements/#flixopt.elements.Bus.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/elements/#flixopt.elements.Bus.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/elements/#flixopt.elements.Connection","title":"Connection","text":"<pre><code>Connection()\n</code></pre> <p>This class is not yet implemented!</p>"},{"location":"api-reference/elements/#flixopt.elements.Connection-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Flow","title":"Flow","text":"<pre><code>Flow(label: str, bus: str, size: Scalar | InvestParameters | None = None, fixed_relative_profile: NumericDataTS | None = None, relative_minimum: NumericDataTS = 0, relative_maximum: NumericDataTS = 1, effects_per_flow_hour: EffectValuesUser | None = None, on_off_parameters: OnOffParameters | None = None, flow_hours_total_max: Scalar | None = None, flow_hours_total_min: Scalar | None = None, load_factor_min: Scalar | None = None, load_factor_max: Scalar | None = None, previous_flow_rate: NumericData | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Element</code></p> <p>Define a directed flow of energy or material between bus and component.</p> <p>A Flow represents the transfer of energy (electricity, heat, fuel) or material between a Bus and a Component in a specific direction. The flow rate is the primary optimization variable, with constraints and costs defined through various parameters. Flows can have fixed or variable sizes, operational constraints, and complex on/off behavior.</p> Key Concepts <p>Flow Rate: The instantaneous rate of energy/material transfer (optimization variable) [kW, m\u00b3/h, kg/h] Flow Hours: Amount of energy/material transferred per timestep. [kWh, m\u00b3, kg] Flow Size: The maximum capacity or nominal rating of the flow [kW, m\u00b3/h, kg/h] Relative Bounds: Flow rate limits expressed as fractions of flow size</p> Integration with Parameter Classes <ul> <li>InvestParameters: Used for <code>size</code> when flow Size is an investment decision</li> <li>OnOffParameters: Used for <code>on_off_parameters</code> when flow has discrete states</li> </ul> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Unique identifier for the flow within its component. The full label combines component and flow labels.</p> required <code>bus</code> <code>str</code> <p>Label of the bus this flow connects to. Must match a bus in the FlowSystem.</p> required <code>size</code> <code>Scalar | InvestParameters | None</code> <p>Flow capacity or nominal rating. Can be: - Scalar value for fixed capacity - InvestParameters for investment-based sizing decisions - None to use large default value (CONFIG.Modeling.big)</p> <code>None</code> <code>relative_minimum</code> <code>NumericDataTS</code> <p>Minimum flow rate as fraction of size. Example: 0.2 means flow cannot go below 20% of rated capacity.</p> <code>0</code> <code>relative_maximum</code> <code>NumericDataTS</code> <p>Maximum flow rate as fraction of size (typically 1.0). Values &gt;1.0 allow temporary overload operation.</p> <code>1</code> <code>load_factor_min</code> <code>Scalar | None</code> <p>Minimum average utilization over the time horizon (0-1). Calculated as total flow hours divided by (size \u00d7 total time).</p> <code>None</code> <code>load_factor_max</code> <code>Scalar | None</code> <p>Maximum average utilization over the time horizon (0-1). Useful for equipment duty cycle limits or maintenance scheduling.</p> <code>None</code> <code>effects_per_flow_hour</code> <code>EffectValuesUser | None</code> <p>Operational costs and impacts per unit of flow-time. Dictionary mapping effect names to unit costs (e.g., fuel costs, emissions).</p> <code>None</code> <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Binary operation constraints using OnOffParameters. Enables modeling of startup costs, minimum run times, cycling limits. Only relevant when relative_minimum &gt; 0 or discrete operation is required.</p> <code>None</code> <code>flow_hours_total_max</code> <code>Scalar | None</code> <p>Maximum cumulative flow-hours over time horizon. Alternative to load_factor_max for absolute energy/material limits.</p> <code>None</code> <code>flow_hours_total_min</code> <code>Scalar | None</code> <p>Minimum cumulative flow-hours over time horizon. Alternative to load_factor_min for contractual or operational requirements.</p> <code>None</code> <code>fixed_relative_profile</code> <code>NumericDataTS | None</code> <p>Predetermined flow pattern as fraction of size. When specified, flow rate becomes: size \u00d7 fixed_relative_profile(t). Used for: demand profiles, renewable generation, fixed schedules.</p> <code>None</code> <code>previous_flow_rate</code> <code>NumericData | None</code> <p>Initial flow state for startup/shutdown dynamics. Used with on_off_parameters to determine initial on/off status. If None, assumes flow was off in previous time period.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Additional information stored with results but not used in optimization. Must contain only Python native types (dict, list, str, int, float, bool).</p> <code>None</code> <p>Examples:</p> <p>Basic power flow with fixed capacity:</p> <pre><code>generator_output = Flow(\n    label='electricity_out',\n    bus='electricity_grid',\n    size=100,  # 100 MW capacity\n    relative_minimum=0.4,  # Cannot operate below 40 MW\n    effects_per_flow_hour={'fuel_cost': 45, 'co2_emissions': 0.8},\n)\n</code></pre> <p>Investment decision for battery capacity:</p> <pre><code>battery_flow = Flow(\n    label='electricity_storage',\n    bus='electricity_grid',\n    size=InvestParameters(\n        minimum_size=10,  # Minimum 10 MWh\n        maximum_size=100,  # Maximum 100 MWh\n        specific_effects={'cost': 150_000},  # \u20ac150k/MWh annualized\n    ),\n)\n</code></pre> <p>Heat pump with startup costs and minimum run times:</p> <pre><code>heat_pump = Flow(\n    label='heat_output',\n    bus='heating_network',\n    size=50,  # 50 kW thermal\n    relative_minimum=0.3,  # Minimum 15 kW output when on\n    effects_per_flow_hour={'electricity_cost': 25, 'maintenance': 2},\n    on_off_parameters=OnOffParameters(\n        effects_per_switch_on={'startup_cost': 100, 'wear': 0.1},\n        consecutive_on_hours_min=2,  # Must run at least 2 hours\n        consecutive_off_hours_min=1,  # Must stay off at least 1 hour\n        switch_on_total_max=200,  # Maximum 200 starts per year\n    ),\n)\n</code></pre> <p>Fixed renewable generation profile:</p> <pre><code>solar_generation = Flow(\n    label='solar_power',\n    bus='electricity_grid',\n    size=25,  # 25 MW installed capacity\n    fixed_relative_profile=np.array([0, 0.1, 0.4, 0.8, 0.9, 0.7, 0.3, 0.1, 0]),\n    effects_per_flow_hour={'maintenance_costs': 5},  # \u20ac5/MWh maintenance\n)\n</code></pre> <p>Industrial process with annual utilization limits:</p> <pre><code>production_line = Flow(\n    label='product_output',\n    bus='product_market',\n    size=1000,  # 1000 units/hour capacity\n    load_factor_min=0.6,  # Must achieve 60% annual utilization\n    load_factor_max=0.85,  # Cannot exceed 85% for maintenance\n    effects_per_flow_hour={'variable_cost': 12, 'quality_control': 0.5},\n)\n</code></pre> Design Considerations <p>Size vs Load Factors: Use <code>flow_hours_total_min/max</code> for absolute limits, <code>load_factor_min/max</code> for utilization-based constraints.</p> <p>Relative Bounds: Set <code>relative_minimum &gt; 0</code> only when equipment cannot operate below that level. Use <code>on_off_parameters</code> for discrete on/off behavior.</p> <p>Fixed Profiles: Use <code>fixed_relative_profile</code> for known exact patterns, <code>relative_maximum</code> for upper bounds on optimization variables.</p> Notes <ul> <li>Default size (CONFIG.Modeling.big) is used when size=None</li> <li>list inputs for previous_flow_rate are converted to NumPy arrays</li> <li>Flow direction is determined by component input/output designation</li> </ul> Deprecated <p>Passing Bus objects to <code>bus</code> parameter. Use bus label strings instead.</p>"},{"location":"api-reference/elements/#flixopt.elements.Flow-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.Flow.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/elements/#flixopt.elements.Flow.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/elements/#flixopt.elements.FlowModel","title":"FlowModel","text":"<pre><code>FlowModel(model: SystemModel, element: Flow)\n</code></pre> <p>               Bases: <code>ElementModel</code></p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements.FlowModel.flow_rate_bounds_on","title":"flow_rate_bounds_on  <code>property</code>","text":"<pre><code>flow_rate_bounds_on: tuple[NumericData, NumericData]\n</code></pre> <p>Returns absolute flow rate bounds. Important for OnOffModel</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.flow_rate_lower_bound_relative","title":"flow_rate_lower_bound_relative  <code>property</code>","text":"<pre><code>flow_rate_lower_bound_relative: NumericData\n</code></pre> <p>Returns the lower bound of the flow_rate relative to its size</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.flow_rate_upper_bound_relative","title":"flow_rate_upper_bound_relative  <code>property</code>","text":"<pre><code>flow_rate_upper_bound_relative: NumericData\n</code></pre> <p>Returns the upper bound of the flow_rate relative to its size</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.flow_rate_lower_bound","title":"flow_rate_lower_bound  <code>property</code>","text":"<pre><code>flow_rate_lower_bound: NumericData\n</code></pre> <p>Returns the minimum bound the flow_rate can reach. Further constraining might be done in OnOffModel and InvestmentModel</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.flow_rate_upper_bound","title":"flow_rate_upper_bound  <code>property</code>","text":"<pre><code>flow_rate_upper_bound: NumericData\n</code></pre> <p>Returns the maximum bound the flow_rate can reach. Further constraining might be done in OnOffModel and InvestmentModel</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/elements/#flixopt.elements.FlowModel-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.FlowModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel","title":"ComponentModel","text":"<pre><code>ComponentModel(model: SystemModel, element: Component)\n</code></pre> <p>               Bases: <code>ElementModel</code></p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel-attributes","title":"Attributes","text":""},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel-functions","title":"Functions","text":""},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.do_modeling","title":"do_modeling","text":"<pre><code>do_modeling()\n</code></pre> <p>Initiates all FlowModels</p>"},{"location":"api-reference/elements/#flixopt.elements.ComponentModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/elements/#flixopt.elements-functions","title":"Functions","text":""},{"location":"api-reference/features/","title":"features","text":""},{"location":"api-reference/features/#flixopt.features","title":"flixopt.features","text":"<p>This module contains the features of the flixopt framework. Features extend the functionality of Elements.</p>"},{"location":"api-reference/features/#flixopt.features-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features-classes","title":"Classes","text":""},{"location":"api-reference/features/#flixopt.features.InvestmentModel","title":"InvestmentModel","text":"<pre><code>InvestmentModel(model: SystemModel, label_of_element: str, parameters: InvestParameters, defining_variable: Variable, relative_bounds_of_defining_variable: tuple[NumericData, NumericData], label: str | None = None, on_variable: Variable | None = None)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Class for modeling an investment</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.InvestmentModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.InvestmentModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.InvestmentModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.StateModel","title":"StateModel","text":"<pre><code>StateModel(model: SystemModel, label_of_element: str, defining_variables: list[Variable], defining_bounds: list[tuple[NumericData, NumericData]], previous_values: list[NumericData | None] | None = None, use_off: bool = True, on_hours_total_min: NumericData | None = 0, on_hours_total_max: NumericData | None = None, effects_per_running_hour: dict[str, NumericData] | None = None, label: str | None = None)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Handles basic on/off binary states for defining variables</p> <p>Models binary state variables based on a continous variable.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>SystemModel</code> <p>The SystemModel that is used to create the model.</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>defining_variables</code> <code>list[Variable]</code> <p>List of Variables that are used to define the state</p> required <code>defining_bounds</code> <code>list[tuple[NumericData, NumericData]]</code> <p>List of Tuples, defining the absolute bounds of each defining variable</p> required <code>previous_values</code> <code>list[NumericData | None] | None</code> <p>List of previous values of the defining variables</p> <code>None</code> <code>use_off</code> <code>bool</code> <p>Whether to use the off state or not</p> <code>True</code> <code>on_hours_total_min</code> <code>NumericData | None</code> <p>min. overall sum of operating hours.</p> <code>0</code> <code>on_hours_total_max</code> <code>NumericData | None</code> <p>max. overall sum of operating hours.</p> <code>None</code> <code>effects_per_running_hour</code> <code>dict[str, NumericData] | None</code> <p>Costs per operating hours</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Label of the OnOffModel</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.StateModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.StateModel.previous_states","title":"previous_states  <code>property</code>","text":"<pre><code>previous_states: ndarray\n</code></pre> <p>Computes the previous states {0, 1} of defining variables as a binary array from their previous values.</p>"},{"location":"api-reference/features/#flixopt.features.StateModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.StateModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.StateModel.compute_previous_states","title":"compute_previous_states  <code>staticmethod</code>","text":"<pre><code>compute_previous_states(previous_values: list[NumericData | None] | None, epsilon: float = 1e-05) -&gt; np.ndarray\n</code></pre> <p>Computes the previous states {0, 1} of defining variables as a binary array from their previous values.</p>"},{"location":"api-reference/features/#flixopt.features.StateModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.SwitchStateModel","title":"SwitchStateModel","text":"<pre><code>SwitchStateModel(model: SystemModel, label_of_element: str, state_variable: Variable, previous_state=0, switch_on_max: Scalar | None = None, label: str | None = None)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Handles switch on/off transitions</p>"},{"location":"api-reference/features/#flixopt.features.SwitchStateModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.SwitchStateModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.SwitchStateModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.SwitchStateModel.do_modeling","title":"do_modeling","text":"<pre><code>do_modeling()\n</code></pre> <p>Create switch variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.SwitchStateModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel","title":"ConsecutiveStateModel","text":"<pre><code>ConsecutiveStateModel(model: SystemModel, label_of_element: str, state_variable: Variable, minimum_duration: NumericData | None = None, maximum_duration: NumericData | None = None, previous_states: NumericData | None = None, label: str | None = None)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Handles tracking consecutive durations in a state</p> <p>Model and constraint the consecutive duration of a state variable.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>SystemModel</code> <p>The SystemModel that is used to create the model.</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>state_variable</code> <code>Variable</code> <p>The state variable that is used to model the duration. state = {0, 1}</p> required <code>minimum_duration</code> <code>NumericData | None</code> <p>The minimum duration of the state variable.</p> <code>None</code> <code>maximum_duration</code> <code>NumericData | None</code> <p>The maximum duration of the state variable.</p> <code>None</code> <code>previous_states</code> <code>NumericData | None</code> <p>The previous states of the state variable.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>The label of the model. Used to construct the full label of the model.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel.previous_duration","title":"previous_duration  <code>property</code>","text":"<pre><code>previous_duration: Scalar\n</code></pre> <p>Computes the previous duration of the state variable</p>"},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel.do_modeling","title":"do_modeling","text":"<pre><code>do_modeling()\n</code></pre> <p>Create consecutive duration variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel.compute_consecutive_hours_in_state","title":"compute_consecutive_hours_in_state  <code>staticmethod</code>","text":"<pre><code>compute_consecutive_hours_in_state(binary_values: NumericData, hours_per_timestep: int | float | ndarray) -&gt; Scalar\n</code></pre> <p>Computes the final consecutive duration in state 'on' (=1) in hours, from a binary array.</p> <p>Parameters:</p> Name Type Description Default <code>binary_values</code> <code>NumericData</code> <p>An int or 1D binary array containing only <code>0</code>s and <code>1</code>s.</p> required <code>hours_per_timestep</code> <code>int | float | ndarray</code> <p>The duration of each timestep in hours. If a scalar is provided, it is used for all timesteps. If an array is provided, it must be as long as the last consecutive duration in binary_values.</p> required <p>Returns:</p> Type Description <code>Scalar</code> <p>The duration of the binary variable in hours.</p>"},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel.compute_consecutive_hours_in_state--raises","title":"Raises","text":"<p>TypeError     If the length of binary_values and dt_in_hours is not equal, but None is a scalar.</p>"},{"location":"api-reference/features/#flixopt.features.ConsecutiveStateModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.OnOffModel","title":"OnOffModel","text":"<pre><code>OnOffModel(model: SystemModel, on_off_parameters: OnOffParameters, label_of_element: str, defining_variables: list[Variable], defining_bounds: list[tuple[NumericData, NumericData]], previous_values: list[NumericData | None], label: str | None = None)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Class for modeling the on and off state of a variable Uses component models to create a modular implementation</p> <p>Constructor for OnOffModel</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>SystemModel</code> <p>Reference to the SystemModel</p> required <code>on_off_parameters</code> <code>OnOffParameters</code> <p>Parameters for the OnOffModel</p> required <code>label_of_element</code> <code>str</code> <p>Label of the Parent</p> required <code>defining_variables</code> <code>list[Variable]</code> <p>List of Variables that are used to define the OnOffModel</p> required <code>defining_bounds</code> <code>list[tuple[NumericData, NumericData]]</code> <p>List of Tuples, defining the absolute bounds of each defining variable</p> required <code>previous_values</code> <code>list[NumericData | None]</code> <p>List of previous values of the defining variables</p> required <code>label</code> <code>str | None</code> <p>Label of the OnOffModel</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.OnOffModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.OnOffModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.OnOffModel.do_modeling","title":"do_modeling","text":"<pre><code>do_modeling()\n</code></pre> <p>Create all variables and constraints for the OnOffModel</p>"},{"location":"api-reference/features/#flixopt.features.OnOffModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.PieceModel","title":"PieceModel","text":"<pre><code>PieceModel(model: SystemModel, label_of_element: str, label: str, as_time_series: bool = True)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Class for modeling a linear piece of one or more variables in parallel</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.PieceModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.PieceModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.PieceModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel","title":"PiecewiseModel","text":"<pre><code>PiecewiseModel(model: SystemModel, label_of_element: str, piecewise_variables: dict[str, Piecewise], zero_point: bool | Variable | None, as_time_series: bool, label: str = '')\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Modeling a Piecewise relation between miultiple variables. The relation is defined by a list of Pieces, which are assigned to the variables. Each Piece is a tuple of (start, end).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>SystemModel</code> <p>The SystemModel that is used to create the model.</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>label</code> <code>str</code> <p>The label of the model. Used to construct the full label of the model.</p> <code>''</code> <code>piecewise_variables</code> <code>dict[str, Piecewise]</code> <p>The variables to which the Pieces are assigned.</p> required <code>zero_point</code> <code>bool | Variable | None</code> <p>A variable that can be used to define a zero point for the Piecewise relation. If None or False, no zero point is defined.</p> required <code>as_time_series</code> <code>bool</code> <p>Whether the Piecewise relation is defined for a TimeSeries or a single variable.</p> required"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.PiecewiseModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.PiecewiseModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel","title":"ShareAllocationModel","text":"<pre><code>ShareAllocationModel(model: SystemModel, shares_are_time_series: bool, label_of_element: str | None = None, label: str | None = None, label_full: str | None = None, total_max: Scalar | None = None, total_min: Scalar | None = None, max_per_hour: NumericData | None = None, min_per_hour: NumericData | None = None)\n</code></pre> <p>               Bases: <code>Model</code></p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.add_share","title":"add_share","text":"<pre><code>add_share(name: str, expression: LinearExpression)\n</code></pre> <p>Add a share to the share allocation model. If the share already exists, the expression is added to the existing share. The expression is added to the right hand side (rhs) of the constraint. The variable representing the total share is on the left hand side (lhs) of the constraint. var_total = sum(expressions)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the share.</p> required <code>expression</code> <code>LinearExpression</code> <p>The expression of the share. Added to the right hand side of the constraint.</p> required"},{"location":"api-reference/features/#flixopt.features.ShareAllocationModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel","title":"PreventSimultaneousUsageModel","text":"<pre><code>PreventSimultaneousUsageModel(model: SystemModel, variables: list[Variable], label_of_element: str, label: str = 'PreventSimultaneousUsage')\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Prevents multiple Multiple Binary variables from being 1 at the same time</p> <p>Only 'classic type is modeled for now (# \"classic\" -&gt; alle Flows brauchen Bin\u00e4rvariable:) In 'new', the binary Variables need to be forced beforehand, which is not that straight forward... --&gt; TODO maybe</p>"},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel--new","title":"\"new\":","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel--eq-flow_1ont-flow_2ont-flow_ivaltflow_imax-1-1-flow-ohne-binarvariable","title":"eq: flow_1.on(t) + flow_2.on(t) + .. + flow_i.val(t)/flow_i.max &lt;= 1 (1 Flow ohne Bin\u00e4rvariable!)","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel--anmerkung-patrick-schonfeld-oemof-customlinkpy-macht-bei-2-flows-ohne-binarvariable-dies","title":"Anmerkung: Patrick Sch\u00f6nfeld (oemof, custom/link.py) macht bei 2 Flows ohne Bin\u00e4rvariable dies:","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel--1-bin-flow1flow1_max-1","title":"1)        bin + flow1/flow1_max &lt;= 1","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel--2-bin-flow2flow2_max-0","title":"2)        bin - flow2/flow2_max &gt;= 0","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel--3-geht-nur-wenn-alle-flowmin-0","title":"3)    geht nur, wenn alle flow.min &gt;= 0","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel---konnte-man-auch-umsetzen-statt-force_on_variable-fur-die-flows-aber-sollte-aufs-selbe-wie-new-kommen","title":"--&gt; k\u00f6nnte man auch umsetzen (statt force_on_variable() f\u00fcr die Flows, aber sollte aufs selbe wie \"new\" kommen)","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel-attributes","title":"Attributes","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel-functions","title":"Functions","text":""},{"location":"api-reference/features/#flixopt.features.PreventSimultaneousUsageModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/flow_system/","title":"flow_system","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system","title":"flixopt.flow_system","text":"<p>This module contains the FlowSystem class, which is used to collect instances of many other classes by the end User.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system-attributes","title":"Attributes","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system-classes","title":"Classes","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem","title":"FlowSystem","text":"<pre><code>FlowSystem(timesteps: DatetimeIndex, hours_of_last_timestep: float | None = None, hours_of_previous_timesteps: int | float | ndarray | None = None)\n</code></pre> <p>A FlowSystem organizes the high level Elements (Components, Buses &amp; Effects).</p> <p>This is the main container class that users work with to build and manage their System.</p> <p>Parameters:</p> Name Type Description Default <code>timesteps</code> <code>DatetimeIndex</code> <p>The timesteps of the model.</p> required <code>hours_of_last_timestep</code> <code>float | None</code> <p>The duration of the last time step. Uses the last time interval if not specified</p> <code>None</code> <code>hours_of_previous_timesteps</code> <code>int | float | ndarray | None</code> <p>The duration of previous timesteps. If None, the first time increment of time_series is used. This is needed to calculate previous durations (for example consecutive_on_hours). If you use an array, take care that its long enough to cover all previous values!</p> <code>None</code> Notes <ul> <li>Creates an empty registry for components and buses, an empty EffectCollection, and a placeholder for a SystemModel.</li> <li>The instance starts disconnected (self._connected == False) and will be connected automatically when trying to solve a calculation.</li> </ul> <p>Initialize a FlowSystem that manages components, buses, effects, and their time-series.</p> <p>Parameters:</p> Name Type Description Default <code>timesteps</code> <code>DatetimeIndex</code> <p>DatetimeIndex defining the primary timesteps for the system's TimeSeriesCollection.</p> required <code>hours_of_last_timestep</code> <code>float | None</code> <p>Duration (in hours) of the final timestep; if None, inferred from timesteps or defaults in TimeSeriesCollection.</p> <code>None</code> <code>hours_of_previous_timesteps</code> <code>int | float | ndarray | None</code> <p>Scalar or array-like durations (in hours) for the preceding timesteps; used to configure non-uniform timestep lengths.</p> <code>None</code> Notes <p>Creates an empty registry for components and buses, an empty EffectCollection, and a placeholder for a SystemModel. The instance starts disconnected (self._connected == False) and with no active network visualization app. This can also be triggered manually with <code>_connect_network()</code>.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem-functions","title":"Functions","text":""},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; FlowSystem\n</code></pre> <p>Load a FlowSystem from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the FlowSystem data.</p> required"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.from_netcdf","title":"from_netcdf  <code>classmethod</code>","text":"<pre><code>from_netcdf(path: str | Path)\n</code></pre> <p>Load a FlowSystem from a netcdf file</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.add_elements","title":"add_elements","text":"<pre><code>add_elements(*elements: Element) -&gt; None\n</code></pre> <p>Add Components(Storages, Boilers, Heatpumps, ...), Buses or Effects to the FlowSystem</p> <p>Parameters:</p> Name Type Description Default <code>*elements</code> <code>Element</code> <p>childs of  Element like Boiler, HeatPump, Bus,... modeling Elements</p> <code>()</code>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the flow system to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the flow_system to others.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.as_dict","title":"as_dict","text":"<pre><code>as_dict(data_mode: Literal['data', 'name', 'stats'] = 'data') -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.as_dataset","title":"as_dataset","text":"<pre><code>as_dataset(constants_in_dataset: bool = False) -&gt; xr.Dataset\n</code></pre> <p>Convert the FlowSystem to a xarray Dataset.</p> <p>Parameters:</p> Name Type Description Default <code>constants_in_dataset</code> <code>bool</code> <p>If True, constants are included as Dataset variables.</p> <code>False</code>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.to_netcdf","title":"to_netcdf","text":"<pre><code>to_netcdf(path: str | Path, compression: int = 0, constants_in_dataset: bool = True) -&gt; None\n</code></pre> <p>Saves the FlowSystem to a netCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the netCDF file.</p> required <code>compression</code> <code>int</code> <p>The compression level to use when saving the file.</p> <code>0</code> <code>constants_in_dataset</code> <code>bool</code> <p>If True, constants are included as Dataset variables.</p> <code>True</code>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.plot_network","title":"plot_network","text":"<pre><code>plot_network(path: bool | str | Path = 'flow_system.html', controls: bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']] = True, show: bool = False) -&gt; pyvis.network.Network | None\n</code></pre> <p>Visualizes the network structure of a FlowSystem using PyVis, saving it as an interactive HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>bool | str | Path</code> <p>Path to save the HTML visualization. - <code>False</code>: Visualization is created but not saved. - <code>str</code> or <code>Path</code>: Specifies file path (default: 'flow_system.html').</p> <code>'flow_system.html'</code> <code>controls</code> <code>bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]</code> <p>UI controls to add to the visualization. - <code>True</code>: Enables all available controls. - <code>List</code>: Specify controls, e.g., ['nodes', 'layout']. - Options: 'nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer'.</p> <code>True</code> <code>show</code> <code>bool</code> <p>Whether to open the visualization in the web browser.</p> <code>False</code> <p>Returns: - 'pyvis.network.Network' | None: The <code>Network</code> instance representing the visualization, or <code>None</code> if <code>pyvis</code> is not installed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; flow_system.plot_network()\n&gt;&gt;&gt; flow_system.plot_network(show=False)\n&gt;&gt;&gt; flow_system.plot_network(path='output/custom_network.html', controls=['nodes', 'layout'])\n</code></pre> <p>Notes: - This function requires <code>pyvis</code>. If not installed, the function prints a warning and returns <code>None</code>. - Nodes are styled based on type (e.g., circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.start_network_app","title":"start_network_app","text":"<pre><code>start_network_app()\n</code></pre> <p>Visualizes the network structure of a FlowSystem using Dash, Cytoscape, and networkx. Requires optional dependencies: dash, dash-cytoscape, dash-daq, networkx, flask, werkzeug.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.stop_network_app","title":"stop_network_app","text":"<pre><code>stop_network_app()\n</code></pre> <p>Stop the network visualization server.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.create_time_series","title":"create_time_series","text":"<pre><code>create_time_series(name: str, data: NumericData | TimeSeriesData | TimeSeries | None, needs_extra_timestep: bool = False) -&gt; TimeSeries | None\n</code></pre> <p>Tries to create a TimeSeries from NumericData Data and adds it to the time_series_collection If the data already is a TimeSeries, nothing happens and the TimeSeries gets reset and returned If the data is a TimeSeriesData, it is converted to a TimeSeries, and the aggregation weights are applied. If the data is None, nothing happens.</p>"},{"location":"api-reference/flow_system/#flixopt.flow_system.FlowSystem.create_effect_time_series","title":"create_effect_time_series","text":"<pre><code>create_effect_time_series(label_prefix: str | None, effect_values: EffectValuesUser, label_suffix: str | None = None) -&gt; EffectTimeSeries | None\n</code></pre> <p>Transform EffectValues to EffectTimeSeries. Creates a TimeSeries for each key in the nested_values dictionary, using the value as the data.</p> <p>The resulting label of the TimeSeries is the label of the parent_element, followed by the label of the Effect in the nested_values and the label_suffix. If the key in the EffectValues is None, the alias 'Standard_Effect' is used</p>"},{"location":"api-reference/interface/","title":"interface","text":""},{"location":"api-reference/interface/#flixopt.interface","title":"flixopt.interface","text":"<p>This module contains classes to collect Parameters for the Investment and OnOff decisions. These are tightly connected to features.py</p>"},{"location":"api-reference/interface/#flixopt.interface-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixopt.interface-classes","title":"Classes","text":""},{"location":"api-reference/interface/#flixopt.interface.Piece","title":"Piece","text":"<pre><code>Piece(start: NumericData, end: NumericData)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a single linear segment with specified domain boundaries.</p> <p>This class represents one linear segment that will be combined with other pieces to form complete piecewise linear functions. Each piece defines a domain interval [start, end] where a linear relationship applies.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>NumericData</code> <p>Lower bound of the domain interval for this linear segment. Can be scalar values or time series arrays for time-varying boundaries.</p> required <code>end</code> <code>NumericData</code> <p>Upper bound of the domain interval for this linear segment. Can be scalar values or time series arrays for time-varying boundaries.</p> required <p>Examples:</p> <p>Basic piece for equipment efficiency curve:</p> <pre><code># Single segment from 40% to 80% load\nefficiency_segment = Piece(start=40, end=80)\n</code></pre> <p>Piece with time-varying boundaries:</p> <pre><code># Capacity limits that change seasonally\nseasonal_piece = Piece(\n    start=np.array([10, 20, 30, 25]),  # Minimum capacity by season\n    end=np.array([80, 100, 90, 70]),  # Maximum capacity by season\n)\n</code></pre> <p>Fixed operating point (start equals end):</p> <pre><code># Equipment that operates at exactly 50 MW\nfixed_output = Piece(start=50, end=50)\n</code></pre> Note <p>Individual pieces are building blocks that gain meaning when combined into Piecewise functions. See the Piecewise class for information about how pieces interact and relate to each other.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.Piece.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/interface/#flixopt.interface.Piece.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piece.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/interface/#flixopt.interface.Piecewise","title":"Piecewise","text":"<pre><code>Piecewise(pieces: list[Piece])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define a piecewise linear function by combining multiple <code>Piece</code>s together.</p> <p>This class creates complex non-linear relationships by combining multiple Piece objects into a single piecewise linear function.</p> <p>Parameters:</p> Name Type Description Default <code>pieces</code> <code>list[Piece]</code> <p>list of Piece objects defining the linear segments. The arrangement and relationships between pieces determine the function behavior: - Touching pieces (end of one = start of next) ensure continuity - Gaps between pieces create forbidden regions - Overlapping pieces provide an extra choice for the optimizer</p> required Piece Relationship Patterns <p>Touching Pieces (Continuous Function): Pieces that share boundary points create smooth, continuous functions without gaps or overlaps.</p> <p>Gaps Between Pieces (Forbidden Regions): Non-contiguous pieces with gaps represent forbidden regions. For example minimum load requirements or safety zones.</p> <p>Overlapping Pieces (Flexible Operation): Pieces with overlapping domains provide optimization flexibility, allowing the solver to choose which segment to operate in.</p> <p>Examples:</p> <p>Continuous efficiency curve (touching pieces):</p> <pre><code>efficiency_curve = Piecewise(\n    [\n        Piece(start=0, end=25),  # Low load: 0-25 MW\n        Piece(start=25, end=75),  # Medium load: 25-75 MW (touches at 25)\n        Piece(start=75, end=100),  # High load: 75-100 MW (touches at 75)\n    ]\n)\n</code></pre> <p>Equipment with forbidden operating range (gap):</p> <pre><code>turbine_operation = Piecewise(\n    [\n        Piece(start=0, end=0),  # Off state (point operation)\n        Piece(start=40, end=100),  # Operating range (gap: 0-40 forbidden)\n    ]\n)\n</code></pre> <p>Flexible operation with overlapping options:</p> <pre><code>flexible_operation = Piecewise(\n    [\n        Piece(start=20, end=60),  # Standard efficiency mode\n        Piece(start=50, end=90),  # High efficiency mode (overlap: 50-60)\n    ]\n)\n</code></pre> <p>Tiered pricing structure:</p> <pre><code>electricity_pricing = Piecewise(\n    [\n        Piece(start=0, end=100),  # Tier 1: 0-100 kWh\n        Piece(start=100, end=500),  # Tier 2: 100-500 kWh\n        Piece(start=500, end=1000),  # Tier 3: 500-1000 kWh\n    ]\n)\n</code></pre> <p>Seasonal capacity variation:</p> <pre><code>seasonal_capacity = Piecewise(\n    [\n        Piece(start=[10, 15, 20, 12], end=[80, 90, 85, 75]),  # Varies by time\n    ]\n)\n</code></pre> Container Operations <p>The Piecewise class supports standard Python container operations:</p> <pre><code>piecewise = Piecewise([piece1, piece2, piece3])\n\nlen(piecewise)  # Returns number of pieces (3)\npiecewise[0]  # Access first piece\nfor piece in piecewise:  # Iterate over all pieces\n    print(piece.start, piece.end)\n</code></pre> Validation Considerations <ul> <li>Pieces are typically ordered by their start values</li> <li>Check for unintended gaps that might create infeasible regions</li> <li>Consider whether overlaps provide desired flexibility or create ambiguity</li> <li>Ensure time-varying pieces have consistent dimensions</li> </ul> Common Use Cases <ul> <li>Power plants: Heat rate curves, efficiency vs load, emissions profiles</li> <li>HVAC systems: COP vs temperature, capacity vs conditions</li> <li>Industrial processes: Conversion rates vs throughput, quality vs speed</li> <li>Financial modeling: Tiered rates, progressive taxes, bulk discounts</li> <li>Transportation: Fuel efficiency curves, capacity vs speed</li> <li>Storage systems: Efficiency vs state of charge, power vs energy</li> <li>Renewable energy: Output vs weather conditions, curtailment strategies</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.Piecewise.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/interface/#flixopt.interface.Piecewise.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion","title":"PiecewiseConversion","text":"<pre><code>PiecewiseConversion(piecewises: dict[str, Piecewise])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define coordinated piecewise linear relationships between multiple flows.</p> <p>This class models conversion processes where multiple flows (inputs, outputs, auxiliaries) have synchronized piecewise relationships. All flows change together based on the same operating point, enabling accurate modeling of complex equipment with variable performance characteristics.</p> Multi-Flow Coordination <p>All piecewise functions must have matching piece structures (same number of pieces with compatible domains) to ensure synchronized operation. When the equipment operates at a given point, ALL flows scale proportionally within their respective pieces.</p> <p>Parameters:</p> Name Type Description Default <code>piecewises</code> <code>dict[str, Piecewise]</code> <p>Dictionary mapping flow labels to their Piecewise functions. Keys are flow identifiers (e.g., 'electricity_in', 'heat_out', 'fuel_consumed'). Values are Piecewise objects that define each flow's behavior. Critical Requirement: All Piecewise objects must have the same number of pieces with compatible domains to ensure consistent operation.</p> required Operating Point Coordination <p>When equipment operates at any point within a piece, all flows scale proportionally within their corresponding pieces. This ensures realistic equipment behavior where efficiency, consumption, and production rates all change together.</p> <p>Examples:</p> <p>Heat pump with coordinated efficiency changes:</p> <pre><code>heat_pump_pc = PiecewiseConversion(\n    {\n        'electricity_in': Piecewise(\n            [\n                Piece(0, 10),  # Low load: 0-10 kW electricity\n                Piece(10, 25),  # High load: 10-25 kW electricity\n            ]\n        ),\n        'heat_out': Piecewise(\n            [\n                Piece(0, 35),  # Low load COP=3.5: 0-35 kW heat\n                Piece(35, 75),  # High load COP=3.0: 35-75 kW heat\n            ]\n        ),\n        'cooling_water': Piecewise(\n            [\n                Piece(0, 2.5),  # Low load: 0-2.5 m\u00b3/h cooling\n                Piece(2.5, 6),  # High load: 2.5-6 m\u00b3/h cooling\n            ]\n        ),\n    }\n)\n# At 15 kW electricity \u2192 52.5 kW heat + 3.75 m\u00b3/h cooling water\n</code></pre> <p>Combined cycle power plant with synchronized flows:</p> <pre><code>power_plant_pc = PiecewiseConversion(\n    {\n        'natural_gas': Piecewise(\n            [\n                Piece(150, 300),  # Part load: 150-300 MW_th fuel\n                Piece(300, 500),  # Full load: 300-500 MW_th fuel\n            ]\n        ),\n        'electricity': Piecewise(\n            [\n                Piece(60, 135),  # Part load: 60-135 MW_e (45% efficiency)\n                Piece(135, 250),  # Full load: 135-250 MW_e (50% efficiency)\n            ]\n        ),\n        'steam_export': Piecewise(\n            [\n                Piece(20, 35),  # Part load: 20-35 MW_th steam\n                Piece(35, 50),  # Full load: 35-50 MW_th steam\n            ]\n        ),\n        'co2_emissions': Piecewise(\n            [\n                Piece(30, 60),  # Part load: 30-60 t/h CO2\n                Piece(60, 100),  # Full load: 60-100 t/h CO2\n            ]\n        ),\n    }\n)\n</code></pre> <p>Chemical reactor with multiple products and waste:</p> <pre><code>reactor_pc = PiecewiseConversion(\n    {\n        'feedstock': Piecewise(\n            [\n                Piece(10, 50),  # Small batch: 10-50 kg/h\n                Piece(50, 200),  # Large batch: 50-200 kg/h\n            ]\n        ),\n        'product_A': Piecewise(\n            [\n                Piece(7, 35),  # Small batch: 70% yield\n                Piece(35, 140),  # Large batch: 70% yield\n            ]\n        ),\n        'product_B': Piecewise(\n            [\n                Piece(2, 10),  # Small batch: 20% yield\n                Piece(10, 45),  # Large batch: 22.5% yield (improved)\n            ]\n        ),\n        'waste_stream': Piecewise(\n            [\n                Piece(1, 5),  # Small batch: 10% waste\n                Piece(5, 15),  # Large batch: 7.5% waste (efficiency)\n            ]\n        ),\n    }\n)\n</code></pre> <p>Equipment with discrete operating modes:</p> <pre><code>compressor_pc = PiecewiseConversion(\n    {\n        'electricity': Piecewise(\n            [\n                Piece(0, 0),  # Off mode: no consumption\n                Piece(45, 45),  # Low mode: fixed 45 kW\n                Piece(85, 85),  # High mode: fixed 85 kW\n            ]\n        ),\n        'compressed_air': Piecewise(\n            [\n                Piece(0, 0),  # Off mode: no production\n                Piece(250, 250),  # Low mode: 250 Nm\u00b3/h\n                Piece(500, 500),  # High mode: 500 Nm\u00b3/h\n            ]\n        ),\n    }\n)\n</code></pre> <p>Equipment with forbidden operating range:</p> <pre><code>steam_turbine_pc = PiecewiseConversion(\n    {\n        'steam_in': Piecewise(\n            [\n                Piece(0, 100),  # Low pressure operation\n                Piece(200, 500),  # High pressure (gap: 100-200 forbidden)\n            ]\n        ),\n        'electricity_out': Piecewise(\n            [\n                Piece(0, 30),  # Low pressure: poor efficiency\n                Piece(80, 220),  # High pressure: good efficiency\n            ]\n        ),\n        'condensate_out': Piecewise(\n            [\n                Piece(0, 100),  # Low pressure condensate\n                Piece(200, 500),  # High pressure condensate\n            ]\n        ),\n    }\n)\n</code></pre> Design Patterns <p>Forbidden Ranges: Use gaps between pieces to model equipment that cannot operate in certain ranges (e.g., minimum loads, unstable regions).</p> <p>Discrete Modes: Use pieces with identical start/end values to model equipment with fixed operating points (e.g., on/off, discrete speeds).</p> <p>Efficiency Changes: Coordinate input and output pieces to reflect changing conversion efficiency across operating ranges.</p> Common Use Cases <ul> <li>Power generation: Multi-fuel plants, cogeneration systems, renewable hybrids</li> <li>HVAC systems: Heat pumps, chillers with variable COP and auxiliary loads</li> <li>Industrial processes: Multi-product reactors, separation units, heat exchangers</li> <li>Transportation: Multi-modal systems, hybrid vehicles, charging infrastructure</li> <li>Water treatment: Multi-stage processes with varying energy and chemical needs</li> <li>Energy storage: Systems with efficiency changes and auxiliary power requirements</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Return an iterator over (flow_label, Piecewise) pairs stored in this PiecewiseConversion.</p> <p>This is a thin convenience wrapper around the internal mapping and yields the same view as dict.items(), where each key is a flow label (str) and each value is a Piecewise.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseConversion.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects","title":"PiecewiseEffects","text":"<pre><code>PiecewiseEffects(piecewise_origin: Piecewise, piecewise_shares: dict[str, Piecewise])\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define how a single decision variable contributes to system effects with piecewise rates.</p> <p>This class models situations where a decision variable (the origin) generates different types of system effects (costs, emissions, resource consumption) at rates that change non-linearly with the variable's operating level. Unlike PiecewiseConversion which coordinates multiple flows, PiecewiseEffects focuses on how one variable impacts multiple system-wide effects.</p> <p>Key Concept - Origin vs. Effects:     - Origin: The primary decision variable (e.g., production level, capacity, size)     - Shares: The amounts which this variable contributes to different system effects</p> Relationship to PiecewiseConversion <p>PiecewiseConversion: Models synchronized relationships between multiple flow variables (e.g., fuel_in, electricity_out, emissions_out all coordinated).</p> <p>PiecewiseEffects: Models how one variable contributes to system-wide effects at variable rates (e.g., production_level \u2192 costs, emissions, resources).</p> <p>Parameters:</p> Name Type Description Default <code>piecewise_origin</code> <code>Piecewise</code> <p>Piecewise function defining the behavior of the primary decision variable. This establishes the operating domain and ranges.</p> required <code>piecewise_shares</code> <code>dict[str, Piecewise]</code> <p>Dictionary mapping effect names to their rate functions. Keys are effect identifiers (e.g., 'cost_per_unit', 'CO2_intensity'). Values are Piecewise objects defining the contribution rate per unit of the origin variable at different operating levels.</p> required Mathematical Relationship <p>For each effect: Total_Effect = Origin_Variable \u00d7 Share_Rate(Origin_Level)</p> <p>This enables modeling of: - Economies of scale (decreasing unit costs with volume) - Learning curves (improving efficiency with experience) - Threshold effects (changing rates at different scales) - Progressive pricing (increasing rates with consumption)</p> <p>Examples:</p> <p>Manufacturing with economies of scale:</p> <pre><code>production_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(0, 1000),  # Small scale: 0-1000 units/month\n            Piece(1000, 5000),  # Medium scale: 1000-5000 units/month\n            Piece(5000, 10000),  # Large scale: 5000-10000 units/month\n        ]\n    ),\n    piecewise_shares={\n        'unit_cost': Piecewise(\n            [\n                Piece(50, 45),  # \u20ac50-45/unit (scale benefits)\n                Piece(45, 35),  # \u20ac45-35/unit (bulk materials)\n                Piece(35, 30),  # \u20ac35-30/unit (automation benefits)\n            ]\n        ),\n        'labor_hours': Piecewise(\n            [\n                Piece(2.5, 2.0),  # 2.5-2.0 hours/unit (learning curve)\n                Piece(2.0, 1.5),  # 2.0-1.5 hours/unit (efficiency gains)\n                Piece(1.5, 1.2),  # 1.5-1.2 hours/unit (specialization)\n            ]\n        ),\n        'CO2_intensity': Piecewise(\n            [\n                Piece(15, 12),  # 15-12 kg CO2/unit (process optimization)\n                Piece(12, 9),  # 12-9 kg CO2/unit (equipment efficiency)\n                Piece(9, 7),  # 9-7 kg CO2/unit (renewable energy)\n            ]\n        ),\n    },\n)\n</code></pre> <p>Power generation with load-dependent characteristics:</p> <pre><code>generator_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(50, 200),  # Part load operation: 50-200 MW\n            Piece(200, 350),  # Rated operation: 200-350 MW\n            Piece(350, 400),  # Overload operation: 350-400 MW\n        ]\n    ),\n    piecewise_shares={\n        'fuel_rate': Piecewise(\n            [\n                Piece(12.0, 10.5),  # Heat rate: 12.0-10.5 GJ/MWh (part load penalty)\n                Piece(10.5, 9.8),  # Heat rate: 10.5-9.8 GJ/MWh (optimal efficiency)\n                Piece(9.8, 11.2),  # Heat rate: 9.8-11.2 GJ/MWh (overload penalty)\n            ]\n        ),\n        'maintenance_factor': Piecewise(\n            [\n                Piece(0.8, 1.0),  # Low stress operation\n                Piece(1.0, 1.0),  # Design operation\n                Piece(1.0, 1.5),  # High stress operation\n            ]\n        ),\n        'NOx_rate': Piecewise(\n            [\n                Piece(0.20, 0.15),  # NOx: 0.20-0.15 kg/MWh\n                Piece(0.15, 0.12),  # NOx: 0.15-0.12 kg/MWh (optimal combustion)\n                Piece(0.12, 0.25),  # NOx: 0.12-0.25 kg/MWh (overload penalties)\n            ]\n        ),\n    },\n)\n</code></pre> <p>Progressive utility pricing structure:</p> <pre><code>electricity_billing = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(0, 200),  # Basic usage: 0-200 kWh/month\n            Piece(200, 800),  # Standard usage: 200-800 kWh/month\n            Piece(800, 2000),  # High usage: 800-2000 kWh/month\n        ]\n    ),\n    piecewise_shares={\n        'energy_rate': Piecewise(\n            [\n                Piece(0.12, 0.12),  # Basic rate: \u20ac0.12/kWh\n                Piece(0.18, 0.18),  # Standard rate: \u20ac0.18/kWh\n                Piece(0.28, 0.28),  # Premium rate: \u20ac0.28/kWh\n            ]\n        ),\n        'carbon_tax': Piecewise(\n            [\n                Piece(0.02, 0.02),  # Low carbon tax: \u20ac0.02/kWh\n                Piece(0.03, 0.03),  # Medium carbon tax: \u20ac0.03/kWh\n                Piece(0.05, 0.05),  # High carbon tax: \u20ac0.05/kWh\n            ]\n        ),\n    },\n)\n</code></pre> <p>Data center with capacity-dependent efficiency:</p> <pre><code>datacenter_effects = PiecewiseEffects(\n    piecewise_origin=Piecewise(\n        [\n            Piece(100, 500),  # Low utilization: 100-500 servers\n            Piece(500, 2000),  # Medium utilization: 500-2000 servers\n            Piece(2000, 5000),  # High utilization: 2000-5000 servers\n        ]\n    ),\n    piecewise_shares={\n        'power_per_server': Piecewise(\n            [\n                Piece(0.8, 0.6),  # 0.8-0.6 kW/server (inefficient cooling)\n                Piece(0.6, 0.4),  # 0.6-0.4 kW/server (optimal efficiency)\n                Piece(0.4, 0.5),  # 0.4-0.5 kW/server (thermal limits)\n            ]\n        ),\n        'cooling_overhead': Piecewise(\n            [\n                Piece(0.4, 0.3),  # 40%-30% cooling overhead\n                Piece(0.3, 0.2),  # 30%-20% cooling overhead\n                Piece(0.2, 0.25),  # 20%-25% cooling overhead\n            ]\n        ),\n    },\n)\n</code></pre> Design Patterns <p>Economies of Scale: Decreasing unit costs/impacts with increased scale Learning Curves: Improving efficiency rates with experience/volume Threshold Effects: Step changes in rates at specific operating levels Progressive Pricing: Increasing rates for higher consumption levels Capacity Utilization: Optimal efficiency at design points, penalties at extremes</p> Common Use Cases <ul> <li>Manufacturing: Production scaling, learning effects, quality improvements</li> <li>Energy systems: Generator efficiency curves, renewable capacity factors</li> <li>Logistics: Transportation rates, warehouse utilization, delivery optimization</li> <li>Utilities: Progressive pricing, infrastructure cost allocation</li> <li>Financial services: Risk premiums, transaction fees, volume discounts</li> <li>Environmental modeling: Pollution intensity, resource consumption rates</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/interface/#flixopt.interface.PiecewiseEffects.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters","title":"InvestParameters","text":"<pre><code>InvestParameters(fixed_size: int | float | None = None, minimum_size: int | float | None = None, maximum_size: int | float | None = None, optional: bool = True, fix_effects: EffectValuesUserScalar | None = None, specific_effects: EffectValuesUserScalar | None = None, piecewise_effects: PiecewiseEffects | None = None, divest_effects: EffectValuesUserScalar | None = None)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define investment decision parameters with flexible sizing and effect modeling.</p> <p>This class models investment decisions in optimization problems, supporting both binary (invest/don't invest) and continuous sizing choices with comprehensive cost structures. It enables realistic representation of investment economics including fixed costs, scale effects, and divestment penalties.</p> Investment Decision Types <p>Binary Investments: Fixed size investments creating yes/no decisions (e.g., install a specific generator, build a particular facility)</p> <p>Continuous Sizing: Variable size investments with minimum/maximum bounds (e.g., battery capacity from 10-1000 kWh, pipeline diameter optimization)</p> Cost Modeling Approaches <ul> <li>Fixed Effects: One-time costs independent of size (permits, connections)</li> <li>Specific Effects: Linear costs proportional to size (\u20ac/kW, \u20ac/m\u00b2)</li> <li>Piecewise Effects: Non-linear relationships (bulk discounts, learning curves)</li> <li>Divestment Effects: Penalties for not investing (demolition, opportunity costs)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>fixed_size</code> <code>int | float | None</code> <p>When specified, creates a binary investment decision at exactly this size. When None, allows continuous sizing between minimum and maximum bounds.</p> <code>None</code> <code>minimum_size</code> <code>int | float | None</code> <p>Lower bound for continuous sizing decisions. Defaults to a small positive value (CONFIG.Modeling.epsilon) to avoid numerical issues. Ignored when fixed_size is specified.</p> <code>None</code> <code>maximum_size</code> <code>int | float | None</code> <p>Upper bound for continuous sizing decisions. Defaults to a large value (CONFIG.Modeling.big) representing unlimited capacity. Ignored when fixed_size is specified.</p> <code>None</code> <code>optional</code> <code>bool</code> <p>Controls whether investment is required. When True (default), optimization can choose not to invest. When False, forces investment to occur (useful for mandatory upgrades or replacement decisions).</p> <code>True</code> <code>fix_effects</code> <code>EffectValuesUserScalar | None</code> <p>Fixed costs incurred once if investment is made, regardless of size. Dictionary mapping effect names to values (e.g., {'cost': 10000, 'CO2_construction': 500}).</p> <code>None</code> <code>specific_effects</code> <code>EffectValuesUserScalar | None</code> <p>Variable costs proportional to investment size, representing per-unit costs (\u20ac/kW, \u20ac/m\u00b2). Dictionary mapping effect names to unit values (e.g., {'cost': 1200, 'steel_required': 0.5}).</p> <code>None</code> <code>piecewise_effects</code> <code>PiecewiseEffects | None</code> <p>Non-linear cost relationships using PiecewiseEffects for economies of scale, learning curves, or threshold effects. Can be combined with fix_effects and specific_effects.</p> <code>None</code> <code>divest_effects</code> <code>EffectValuesUserScalar | None</code> <p>Costs incurred if the investment is NOT made, such as demolition of existing equipment, contractual penalties, or lost opportunities. Dictionary mapping effect names to values.</p> <code>None</code> Cost Annualization Requirements <p>All cost values must be properly weighted to match the optimization model's time horizon. For long-term investments, the cost values should be annualized to the corresponding operation time (annuity).</p> <ul> <li>Use equivalent annual cost (capital cost / equipment lifetime)</li> <li>Apply appropriate discount rates for present value calculations</li> <li>Account for inflation, escalation, and financing costs</li> </ul> <p>Example: \u20ac1M equipment with 20-year life \u2192 \u20ac50k/year fixed cost</p> <p>Examples:</p> <p>Simple binary investment (solar panels):</p> <pre><code>solar_investment = InvestParameters(\n    fixed_size=100,  # 100 kW system (binary decision)\n    optional=True,\n    fix_effects={\n        'cost': 25000,  # Installation and permitting costs\n        'CO2': -50000,  # Avoided emissions over lifetime\n    },\n    specific_effects={\n        'cost': 1200,  # \u20ac1200/kW for panels (annualized)\n        'CO2': -800,  # kg CO2 avoided per kW annually\n    },\n)\n</code></pre> <p>Flexible sizing with economies of scale:</p> <pre><code>battery_investment = InvestParameters(\n    minimum_size=10,  # Minimum viable system size (kWh)\n    maximum_size=1000,  # Maximum installable capacity\n    optional=True,\n    fix_effects={\n        'cost': 5000,  # Grid connection and control system\n        'installation_time': 2,  # Days for fixed components\n    },\n    piecewise_effects=PiecewiseEffects(\n        piecewise_origin=Piecewise(\n            [\n                Piece(0, 100),  # Small systems\n                Piece(100, 500),  # Medium systems\n                Piece(500, 1000),  # Large systems\n            ]\n        ),\n        piecewise_shares={\n            'cost': Piecewise(\n                [\n                    Piece(800, 750),  # High cost/kWh for small systems\n                    Piece(750, 600),  # Medium cost/kWh\n                    Piece(600, 500),  # Bulk discount for large systems\n                ]\n            )\n        },\n    ),\n)\n</code></pre> <p>Mandatory replacement with divestment costs:</p> <pre><code>boiler_replacement = InvestParameters(\n    minimum_size=50,\n    maximum_size=200,\n    optional=True,  # Can choose not to replace\n    fix_effects={\n        'cost': 15000,  # Installation costs\n        'disruption': 3,  # Days of downtime\n    },\n    specific_effects={\n        'cost': 400,  # \u20ac400/kW capacity\n        'maintenance': 25,  # Annual maintenance per kW\n    },\n    divest_effects={\n        'cost': 8000,  # Demolition if not replaced\n        'environmental': 100,  # Disposal fees\n    },\n)\n</code></pre> <p>Multi-technology comparison:</p> <pre><code># Gas turbine option\ngas_turbine = InvestParameters(\n    fixed_size=50,  # MW\n    fix_effects={'cost': 2500000, 'CO2': 1250000},\n    specific_effects={'fuel_cost': 45, 'maintenance': 12},\n)\n\n# Wind farm option\nwind_farm = InvestParameters(\n    minimum_size=20,\n    maximum_size=100,\n    fix_effects={'cost': 1000000, 'CO2': -5000000},\n    specific_effects={'cost': 1800000, 'land_use': 0.5},\n)\n</code></pre> <p>Technology learning curve:</p> <pre><code>hydrogen_electrolyzer = InvestParameters(\n    minimum_size=1,\n    maximum_size=50,  # MW\n    piecewise_effects=PiecewiseEffects(\n        piecewise_origin=Piecewise(\n            [\n                Piece(0, 5),  # Small scale: early adoption\n                Piece(5, 20),  # Medium scale: cost reduction\n                Piece(20, 50),  # Large scale: mature technology\n            ]\n        ),\n        piecewise_shares={\n            'capex': Piecewise(\n                [\n                    Piece(2000, 1800),  # Learning reduces costs\n                    Piece(1800, 1400),  # Continued cost reduction\n                    Piece(1400, 1200),  # Technology maturity\n                ]\n            ),\n            'efficiency': Piecewise(\n                [\n                    Piece(65, 68),  # Improving efficiency\n                    Piece(68, 72),  # with scale and experience\n                    Piece(72, 75),  # Best efficiency at scale\n                ]\n            ),\n        },\n    ),\n)\n</code></pre> Common Use Cases <ul> <li>Power generation: Plant sizing, technology selection, retrofit decisions</li> <li>Industrial equipment: Capacity expansion, efficiency upgrades, replacements</li> <li>Infrastructure: Network expansion, facility construction, system upgrades</li> <li>Energy storage: Battery sizing, pumped hydro, compressed air systems</li> <li>Transportation: Fleet expansion, charging infrastructure, modal shifts</li> <li>Buildings: HVAC systems, insulation upgrades, renewable integration</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/interface/#flixopt.interface.InvestParameters.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters","title":"OnOffParameters","text":"<pre><code>OnOffParameters(effects_per_switch_on: EffectValuesUser | None = None, effects_per_running_hour: EffectValuesUser | None = None, on_hours_total_min: int | None = None, on_hours_total_max: int | None = None, consecutive_on_hours_min: NumericData | None = None, consecutive_on_hours_max: NumericData | None = None, consecutive_off_hours_min: NumericData | None = None, consecutive_off_hours_max: NumericData | None = None, switch_on_total_max: int | None = None, force_switch_on: bool = False)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>Define operational constraints and effects for binary on/off equipment behavior.</p> <p>This class models equipment that operates in discrete states (on/off) rather than continuous operation, capturing realistic operational constraints and associated costs. It handles complex equipment behavior including startup costs, minimum run times, cycling limitations, and maintenance scheduling requirements.</p> Key Modeling Capabilities <p>Switching Costs: One-time costs for starting equipment (fuel, wear, labor) Runtime Constraints: Minimum and maximum continuous operation periods Cycling Limits: Maximum number of starts to prevent excessive wear Operating Hours: Total runtime limits and requirements over time horizon</p> Typical Equipment Applications <ul> <li>Power Plants: Combined cycle units, steam turbines with startup costs</li> <li>Industrial Processes: Batch reactors, furnaces with thermal cycling</li> <li>HVAC Systems: Chillers, boilers with minimum run times</li> <li>Backup Equipment: Emergency generators, standby systems</li> <li>Process Equipment: Compressors, pumps with operational constraints</li> </ul> <p>Parameters:</p> Name Type Description Default <code>effects_per_switch_on</code> <code>EffectValuesUser | None</code> <p>Costs or impacts incurred for each transition from off state (var_on=0) to on state (var_on=1). Represents startup costs, wear and tear, or other switching impacts. Dictionary mapping effect names to values (e.g., {'cost': 500, 'maintenance_hours': 2}).</p> <code>None</code> <code>effects_per_running_hour</code> <code>EffectValuesUser | None</code> <p>Ongoing costs or impacts while equipment operates in the on state. Includes fuel costs, labor, consumables, or emissions. Dictionary mapping effect names to hourly values (e.g., {'fuel_cost': 45}).</p> <code>None</code> <code>on_hours_total_min</code> <code>int | None</code> <p>Minimum total operating hours across the entire time horizon. Ensures equipment meets minimum utilization requirements or contractual obligations (e.g., power purchase agreements, maintenance schedules).</p> <code>None</code> <code>on_hours_total_max</code> <code>int | None</code> <p>Maximum total operating hours across the entire time horizon. Limits equipment usage due to maintenance schedules, fuel availability, environmental permits, or equipment lifetime constraints.</p> <code>None</code> <code>consecutive_on_hours_min</code> <code>NumericData | None</code> <p>Minimum continuous operating duration once started. Models minimum run times due to thermal constraints, process stability, or efficiency considerations. Can be time-varying to reflect different constraints across the planning horizon.</p> <code>None</code> <code>consecutive_on_hours_max</code> <code>NumericData | None</code> <p>Maximum continuous operating duration in one campaign. Models mandatory maintenance intervals, process batch sizes, or equipment thermal limits requiring periodic shutdowns.</p> <code>None</code> <code>consecutive_off_hours_min</code> <code>NumericData | None</code> <p>Minimum continuous shutdown duration between operations. Models cooling periods, maintenance requirements, or process constraints that prevent immediate restart after shutdown.</p> <code>None</code> <code>consecutive_off_hours_max</code> <code>NumericData | None</code> <p>Maximum continuous shutdown duration before mandatory restart. Models equipment preservation, process stability, or contractual requirements for minimum activity levels.</p> <code>None</code> <code>switch_on_total_max</code> <code>int | None</code> <p>Maximum number of startup operations across the time horizon. Limits equipment cycling to reduce wear, maintenance costs, or comply with operational constraints (e.g., grid stability requirements).</p> <code>None</code> <code>force_switch_on</code> <code>bool</code> <p>When True, creates switch-on variables even without explicit switch_on_total_max constraint. Useful for tracking or reporting startup events without enforcing limits.</p> <code>False</code> Note <p>Time Series Boundary Handling: The final time period constraints for consecutive_on_hours_min/max and consecutive_off_hours_min/max are not enforced, allowing the optimization to end with ongoing campaigns that may be shorter than the specified minimums or longer than maximums.</p> <p>Examples:</p> <p>Combined cycle power plant with startup costs and minimum run time:</p> <pre><code>power_plant_operation = OnOffParameters(\n    effects_per_switch_on={\n        'startup_cost': 25000,  # \u20ac25,000 per startup\n        'startup_fuel': 150,  # GJ natural gas for startup\n        'startup_time': 4,  # Hours to reach full output\n        'maintenance_impact': 0.1,  # Fractional life consumption\n    },\n    effects_per_running_hour={\n        'fixed_om': 125,  # Fixed O&amp;M costs while running\n        'auxiliary_power': 2.5,  # MW parasitic loads\n    },\n    consecutive_on_hours_min=8,  # Minimum 8-hour run once started\n    consecutive_off_hours_min=4,  # Minimum 4-hour cooling period\n    on_hours_total_max=6000,  # Annual operating limit\n)\n</code></pre> <p>Industrial batch process with cycling limits:</p> <pre><code>batch_reactor = OnOffParameters(\n    effects_per_switch_on={\n        'setup_cost': 1500,  # Labor and materials for startup\n        'catalyst_consumption': 5,  # kg catalyst per batch\n        'cleaning_chemicals': 200,  # L cleaning solution\n    },\n    effects_per_running_hour={\n        'steam': 2.5,  # t/h process steam\n        'electricity': 150,  # kWh electrical load\n        'cooling_water': 50,  # m\u00b3/h cooling water\n    },\n    consecutive_on_hours_min=12,  # Minimum batch size (12 hours)\n    consecutive_on_hours_max=24,  # Maximum batch size (24 hours)\n    consecutive_off_hours_min=6,  # Cleaning and setup time\n    switch_on_total_max=200,  # Maximum 200 batches per year\n    on_hours_total_max=4000,  # Maximum production time\n)\n</code></pre> <p>HVAC system with thermostat control and maintenance:</p> <pre><code>hvac_operation = OnOffParameters(\n    effects_per_switch_on={\n        'compressor_wear': 0.5,  # Hours of compressor life per start\n        'inrush_current': 15,  # kW peak demand on startup\n    },\n    effects_per_running_hour={\n        'electricity': 25,  # kW electrical consumption\n        'maintenance': 0.12,  # \u20ac/hour maintenance reserve\n    },\n    consecutive_on_hours_min=1,  # Minimum 1-hour run to avoid cycling\n    consecutive_off_hours_min=0.5,  # 30-minute minimum off time\n    switch_on_total_max=2000,  # Limit cycling for compressor life\n    on_hours_total_min=2000,  # Minimum operation for humidity control\n    on_hours_total_max=5000,  # Maximum operation for energy budget\n)\n</code></pre> <p>Backup generator with testing and maintenance requirements:</p> <pre><code>backup_generator = OnOffParameters(\n    effects_per_switch_on={\n        'fuel_priming': 50,  # L diesel for system priming\n        'wear_factor': 1.0,  # Start cycles impact on maintenance\n        'testing_labor': 2,  # Hours technician time per test\n    },\n    effects_per_running_hour={\n        'fuel_consumption': 180,  # L/h diesel consumption\n        'emissions_permit': 15,  # \u20ac emissions allowance cost\n        'noise_penalty': 25,  # \u20ac noise compliance cost\n    },\n    consecutive_on_hours_min=0.5,  # Minimum test duration (30 min)\n    consecutive_off_hours_max=720,  # Maximum 30 days between tests\n    switch_on_total_max=52,  # Weekly testing limit\n    on_hours_total_min=26,  # Minimum annual testing (0.5h \u00d7 52)\n    on_hours_total_max=200,  # Maximum runtime (emergencies + tests)\n)\n</code></pre> <p>Peak shaving battery with cycling degradation:</p> <pre><code>battery_cycling = OnOffParameters(\n    effects_per_switch_on={\n        'cycle_degradation': 0.01,  # % capacity loss per cycle\n        'inverter_startup': 0.5,  # kWh losses during startup\n    },\n    effects_per_running_hour={\n        'standby_losses': 2,  # kW standby consumption\n        'cooling': 5,  # kW thermal management\n        'inverter_losses': 8,  # kW conversion losses\n    },\n    consecutive_on_hours_min=1,  # Minimum discharge duration\n    consecutive_on_hours_max=4,  # Maximum continuous discharge\n    consecutive_off_hours_min=1,  # Minimum rest between cycles\n    switch_on_total_max=365,  # Daily cycling limit\n    force_switch_on=True,  # Track all cycling events\n)\n</code></pre> Common Use Cases <ul> <li>Power generation: Thermal plant cycling, renewable curtailment, grid services</li> <li>Industrial processes: Batch production, maintenance scheduling, equipment rotation</li> <li>Buildings: HVAC control, lighting systems, elevator operations</li> <li>Transportation: Fleet management, charging infrastructure, maintenance windows</li> <li>Storage systems: Battery cycling, pumped hydro, compressed air systems</li> <li>Emergency equipment: Backup generators, safety systems, emergency lighting</li> </ul>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters-attributes","title":"Attributes","text":""},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.use_off","title":"use_off  <code>property</code>","text":"<pre><code>use_off: bool\n</code></pre> <p>Proxy: whether OFF variable is required</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.use_consecutive_on_hours","title":"use_consecutive_on_hours  <code>property</code>","text":"<pre><code>use_consecutive_on_hours: bool\n</code></pre> <p>Determines whether a Variable for consecutive on hours is needed or not</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.use_consecutive_off_hours","title":"use_consecutive_off_hours  <code>property</code>","text":"<pre><code>use_consecutive_off_hours: bool\n</code></pre> <p>Determines whether a Variable for consecutive off hours is needed or not</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.use_switch_on","title":"use_switch_on  <code>property</code>","text":"<pre><code>use_switch_on: bool\n</code></pre> <p>Determines whether a Variable for SWITCH-ON is needed or not</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters-functions","title":"Functions","text":""},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/interface/#flixopt.interface.OnOffParameters.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/interface/#flixopt.interface-functions","title":"Functions","text":""},{"location":"api-reference/io/","title":"io","text":""},{"location":"api-reference/io/#flixopt.io","title":"flixopt.io","text":""},{"location":"api-reference/io/#flixopt.io-classes","title":"Classes","text":""},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths","title":"CalculationResultsPaths  <code>dataclass</code>","text":"<pre><code>CalculationResultsPaths(folder: Path, name: str)\n</code></pre> <p>Container for all paths related to saving CalculationResults.</p>"},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths-functions","title":"Functions","text":""},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths.all_paths","title":"all_paths","text":"<pre><code>all_paths() -&gt; dict[str, pathlib.Path]\n</code></pre> <p>Return a dictionary of all paths.</p>"},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths.create_folders","title":"create_folders","text":"<pre><code>create_folders(parents: bool = False) -&gt; None\n</code></pre> <p>Ensure the folder exists. Args:     parents: Whether to create the parent folders if they do not exist.</p>"},{"location":"api-reference/io/#flixopt.io.CalculationResultsPaths.update","title":"update","text":"<pre><code>update(new_name: str | None = None, new_folder: Path | None = None) -&gt; None\n</code></pre> <p>Update name and/or folder and refresh all paths.</p>"},{"location":"api-reference/io/#flixopt.io-functions","title":"Functions","text":""},{"location":"api-reference/io/#flixopt.io.replace_timeseries","title":"replace_timeseries","text":"<pre><code>replace_timeseries(obj, mode: Literal['name', 'stats', 'data'] = 'name')\n</code></pre> <p>Recursively replaces TimeSeries objects with their names prefixed by '::::'.</p>"},{"location":"api-reference/io/#flixopt.io.insert_dataarray","title":"insert_dataarray","text":"<pre><code>insert_dataarray(obj, ds: Dataset)\n</code></pre> <p>Recursively inserts TimeSeries objects into a dataset.</p>"},{"location":"api-reference/io/#flixopt.io.remove_none_and_empty","title":"remove_none_and_empty","text":"<pre><code>remove_none_and_empty(obj)\n</code></pre> <p>Recursively removes None and empty dicts and lists values from a dictionary or list.</p>"},{"location":"api-reference/io/#flixopt.io.document_linopy_model","title":"document_linopy_model","text":"<pre><code>document_linopy_model(model: Model, path: Path | None = None) -&gt; dict[str, str]\n</code></pre> <p>Convert all model variables and constraints to a structured string representation. This can take multiple seconds for large models. The output can be saved to a yaml file with readable formating applied.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to save the document. Defaults to None.</p> <code>None</code>"},{"location":"api-reference/io/#flixopt.io.save_dataset_to_netcdf","title":"save_dataset_to_netcdf","text":"<pre><code>save_dataset_to_netcdf(ds: Dataset, path: str | Path, compression: int = 0, engine: Literal['netcdf4', 'scipy', 'h5netcdf'] = 'h5netcdf') -&gt; None\n</code></pre> <p>Save a dataset to a netcdf file. Store the attrs as a json string in the 'attrs' attribute.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset to save.</p> required <code>path</code> <code>str | Path</code> <p>Path to save the dataset to.</p> required <code>compression</code> <code>int</code> <p>Compression level for the dataset (0-9). 0 means no compression. 5 is a good default.</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path has an invalid file extension.</p>"},{"location":"api-reference/io/#flixopt.io.load_dataset_from_netcdf","title":"load_dataset_from_netcdf","text":"<pre><code>load_dataset_from_netcdf(path: str | Path) -&gt; xr.Dataset\n</code></pre> <p>Load a dataset from a netcdf file. Load the attrs from the 'attrs' attribute.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to load the dataset from.</p> required <p>Returns:</p> Name Type Description <code>Dataset</code> <code>Dataset</code> <p>Loaded dataset.</p>"},{"location":"api-reference/linear_converters/","title":"linear_converters","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters","title":"flixopt.linear_converters","text":"<p>This Module contains high-level classes to easily model a FlowSystem.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters-attributes","title":"Attributes","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters-classes","title":"Classes","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler","title":"Boiler","text":"<pre><code>Boiler(label: str, eta: NumericDataTS, Q_fu: Flow, Q_th: Flow, on_off_parameters: OnOffParameters | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing a fuel-fired boiler for thermal energy generation.</p> <p>Boilers convert fuel input into thermal energy with a specified efficiency factor. This is a simplified wrapper around LinearConverter with predefined conversion relationships for thermal generation applications.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>eta</code> <code>NumericDataTS</code> <p>Thermal efficiency factor (0-1 range). Defines the ratio of thermal output to fuel input energy content.</p> required <code>Q_fu</code> <code>Flow</code> <p>Fuel input-flow representing fuel consumption.</p> required <code>Q_th</code> <code>Flow</code> <p>Thermal output-flow representing heat generation.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Natural gas boiler:</p> <pre><code>gas_boiler = Boiler(\n    label='natural_gas_boiler',\n    eta=0.85,  # 85% thermal efficiency\n    Q_fu=natural_gas_flow,\n    Q_th=hot_water_flow,\n)\n</code></pre> <p>Biomass boiler with seasonal efficiency variation:</p> <pre><code>biomass_boiler = Boiler(\n    label='wood_chip_boiler',\n    eta=seasonal_efficiency_profile,  # Time-varying efficiency\n    Q_fu=biomass_flow,\n    Q_th=district_heat_flow,\n    on_off_parameters=OnOffParameters(\n        consecutive_on_hours_min=4,  # Minimum 4-hour operation\n        effects_per_switch_on={'startup_fuel': 50},  # Startup fuel penalty\n    ),\n)\n</code></pre> Note <p>The conversion relationship is: Q_th = Q_fu \u00d7 eta</p> <p>Efficiency should be between 0 and 1, where 1 represents perfect conversion (100% of fuel energy converted to useful thermal output).</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Boiler.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat","title":"Power2Heat","text":"<pre><code>Power2Heat(label: str, eta: NumericDataTS, P_el: Flow, Q_th: Flow, on_off_parameters: OnOffParameters | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing electric resistance heating or power-to-heat conversion.</p> <p>Power2Heat components convert electrical energy directly into thermal energy through resistance heating elements, electrode boilers, or other direct electric heating technologies. This is a simplified wrapper around LinearConverter with predefined conversion relationships for electric heating applications.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>eta</code> <code>NumericDataTS</code> <p>Thermal efficiency factor (0-1 range). For resistance heating this is typically close to 1.0 (nearly 100% efficiency), but may be lower for electrode boilers or systems with distribution losses.</p> required <code>P_el</code> <code>Flow</code> <p>Electrical input-flow representing electricity consumption.</p> required <code>Q_th</code> <code>Flow</code> <p>Thermal output-flow representing heat generation.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Electric resistance heater:</p> <pre><code>electric_heater = Power2Heat(\n    label='resistance_heater',\n    eta=0.98,  # 98% efficiency (small losses)\n    P_el=electricity_flow,\n    Q_th=space_heating_flow,\n)\n</code></pre> <p>Electrode boiler for industrial steam:</p> <pre><code>electrode_boiler = Power2Heat(\n    label='electrode_steam_boiler',\n    eta=0.95,  # 95% efficiency including boiler losses\n    P_el=industrial_electricity,\n    Q_th=process_steam_flow,\n    on_off_parameters=OnOffParameters(\n        consecutive_on_hours_min=1,  # Minimum 1-hour operation\n        effects_per_switch_on={'startup_cost': 100},\n    ),\n)\n</code></pre> Note <p>The conversion relationship is: Q_th = P_el \u00d7 eta</p> <p>Unlike heat pumps, Power2Heat systems cannot exceed 100% efficiency (eta \u2264 1.0) as they only convert electrical energy without extracting additional energy from the environment. However, they provide fast response times and precise temperature control.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.Power2Heat.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump","title":"HeatPump","text":"<pre><code>HeatPump(label: str, COP: NumericDataTS, P_el: Flow, Q_th: Flow, on_off_parameters: OnOffParameters | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing an electric heat pump for thermal energy generation.</p> <p>Heat pumps convert electrical energy into thermal energy with a Coefficient of Performance (COP) greater than 1, making them more efficient than direct electric heating. This is a simplified wrapper around LinearConverter with predefined conversion relationships for heat pump applications.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>COP</code> <code>NumericDataTS</code> <p>Coefficient of Performance (typically 1-20 range). Defines the ratio of thermal output to electrical input. COP &gt; 1 indicates the heat pump extracts additional energy from the environment.</p> required <code>P_el</code> <code>Flow</code> <p>Electrical input-flow representing electricity consumption.</p> required <code>Q_th</code> <code>Flow</code> <p>Thermal output-flow representing heat generation.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Air-source heat pump with constant COP:</p> <pre><code>air_hp = HeatPump(\n    label='air_source_heat_pump',\n    COP=3.5,  # COP of 3.5 (350% efficiency)\n    P_el=electricity_flow,\n    Q_th=heating_flow,\n)\n</code></pre> <p>Ground-source heat pump with temperature-dependent COP:</p> <pre><code>ground_hp = HeatPump(\n    label='geothermal_heat_pump',\n    COP=temperature_dependent_cop,  # Time-varying COP based on ground temp\n    P_el=electricity_flow,\n    Q_th=radiant_heating_flow,\n    on_off_parameters=OnOffParameters(\n        consecutive_on_hours_min=2,  # Avoid frequent cycling\n        effects_per_running_hour={'maintenance': 0.5},\n    ),\n)\n</code></pre> Note <p>The conversion relationship is: Q_th = P_el \u00d7 COP</p> <p>COP should be greater than 1 for realistic heat pump operation, with typical values ranging from 2-6 depending on technology and operating conditions. Higher COP values indicate more efficient heat extraction from the environment.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPump.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower","title":"CoolingTower","text":"<pre><code>CoolingTower(label: str, specific_electricity_demand: NumericDataTS, P_el: Flow, Q_th: Flow, on_off_parameters: OnOffParameters | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing a cooling tower for waste heat rejection.</p> <p>Cooling towers consume electrical energy (for fans, pumps) to reject thermal energy to the environment through evaporation and heat transfer. The electricity demand is typically a small fraction of the thermal load being rejected. This component has no thermal outputs as the heat is rejected to the environment.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>specific_electricity_demand</code> <code>NumericDataTS</code> <p>Auxiliary electricity demand per unit of cooling power (dimensionless, typically 0.01-0.05 range). Represents the fraction of thermal power that must be supplied as electricity for fans and pumps.</p> required <code>P_el</code> <code>Flow</code> <p>Electrical input-flow representing electricity consumption for fans/pumps.</p> required <code>Q_th</code> <code>Flow</code> <p>Thermal input-flow representing waste heat to be rejected to environment.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Industrial cooling tower:</p> <pre><code>cooling_tower = CoolingTower(\n    label='process_cooling_tower',\n    specific_electricity_demand=0.025,  # 2.5% auxiliary power\n    P_el=cooling_electricity,\n    Q_th=waste_heat_flow,\n)\n</code></pre> <p>Power plant condenser cooling:</p> <pre><code>condenser_cooling = CoolingTower(\n    label='power_plant_cooling',\n    specific_electricity_demand=0.015,  # 1.5% auxiliary power\n    P_el=auxiliary_electricity,\n    Q_th=condenser_waste_heat,\n    on_off_parameters=OnOffParameters(\n        consecutive_on_hours_min=4,  # Minimum operation time\n        effects_per_running_hour={'water_consumption': 2.5},  # m\u00b3/h\n    ),\n)\n</code></pre> Note <p>The conversion relationship is: P_el = Q_th \u00d7 specific_electricity_demand</p> <p>The cooling tower consumes electrical power proportional to the thermal load. No thermal energy is produced - all thermal input is rejected to the environment.</p> <p>Typical specific electricity demands range from 1-5% of the thermal cooling load, depending on tower design, climate conditions, and operational requirements.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CoolingTower.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP","title":"CHP","text":"<pre><code>CHP(label: str, eta_th: NumericDataTS, eta_el: NumericDataTS, Q_fu: Flow, P_el: Flow, Q_th: Flow, on_off_parameters: OnOffParameters | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing a Combined Heat and Power (CHP) unit.</p> <p>CHP units simultaneously generate both electrical and thermal energy from a single fuel input, providing higher overall efficiency than separate generation. This is a wrapper around LinearConverter with predefined conversion relationships for cogeneration applications.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>eta_th</code> <code>NumericDataTS</code> <p>Thermal efficiency factor (0-1 range). Defines the fraction of fuel energy converted to useful thermal output.</p> required <code>eta_el</code> <code>NumericDataTS</code> <p>Electrical efficiency factor (0-1 range). Defines the fraction of fuel energy converted to electrical output.</p> required <code>Q_fu</code> <code>Flow</code> <p>Fuel input-flow representing fuel consumption.</p> required <code>P_el</code> <code>Flow</code> <p>Electrical output-flow representing electricity generation.</p> required <code>Q_th</code> <code>Flow</code> <p>Thermal output-flow representing heat generation.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Natural gas CHP unit:</p> <pre><code>gas_chp = CHP(\n    label='natural_gas_chp',\n    eta_th=0.45,  # 45% thermal efficiency\n    eta_el=0.35,  # 35% electrical efficiency (80% total)\n    Q_fu=natural_gas_flow,\n    P_el=electricity_flow,\n    Q_th=district_heat_flow,\n)\n</code></pre> <p>Industrial CHP with operational constraints:</p> <pre><code>industrial_chp = CHP(\n    label='industrial_chp',\n    eta_th=0.40,\n    eta_el=0.38,\n    Q_fu=fuel_gas_flow,\n    P_el=plant_electricity,\n    Q_th=process_steam,\n    on_off_parameters=OnOffParameters(\n        consecutive_on_hours_min=8,  # Minimum 8-hour operation\n        effects_per_switch_on={'startup_cost': 5000},\n        on_hours_total_max=6000,  # Annual operating limit\n    ),\n)\n</code></pre> Note <p>The conversion relationships are: - Q_th = Q_fu \u00d7 eta_th (thermal output) - P_el = Q_fu \u00d7 eta_el (electrical output)</p> <p>Total efficiency (eta_th + eta_el) should be \u2264 1.0, with typical combined efficiencies of 80-90% for modern CHP units. This provides significant efficiency gains compared to separate heat and power generation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.CHP.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource","title":"HeatPumpWithSource","text":"<pre><code>HeatPumpWithSource(label: str, COP: NumericDataTS, P_el: Flow, Q_ab: Flow, Q_th: Flow, on_off_parameters: OnOffParameters | None = None, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>LinearConverter</code></p> <p>A specialized LinearConverter representing a heat pump with explicit heat source modeling.</p> <p>This component models a heat pump that extracts thermal energy from a heat source (ground, air, water) and upgrades it using electrical energy to provide higher-grade thermal output. Unlike the simple HeatPump class, this explicitly models both the heat source extraction and electrical consumption with their interdependent relationships.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the Element. Used to identify it in the FlowSystem.</p> required <code>COP</code> <code>NumericDataTS</code> <p>Coefficient of Performance (typically 1-20 range). Defines the ratio of thermal output to electrical input. The heat source extraction is automatically calculated as Q_ab = Q_th \u00d7 (COP-1)/COP.</p> required <code>P_el</code> <code>Flow</code> <p>Electrical input-flow representing electricity consumption for compressor.</p> required <code>Q_ab</code> <code>Flow</code> <p>Heat source input-flow representing thermal energy extracted from environment (ground, air, water source).</p> required <code>Q_th</code> <code>Flow</code> <p>Thermal output-flow representing useful heat delivered to the application.</p> required <code>on_off_parameters</code> <code>OnOffParameters | None</code> <p>Parameters defining binary operation constraints and costs.</p> <code>None</code> <code>meta_data</code> <code>dict | None</code> <p>Used to store additional information. Not used internally but saved in results. Only use Python native types.</p> <code>None</code> <p>Examples:</p> <p>Ground-source heat pump with explicit ground coupling:</p> <pre><code>ground_source_hp = HeatPumpWithSource(\n    label='geothermal_heat_pump',\n    COP=4.5,  # High COP due to stable ground temperature\n    P_el=electricity_flow,\n    Q_ab=ground_heat_extraction,  # Heat extracted from ground loop\n    Q_th=building_heating_flow,\n)\n</code></pre> <p>Air-source heat pump with temperature-dependent performance:</p> <pre><code>waste_heat_pump = HeatPumpWithSource(\n    label='waste_heat_pump',\n    COP=temperature_dependent_cop,  # Varies with temperature of heat source\n    P_el=electricity_consumption,\n    Q_ab=industrial_heat_extraction,  # Heat extracted from a industrial process or waste water\n    Q_th=heat_supply,\n    on_off_parameters=OnOffParameters(\n        consecutive_on_hours_min=0.5,  # 30-minute minimum runtime\n        effects_per_switch_on={'costs': 1000},\n    ),\n)\n</code></pre> Note <p>The conversion relationships are: - Q_th = P_el \u00d7 COP (thermal output from electrical input) - Q_ab = Q_th \u00d7 (COP-1)/COP (heat source extraction) - Energy balance: Q_th = P_el + Q_ab</p> <p>This formulation explicitly tracks the heat source, which is important for systems where the source capacity or temperature is limited, or where the impact of heat extraction must be considered.</p> <p>COP should be &gt; 1 for thermodynamically valid operation, with typical values of 2-6 depending on source and sink temperatures.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/linear_converters/#flixopt.linear_converters.HeatPumpWithSource.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/linear_converters/#flixopt.linear_converters-functions","title":"Functions","text":""},{"location":"api-reference/linear_converters/#flixopt.linear_converters.check_bounds","title":"check_bounds","text":"<pre><code>check_bounds(value: NumericDataTS, parameter_label: str, element_label: str, lower_bound: NumericDataTS, upper_bound: NumericDataTS) -&gt; None\n</code></pre> <p>Check if the value is within the bounds. The bounds are exclusive. If not, log a warning. Args:     value: The value to check.     parameter_label: The label of the value.     element_label: The label of the element.     lower_bound: The lower bound.     upper_bound: The upper bound.</p>"},{"location":"api-reference/network_app/","title":"network_app","text":""},{"location":"api-reference/network_app/#flixopt.network_app","title":"flixopt.network_app","text":""},{"location":"api-reference/network_app/#flixopt.network_app-classes","title":"Classes","text":""},{"location":"api-reference/network_app/#flixopt.network_app.VisualizationConfig","title":"VisualizationConfig","text":"<p>Configuration constants for the visualization</p>"},{"location":"api-reference/network_app/#flixopt.network_app-functions","title":"Functions","text":""},{"location":"api-reference/network_app/#flixopt.network_app.flow_graph","title":"flow_graph","text":"<pre><code>flow_graph(flow_system: FlowSystem) -&gt; nx.DiGraph\n</code></pre> <p>Convert FlowSystem to NetworkX graph - simplified and more robust</p>"},{"location":"api-reference/network_app/#flixopt.network_app.make_cytoscape_elements","title":"make_cytoscape_elements","text":"<pre><code>make_cytoscape_elements(graph: DiGraph) -&gt; list[dict[str, Any]]\n</code></pre> <p>Convert NetworkX graph to Cytoscape elements</p>"},{"location":"api-reference/network_app/#flixopt.network_app.create_color_picker_input","title":"create_color_picker_input","text":"<pre><code>create_color_picker_input(label: str, input_id: str, default_color: str)\n</code></pre> <p>Create a compact color picker with DAQ ColorPicker</p>"},{"location":"api-reference/network_app/#flixopt.network_app.create_style_section","title":"create_style_section","text":"<pre><code>create_style_section(title: str, children: list)\n</code></pre> <p>Create a collapsible section for organizing controls</p>"},{"location":"api-reference/network_app/#flixopt.network_app.create_sidebar","title":"create_sidebar","text":"<pre><code>create_sidebar()\n</code></pre> <p>Create the main sidebar with improved organization</p>"},{"location":"api-reference/network_app/#flixopt.network_app.shownetwork","title":"shownetwork","text":"<pre><code>shownetwork(graph: DiGraph)\n</code></pre> <p>Main function to create and run the network visualization</p>"},{"location":"api-reference/plotting/","title":"plotting","text":""},{"location":"api-reference/plotting/#flixopt.plotting","title":"flixopt.plotting","text":"<p>Comprehensive visualization toolkit for flixopt optimization results and data analysis.</p> <p>This module provides a unified plotting interface supporting both Plotly (interactive) and Matplotlib (static) backends for visualizing energy system optimization results. It offers specialized plotting functions for time series, heatmaps, network diagrams, and statistical analyses commonly needed in energy system modeling.</p> Key Features <p>Dual Backend Support: Seamless switching between Plotly and Matplotlib Energy System Focus: Specialized plots for power flows, storage states, emissions Color Management: Intelligent color processing and palette management Export Capabilities: High-quality export for reports and publications Integration Ready: Designed for use with CalculationResults and standalone analysis</p> Main Plot Types <ul> <li>Time Series: Flow rates, power profiles, storage states over time</li> <li>Heatmaps: High-resolution temporal data visualization with customizable aggregation</li> <li>Network Diagrams: System topology with flow visualization</li> <li>Statistical Plots: Distribution analysis, correlation studies, performance metrics</li> <li>Comparative Analysis: Multi-scenario and sensitivity study visualizations</li> </ul> <p>The module integrates seamlessly with flixopt's result classes while remaining accessible for standalone data visualization tasks.</p>"},{"location":"api-reference/plotting/#flixopt.plotting-attributes","title":"Attributes","text":""},{"location":"api-reference/plotting/#flixopt.plotting.ColorType","title":"ColorType  <code>module-attribute</code>","text":"<pre><code>ColorType = str | list[str] | dict[str, str]\n</code></pre> <p>Flexible color specification type supporting multiple input formats for visualization.</p> <p>Color specifications can take several forms to accommodate different use cases:</p> <p>Named Colormaps (str):     - Standard colormaps: 'viridis', 'plasma', 'cividis', 'tab10', 'Set1'     - Energy-focused: 'portland' (custom flixopt colormap for energy systems)     - Backend-specific maps available in Plotly and Matplotlib</p> <p>Color Lists (list[str]):     - Explicit color sequences: ['red', 'blue', 'green', 'orange']     - HEX codes: ['#FF0000', '#0000FF', '#00FF00', '#FFA500']     - Mixed formats: ['red', '#0000FF', 'green', 'orange']</p> <p>Label-to-Color Mapping (dict[str, str]):     - Explicit associations: {'Wind': 'skyblue', 'Solar': 'gold', 'Gas': 'brown'}     - Ensures consistent colors across different plots and datasets     - Ideal for energy system components with semantic meaning</p> <p>Examples:</p> <pre><code># Named colormap\ncolors = 'viridis'  # Automatic color generation\n\n# Explicit color list\ncolors = ['red', 'blue', 'green', '#FFD700']\n\n# Component-specific mapping\ncolors = {\n    'Wind_Turbine': 'skyblue',\n    'Solar_Panel': 'gold',\n    'Natural_Gas': 'brown',\n    'Battery': 'green',\n    'Electric_Load': 'darkred'\n}\n</code></pre> Color Format Support <ul> <li>Named Colors: 'red', 'blue', 'forestgreen', 'darkorange'</li> <li>HEX Codes: '#FF0000', '#0000FF', '#228B22', '#FF8C00'</li> <li>RGB Tuples: (255, 0, 0), (0, 0, 255) [Matplotlib only]</li> <li>RGBA: 'rgba(255,0,0,0.8)' [Plotly only]</li> </ul> References <ul> <li>HTML Color Names: https://htmlcolorcodes.com/color-names/</li> <li>Matplotlib Colormaps: https://matplotlib.org/stable/tutorials/colors/colormaps.html</li> <li>Plotly Built-in Colorscales: https://plotly.com/python/builtin-colorscales/</li> </ul>"},{"location":"api-reference/plotting/#flixopt.plotting.PlottingEngine","title":"PlottingEngine  <code>module-attribute</code>","text":"<pre><code>PlottingEngine = Literal['plotly', 'matplotlib']\n</code></pre> <p>Identifier for the plotting engine to use.</p>"},{"location":"api-reference/plotting/#flixopt.plotting-classes","title":"Classes","text":""},{"location":"api-reference/plotting/#flixopt.plotting.ColorProcessor","title":"ColorProcessor","text":"<pre><code>ColorProcessor(engine: PlottingEngine = 'plotly', default_colormap: str = 'viridis')\n</code></pre> <p>Intelligent color management system for consistent multi-backend visualization.</p> <p>This class provides unified color processing across Plotly and Matplotlib backends, ensuring consistent visual appearance regardless of the plotting engine used. It handles color palette generation, named colormap translation, and intelligent color cycling for complex datasets with many categories.</p> Key Features <p>Backend Agnostic: Automatic color format conversion between engines Palette Management: Support for named colormaps, custom palettes, and color lists Intelligent Cycling: Smart color assignment for datasets with many categories Fallback Handling: Graceful degradation when requested colormaps are unavailable Energy System Colors: Built-in palettes optimized for energy system visualization</p> Color Input Types <ul> <li>Named Colormaps: 'viridis', 'plasma', 'portland', 'tab10', etc.</li> <li>Color Lists: ['red', 'blue', 'green'] or ['#FF0000', '#0000FF', '#00FF00']</li> <li>Label Dictionaries: {'Generator': 'red', 'Storage': 'blue', 'Load': 'green'}</li> </ul> <p>Examples:</p> <p>Basic color processing:</p> <pre><code># Initialize for Plotly backend\nprocessor = ColorProcessor(engine='plotly', default_colormap='viridis')\n\n# Process different color specifications\ncolors = processor.process_colors('plasma', ['Gen1', 'Gen2', 'Storage'])\ncolors = processor.process_colors(['red', 'blue', 'green'], ['A', 'B', 'C'])\ncolors = processor.process_colors({'Wind': 'skyblue', 'Solar': 'gold'}, ['Wind', 'Solar', 'Gas'])\n\n# Switch to Matplotlib\nprocessor = ColorProcessor(engine='matplotlib')\nmpl_colors = processor.process_colors('tab10', component_labels)\n</code></pre> <p>Energy system visualization:</p> <pre><code># Specialized energy system palette\nenergy_colors = {\n    'Natural_Gas': '#8B4513',  # Brown\n    'Electricity': '#FFD700',  # Gold\n    'Heat': '#FF4500',  # Red-orange\n    'Cooling': '#87CEEB',  # Sky blue\n    'Hydrogen': '#E6E6FA',  # Lavender\n    'Battery': '#32CD32',  # Lime green\n}\n\nprocessor = ColorProcessor('plotly')\nflow_colors = processor.process_colors(energy_colors, flow_labels)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>engine</code> <code>PlottingEngine</code> <p>Plotting backend ('plotly' or 'matplotlib'). Determines output color format.</p> <code>'plotly'</code> <code>default_colormap</code> <code>str</code> <p>Fallback colormap when requested palettes are unavailable. Common options: 'viridis', 'plasma', 'tab10', 'portland'.</p> <code>'viridis'</code> <p>Initialize the color processor with specified backend and defaults.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.ColorProcessor-functions","title":"Functions","text":""},{"location":"api-reference/plotting/#flixopt.plotting.ColorProcessor.process_colors","title":"process_colors","text":"<pre><code>process_colors(colors: ColorType, labels: list[str], return_mapping: bool = False) -&gt; list[Any] | dict[str, Any]\n</code></pre> <p>Process colors for the specified labels.</p> <p>Parameters:</p> Name Type Description Default <code>colors</code> <code>ColorType</code> <p>Color specification (colormap name, list of colors, or label-to-color mapping)</p> required <code>labels</code> <code>list[str]</code> <p>list of data labels that need colors assigned</p> required <code>return_mapping</code> <code>bool</code> <p>If True, returns a dictionary mapping labels to colors;            if False, returns a list of colors in the same order as labels</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Any] | dict[str, Any]</code> <p>Either a list of colors or a dictionary mapping labels to colors</p>"},{"location":"api-reference/plotting/#flixopt.plotting-functions","title":"Functions","text":""},{"location":"api-reference/plotting/#flixopt.plotting.with_plotly","title":"with_plotly","text":"<pre><code>with_plotly(data: DataFrame, mode: Literal['bar', 'line', 'area'] = 'area', colors: ColorType = 'viridis', title: str = '', ylabel: str = '', xlabel: str = 'Time in h', fig: Figure | None = None) -&gt; go.Figure\n</code></pre> <p>Plot a DataFrame with Plotly, using either stacked bars or stepped lines.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame containing the data to plot, where the index represents time (e.g., hours),   and each column represents a separate data series.</p> required <code>mode</code> <code>Literal['bar', 'line', 'area']</code> <p>The plotting mode. Use 'bar' for stacked bar charts, 'line' for stepped lines,   or 'area' for stacked area charts.</p> <code>'area'</code> <code>colors</code> <code>ColorType</code> <p>Color specification, can be: - A string with a colorscale name (e.g., 'viridis', 'plasma') - A list of color strings (e.g., ['#ff0000', '#00ff00']) - A dictionary mapping column names to colors (e.g., {'Column1': '#ff0000'})</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The title of the plot.</p> <code>''</code> <code>ylabel</code> <code>str</code> <p>The label for the y-axis.</p> <code>''</code> <code>xlabel</code> <code>str</code> <p>The label for the x-axis.</p> <code>'Time in h'</code> <code>fig</code> <code>Figure | None</code> <p>A Plotly figure object to plot on. If not provided, a new figure will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A Plotly figure object containing the generated plot.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.with_matplotlib","title":"with_matplotlib","text":"<pre><code>with_matplotlib(data: DataFrame, mode: Literal['bar', 'line'] = 'bar', colors: ColorType = 'viridis', title: str = '', ylabel: str = '', xlabel: str = 'Time in h', figsize: tuple[int, int] = (12, 6), fig: Figure | None = None, ax: Axes | None = None) -&gt; tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plot a DataFrame with Matplotlib using stacked bars or stepped lines.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame containing the data to plot. The index should represent time (e.g., hours),   and each column represents a separate data series.</p> required <code>mode</code> <code>Literal['bar', 'line']</code> <p>Plotting mode. Use 'bar' for stacked bar charts or 'line' for stepped lines.</p> <code>'bar'</code> <code>colors</code> <code>ColorType</code> <p>Color specification, can be: - A string with a colormap name (e.g., 'viridis', 'plasma') - A list of color strings (e.g., ['#ff0000', '#00ff00']) - A dictionary mapping column names to colors (e.g., {'Column1': '#ff0000'})</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The title of the plot.</p> <code>''</code> <code>ylabel</code> <code>str</code> <p>The ylabel of the plot.</p> <code>''</code> <code>xlabel</code> <code>str</code> <p>The xlabel of the plot.</p> <code>'Time in h'</code> <code>figsize</code> <code>tuple[int, int]</code> <p>Specify the size of the figure</p> <code>(12, 6)</code> <code>fig</code> <code>Figure | None</code> <p>A Matplotlib figure object to plot on. If not provided, a new figure will be created.</p> <code>None</code> <code>ax</code> <code>Axes | None</code> <p>A Matplotlib axes object to plot on. If not provided, a new axes will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Figure, Axes]</code> <p>A tuple containing the Matplotlib figure and axes objects used for the plot.</p> Notes <ul> <li>If <code>mode</code> is 'bar', bars are stacked for both positive and negative values.   Negative values are stacked separately without extra labels in the legend.</li> <li>If <code>mode</code> is 'line', stepped lines are drawn for each data series.</li> <li>The legend is placed below the plot to accommodate multiple data series.</li> </ul>"},{"location":"api-reference/plotting/#flixopt.plotting.heat_map_matplotlib","title":"heat_map_matplotlib","text":"<pre><code>heat_map_matplotlib(data: DataFrame, color_map: str = 'viridis', title: str = '', xlabel: str = 'Period', ylabel: str = 'Step', figsize: tuple[float, float] = (12, 6)) -&gt; tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plots a DataFrame as a heatmap using Matplotlib. The columns of the DataFrame will be displayed on the x-axis, the index will be displayed on the y-axis, and the values will represent the 'heat' intensity in the plot.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame containing the data to be visualized. The index will be used for the y-axis, and columns will be used for the x-axis. The values in the DataFrame will be represented as colors in the heatmap.</p> required <code>color_map</code> <code>str</code> <p>The colormap to use for the heatmap. Default is 'viridis'. Matplotlib supports various colormaps like 'plasma', 'inferno', 'cividis', etc.</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The title of the plot.</p> <code>''</code> <code>xlabel</code> <code>str</code> <p>The label for the x-axis.</p> <code>'Period'</code> <code>ylabel</code> <code>str</code> <p>The label for the y-axis.</p> <code>'Step'</code> <code>figsize</code> <code>tuple[float, float]</code> <p>The size of the figure to create. Default is (12, 6), which results in a width of 12 inches and a height of 6 inches.</p> <code>(12, 6)</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A tuple containing the Matplotlib <code>Figure</code> and <code>Axes</code> objects. The <code>Figure</code> contains the overall plot, while the <code>Axes</code> is the area</p> <code>Axes</code> <p>where the heatmap is drawn. These can be used for further customization or saving the plot to a file.</p> Notes <ul> <li>The y-axis is flipped so that the first row of the DataFrame is displayed at the top of the plot.</li> <li>The color scale is normalized based on the minimum and maximum values in the DataFrame.</li> <li>The x-axis labels (periods) are placed at the top of the plot.</li> <li>The colorbar is added horizontally at the bottom of the plot, with a label.</li> </ul>"},{"location":"api-reference/plotting/#flixopt.plotting.heat_map_plotly","title":"heat_map_plotly","text":"<pre><code>heat_map_plotly(data: DataFrame, color_map: str = 'viridis', title: str = '', xlabel: str = 'Period', ylabel: str = 'Step', categorical_labels: bool = True) -&gt; go.Figure\n</code></pre> <p>Plots a DataFrame as a heatmap using Plotly. The columns of the DataFrame will be mapped to the x-axis, and the index will be displayed on the y-axis. The values in the DataFrame will represent the 'heat' in the plot.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame with the data to be visualized. The index will be used for the y-axis, and columns will be used for the x-axis. The values in the DataFrame will be represented as colors in the heatmap.</p> required <code>color_map</code> <code>str</code> <p>The color scale to use for the heatmap. Default is 'viridis'. Plotly supports various color scales like 'Cividis', 'Inferno', etc.</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The title of the heatmap. Default is an empty string.</p> <code>''</code> <code>xlabel</code> <code>str</code> <p>The label for the x-axis. Default is 'Period'.</p> <code>'Period'</code> <code>ylabel</code> <code>str</code> <p>The label for the y-axis. Default is 'Step'.</p> <code>'Step'</code> <code>categorical_labels</code> <code>bool</code> <p>If True, the x and y axes are treated as categorical data (i.e., the index and columns will not be interpreted as continuous data). Default is True. If False, the axes are treated as continuous, which may be useful for time series or numeric data.</p> <code>True</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A Plotly figure object containing the heatmap. This can be further customized and saved</p> <code>Figure</code> <p>or displayed using <code>fig.show()</code>.</p> Notes <p>The color bar is automatically scaled to the minimum and maximum values in the data. The y-axis is reversed to display the first row at the top.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.reshape_to_2d","title":"reshape_to_2d","text":"<pre><code>reshape_to_2d(data_1d: ndarray, nr_of_steps_per_column: int) -&gt; np.ndarray\n</code></pre> <p>Reshapes a 1D numpy array into a 2D array suitable for plotting as a colormap.</p> <p>The reshaped array will have the number of rows corresponding to the steps per column (e.g., 24 hours per day) and columns representing time periods (e.g., days or months).</p> <p>Parameters:</p> Name Type Description Default <code>data_1d</code> <code>ndarray</code> <p>A 1D numpy array with the data to reshape.</p> required <code>nr_of_steps_per_column</code> <code>int</code> <p>The number of steps (rows) per column in the resulting 2D array. For example, this could be 24 (for hours) or 31 (for days in a month).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The reshaped 2D array. Each internal array corresponds to one column, with the specified number of steps.</p> <code>ndarray</code> <p>Each column might represents a time period (e.g., day, month, etc.).</p>"},{"location":"api-reference/plotting/#flixopt.plotting.heat_map_data_from_df","title":"heat_map_data_from_df","text":"<pre><code>heat_map_data_from_df(df: DataFrame, periods: Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'], steps_per_period: Literal['W', 'D', 'h', '15min', 'min'], fill: Literal['ffill', 'bfill'] | None = None) -&gt; pd.DataFrame\n</code></pre> <p>Reshapes a DataFrame with a DateTime index into a 2D array for heatmap plotting, based on a specified sample rate. Only specific combinations of <code>periods</code> and <code>steps_per_period</code> are supported; invalid combinations raise an assertion.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A DataFrame with a DateTime index containing the data to reshape.</p> required <code>periods</code> <code>Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min']</code> <p>The time interval of each period (columns of the heatmap), such as 'YS' (year start), 'W' (weekly), 'D' (daily), 'h' (hourly) etc.</p> required <code>steps_per_period</code> <code>Literal['W', 'D', 'h', '15min', 'min']</code> <p>The time interval within each period (rows in the heatmap), such as 'YS' (year start), 'W' (weekly), 'D' (daily), 'h' (hourly) etc.</p> required <code>fill</code> <code>Literal['ffill', 'bfill'] | None</code> <p>Method to fill missing values: 'ffill' for forward fill or 'bfill' for backward fill.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame suitable for heatmap plotting, with rows representing steps within each period</p> <code>DataFrame</code> <p>and columns representing each period.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.plot_network","title":"plot_network","text":"<pre><code>plot_network(node_infos: dict, edge_infos: dict, path: str | Path | None = None, controls: bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']] = True, show: bool = False) -&gt; pyvis.network.Network | None\n</code></pre> <p>Visualizes the network structure of a FlowSystem using PyVis, using info-dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path | None</code> <p>Path to save the HTML visualization. <code>False</code>: Visualization is created but not saved. <code>str</code> or <code>Path</code>: Specifies file path (default: 'results/network.html').</p> <code>None</code> <code>controls</code> <code>bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]</code> <p>UI controls to add to the visualization. <code>True</code>: Enables all available controls. <code>list</code>: Specify controls, e.g., ['nodes', 'layout']. Options: 'nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer'. You can play with these and generate a Dictionary from it that can be applied to the network returned by this function. network.set_options() https://pyvis.readthedocs.io/en/latest/tutorial.html</p> <code>True</code> <code>show</code> <code>bool</code> <p>Whether to open the visualization in the web browser. The calculation must be saved to show it. If no path is given, it defaults to 'network.html'.</p> <code>False</code> <p>Returns:     The <code>Network</code> instance representing the visualization, or <code>None</code> if <code>pyvis</code> is not installed.</p> <p>Notes: - This function requires <code>pyvis</code>. If not installed, the function prints a warning and returns <code>None</code>. - Nodes are styled based on type (e.g., circles for buses, boxes for components) and annotated with node information.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.pie_with_plotly","title":"pie_with_plotly","text":"<pre><code>pie_with_plotly(data: DataFrame, colors: ColorType = 'viridis', title: str = '', legend_title: str = '', hole: float = 0.0, fig: Figure | None = None) -&gt; go.Figure\n</code></pre> <p>Create a pie chart with Plotly to visualize the proportion of values in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame containing the data to plot. If multiple rows exist,   they will be summed unless a specific index value is passed.</p> required <code>colors</code> <code>ColorType</code> <p>Color specification, can be: - A string with a colorscale name (e.g., 'viridis', 'plasma') - A list of color strings (e.g., ['#ff0000', '#00ff00']) - A dictionary mapping column names to colors (e.g., {'Column1': '#ff0000'})</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The title of the plot.</p> <code>''</code> <code>legend_title</code> <code>str</code> <p>The title for the legend.</p> <code>''</code> <code>hole</code> <code>float</code> <p>Size of the hole in the center for creating a donut chart (0.0 to 1.0).</p> <code>0.0</code> <code>fig</code> <code>Figure | None</code> <p>A Plotly figure object to plot on. If not provided, a new figure will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A Plotly figure object containing the generated pie chart.</p> Notes <ul> <li>Negative values are not appropriate for pie charts and will be converted to absolute values with a warning.</li> <li>If the data contains very small values (less than 1% of the total), they can be grouped into an \"Other\" category   for better readability.</li> <li>By default, the sum of all columns is used for the pie chart. For time series data, consider preprocessing.</li> </ul>"},{"location":"api-reference/plotting/#flixopt.plotting.pie_with_matplotlib","title":"pie_with_matplotlib","text":"<pre><code>pie_with_matplotlib(data: DataFrame, colors: ColorType = 'viridis', title: str = '', legend_title: str = 'Categories', hole: float = 0.0, figsize: tuple[int, int] = (10, 8), fig: Figure | None = None, ax: Axes | None = None) -&gt; tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Create a pie chart with Matplotlib to visualize the proportion of values in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A DataFrame containing the data to plot. If multiple rows exist,   they will be summed unless a specific index value is passed.</p> required <code>colors</code> <code>ColorType</code> <p>Color specification, can be: - A string with a colormap name (e.g., 'viridis', 'plasma') - A list of color strings (e.g., ['#ff0000', '#00ff00']) - A dictionary mapping column names to colors (e.g., {'Column1': '#ff0000'})</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The title of the plot.</p> <code>''</code> <code>legend_title</code> <code>str</code> <p>The title for the legend.</p> <code>'Categories'</code> <code>hole</code> <code>float</code> <p>Size of the hole in the center for creating a donut chart (0.0 to 1.0).</p> <code>0.0</code> <code>figsize</code> <code>tuple[int, int]</code> <p>The size of the figure (width, height) in inches.</p> <code>(10, 8)</code> <code>fig</code> <code>Figure | None</code> <p>A Matplotlib figure object to plot on. If not provided, a new figure will be created.</p> <code>None</code> <code>ax</code> <code>Axes | None</code> <p>A Matplotlib axes object to plot on. If not provided, a new axes will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Figure, Axes]</code> <p>A tuple containing the Matplotlib figure and axes objects used for the plot.</p> Notes <ul> <li>Negative values are not appropriate for pie charts and will be converted to absolute values with a warning.</li> <li>If the data contains very small values (less than 1% of the total), they can be grouped into an \"Other\" category   for better readability.</li> <li>By default, the sum of all columns is used for the pie chart. For time series data, consider preprocessing.</li> </ul>"},{"location":"api-reference/plotting/#flixopt.plotting.dual_pie_with_plotly","title":"dual_pie_with_plotly","text":"<pre><code>dual_pie_with_plotly(data_left: Series, data_right: Series, colors: ColorType = 'viridis', title: str = '', subtitles: tuple[str, str] = ('Left Chart', 'Right Chart'), legend_title: str = '', hole: float = 0.2, lower_percentage_group: float = 5.0, hover_template: str = '%{label}: %{value} (%{percent})', text_info: str = 'percent+label', text_position: str = 'inside') -&gt; go.Figure\n</code></pre> <p>Create two pie charts side by side with Plotly, with consistent coloring across both charts.</p> <p>Parameters:</p> Name Type Description Default <code>data_left</code> <code>Series</code> <p>Series for the left pie chart.</p> required <code>data_right</code> <code>Series</code> <p>Series for the right pie chart.</p> required <code>colors</code> <code>ColorType</code> <p>Color specification, can be: - A string with a colorscale name (e.g., 'viridis', 'plasma') - A list of color strings (e.g., ['#ff0000', '#00ff00']) - A dictionary mapping category names to colors (e.g., {'Category1': '#ff0000'})</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The main title of the plot.</p> <code>''</code> <code>subtitles</code> <code>tuple[str, str]</code> <p>Tuple containing the subtitles for (left, right) charts.</p> <code>('Left Chart', 'Right Chart')</code> <code>legend_title</code> <code>str</code> <p>The title for the legend.</p> <code>''</code> <code>hole</code> <code>float</code> <p>Size of the hole in the center for creating donut charts (0.0 to 1.0).</p> <code>0.2</code> <code>lower_percentage_group</code> <code>float</code> <p>Group segments whose cumulative share is below this percentage (0\u2013100) into \"Other\".</p> <code>5.0</code> <code>hover_template</code> <code>str</code> <p>Template for hover text. Use %{label}, %{value}, %{percent}.</p> <code>'%{label}: %{value} (%{percent})'</code> <code>text_info</code> <code>str</code> <p>What to show on pie segments: 'label', 'percent', 'value', 'label+percent',       'label+value', 'percent+value', 'label+percent+value', or 'none'.</p> <code>'percent+label'</code> <code>text_position</code> <code>str</code> <p>Position of text: 'inside', 'outside', 'auto', or 'none'.</p> <code>'inside'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A Plotly figure object containing the generated dual pie chart.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.dual_pie_with_matplotlib","title":"dual_pie_with_matplotlib","text":"<pre><code>dual_pie_with_matplotlib(data_left: Series, data_right: Series, colors: ColorType = 'viridis', title: str = '', subtitles: tuple[str, str] = ('Left Chart', 'Right Chart'), legend_title: str = '', hole: float = 0.2, lower_percentage_group: float = 5.0, figsize: tuple[int, int] = (14, 7), fig: Figure | None = None, axes: list[Axes] | None = None) -&gt; tuple[plt.Figure, list[plt.Axes]]\n</code></pre> <p>Create two pie charts side by side with Matplotlib, with consistent coloring across both charts. Leverages the existing pie_with_matplotlib function.</p> <p>Parameters:</p> Name Type Description Default <code>data_left</code> <code>Series</code> <p>Series for the left pie chart.</p> required <code>data_right</code> <code>Series</code> <p>Series for the right pie chart.</p> required <code>colors</code> <code>ColorType</code> <p>Color specification, can be: - A string with a colormap name (e.g., 'viridis', 'plasma') - A list of color strings (e.g., ['#ff0000', '#00ff00']) - A dictionary mapping category names to colors (e.g., {'Category1': '#ff0000'})</p> <code>'viridis'</code> <code>title</code> <code>str</code> <p>The main title of the plot.</p> <code>''</code> <code>subtitles</code> <code>tuple[str, str]</code> <p>Tuple containing the subtitles for (left, right) charts.</p> <code>('Left Chart', 'Right Chart')</code> <code>legend_title</code> <code>str</code> <p>The title for the legend.</p> <code>''</code> <code>hole</code> <code>float</code> <p>Size of the hole in the center for creating donut charts (0.0 to 1.0).</p> <code>0.2</code> <code>lower_percentage_group</code> <code>float</code> <p>Whether to group small segments (below percentage) into an \"Other\" category.</p> <code>5.0</code> <code>figsize</code> <code>tuple[int, int]</code> <p>The size of the figure (width, height) in inches.</p> <code>(14, 7)</code> <code>fig</code> <code>Figure | None</code> <p>A Matplotlib figure object to plot on. If not provided, a new figure will be created.</p> <code>None</code> <code>axes</code> <code>list[Axes] | None</code> <p>A list of Matplotlib axes objects to plot on. If not provided, new axes will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Figure, list[Axes]]</code> <p>A tuple containing the Matplotlib figure and list of axes objects used for the plot.</p>"},{"location":"api-reference/plotting/#flixopt.plotting.export_figure","title":"export_figure","text":"<pre><code>export_figure(figure_like: Figure | tuple[Figure, Axes], default_path: Path, default_filetype: str | None = None, user_path: Path | None = None, show: bool = True, save: bool = False) -&gt; go.Figure | tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Export a figure to a file and or show it.</p> <p>Parameters:</p> Name Type Description Default <code>figure_like</code> <code>Figure | tuple[Figure, Axes]</code> <p>The figure to export. Can be a Plotly figure or a tuple of Matplotlib figure and axes.</p> required <code>default_path</code> <code>Path</code> <p>The default file path if no user filename is provided.</p> required <code>default_filetype</code> <code>str | None</code> <p>The default filetype if the path doesnt end with a filetype.</p> <code>None</code> <code>user_path</code> <code>Path | None</code> <p>An optional user-specified file path.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Whether to display the figure (default: True).</p> <code>True</code> <code>save</code> <code>bool</code> <p>Whether to save the figure (default: False).</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no default filetype is provided and the path doesn't specify a filetype.</p> <code>TypeError</code> <p>If the figure type is not supported.</p>"},{"location":"api-reference/results/","title":"results","text":""},{"location":"api-reference/results/#flixopt.results","title":"flixopt.results","text":""},{"location":"api-reference/results/#flixopt.results-classes","title":"Classes","text":""},{"location":"api-reference/results/#flixopt.results.CalculationResults","title":"CalculationResults","text":"<pre><code>CalculationResults(solution: Dataset, flow_system: Dataset, name: str, summary: dict, folder: Path | None = None, model: Model | None = None)\n</code></pre> <p>Comprehensive container for optimization calculation results and analysis tools.</p> <p>This class provides unified access to all optimization results including flow rates, component states, bus balances, and system effects. It offers powerful analysis capabilities through filtering, plotting, and export functionality, making it the primary interface for post-processing optimization results.</p> Key Features <p>Unified Access: Single interface to all solution variables and constraints Element Results: Direct access to component, bus, and effect-specific results Visualization: Built-in plotting methods for heatmaps, time series, and networks Persistence: Save/load functionality with compression for large datasets Analysis Tools: Filtering, aggregation, and statistical analysis methods</p> Result Organization <ul> <li>Components: Equipment-specific results (flows, states, constraints)</li> <li>Buses: Network node balances and energy flows</li> <li>Effects: System-wide impacts (costs, emissions, resource consumption)</li> <li>Solution: Raw optimization variables and their values</li> <li>Metadata: Calculation parameters, timing, and system configuration</li> </ul> <p>Attributes:</p> Name Type Description <code>solution</code> <p>Dataset containing all optimization variable solutions</p> <code>flow_system</code> <p>Dataset with complete system configuration and parameters. Restore the used FlowSystem for further analysis.</p> <code>summary</code> <p>Calculation metadata including solver status, timing, and statistics</p> <code>name</code> <p>Unique identifier for this calculation</p> <code>model</code> <p>Original linopy optimization model (if available)</p> <code>folder</code> <p>Directory path for result storage and loading</p> <code>components</code> <p>Dictionary mapping component labels to ComponentResults objects</p> <code>buses</code> <p>Dictionary mapping bus labels to BusResults objects</p> <code>effects</code> <p>Dictionary mapping effect names to EffectResults objects</p> <code>timesteps_extra</code> <p>Extended time index including boundary conditions</p> <code>hours_per_timestep</code> <p>Duration of each timestep for proper energy calculations</p> <p>Examples:</p> <p>Load and analyze saved results:</p> <pre><code># Load results from file\nresults = CalculationResults.from_file('results', 'annual_optimization')\n\n# Access specific component results\nboiler_results = results['Boiler_01']\nheat_pump_results = results['HeatPump_02']\n\n# Plot component flow rates\nresults.plot_heatmap('Boiler_01(Natural_Gas)|flow_rate')\nresults['Boiler_01'].plot_node_balance()\n\n# Access raw solution dataarrays\nelectricity_flows = results.solution[['Generator_01(Grid)|flow_rate', 'HeatPump_02(Grid)|flow_rate']]\n\n# Filter and analyze results\npeak_demand_hours = results.filter_solution(variable_dims='time')\ncosts_solution = results.effects['cost'].solution\n</code></pre> <p>Advanced filtering and aggregation:</p> <pre><code># Filter by variable type\nscalar_results = results.filter_solution(variable_dims='scalar')\ntime_series = results.filter_solution(variable_dims='time')\n\n# Custom data analysis leveraging xarray\npeak_power = results.solution['Generator_01(Grid)|flow_rate'].max()\navg_efficiency = (\n    results.solution['HeatPump(Heat)|flow_rate'] / results.solution['HeatPump(Electricity)|flow_rate']\n).mean()\n</code></pre> Design Patterns <p>Factory Methods: Use <code>from_file()</code> and <code>from_calculation()</code> for creation or access directly from <code>Calculation.results</code> Dictionary Access: Use <code>results[element_label]</code> for element-specific results Lazy Loading: Results objects created on-demand for memory efficiency Unified Interface: Consistent API across different result types</p> <p>Initialize CalculationResults with optimization data. Usually, this class is instantiated by the Calculation class, or by loading from file.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>Dataset</code> <p>Optimization solution dataset.</p> required <code>flow_system</code> <code>Dataset</code> <p>Flow system configuration dataset.</p> required <code>name</code> <code>str</code> <p>Calculation name.</p> required <code>summary</code> <code>dict</code> <p>Calculation metadata.</p> required <code>folder</code> <code>Path | None</code> <p>Results storage folder.</p> <code>None</code> <code>model</code> <code>Model | None</code> <p>Linopy optimization model.</p> <code>None</code>"},{"location":"api-reference/results/#flixopt.results.CalculationResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.CalculationResults.storages","title":"storages  <code>property</code>","text":"<pre><code>storages: list[ComponentResults]\n</code></pre> <p>Get all storage components in the results.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.objective","title":"objective  <code>property</code>","text":"<pre><code>objective: float\n</code></pre> <p>Get optimization objective value.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>Get optimization variables (requires linopy model).</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>Get optimization constraints (requires linopy model).</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.CalculationResults.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(folder: str | Path, name: str) -&gt; CalculationResults\n</code></pre> <p>Load CalculationResults from saved files.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path</code> <p>Directory containing saved files.</p> required <code>name</code> <code>str</code> <p>Base name of saved files (without extensions).</p> required <p>Returns:</p> Name Type Description <code>CalculationResults</code> <code>CalculationResults</code> <p>Loaded instance.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.from_calculation","title":"from_calculation  <code>classmethod</code>","text":"<pre><code>from_calculation(calculation: Calculation) -&gt; CalculationResults\n</code></pre> <p>Create CalculationResults from a Calculation object.</p> <p>Parameters:</p> Name Type Description Default <code>calculation</code> <code>Calculation</code> <p>Calculation object with solved model.</p> required <p>Returns:</p> Name Type Description <code>CalculationResults</code> <code>CalculationResults</code> <p>New instance with extracted results.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.filter_solution","title":"filter_solution","text":"<pre><code>filter_solution(variable_dims: Literal['scalar', 'time'] | None = None, element: str | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter solution by variable dimension and/or element.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Literal['scalar', 'time'] | None</code> <p>Variable dimension to filter ('scalar' or 'time').</p> <code>None</code> <code>element</code> <code>str | None</code> <p>Element label to filter.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Filtered solution dataset.</p>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.plot_network","title":"plot_network","text":"<pre><code>plot_network(controls: bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']] = True, path: Path | None = None, show: bool = False) -&gt; pyvis.network.Network | None\n</code></pre> <p>Plot interactive network visualization of the system.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>bool | list[Literal['nodes', 'edges', 'layout', 'interaction', 'manipulation', 'physics', 'selection', 'renderer']]</code> <p>Enable/disable interactive controls.</p> <code>True</code> <code>path</code> <code>Path | None</code> <p>Save path for network HTML.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Whether to display the plot.</p> <code>False</code>"},{"location":"api-reference/results/#flixopt.results.CalculationResults.to_file","title":"to_file","text":"<pre><code>to_file(folder: str | Path | None = None, name: str | None = None, compression: int = 5, document_model: bool = True, save_linopy_model: bool = False)\n</code></pre> <p>Save results to files.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path | None</code> <p>Save folder (defaults to calculation folder).</p> <code>None</code> <code>name</code> <code>str | None</code> <p>File name (defaults to calculation name).</p> <code>None</code> <code>compression</code> <code>int</code> <p>Compression level 0-9.</p> <code>5</code> <code>document_model</code> <code>bool</code> <p>Whether to document model formulations as yaml.</p> <code>True</code> <code>save_linopy_model</code> <code>bool</code> <p>Whether to save linopy model file.</p> <code>False</code>"},{"location":"api-reference/results/#flixopt.results.BusResults","title":"BusResults","text":"<pre><code>BusResults(calculation_results: CalculationResults, label: str, variables: list[str], constraints: list[str], inputs: list[str], outputs: list[str])\n</code></pre> <p>               Bases: <code>_NodeResults</code></p> <p>Results container for energy/material balance nodes in the system.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.BusResults.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>Get element variables (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>Get element constraints (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.BusResults.filter_solution","title":"filter_solution","text":"<pre><code>filter_solution(variable_dims: Literal['scalar', 'time'] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter element solution by dimension.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Literal['scalar', 'time'] | None</code> <p>Variable dimension to filter.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Filtered solution dataset.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults.plot_node_balance","title":"plot_node_balance","text":"<pre><code>plot_node_balance(save: bool | Path = False, show: bool = True, colors: ColorType = 'viridis', engine: PlottingEngine = 'plotly') -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plot node balance flows.</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool | Path</code> <p>Whether to save plot (path or boolean).</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to display plot.</p> <code>True</code> <code>colors</code> <code>ColorType</code> <p>Color scheme. Also see plotly.</p> <code>'viridis'</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine ('plotly' or 'matplotlib').</p> <code>'plotly'</code> <p>Returns:</p> Type Description <code>Figure | tuple[Figure, Axes]</code> <p>Figure object.</p>"},{"location":"api-reference/results/#flixopt.results.BusResults.plot_node_balance_pie","title":"plot_node_balance_pie","text":"<pre><code>plot_node_balance_pie(lower_percentage_group: float = 5, colors: ColorType = 'viridis', text_info: str = 'percent+label+value', save: bool | Path = False, show: bool = True, engine: PlottingEngine = 'plotly') -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, list[plt.Axes]]\n</code></pre> <p>Plot pie chart of flow hours distribution.</p> <p>Parameters:</p> Name Type Description Default <code>lower_percentage_group</code> <code>float</code> <p>Percentage threshold for \"Others\" grouping.</p> <code>5</code> <code>colors</code> <code>ColorType</code> <p>Color scheme. Also see plotly.</p> <code>'viridis'</code> <code>text_info</code> <code>str</code> <p>Information to display on pie slices.</p> <code>'percent+label+value'</code> <code>save</code> <code>bool | Path</code> <p>Whether to save plot.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to display plot.</p> <code>True</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine ('plotly' or 'matplotlib').</p> <code>'plotly'</code>"},{"location":"api-reference/results/#flixopt.results.ComponentResults","title":"ComponentResults","text":"<pre><code>ComponentResults(calculation_results: CalculationResults, label: str, variables: list[str], constraints: list[str], inputs: list[str], outputs: list[str])\n</code></pre> <p>               Bases: <code>_NodeResults</code></p> <p>Results container for individual system components with specialized analysis tools.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.ComponentResults.charge_state","title":"charge_state  <code>property</code>","text":"<pre><code>charge_state: DataArray\n</code></pre> <p>Get storage charge state solution.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>Get element variables (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>Get element constraints (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.ComponentResults.plot_charge_state","title":"plot_charge_state","text":"<pre><code>plot_charge_state(save: bool | Path = False, show: bool = True, colors: ColorType = 'viridis', engine: PlottingEngine = 'plotly') -&gt; plotly.graph_objs.Figure\n</code></pre> <p>Plot storage charge state over time, combined with the node balance.</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool | Path</code> <p>Whether to save plot.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to display plot.</p> <code>True</code> <code>colors</code> <code>ColorType</code> <p>Color scheme. Also see plotly.</p> <code>'viridis'</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine (only 'plotly' supported).</p> <code>'plotly'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>plotly.graph_objs.Figure: Charge state plot.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If component is not a storage.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.node_balance_with_charge_state","title":"node_balance_with_charge_state","text":"<pre><code>node_balance_with_charge_state(negate_inputs: bool = True, negate_outputs: bool = False, threshold: float | None = 1e-05) -&gt; xr.Dataset\n</code></pre> <p>Get storage node balance including charge state.</p> <p>Parameters:</p> Name Type Description Default <code>negate_inputs</code> <code>bool</code> <p>Whether to negate input flows.</p> <code>True</code> <code>negate_outputs</code> <code>bool</code> <p>Whether to negate output flows.</p> <code>False</code> <code>threshold</code> <code>float | None</code> <p>Threshold for small values.</p> <code>1e-05</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Node balance with charge state.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If component is not a storage.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.filter_solution","title":"filter_solution","text":"<pre><code>filter_solution(variable_dims: Literal['scalar', 'time'] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter element solution by dimension.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Literal['scalar', 'time'] | None</code> <p>Variable dimension to filter.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Filtered solution dataset.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.plot_node_balance","title":"plot_node_balance","text":"<pre><code>plot_node_balance(save: bool | Path = False, show: bool = True, colors: ColorType = 'viridis', engine: PlottingEngine = 'plotly') -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plot node balance flows.</p> <p>Parameters:</p> Name Type Description Default <code>save</code> <code>bool | Path</code> <p>Whether to save plot (path or boolean).</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to display plot.</p> <code>True</code> <code>colors</code> <code>ColorType</code> <p>Color scheme. Also see plotly.</p> <code>'viridis'</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine ('plotly' or 'matplotlib').</p> <code>'plotly'</code> <p>Returns:</p> Type Description <code>Figure | tuple[Figure, Axes]</code> <p>Figure object.</p>"},{"location":"api-reference/results/#flixopt.results.ComponentResults.plot_node_balance_pie","title":"plot_node_balance_pie","text":"<pre><code>plot_node_balance_pie(lower_percentage_group: float = 5, colors: ColorType = 'viridis', text_info: str = 'percent+label+value', save: bool | Path = False, show: bool = True, engine: PlottingEngine = 'plotly') -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, list[plt.Axes]]\n</code></pre> <p>Plot pie chart of flow hours distribution.</p> <p>Parameters:</p> Name Type Description Default <code>lower_percentage_group</code> <code>float</code> <p>Percentage threshold for \"Others\" grouping.</p> <code>5</code> <code>colors</code> <code>ColorType</code> <p>Color scheme. Also see plotly.</p> <code>'viridis'</code> <code>text_info</code> <code>str</code> <p>Information to display on pie slices.</p> <code>'percent+label+value'</code> <code>save</code> <code>bool | Path</code> <p>Whether to save plot.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to display plot.</p> <code>True</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine ('plotly' or 'matplotlib').</p> <code>'plotly'</code>"},{"location":"api-reference/results/#flixopt.results.EffectResults","title":"EffectResults","text":"<pre><code>EffectResults(calculation_results: CalculationResults, label: str, variables: list[str], constraints: list[str])\n</code></pre> <p>               Bases: <code>_ElementResults</code></p> <p>Results for an Effect</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults-attributes","title":"Attributes","text":""},{"location":"api-reference/results/#flixopt.results.EffectResults.variables","title":"variables  <code>property</code>","text":"<pre><code>variables: Variables\n</code></pre> <p>Get element variables (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults.constraints","title":"constraints  <code>property</code>","text":"<pre><code>constraints: Constraints\n</code></pre> <p>Get element constraints (requires linopy model).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If linopy model is unavailable.</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.EffectResults.get_shares_from","title":"get_shares_from","text":"<pre><code>get_shares_from(element: str)\n</code></pre> <p>Get effect shares from specific element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>Element label to get shares from.</p> required <p>Returns:</p> Type Description <p>xr.Dataset: Element shares to this effect.</p>"},{"location":"api-reference/results/#flixopt.results.EffectResults.filter_solution","title":"filter_solution","text":"<pre><code>filter_solution(variable_dims: Literal['scalar', 'time'] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter element solution by dimension.</p> <p>Parameters:</p> Name Type Description Default <code>variable_dims</code> <code>Literal['scalar', 'time'] | None</code> <p>Variable dimension to filter.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Filtered solution dataset.</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults","title":"SegmentedCalculationResults","text":"<pre><code>SegmentedCalculationResults(segment_results: list[CalculationResults], all_timesteps: DatetimeIndex, timesteps_per_segment: int, overlap_timesteps: int, name: str, folder: Path | None = None)\n</code></pre> <p>Results container for segmented optimization calculations with temporal decomposition.</p> <p>This class manages results from SegmentedCalculation runs where large optimization problems are solved by dividing the time horizon into smaller, overlapping segments. It provides unified access to results across all segments while maintaining the ability to analyze individual segment behavior.</p> Key Features <p>Unified Time Series: Automatically assembles results from all segments into continuous time series, removing overlaps and boundary effects Segment Analysis: Access individual segment results for debugging and validation Consistency Checks: Verify solution continuity at segment boundaries Memory Efficiency: Handles large datasets that exceed single-segment memory limits</p> Temporal Handling <p>The class manages the complex task of combining overlapping segment solutions into coherent time series, ensuring proper treatment of: - Storage state continuity between segments - Flow rate transitions at segment boundaries - Aggregated results over the full time horizon</p> <p>Examples:</p> <p>Load and analyze segmented results:</p> <pre><code># Load segmented calculation results\nresults = SegmentedCalculationResults.from_file('results', 'annual_segmented')\n\n# Access unified results across all segments\nfull_timeline = results.all_timesteps\ntotal_segments = len(results.segment_results)\n\n# Analyze individual segments\nfor i, segment in enumerate(results.segment_results):\n    print(f'Segment {i + 1}: {len(segment.solution.time)} timesteps')\n    segment_costs = segment.effects['cost'].total_value\n\n# Check solution continuity at boundaries\nsegment_boundaries = results.get_boundary_analysis()\nmax_discontinuity = segment_boundaries['max_storage_jump']\n</code></pre> <p>Create from segmented calculation:</p> <pre><code># After running segmented calculation\nsegmented_calc = SegmentedCalculation(\n    name='annual_system',\n    flow_system=system,\n    timesteps_per_segment=730,  # Monthly segments\n    overlap_timesteps=48,  # 2-day overlap\n)\nsegmented_calc.do_modeling_and_solve(solver='gurobi')\n\n# Extract unified results\nresults = SegmentedCalculationResults.from_calculation(segmented_calc)\n\n# Save combined results\nresults.to_file(compression=5)\n</code></pre> <p>Performance analysis across segments:</p> <pre><code># Compare segment solve times\nsolve_times = [seg.summary['durations']['solving'] for seg in results.segment_results]\navg_solve_time = sum(solve_times) / len(solve_times)\n\n# Verify solution quality consistency\nsegment_objectives = [seg.summary['objective_value'] for seg in results.segment_results]\n\n# Storage continuity analysis\nif 'Battery' in results.segment_results[0].components:\n    storage_continuity = results.check_storage_continuity('Battery')\n</code></pre> Design Considerations <p>Boundary Effects: Monitor solution quality at segment interfaces where foresight is limited compared to full-horizon optimization.</p> <p>Memory Management: Individual segment results are maintained for detailed analysis while providing unified access for system-wide metrics.</p> <p>Validation Tools: Built-in methods to verify temporal consistency and identify potential issues from segmentation approach.</p> Common Use Cases <ul> <li>Large-Scale Analysis: Annual or multi-year optimization results</li> <li>Memory-Constrained Systems: Results from systems exceeding hardware limits</li> <li>Segment Validation: Verifying segmentation approach effectiveness</li> <li>Performance Monitoring: Comparing segmented vs. full-horizon solutions</li> <li>Debugging: Identifying issues specific to temporal decomposition</li> </ul>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(folder: str | Path, name: str)\n</code></pre> <p>Load SegmentedCalculationResults from saved files.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path</code> <p>Directory containing saved files.</p> required <code>name</code> <code>str</code> <p>Base name of saved files.</p> required <p>Returns:</p> Name Type Description <code>SegmentedCalculationResults</code> <p>Loaded instance.</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults.solution_without_overlap","title":"solution_without_overlap","text":"<pre><code>solution_without_overlap(variable_name: str) -&gt; xr.DataArray\n</code></pre> <p>Get variable solution removing segment overlaps.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>Name of variable to extract.</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xr.DataArray: Continuous solution without overlaps.</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults.plot_heatmap","title":"plot_heatmap","text":"<pre><code>plot_heatmap(variable_name: str, heatmap_timeframes: Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'] = 'D', heatmap_timesteps_per_frame: Literal['W', 'D', 'h', '15min', 'min'] = 'h', color_map: str = 'portland', save: bool | Path = False, show: bool = True, engine: PlottingEngine = 'plotly') -&gt; plotly.graph_objs.Figure | tuple[plt.Figure, plt.Axes]\n</code></pre> <p>Plot heatmap of variable solution across segments.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>Variable to plot.</p> required <code>heatmap_timeframes</code> <code>Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min']</code> <p>Time aggregation level.</p> <code>'D'</code> <code>heatmap_timesteps_per_frame</code> <code>Literal['W', 'D', 'h', '15min', 'min']</code> <p>Timesteps per frame.</p> <code>'h'</code> <code>color_map</code> <code>str</code> <p>Color scheme. Also see plotly.</p> <code>'portland'</code> <code>save</code> <code>bool | Path</code> <p>Whether to save plot.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to display plot.</p> <code>True</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine.</p> <code>'plotly'</code> <p>Returns:</p> Type Description <code>Figure | tuple[Figure, Axes]</code> <p>Figure object.</p>"},{"location":"api-reference/results/#flixopt.results.SegmentedCalculationResults.to_file","title":"to_file","text":"<pre><code>to_file(folder: str | Path | None = None, name: str | None = None, compression: int = 5)\n</code></pre> <p>Save segmented results to files.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str | Path | None</code> <p>Save folder (defaults to instance folder).</p> <code>None</code> <code>name</code> <code>str | None</code> <p>File name (defaults to instance name).</p> <code>None</code> <code>compression</code> <code>int</code> <p>Compression level 0-9.</p> <code>5</code>"},{"location":"api-reference/results/#flixopt.results-functions","title":"Functions","text":""},{"location":"api-reference/results/#flixopt.results.plot_heatmap","title":"plot_heatmap","text":"<pre><code>plot_heatmap(dataarray: DataArray, name: str, folder: Path, heatmap_timeframes: Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min'] = 'D', heatmap_timesteps_per_frame: Literal['W', 'D', 'h', '15min', 'min'] = 'h', color_map: str = 'portland', save: bool | Path = False, show: bool = True, engine: PlottingEngine = 'plotly')\n</code></pre> <p>Plot heatmap of time series data.</p> <p>Parameters:</p> Name Type Description Default <code>dataarray</code> <code>DataArray</code> <p>Data to plot.</p> required <code>name</code> <code>str</code> <p>Variable name for title.</p> required <code>folder</code> <code>Path</code> <p>Save folder.</p> required <code>heatmap_timeframes</code> <code>Literal['YS', 'MS', 'W', 'D', 'h', '15min', 'min']</code> <p>Time aggregation level.</p> <code>'D'</code> <code>heatmap_timesteps_per_frame</code> <code>Literal['W', 'D', 'h', '15min', 'min']</code> <p>Timesteps per frame.</p> <code>'h'</code> <code>color_map</code> <code>str</code> <p>Color scheme. Also see plotly.</p> <code>'portland'</code> <code>save</code> <code>bool | Path</code> <p>Whether to save plot.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to display plot.</p> <code>True</code> <code>engine</code> <code>PlottingEngine</code> <p>Plotting engine.</p> <code>'plotly'</code> <p>Returns:</p> Type Description <p>Figure object.</p>"},{"location":"api-reference/results/#flixopt.results.sanitize_dataset","title":"sanitize_dataset","text":"<pre><code>sanitize_dataset(ds: Dataset, timesteps: DatetimeIndex | None = None, threshold: float | None = 1e-05, negate: list[str] | None = None, drop_small_vars: bool = True, zero_small_values: bool = False) -&gt; xr.Dataset\n</code></pre> <p>Clean dataset by handling small values and reindexing time.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset to sanitize.</p> required <code>timesteps</code> <code>DatetimeIndex | None</code> <p>Time index for reindexing (optional).</p> <code>None</code> <code>threshold</code> <code>float | None</code> <p>Threshold for small values processing.</p> <code>1e-05</code> <code>negate</code> <code>list[str] | None</code> <p>Variables to negate.</p> <code>None</code> <code>drop_small_vars</code> <code>bool</code> <p>Whether to drop variables below threshold.</p> <code>True</code> <code>zero_small_values</code> <code>bool</code> <p>Whether to zero values below threshold.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Sanitized dataset.</p>"},{"location":"api-reference/results/#flixopt.results.filter_dataset","title":"filter_dataset","text":"<pre><code>filter_dataset(ds: Dataset, variable_dims: Literal['scalar', 'time'] | None = None) -&gt; xr.Dataset\n</code></pre> <p>Filter dataset by variable dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>Dataset</code> <p>Dataset to filter.</p> required <code>variable_dims</code> <code>Literal['scalar', 'time'] | None</code> <p>Variable dimension to filter ('scalar' or 'time').</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>xr.Dataset: Filtered dataset.</p>"},{"location":"api-reference/solvers/","title":"solvers","text":""},{"location":"api-reference/solvers/#flixopt.solvers","title":"flixopt.solvers","text":"<p>This module contains the solvers of the flixopt framework, making them available to the end user in a compact way.</p>"},{"location":"api-reference/solvers/#flixopt.solvers-classes","title":"Classes","text":""},{"location":"api-reference/solvers/#flixopt.solvers.GurobiSolver","title":"GurobiSolver  <code>dataclass</code>","text":"<pre><code>GurobiSolver(mip_gap: float, time_limit_seconds: int, extra_options: dict[str, Any] = dict())\n</code></pre> <p>               Bases: <code>_Solver</code></p> <p>Gurobi solver configuration.</p> <p>Parameters:</p> Name Type Description Default <code>mip_gap</code> <code>float</code> <p>Acceptable relative optimality gap in [0.0, 1.0]; mapped to Gurobi <code>MIPGap</code>.</p> required <code>time_limit_seconds</code> <code>int</code> <p>Time limit in seconds; mapped to Gurobi <code>TimeLimit</code>.</p> required <code>extra_options</code> <code>dict[str, Any]</code> <p>Additional solver options merged into <code>options</code>.</p> <code>dict()</code>"},{"location":"api-reference/solvers/#flixopt.solvers.GurobiSolver-attributes","title":"Attributes","text":""},{"location":"api-reference/solvers/#flixopt.solvers.GurobiSolver.options","title":"options  <code>property</code>","text":"<pre><code>options: dict[str, Any]\n</code></pre> <p>Return a dictionary of solver options.</p>"},{"location":"api-reference/solvers/#flixopt.solvers.HighsSolver","title":"HighsSolver  <code>dataclass</code>","text":"<pre><code>HighsSolver(mip_gap: float, time_limit_seconds: int, extra_options: dict[str, Any] = dict())\n</code></pre> <p>               Bases: <code>_Solver</code></p> <p>HiGHS solver configuration.</p> <p>Attributes:</p> Name Type Description <code>mip_gap</code> <code>float</code> <p>Acceptable relative optimality gap in [0.0, 1.0]; mapped to HiGHS <code>mip_rel_gap</code>.</p> <code>time_limit_seconds</code> <code>int</code> <p>Time limit in seconds; mapped to HiGHS <code>time_limit</code>.</p> <code>extra_options</code> <code>dict[str, Any]</code> <p>Additional solver options merged into <code>options</code>.</p> <code>threads</code> <code>int | None</code> <p>Number of threads to use. If None, HiGHS chooses.</p>"},{"location":"api-reference/solvers/#flixopt.solvers.HighsSolver-attributes","title":"Attributes","text":""},{"location":"api-reference/solvers/#flixopt.solvers.HighsSolver.options","title":"options  <code>property</code>","text":"<pre><code>options: dict[str, Any]\n</code></pre> <p>Return a dictionary of solver options.</p>"},{"location":"api-reference/structure/","title":"structure","text":""},{"location":"api-reference/structure/#flixopt.structure","title":"flixopt.structure","text":"<p>This module contains the core structure of the flixopt framework. These classes are not directly used by the end user, but are used by other modules.</p>"},{"location":"api-reference/structure/#flixopt.structure-classes","title":"Classes","text":""},{"location":"api-reference/structure/#flixopt.structure.SystemModel","title":"SystemModel","text":"<pre><code>SystemModel(flow_system: FlowSystem)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>The SystemModel is the linopy Model that is used to create the mathematical model of the flow_system. It is used to create and store the variables and constraints for the flow_system.</p> <p>Parameters:</p> Name Type Description Default <code>flow_system</code> <code>FlowSystem</code> <p>The flow_system that is used to create the model.</p> required"},{"location":"api-reference/structure/#flixopt.structure.SystemModel-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Interface","title":"Interface","text":"<p>This class is used to collect arguments about a Model. Its the base class for all Elements and Models in flixopt.</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Interface.transform_data","title":"transform_data","text":"<pre><code>transform_data(flow_system: FlowSystem)\n</code></pre> <p>Transforms the data of the interface to match the FlowSystem's dimensions</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/structure/#flixopt.structure.Interface.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/structure/#flixopt.structure.Interface.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/structure/#flixopt.structure.Element","title":"Element","text":"<pre><code>Element(label: str, meta_data: dict | None = None)\n</code></pre> <p>               Bases: <code>Interface</code></p> <p>This class is the basic Element of flixopt. Every Element has a label</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the element</p> required <code>meta_data</code> <code>dict | None</code> <p>used to store more information about the Element. Is not used internally, but saved in the results. Only use python native types.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure.Element-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Element.transform_data","title":"transform_data","text":"<pre><code>transform_data(flow_system: FlowSystem)\n</code></pre> <p>Transforms the data of the interface to match the FlowSystem's dimensions</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.infos","title":"infos","text":"<pre><code>infos(use_numpy: bool = True, use_element_label: bool = False) -&gt; dict\n</code></pre> <p>Generate a dictionary representation of the object's constructor arguments. Excludes default values and empty dictionaries and lists. Converts data to be compatible with JSON.</p> <p>Parameters:</p> Name Type Description Default <code>use_numpy</code> <code>bool</code> <p>Whether to convert NumPy arrays to lists. Defaults to True. If True, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If False, they are converted to lists.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>Whether to use the element label instead of the infos of the element. Defaults to False. Note that Elements used as keys in dictionaries are always converted to their labels.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object's constructor arguments.</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.to_json","title":"to_json","text":"<pre><code>to_json(path: str | Path)\n</code></pre> <p>Saves the element to a json file. This not meant to be reloaded and recreate the object, but rather used to document or compare the object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The path to the json file.</p> required"},{"location":"api-reference/structure/#flixopt.structure.Element.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert the object to a dictionary representation.</p>"},{"location":"api-reference/structure/#flixopt.structure.Element.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; Interface\n</code></pre> <p>Create an instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary containing the data for the object.</p> required"},{"location":"api-reference/structure/#flixopt.structure.Model","title":"Model","text":"<pre><code>Model(model: SystemModel, label_of_element: str, label: str = '', label_full: str | None = None)\n</code></pre> <p>Stores Variables and Constraints.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>SystemModel</code> <p>The SystemModel that is used to create the model.</p> required <code>label_of_element</code> <code>str</code> <p>The label of the parent (Element). Used to construct the full label of the model.</p> required <code>label</code> <code>str</code> <p>The label of the model. Used to construct the full label of the model.</p> <code>''</code> <code>label_full</code> <code>str | None</code> <p>The full label of the model. Can overwrite the full label constructed from the other labels.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure.Model-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.Model.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/structure/#flixopt.structure.Model-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.Model.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel","title":"ElementModel","text":"<pre><code>ElementModel(model: SystemModel, element: Element)\n</code></pre> <p>               Bases: <code>Model</code></p> <p>Stores the mathematical Variables and Constraints for Elements</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>SystemModel</code> <p>The SystemModel that is used to create the model.</p> required <code>element</code> <code>Element</code> <p>The element this model is created for.</p> required"},{"location":"api-reference/structure/#flixopt.structure.ElementModel-attributes","title":"Attributes","text":""},{"location":"api-reference/structure/#flixopt.structure.ElementModel.label_full","title":"label_full  <code>property</code>","text":"<pre><code>label_full: str\n</code></pre> <p>Used to construct the names of variables and constraints</p>"},{"location":"api-reference/structure/#flixopt.structure.ElementModel-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.ElementModel.add","title":"add","text":"<pre><code>add(item: Variable | Constraint | Model, short_name: str | None = None) -&gt; linopy.Variable | linopy.Constraint | Model\n</code></pre> <p>Add a variable, constraint or sub-model to the model</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Variable | Constraint | Model</code> <p>The variable, constraint or sub-model to add to the model</p> required <code>short_name</code> <code>str | None</code> <p>The short name of the variable, constraint or sub-model. If not provided, the full name is used.</p> <code>None</code>"},{"location":"api-reference/structure/#flixopt.structure-functions","title":"Functions","text":""},{"location":"api-reference/structure/#flixopt.structure.register_class_for_io","title":"register_class_for_io","text":"<pre><code>register_class_for_io(cls)\n</code></pre> <p>Register a class for serialization/deserialization.</p>"},{"location":"api-reference/structure/#flixopt.structure.copy_and_convert_datatypes","title":"copy_and_convert_datatypes","text":"<pre><code>copy_and_convert_datatypes(data: Any, use_numpy: bool = True, use_element_label: bool = False) -&gt; Any\n</code></pre> <p>Converts values in a nested data structure into JSON-compatible types while preserving or transforming numpy arrays and custom <code>Element</code> objects based on the specified options.</p> <p>The function handles various data types and transforms them into a consistent, readable format: - Primitive types (<code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, <code>None</code>) are returned as-is. - Numpy scalars are converted to their corresponding Python scalar types. - Collections (<code>list</code>, <code>tuple</code>, <code>set</code>, <code>dict</code>) are recursively processed to ensure all elements are compatible. - Numpy arrays are preserved or converted to lists, depending on <code>use_numpy</code>. - Custom <code>Element</code> objects can be represented either by their <code>label</code> or their initialization parameters as a dictionary. - Timestamps (<code>datetime</code>) are converted to ISO 8601 strings.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data to process, which may be deeply nested and contain a mix of types.</p> required <code>use_numpy</code> <code>bool</code> <p>If <code>True</code>, numeric numpy arrays (<code>np.ndarray</code>) are preserved as-is. If <code>False</code>, they are converted to lists. Default is <code>True</code>.</p> <code>True</code> <code>use_element_label</code> <code>bool</code> <p>If <code>True</code>, <code>Element</code> objects are represented by their <code>label</code>. If <code>False</code>, they are converted into a dictionary based on their initialization parameters. Default is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Any</code> <p>A transformed version of the input data, containing only JSON-compatible types:</p> <code>Any</code> <ul> <li><code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, <code>None</code></li> </ul> <code>Any</code> <ul> <li><code>list</code>, <code>dict</code></li> </ul> <code>Any</code> <ul> <li><code>np.ndarray</code> (if <code>use_numpy=True</code>. This is NOT JSON-compatible)</li> </ul> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the data cannot be converted to the specified types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; copy_and_convert_datatypes({'a': np.array([1, 2, 3]), 'b': Element(label='example')})\n{'a': array([1, 2, 3]), 'b': {'class': 'Element', 'label': 'example'}}\n</code></pre> <pre><code>&gt;&gt;&gt; copy_and_convert_datatypes({'a': np.array([1, 2, 3]), 'b': Element(label='example')}, use_numpy=False)\n{'a': [1, 2, 3], 'b': {'class': 'Element', 'label': 'example'}}\n</code></pre> Notes <ul> <li>The function gracefully handles unexpected types by issuing a warning and returning a deep copy of the data.</li> <li>Empty collections (lists, dictionaries) and default parameter values in <code>Element</code> objects are omitted from the output.</li> <li>Numpy arrays with non-numeric data types are automatically converted to lists.</li> </ul>"},{"location":"api-reference/structure/#flixopt.structure.get_compact_representation","title":"get_compact_representation","text":"<pre><code>get_compact_representation(data: Any, array_threshold: int = 50, decimals: int = 2) -&gt; dict\n</code></pre> <p>Generate a compact json serializable representation of deeply nested data. Numpy arrays are statistically described if they exceed a threshold and converted to lists.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to format and represent.</p> required <code>array_threshold</code> <code>int</code> <p>Maximum length of NumPy arrays to display. Longer arrays are statistically described.</p> <code>50</code> <code>decimals</code> <code>int</code> <p>Number of decimal places in which to describe the arrays.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary representation of the data</p>"},{"location":"api-reference/structure/#flixopt.structure.get_str_representation","title":"get_str_representation","text":"<pre><code>get_str_representation(data: Any, array_threshold: int = 50, decimals: int = 2) -&gt; str\n</code></pre> <p>Generate a string representation of deeply nested data using <code>rich.print</code>. NumPy arrays are shortened to the specified length and converted to strings.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The data to format and represent.</p> required <code>array_threshold</code> <code>int</code> <p>Maximum length of NumPy arrays to display. Longer arrays are statistically described.</p> <code>50</code> <code>decimals</code> <code>int</code> <p>Number of decimal places in which to describe the arrays.</p> <code>2</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted string representation of the data.</p>"},{"location":"api-reference/utils/","title":"utils","text":""},{"location":"api-reference/utils/#flixopt.utils","title":"flixopt.utils","text":"<p>This module contains several utility functions used throughout the flixopt framework.</p>"},{"location":"api-reference/utils/#flixopt.utils-functions","title":"Functions","text":""},{"location":"api-reference/utils/#flixopt.utils.is_number","title":"is_number","text":"<pre><code>is_number(number_alias: int | float | str) -&gt; bool\n</code></pre> <p>Returns True if value is a number or a number-like string.</p>"},{"location":"api-reference/utils/#flixopt.utils.convert_dataarray","title":"convert_dataarray","text":"<pre><code>convert_dataarray(data: DataArray, mode: Literal['py', 'numpy', 'xarray', 'structure']) -&gt; list[Any] | np.ndarray | xr.DataArray | str\n</code></pre> <p>Convert a DataArray to a different format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataArray</code> <p>The DataArray to convert.</p> required <code>mode</code> <code>Literal['py', 'numpy', 'xarray', 'structure']</code> <p>The mode to convert to. - 'py': Convert to python native types (for json) - 'numpy': Convert to numpy array - 'xarray': Convert to xarray.DataArray - 'structure': Convert to strings (for structure, storing variable names)</p> required <p>Returns:</p> Type Description <code>list[Any] | ndarray | DataArray | str</code> <p>The converted data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the mode is unknown.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This project adheres to Semantic Versioning. Formatting is based on Keep a Changelog &amp; Gitmoji. For more details regarding the individual PRs and contributors, please refer to our GitHub releases.</p>"},{"location":"changelog/99985-v2.2.0/","title":"2.2.0 - 2025-10-11","text":"<p>\u2190 Previous: 2.1.11 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: This release is a Configuration and Logging management release.</p>"},{"location":"changelog/99985-v2.2.0/#added","title":"\u2728 Added","text":"<ul> <li>Added <code>CONFIG.reset()</code> method to restore configuration to default values</li> <li>Added configurable log file rotation settings: <code>CONFIG.Logging.max_file_size</code> and <code>CONFIG.Logging.backup_count</code></li> <li>Added configurable log format settings: <code>CONFIG.Logging.date_format</code> and <code>CONFIG.Logging.format</code></li> <li>Added configurable console settings: <code>CONFIG.Logging.console_width</code> and <code>CONFIG.Logging.show_path</code></li> <li>Added <code>CONFIG.Logging.Colors</code> nested class for customizable log level colors using ANSI escape codes (works with both standard and Rich handlers)</li> </ul>"},{"location":"changelog/99985-v2.2.0/#changed","title":"\u267b\ufe0f Changed","text":"<ul> <li>Logging and Configuration management changed</li> </ul>"},{"location":"changelog/99985-v2.2.0/#deprecated","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<ul> <li><code>change_logging_level()</code> function is now deprecated in favor of <code>CONFIG.Logging.level</code> and <code>CONFIG.apply()</code>. Will be removed in version 3.0.0.</li> </ul>"},{"location":"changelog/99985-v2.2.0/#removed","title":"\ud83d\udd25 Removed","text":"<ul> <li>Removed unused <code>config.merge_configs</code> function from configuration module</li> </ul>"},{"location":"changelog/99985-v2.2.0/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>Greatly expanded test coverage for <code>config.py</code> module</li> <li>Added <code>@pytest.mark.xdist_group</code> to <code>TestConfigModule</code> tests to prevent global config interference</li> </ul> <p>\u2190 Previous: 2.1.11 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99986-v2.1.11/","title":"2.1.11 - 2025-10-05","text":"<p>\u2190 Previous: 2.1.10 | Next: 2.2.0 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: Important bugfix in <code>Storage</code> leading to wrong results due to incorrect discharge losses.</p>"},{"location":"changelog/99986-v2.1.11/#changed","title":"\u267b\ufe0f Changed","text":"<ul> <li>Using <code>h5netcdf</code> instead of <code>netCDF4</code> for dataset I/O operations. This follows the update in <code>xarray==2025.09.01</code></li> </ul>"},{"location":"changelog/99986-v2.1.11/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fix <code>charge_state</code> Constraint in <code>Storage</code> leading to incorrect losses in discharge and therefore incorrect charge states and discharge values.</li> </ul>"},{"location":"changelog/99986-v2.1.11/#dependencies","title":"\ud83d\udce6 Dependencies","text":"<ul> <li>Updated <code>renovate.config</code> to treat CalVer packages (xarray and dask) with more care</li> <li>Updated packaging configuration</li> </ul> <p>\u2190 Previous: 2.1.10 | Next: 2.2.0 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99987-v2.1.10/","title":"2.1.10 - 2025-09-29","text":"<p>\u2190 Previous: 2.1.9 | Next: 2.1.11 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: This release is a Documentation and Development release.</p>"},{"location":"changelog/99987-v2.1.10/#docs","title":"\ud83d\udcdd Docs","text":"<ul> <li>Improved CHANGELOG.md formatting by adding better categories and formating by Gitmoji.</li> <li>Added a script to extract the release notes from the CHANGELOG.md file for better organized documentation.</li> </ul>"},{"location":"changelog/99987-v2.1.10/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>Improved <code>renovate.config</code></li> <li>Sped up CI by not running examples in every run and using <code>pytest-xdist</code></li> </ul> <p>\u2190 Previous: 2.1.9 | Next: 2.1.11 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99988-v2.1.9/","title":"2.1.9 - 2025-09-23","text":"<p>\u2190 Previous: 2.1.8 | Next: 2.1.10 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: Small bugfix release addressing network visualization error handling.</p>"},{"location":"changelog/99988-v2.1.9/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fix error handling in network visualization if <code>networkx</code> is not installed</li> </ul> <p>\u2190 Previous: 2.1.8 | Next: 2.1.10 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99989-v2.1.8/","title":"2.1.8 - 2025-09-22","text":"<p>\u2190 Previous: 2.1.7 | Next: 2.1.9 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: Code quality improvements, enhanced documentation, and bug fixes for heat pump components and visualization features.</p>"},{"location":"changelog/99989-v2.1.8/#added","title":"\u2728 Added","text":"<ul> <li>Extra Check for HeatPumpWithSource.COP to be strictly &gt; 1 to avoid division by zero</li> <li>Apply deterministic color assignment by using sorted() in <code>plotting.py</code></li> <li>Add missing args in docstrings in <code>plotting.py</code>, <code>solvers.py</code>, and <code>core.py</code>.</li> </ul>"},{"location":"changelog/99989-v2.1.8/#changed","title":"\u267b\ufe0f Changed","text":"<ul> <li>Greatly improved docstrings and documentation of all public classes</li> <li>Make path handling to be gentle about missing .html suffix in <code>plotting.py</code></li> <li>Default for <code>relative_losses</code> in <code>Transmission</code> is now 0 instead of None</li> <li>Setter of COP in <code>HeatPumpWithSource</code> now completely overwrites the conversion factors, which is safer.</li> <li>Fix some docstrings in plotting.py</li> <li>Change assertions to raise Exceptions in <code>plotting.py</code></li> </ul>"},{"location":"changelog/99989-v2.1.8/#fixed","title":"\ud83d\udc1b Fixed","text":"<p>Core Components: - Fix COP getter and setter of <code>HeatPumpWithSource</code> returning and setting wrong conversion factors - Fix custom compression levels in <code>io.save_dataset_to_netcdf</code> - Fix <code>total_max</code> did not work when total min was not used</p> <p>Visualization: - Fix color scheme selection in network_app; color pickers now update when a scheme is selected</p>"},{"location":"changelog/99989-v2.1.8/#docs","title":"\ud83d\udcdd Docs","text":"<ul> <li>Fix broken links in docs</li> <li>Fix some docstrings in plotting.py</li> </ul>"},{"location":"changelog/99989-v2.1.8/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>Pin dev dependencies to specific versions</li> <li>Improve CI workflows to run faster and smarter</li> </ul> <p>\u2190 Previous: 2.1.7 | Next: 2.1.9 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99990-v2.1.7/","title":"2.1.7 - 2025-09-13","text":"<p>\u2190 Previous: 2.1.6 | Next: 2.1.8 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: Maintenance release to improve Code Quality, CI and update the dependencies. There are no changes or new features.</p>"},{"location":"changelog/99990-v2.1.7/#added","title":"\u2728 Added","text":"<ul> <li>Added <code>__version__</code> to flixopt</li> </ul>"},{"location":"changelog/99990-v2.1.7/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>ruff format the whole Codebase</li> <li>Added renovate config</li> <li>Added pre-commit</li> <li>lint and format in CI</li> <li>improved CI</li> <li>Updated Dependencies</li> <li>Updated Issue Templates</li> </ul> <p>\u2190 Previous: 2.1.6 | Next: 2.1.8 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99991-v2.1.6/","title":"2.1.6 - 2025-09-02","text":"<p>\u2190 Previous: 2.1.5 | Next: 2.1.7 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: Enhanced Sink/Source components with multi-flow support and new interactive network visualization.</p>"},{"location":"changelog/99991-v2.1.6/#added","title":"\u2728 Added","text":"<ul> <li>Network Visualization: Added <code>FlowSystem.start_network_app()</code> and <code>FlowSystem.stop_network_app()</code> to easily visualize the network structure of a flow system in an interactive Dash web app</li> <li>Note: This is still experimental and might change in the future</li> </ul>"},{"location":"changelog/99991-v2.1.6/#changed","title":"\u267b\ufe0f Changed","text":"<ul> <li>Multi-Flow Support: <code>Sink</code>, <code>Source</code>, and <code>SourceAndSink</code> now accept multiple <code>flows</code> as <code>inputs</code> and <code>outputs</code> instead of just one. This enables modeling more use cases with these classes</li> <li>Flow Control: Both <code>Sink</code> and <code>Source</code> now have a <code>prevent_simultaneous_flow_rates</code> argument to prevent simultaneous flow rates of more than one of their flows</li> </ul>"},{"location":"changelog/99991-v2.1.6/#deprecated","title":"\ud83d\uddd1\ufe0f Deprecated","text":"<ul> <li>For the classes <code>Sink</code>, <code>Source</code> and <code>SourceAndSink</code>: <code>.sink</code>, <code>.source</code> and <code>.prevent_simultaneous_sink_and_source</code> are deprecated in favor of the new arguments <code>inputs</code>, <code>outputs</code> and <code>prevent_simultaneous_flow_rates</code></li> </ul>"},{"location":"changelog/99991-v2.1.6/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed testing issue with new <code>linopy</code> version 0.5.6</li> </ul>"},{"location":"changelog/99991-v2.1.6/#development","title":"\ud83d\udc77 Development","text":"<ul> <li>Added dependency \"nbformat&gt;=4.2.0\" to dev dependencies to resolve issue with plotly CI</li> </ul> <p>\u2190 Previous: 2.1.5 | Next: 2.1.7 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99992-v2.1.5/","title":"2.1.5 - 2025-07-08","text":"<p>\u2190 Previous: 2.1.4 | Next: 2.1.6 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99992-v2.1.5/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed Docs deployment</li> </ul> <p>\u2190 Previous: 2.1.4 | Next: 2.1.6 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99993-v2.1.4/","title":"2.1.4 - 2025-07-08","text":"<p>\u2190 Previous: 2.1.3 | Next: 2.1.5 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99993-v2.1.4/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixing release notes of 2.1.3, as well as documentation build.</li> </ul> <p>\u2190 Previous: 2.1.3 | Next: 2.1.5 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99994-v2.1.3/","title":"2.1.3 - 2025-07-08","text":"<p>\u2190 Previous: 2.1.2 | Next: 2.1.4 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99994-v2.1.3/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Using <code>Effect.maximum_operation_per_hour</code> raised an error, needing an extra timestep. This has been fixed thanks to @PRse4.</li> </ul> <p>\u2190 Previous: 2.1.2 | Next: 2.1.4 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99995-v2.1.2/","title":"2.1.2 - 2025-06-14","text":"<p>\u2190 Previous: 2.1.1 | Next: 2.1.3 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99995-v2.1.2/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Storage losses per hour were not calculated correctly, as mentioned by @brokenwings01. This might have led to issues when modeling large losses and long timesteps.</li> <li>Old implementation:     \\(c(\\text{t}_{i}) \\cdot (1-\\dot{\\text{c}}_\\text{rel,loss}(\\text{t}_i)) \\cdot \\Delta \\text{t}_{i}\\)</li> <li>Correct implementation: \\(c(\\text{t}_{i}) \\cdot (1-\\dot{\\text{c}}_\\text{rel,loss}(\\text{t}_i)) ^{\\Delta \\text{t}_{i}}\\)</li> </ul>"},{"location":"changelog/99995-v2.1.2/#known-issues","title":"\ud83d\udea7 Known Issues","text":"<ul> <li>Just to mention: Plotly &gt;= 6 may raise errors if \"nbformat\" is not installed. We pinned plotly to &lt;6, but this may be fixed in the future.</li> </ul> <p>\u2190 Previous: 2.1.1 | Next: 2.1.3 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99996-v2.1.1/","title":"2.1.1 - 2025-05-08","text":"<p>\u2190 Previous: 2.1.0 | Next: 2.1.2 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99996-v2.1.1/#changed","title":"\u267b\ufe0f Changed","text":"<ul> <li>Improved docstring and tests</li> </ul>"},{"location":"changelog/99996-v2.1.1/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed bug in the <code>_ElementResults.constraints</code> not returning the constraints but rather the variables</li> </ul> <p>\u2190 Previous: 2.1.0 | Next: 2.1.2 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99997-v2.1.0/","title":"2.1.0 - 2025-04-11","text":"<p>\u2190 Previous: 2.0.1 | Next: 2.1.1 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99997-v2.1.0/#added","title":"\u2728 Added","text":"<ul> <li>Python 3.13 support added</li> <li>Logger warning if relative_minimum is used without on_off_parameters in Flow</li> <li>Greatly improved internal testing infrastructure by leveraging linopy's testing framework</li> </ul>"},{"location":"changelog/99997-v2.1.0/#breaking-changes","title":"\ud83d\udca5 Breaking Changes","text":"<ul> <li>Restructured the modeling of the On/Off state of Flows or Components</li> <li>Variable renaming: <code>...|consecutive_on_hours</code> \u2192 <code>...|ConsecutiveOn|hours</code></li> <li>Variable renaming: <code>...|consecutive_off_hours</code> \u2192 <code>...|ConsecutiveOff|hours</code></li> <li>Constraint renaming: <code>...|consecutive_on_hours_con1</code> \u2192 <code>...|ConsecutiveOn|con1</code></li> <li>Similar pattern for all consecutive on/off constraints</li> </ul>"},{"location":"changelog/99997-v2.1.0/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Fixed the lower bound of <code>flow_rate</code> when using optional investments without OnOffParameters</li> <li>Fixed bug that prevented divest effects from working</li> <li>Added lower bounds of 0 to two unbounded vars (numerical improvement)</li> </ul> <p>\u2190 Previous: 2.0.1 | Next: 2.1.1 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99998-v2.0.1/","title":"2.0.1 - 2025-04-10","text":"<p>\u2190 Previous: 2.0.0 | Next: 2.1.0 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99998-v2.0.1/#added","title":"\u2728 Added","text":"<ul> <li>Logger warning if relative_minimum is used without on_off_parameters in Flow</li> </ul>"},{"location":"changelog/99998-v2.0.1/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Replace \"|\" with \"__\" in filenames when saving figures (Windows compatibility)</li> <li>Fixed bug that prevented the load factor from working without InvestmentParameters</li> </ul> <p>\u2190 Previous: 2.0.0 | Next: 2.1.0 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"changelog/99999-v2.0.0/","title":"2.0.0 - 2025-03-29","text":"<p>Next: 2.0.1 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p> <p>Summary: \ud83d\udca5 MAJOR RELEASE - Complete framework migration from Pyomo to Linopy with redesigned architecture.</p>"},{"location":"changelog/99999-v2.0.0/#added","title":"\u2728 Added","text":"<p>Model Capabilities: - Full model serialization support - save and restore unsolved Models - Enhanced model documentation with YAML export containing human-readable mathematical formulations - Extend flixopt models with native linopy language support - Full Model Export/Import capabilities via linopy.Model</p> <p>Results &amp; Data: - Unified solution exploration through <code>Calculation.results</code> attribute - Compression support for result files - <code>to_netcdf/from_netcdf</code> methods for FlowSystem and core components - xarray integration for TimeSeries with improved datatypes support</p>"},{"location":"changelog/99999-v2.0.0/#breaking-changes","title":"\ud83d\udca5 Breaking Changes","text":"<p>Framework Migration: - Optimization Engine: Complete migration from Pyomo to Linopy optimization framework - Package Import: Framework renamed from flixOpt to flixopt (<code>import flixopt as fx</code>) - Data Architecture: Redesigned data handling to rely on xarray.Dataset throughout the package - Results System: Results handling completely redesigned with new <code>CalculationResults</code> class</p> <p>Variable Structure: - Restructured the modeling of the On/Off state of Flows or Components   - Variable renaming: <code>...|consecutive_on_hours</code> \u2192 <code>...|ConsecutiveOn|hours</code>   - Variable renaming: <code>...|consecutive_off_hours</code> \u2192 <code>...|ConsecutiveOff|hours</code>   - Constraint renaming: <code>...|consecutive_on_hours_con1</code> \u2192 <code>...|ConsecutiveOn|con1</code>   - Similar pattern for all consecutive on/off constraints</p>"},{"location":"changelog/99999-v2.0.0/#removed","title":"\ud83d\udd25 Removed","text":"<ul> <li>Pyomo dependency (replaced by linopy)</li> <li>Period concepts in time management (simplified to timesteps)</li> </ul>"},{"location":"changelog/99999-v2.0.0/#fixed","title":"\ud83d\udc1b Fixed","text":"<ul> <li>Improved infeasible model detection and reporting</li> <li>Enhanced time series management and serialization</li> <li>Reduced file size through improved compression</li> </ul>"},{"location":"changelog/99999-v2.0.0/#docs","title":"\ud83d\udcdd Docs","text":"<ul> <li>Google Style Docstrings throughout the codebase</li> </ul> <p>Next: 2.0.1 \u2192 | \ud83d\udccb All Releases | \ud83c\udff7\ufe0f GitHub Release</p>"},{"location":"examples/","title":"Examples","text":"<p>Here you can find a collection of examples that demonstrate how to use FlixOpt.</p> <p>We work on improving this gallery. If you have something to share, please contact us!</p>"},{"location":"examples/00-Minimal%20Example/","title":"Minimal Example","text":"<pre><code>\"\"\"\nThis script shows how to use the flixopt framework to model a super minimalistic energy system.\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\nfrom rich.pretty import pprint\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # --- Define the Flow System, that will hold all elements, and the time steps you want to model ---\n    timesteps = pd.date_range('2020-01-01', periods=3, freq='h')\n    flow_system = fx.FlowSystem(timesteps)\n\n    # --- Define Thermal Load Profile ---\n    # Load profile (e.g., kW) for heating demand over time\n    thermal_load_profile = np.array([30, 0, 20])\n\n    # --- Define Energy Buses ---\n    # These are balancing nodes (inputs=outputs) and balance the different energy carriers your system\n    flow_system.add_elements(fx.Bus('District Heating'), fx.Bus('Natural Gas'))\n\n    # --- Define Objective Effect (Cost) ---\n    # Cost effect representing the optimization objective (minimizing costs)\n    cost_effect = fx.Effect('costs', '\u20ac', 'Cost', is_standard=True, is_objective=True)\n\n    # --- Define Flow System Components ---\n    # Boiler component with thermal output (heat) and fuel input (gas)\n    boiler = fx.linear_converters.Boiler(\n        'Boiler',\n        eta=0.5,\n        Q_th=fx.Flow(label='Thermal Output', bus='District Heating', size=50),\n        Q_fu=fx.Flow(label='Fuel Input', bus='Natural Gas'),\n    )\n\n    # Heat load component with a fixed thermal demand profile\n    heat_load = fx.Sink(\n        'Heat Demand',\n        sink=fx.Flow(label='Thermal Load', bus='District Heating', size=1, fixed_relative_profile=thermal_load_profile),\n    )\n\n    # Gas source component with cost-effect per flow hour\n    gas_source = fx.Source(\n        'Natural Gas Tariff',\n        source=fx.Flow(label='Gas Flow', bus='Natural Gas', size=1000, effects_per_flow_hour=0.04),  # 0.04 \u20ac/kWh\n    )\n\n    # --- Build the Flow System ---\n    # Add all components and effects to the system\n    flow_system.add_elements(cost_effect, boiler, heat_load, gas_source)\n\n    # --- Define, model and solve a Calculation ---\n    calculation = fx.FullCalculation('Simulation1', flow_system)\n    calculation.do_modeling()\n    calculation.solve(fx.solvers.HighsSolver(0.01, 60))\n\n    # --- Analyze Results ---\n    # Access the results of an element\n    df1 = calculation.results['costs'].filter_solution('time').to_dataframe()\n\n    # Plot the results of a specific element\n    calculation.results['District Heating'].plot_node_balance_pie()\n    calculation.results['District Heating'].plot_node_balance()\n\n    # Save results to a file\n    df2 = calculation.results['District Heating'].node_balance().to_dataframe()\n    # df2.to_csv('results/District Heating.csv')  # Save results to csv\n\n    # Print infos to the console.\n    pprint(calculation.summary)\n</code></pre>"},{"location":"examples/01-Basic%20Example/","title":"Simple example","text":"<pre><code>\"\"\"\nThis script shows how to use the flixopt framework to model a simple energy system.\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # --- Create Time Series Data ---\n    # Heat demand profile (e.g., kW) over time and corresponding power prices\n    heat_demand_per_h = np.array([30, 0, 90, 110, 110, 20, 20, 20, 20])\n    power_prices = 1 / 1000 * np.array([80, 80, 80, 80, 80, 80, 80, 80, 80])\n\n    # Create datetime array starting from '2020-01-01' for the given time period\n    timesteps = pd.date_range('2020-01-01', periods=len(heat_demand_per_h), freq='h')\n    flow_system = fx.FlowSystem(timesteps=timesteps)\n\n    # --- Define Energy Buses ---\n    # These represent nodes, where the used medias are balanced (electricity, heat, and gas)\n    flow_system.add_elements(fx.Bus(label='Strom'), fx.Bus(label='Fernw\u00e4rme'), fx.Bus(label='Gas'))\n\n    # --- Define Effects (Objective and CO2 Emissions) ---\n    # Cost effect: used as the optimization objective --&gt; minimizing costs\n    costs = fx.Effect(\n        label='costs',\n        unit='\u20ac',\n        description='Kosten',\n        is_standard=True,  # standard effect: no explicit value needed for costs\n        is_objective=True,  # Minimizing costs as the optimization objective\n    )\n\n    # CO2 emissions effect with an associated cost impact\n    CO2 = fx.Effect(\n        label='CO2',\n        unit='kg',\n        description='CO2_e-Emissionen',\n        specific_share_to_other_effects_operation={costs.label: 0.2},\n        maximum_operation_per_hour=1000,  # Max CO2 emissions per hour\n    )\n\n    # --- Define Flow System Components ---\n    # Boiler: Converts fuel (gas) into thermal energy (heat)\n    boiler = fx.linear_converters.Boiler(\n        label='Boiler',\n        eta=0.5,\n        Q_th=fx.Flow(label='Q_th', bus='Fernw\u00e4rme', size=50, relative_minimum=0.1, relative_maximum=1),\n        Q_fu=fx.Flow(label='Q_fu', bus='Gas'),\n    )\n\n    # Combined Heat and Power (CHP): Generates both electricity and heat from fuel\n    chp = fx.linear_converters.CHP(\n        label='CHP',\n        eta_th=0.5,\n        eta_el=0.4,\n        P_el=fx.Flow('P_el', bus='Strom', size=60, relative_minimum=5 / 60),\n        Q_th=fx.Flow('Q_th', bus='Fernw\u00e4rme'),\n        Q_fu=fx.Flow('Q_fu', bus='Gas'),\n    )\n\n    # Storage: Energy storage system with charging and discharging capabilities\n    storage = fx.Storage(\n        label='Storage',\n        charging=fx.Flow('Q_th_load', bus='Fernw\u00e4rme', size=1000),\n        discharging=fx.Flow('Q_th_unload', bus='Fernw\u00e4rme', size=1000),\n        capacity_in_flow_hours=fx.InvestParameters(fix_effects=20, fixed_size=30, optional=False),\n        initial_charge_state=0,  # Initial storage state: empty\n        relative_maximum_charge_state=1 / 100 * np.array([80, 70, 80, 80, 80, 80, 80, 80, 80, 80]),\n        eta_charge=0.9,\n        eta_discharge=1,  # Efficiency factors for charging/discharging\n        relative_loss_per_hour=0.08,  # 8% loss per hour. Absolute loss depends on current charge state\n        prevent_simultaneous_charge_and_discharge=True,  # Prevent charging and discharging at the same time\n    )\n\n    # Heat Demand Sink: Represents a fixed heat demand profile\n    heat_sink = fx.Sink(\n        label='Heat Demand',\n        sink=fx.Flow(label='Q_th_Last', bus='Fernw\u00e4rme', size=1, fixed_relative_profile=heat_demand_per_h),\n    )\n\n    # Gas Source: Gas tariff source with associated costs and CO2 emissions\n    gas_source = fx.Source(\n        label='Gastarif',\n        source=fx.Flow(label='Q_Gas', bus='Gas', size=1000, effects_per_flow_hour={costs.label: 0.04, CO2.label: 0.3}),\n    )\n\n    # Power Sink: Represents the export of electricity to the grid\n    power_sink = fx.Sink(\n        label='Einspeisung', sink=fx.Flow(label='P_el', bus='Strom', effects_per_flow_hour=-1 * power_prices)\n    )\n\n    # --- Build the Flow System ---\n    # Add all defined components and effects to the flow system\n    flow_system.add_elements(costs, CO2, boiler, storage, chp, heat_sink, gas_source, power_sink)\n\n    # Visualize the flow system for validation purposes\n    flow_system.plot_network(show=True)\n\n    # --- Define and Run Calculation ---\n    # Create a calculation object to model the Flow System\n    calculation = fx.FullCalculation(name='Sim1', flow_system=flow_system)\n    calculation.do_modeling()  # Translate the model to a solvable form, creating equations and Variables\n\n    # --- Solve the Calculation and Save Results ---\n    calculation.solve(fx.solvers.HighsSolver(mip_gap=0, time_limit_seconds=30))\n\n    # --- Analyze Results ---\n    calculation.results['Fernw\u00e4rme'].plot_node_balance_pie()\n    calculation.results['Fernw\u00e4rme'].plot_node_balance()\n    calculation.results['Storage'].plot_node_balance()\n    calculation.results.plot_heatmap('CHP(Q_th)|flow_rate')\n\n    # Convert the results for the storage component to a dataframe and display\n    df = calculation.results['Storage'].node_balance_with_charge_state()\n    print(df)\n\n    # Save results to file for later usage\n    calculation.results.to_file()\n</code></pre>"},{"location":"examples/02-Complex%20Example/","title":"Complex example","text":"<p>This saves the results of a calculation to file and reloads them to analyze the results</p>"},{"location":"examples/02-Complex%20Example/#build-the-model","title":"Build the Model","text":"<pre><code>\"\"\"\nThis script shows how to use the flixopt framework to model a more complex energy system.\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\nfrom rich.pretty import pprint  # Used for pretty printing\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # --- Experiment Options ---\n    # Configure options for testing various parameters and behaviors\n    check_penalty = False\n    excess_penalty = 1e5\n    use_chp_with_piecewise_conversion = True\n    time_indices = None  # Define specific time steps for custom calculations, or use the entire series\n\n    # --- Define Demand and Price Profiles ---\n    # Input data for electricity and heat demands, as well as electricity price\n    electricity_demand = np.array([70, 80, 90, 90, 90, 90, 90, 90, 90])\n    heat_demand = (\n        np.array([30, 0, 90, 110, 2000, 20, 20, 20, 20])\n        if check_penalty\n        else np.array([30, 0, 90, 110, 110, 20, 20, 20, 20])\n    )\n    electricity_price = np.array([40, 40, 40, 40, 40, 40, 40, 40, 40])\n\n    # --- Define the Flow System, that will hold all elements, and the time steps you want to model ---\n    timesteps = pd.date_range('2020-01-01', periods=len(heat_demand), freq='h')\n    flow_system = fx.FlowSystem(timesteps)  # Create FlowSystem\n\n    # --- Define Energy Buses ---\n    # Represent node balances (inputs=outputs) for the different energy carriers (electricity, heat, gas) in the system\n    flow_system.add_elements(\n        fx.Bus('Strom', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Fernw\u00e4rme', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Gas', excess_penalty_per_flow_hour=excess_penalty),\n    )\n\n    # --- Define Effects ---\n    # Specify effects related to costs, CO2 emissions, and primary energy consumption\n    Costs = fx.Effect('costs', '\u20ac', 'Kosten', is_standard=True, is_objective=True)\n    CO2 = fx.Effect('CO2', 'kg', 'CO2_e-Emissionen', specific_share_to_other_effects_operation={Costs.label: 0.2})\n    PE = fx.Effect('PE', 'kWh_PE', 'Prim\u00e4renergie', maximum_total=3.5e3)\n\n    # --- Define Components ---\n    # 1. Define Boiler Component\n    # A gas boiler that converts fuel into thermal output, with investment and on-off parameters\n    Gaskessel = fx.linear_converters.Boiler(\n        'Kessel',\n        eta=0.5,  # Efficiency ratio\n        on_off_parameters=fx.OnOffParameters(\n            effects_per_running_hour={Costs.label: 0, CO2.label: 1000}\n        ),  # CO2 emissions per hour\n        Q_th=fx.Flow(\n            label='Q_th',  # Thermal output\n            bus='Fernw\u00e4rme',  # Linked bus\n            size=fx.InvestParameters(\n                fix_effects=1000,  # Fixed investment costs\n                fixed_size=50,  # Fixed size\n                optional=False,  # Forced investment\n                specific_effects={Costs.label: 10, PE.label: 2},  # Specific costs\n            ),\n            load_factor_max=1.0,  # Maximum load factor (50 kW)\n            load_factor_min=0.1,  # Minimum load factor (5 kW)\n            relative_minimum=5 / 50,  # Minimum part load\n            relative_maximum=1,  # Maximum part load\n            previous_flow_rate=50,  # Previous flow rate\n            flow_hours_total_max=1e6,  # Total energy flow limit\n            on_off_parameters=fx.OnOffParameters(\n                on_hours_total_min=0,  # Minimum operating hours\n                on_hours_total_max=1000,  # Maximum operating hours\n                consecutive_on_hours_max=10,  # Max consecutive operating hours\n                consecutive_on_hours_min=np.array(\n                    [1, 1, 1, 1, 1, 2, 2, 2, 2]\n                ),  # min consecutive operation hoursconsecutive_off_hours_max=10,  # Max consecutive off hours\n                effects_per_switch_on=0.01,  # Cost per switch-on\n                switch_on_total_max=1000,  # Max number of starts\n            ),\n        ),\n        Q_fu=fx.Flow(label='Q_fu', bus='Gas', size=200),\n    )\n\n    # 2. Define CHP Unit\n    # Combined Heat and Power unit that generates both electricity and heat from fuel\n    bhkw = fx.linear_converters.CHP(\n        'BHKW2',\n        eta_th=0.5,\n        eta_el=0.4,\n        on_off_parameters=fx.OnOffParameters(effects_per_switch_on=0.01),\n        P_el=fx.Flow('P_el', bus='Strom', size=60, relative_minimum=5 / 60),\n        Q_th=fx.Flow('Q_th', bus='Fernw\u00e4rme', size=1e3),\n        Q_fu=fx.Flow('Q_fu', bus='Gas', size=1e3, previous_flow_rate=20),  # The CHP was ON previously\n    )\n\n    # 3. Define CHP with Piecewise Conversion\n    # This CHP unit uses piecewise conversion for more dynamic behavior over time\n    P_el = fx.Flow('P_el', bus='Strom', size=60, previous_flow_rate=20)\n    Q_th = fx.Flow('Q_th', bus='Fernw\u00e4rme')\n    Q_fu = fx.Flow('Q_fu', bus='Gas')\n    piecewise_conversion = fx.PiecewiseConversion(\n        {\n            P_el.label: fx.Piecewise([fx.Piece(5, 30), fx.Piece(40, 60)]),\n            Q_th.label: fx.Piecewise([fx.Piece(6, 35), fx.Piece(45, 100)]),\n            Q_fu.label: fx.Piecewise([fx.Piece(12, 70), fx.Piece(90, 200)]),\n        }\n    )\n\n    bhkw_2 = fx.LinearConverter(\n        'BHKW2',\n        inputs=[Q_fu],\n        outputs=[P_el, Q_th],\n        piecewise_conversion=piecewise_conversion,\n        on_off_parameters=fx.OnOffParameters(effects_per_switch_on=0.01),\n    )\n\n    # 4. Define Storage Component\n    # Storage with variable size and piecewise investment effects\n    segmented_investment_effects = fx.PiecewiseEffects(\n        piecewise_origin=fx.Piecewise([fx.Piece(5, 25), fx.Piece(25, 100)]),\n        piecewise_shares={\n            Costs.label: fx.Piecewise([fx.Piece(50, 250), fx.Piece(250, 800)]),\n            PE.label: fx.Piecewise([fx.Piece(5, 25), fx.Piece(25, 100)]),\n        },\n    )\n\n    speicher = fx.Storage(\n        'Speicher',\n        charging=fx.Flow('Q_th_load', bus='Fernw\u00e4rme', size=1e4),\n        discharging=fx.Flow('Q_th_unload', bus='Fernw\u00e4rme', size=1e4),\n        capacity_in_flow_hours=fx.InvestParameters(\n            piecewise_effects=segmented_investment_effects,  # Investment effects\n            optional=False,  # Forced investment\n            minimum_size=0,\n            maximum_size=1000,  # Optimizing between 0 and 1000 kWh\n        ),\n        initial_charge_state=0,  # Initial charge state\n        maximal_final_charge_state=10,  # Maximum final charge state\n        eta_charge=0.9,\n        eta_discharge=1,  # Charge/discharge efficiency\n        relative_loss_per_hour=0.08,  # Energy loss per hour, relative to current charge state\n        prevent_simultaneous_charge_and_discharge=True,  # Prevent simultaneous charge/discharge\n    )\n\n    # 5. Define Sinks and Sources\n    # 5.a) Heat demand profile\n    Waermelast = fx.Sink(\n        'W\u00e4rmelast',\n        sink=fx.Flow(\n            'Q_th_Last',  # Heat sink\n            bus='Fernw\u00e4rme',  # Linked bus\n            size=1,\n            fixed_relative_profile=heat_demand,  # Fixed demand profile\n        ),\n    )\n\n    # 5.b) Gas tariff\n    Gasbezug = fx.Source(\n        'Gastarif',\n        source=fx.Flow(\n            'Q_Gas',\n            bus='Gas',  # Gas source\n            size=1000,  # Nominal size\n            effects_per_flow_hour={Costs.label: 0.04, CO2.label: 0.3},\n        ),\n    )\n\n    # 5.c) Feed-in of electricity\n    Stromverkauf = fx.Sink(\n        'Einspeisung',\n        sink=fx.Flow(\n            'P_el',\n            bus='Strom',  # Feed-in tariff for electricity\n            effects_per_flow_hour=-1 * electricity_price,  # Negative price for feed-in\n        ),\n    )\n\n    # --- Build FlowSystem ---\n    # Select components to be included in the flow system\n    flow_system.add_elements(Costs, CO2, PE, Gaskessel, Waermelast, Gasbezug, Stromverkauf, speicher)\n    flow_system.add_elements(bhkw_2) if use_chp_with_piecewise_conversion else flow_system.add_elements(bhkw)\n\n    pprint(flow_system)  # Get a string representation of the FlowSystem\n    flow_system.start_network_app()  # Start the network app. DOes only work with extra dependencies installed\n\n    # --- Solve FlowSystem ---\n    calculation = fx.FullCalculation('complex example', flow_system, time_indices)\n    calculation.do_modeling()\n\n    calculation.solve(fx.solvers.HighsSolver(0.01, 60))\n\n    # --- Results ---\n    # You can analyze results directly or save them to file and reload them later.\n    calculation.results.to_file()\n\n    # But let's plot some results anyway\n    calculation.results.plot_heatmap('BHKW2(Q_th)|flow_rate')\n    calculation.results['BHKW2'].plot_node_balance()\n    calculation.results['Speicher'].plot_charge_state()\n    calculation.results['Fernw\u00e4rme'].plot_node_balance_pie()\n</code></pre>"},{"location":"examples/02-Complex%20Example/#load-the-results-from-file","title":"Load the Results from file","text":"<pre><code>\"\"\"\nThis script shows how load results of a prior calcualtion and how to analyze them.\n\"\"\"\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # --- Load Results ---\n    try:\n        results = fx.results.CalculationResults.from_file('results', 'complex example')\n    except FileNotFoundError as e:\n        raise FileNotFoundError(\n            f\"Results file not found in the specified directory ('results'). \"\n            f\"Please ensure that the file is generated by running 'complex_example.py'. \"\n            f'Original error: {e}'\n        ) from e\n\n    # --- Basic overview ---\n    results.plot_network(show=True)\n    results['Fernw\u00e4rme'].plot_node_balance()\n\n    # --- Detailed Plots ---\n    # In depth plot for individual flow rates ('__' is used as the delimiter between Component and Flow\n    results.plot_heatmap('W\u00e4rmelast(Q_th_Last)|flow_rate')\n    for flow_rate in results['BHKW2'].inputs + results['BHKW2'].outputs:\n        results.plot_heatmap(flow_rate)\n\n    # --- Plotting internal variables manually ---\n    results.plot_heatmap('BHKW2(Q_th)|on')\n    results.plot_heatmap('Kessel(Q_th)|on')\n\n    # Dataframes from results:\n    fw_bus = results['Fernw\u00e4rme'].node_balance().to_dataframe()\n    all = results.solution.to_dataframe()\n</code></pre>"},{"location":"examples/03-Calculation%20Modes/","title":"Calculation Mode comparison","text":"<p>Note: This example relies on time series data. You can find it in the <code>examples</code> folder of the FlixOpt repository. <pre><code>\"\"\"\nThis script demonstrates how to use the different calculation types in the flixopt framework\nto model the same energy system. The results will be compared to each other.\n\"\"\"\n\nimport pathlib\n\nimport pandas as pd\nimport xarray as xr\n\nimport flixopt as fx\n\nif __name__ == '__main__':\n    # Calculation Types\n    full, segmented, aggregated = True, True, True\n\n    # Segmented Properties\n    segment_length, overlap_length = 96, 1\n\n    # Aggregated Properties\n    aggregation_parameters = fx.AggregationParameters(\n        hours_per_period=6,\n        nr_of_periods=4,\n        fix_storage_flows=False,\n        aggregate_data_and_fix_non_binary_vars=True,\n        percentage_of_period_freedom=0,\n        penalty_of_period_freedom=0,\n    )\n    keep_extreme_periods = True\n    excess_penalty = 1e5  # or set to None if not needed\n\n    # Data Import\n    data_import = pd.read_csv(pathlib.Path('Zeitreihen2020.csv'), index_col=0).sort_index()\n    filtered_data = data_import['2020-01-01':'2020-01-02 23:45:00']\n    # filtered_data = data_import[0:500]  # Alternatively filter by index\n\n    filtered_data.index = pd.to_datetime(filtered_data.index)\n    timesteps = filtered_data.index\n\n    # Access specific columns and convert to 1D-numpy array\n    electricity_demand = filtered_data['P_Netz/MW'].to_numpy()\n    heat_demand = filtered_data['Q_Netz/MW'].to_numpy()\n    electricity_price = filtered_data['Strompr.\u20ac/MWh'].to_numpy()\n    gas_price = filtered_data['Gaspr.\u20ac/MWh'].to_numpy()\n\n    # TimeSeriesData objects\n    TS_heat_demand = fx.TimeSeriesData(heat_demand)\n    TS_electricity_demand = fx.TimeSeriesData(electricity_demand, agg_weight=0.7)\n    TS_electricity_price_sell = fx.TimeSeriesData(-(electricity_demand - 0.5), agg_group='p_el')\n    TS_electricity_price_buy = fx.TimeSeriesData(electricity_price + 0.5, agg_group='p_el')\n\n    flow_system = fx.FlowSystem(timesteps)\n    flow_system.add_elements(\n        fx.Bus('Strom', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Fernw\u00e4rme', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Gas', excess_penalty_per_flow_hour=excess_penalty),\n        fx.Bus('Kohle', excess_penalty_per_flow_hour=excess_penalty),\n    )\n\n    # Effects\n    costs = fx.Effect('costs', '\u20ac', 'Kosten', is_standard=True, is_objective=True)\n    CO2 = fx.Effect('CO2', 'kg', 'CO2_e-Emissionen')\n    PE = fx.Effect('PE', 'kWh_PE', 'Prim\u00e4renergie')\n\n    # Component Definitions\n\n    # 1. Boiler\n    a_gaskessel = fx.linear_converters.Boiler(\n        'Kessel',\n        eta=0.85,\n        Q_th=fx.Flow(label='Q_th', bus='Fernw\u00e4rme'),\n        Q_fu=fx.Flow(\n            label='Q_fu',\n            bus='Gas',\n            size=95,\n            relative_minimum=12 / 95,\n            previous_flow_rate=20,\n            on_off_parameters=fx.OnOffParameters(effects_per_switch_on=1000),\n        ),\n    )\n\n    # 2. CHP\n    a_kwk = fx.linear_converters.CHP(\n        'BHKW2',\n        eta_th=0.58,\n        eta_el=0.22,\n        on_off_parameters=fx.OnOffParameters(effects_per_switch_on=24000),\n        P_el=fx.Flow('P_el', bus='Strom', size=200),\n        Q_th=fx.Flow('Q_th', bus='Fernw\u00e4rme', size=200),\n        Q_fu=fx.Flow('Q_fu', bus='Kohle', size=288, relative_minimum=87 / 288, previous_flow_rate=100),\n    )\n\n    # 3. Storage\n    a_speicher = fx.Storage(\n        'Speicher',\n        capacity_in_flow_hours=684,\n        initial_charge_state=137,\n        minimal_final_charge_state=137,\n        maximal_final_charge_state=158,\n        eta_charge=1,\n        eta_discharge=1,\n        relative_loss_per_hour=0.001,\n        prevent_simultaneous_charge_and_discharge=True,\n        charging=fx.Flow('Q_th_load', size=137, bus='Fernw\u00e4rme'),\n        discharging=fx.Flow('Q_th_unload', size=158, bus='Fernw\u00e4rme'),\n    )\n\n    # 4. Sinks and Sources\n    # Heat Load Profile\n    a_waermelast = fx.Sink(\n        'W\u00e4rmelast', sink=fx.Flow('Q_th_Last', bus='Fernw\u00e4rme', size=1, fixed_relative_profile=TS_heat_demand)\n    )\n\n    # Electricity Feed-in\n    a_strom_last = fx.Sink(\n        'Stromlast', sink=fx.Flow('P_el_Last', bus='Strom', size=1, fixed_relative_profile=TS_electricity_demand)\n    )\n\n    # Gas Tariff\n    a_gas_tarif = fx.Source(\n        'Gastarif',\n        source=fx.Flow('Q_Gas', bus='Gas', size=1000, effects_per_flow_hour={costs.label: gas_price, CO2.label: 0.3}),\n    )\n\n    # Coal Tariff\n    a_kohle_tarif = fx.Source(\n        'Kohletarif',\n        source=fx.Flow('Q_Kohle', bus='Kohle', size=1000, effects_per_flow_hour={costs.label: 4.6, CO2.label: 0.3}),\n    )\n\n    # Electricity Tariff and Feed-in\n    a_strom_einspeisung = fx.Sink(\n        'Einspeisung', sink=fx.Flow('P_el', bus='Strom', size=1000, effects_per_flow_hour=TS_electricity_price_sell)\n    )\n\n    a_strom_tarif = fx.Source(\n        'Stromtarif',\n        source=fx.Flow(\n            'P_el', bus='Strom', size=1000, effects_per_flow_hour={costs.label: TS_electricity_price_buy, CO2: 0.3}\n        ),\n    )\n\n    # Flow System Setup\n    flow_system.add_elements(costs, CO2, PE)\n    flow_system.add_elements(\n        a_gaskessel,\n        a_waermelast,\n        a_strom_last,\n        a_gas_tarif,\n        a_kohle_tarif,\n        a_strom_einspeisung,\n        a_strom_tarif,\n        a_kwk,\n        a_speicher,\n    )\n    flow_system.plot_network(controls=False, show=True)\n\n    # Calculations\n    calculations: list[fx.FullCalculation | fx.AggregatedCalculation | fx.SegmentedCalculation] = []\n\n    if full:\n        calculation = fx.FullCalculation('Full', flow_system)\n        calculation.do_modeling()\n        calculation.solve(fx.solvers.HighsSolver(0, 60))\n        calculations.append(calculation)\n\n    if segmented:\n        calculation = fx.SegmentedCalculation('Segmented', flow_system, segment_length, overlap_length)\n        calculation.do_modeling_and_solve(fx.solvers.HighsSolver(0, 60))\n        calculations.append(calculation)\n\n    if aggregated:\n        if keep_extreme_periods:\n            aggregation_parameters.time_series_for_high_peaks = [TS_heat_demand]\n            aggregation_parameters.time_series_for_low_peaks = [TS_electricity_demand, TS_heat_demand]\n        calculation = fx.AggregatedCalculation('Aggregated', flow_system, aggregation_parameters)\n        calculation.do_modeling()\n        calculation.solve(fx.solvers.HighsSolver(0, 60))\n        calculations.append(calculation)\n\n    # Get solutions for plotting for different calculations\n    def get_solutions(calcs: list, variable: str) -&gt; xr.Dataset:\n        dataarrays = []\n        for calc in calcs:\n            if calc.name == 'Segmented':\n                dataarrays.append(calc.results.solution_without_overlap(variable).rename(calc.name))\n            else:\n                dataarrays.append(calc.results.model.variables[variable].solution.rename(calc.name))\n        return xr.merge(dataarrays)\n\n    # --- Plotting for comparison ---\n    fx.plotting.with_plotly(\n        get_solutions(calculations, 'Speicher|charge_state').to_dataframe(),\n        mode='line',\n        title='Charge State Comparison',\n        ylabel='Charge state',\n    ).write_html('results/Charge State.html')\n\n    fx.plotting.with_plotly(\n        get_solutions(calculations, 'BHKW2(Q_th)|flow_rate').to_dataframe(),\n        mode='line',\n        title='BHKW2(Q_th) Flow Rate Comparison',\n        ylabel='Flow rate',\n    ).write_html('results/BHKW2 Thermal Power.html')\n\n    fx.plotting.with_plotly(\n        get_solutions(calculations, 'costs(operation)|total_per_timestep').to_dataframe(),\n        mode='line',\n        title='Operation Cost Comparison',\n        ylabel='Costs [\u20ac]',\n    ).write_html('results/Operation Costs.html')\n\n    fx.plotting.with_plotly(\n        pd.DataFrame(get_solutions(calculations, 'costs(operation)|total_per_timestep').to_dataframe().sum()).T,\n        mode='bar',\n        title='Total Cost Comparison',\n        ylabel='Costs [\u20ac]',\n    ).update_layout(barmode='group').write_html('results/Total Costs.html')\n\n    fx.plotting.with_plotly(\n        pd.DataFrame([calc.durations for calc in calculations], index=[calc.name for calc in calculations]), 'bar'\n    ).update_layout(title='Duration Comparison', xaxis_title='Calculation type', yaxis_title='Time (s)').write_html(\n        'results/Speed Comparison.html'\n    )\n</code></pre></p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#work-in-progress","title":"Work in progress","text":""},{"location":"faq/contribute/","title":"Contributing to the Project","text":"<p>We warmly welcome contributions from the community! This guide will help you get started with contributing to our project.</p>"},{"location":"faq/contribute/#development-setup","title":"Development Setup","text":"<ol> <li>Clone the repository <code>git clone https://github.com/flixOpt/flixopt.git</code></li> <li>Install the development dependencies <code>pip install -e \".[dev]\"</code></li> <li>Install pre-commit hooks <code>pre-commit install</code> (one-time setup)</li> <li>Run <code>pytest</code> to ensure your code passes all tests</li> </ol>"},{"location":"faq/contribute/#code-quality","title":"Code Quality","text":"<p>We use Ruff for linting and formatting. After the one-time setup above, code quality checks run automatically on every commit.</p> <p>To run manually: - <code>ruff check --fix .</code> to check and fix linting issues - <code>ruff format .</code> to format code</p>"},{"location":"faq/contribute/#documentation-optional","title":"Documentation (Optional)","text":"<p>FlixOpt uses mkdocs to generate documentation. To work on documentation: <pre><code>pip install -e \".[docs]\"\nmkdocs serve\n</code></pre> Then navigate to http://127.0.0.1:8000/</p>"},{"location":"faq/contribute/#testing","title":"Testing","text":"<ul> <li><code>pytest</code> to run the test suite</li> <li>You can also run the provided python script <code>run_all_test.py</code></li> </ul>"},{"location":"faq/contribute/#best-practices","title":"Best practices","text":""},{"location":"faq/contribute/#coding-guidelines","title":"Coding Guidelines","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Write clear, commented code</li> <li>Include type hints</li> <li>Create or update tests for new functionality</li> <li>Ensure 100% test coverage for new code</li> </ul>"},{"location":"faq/contribute/#branches","title":"Branches","text":"<p>As we start to think FlixOpt in Releases, we decided to introduce multiple dev-branches instead of only one: Following the Semantic Versioning guidelines, we introduced: - <code>next/patch</code>: This is where all pull requests for the next patch release (1.0.x) go. - <code>next/minor</code>: This is where all pull requests for the next minor release (1.x.0) go. - <code>next/major</code>: This is where all pull requests for the next major release (x.0.0) go.</p> <p>Everything else remains in <code>feature/...</code>-branches.</p>"},{"location":"faq/contribute/#pull-requests","title":"Pull requests","text":"<p>Every feature or bugfix should be merged into one of the 3 release branches, using Squash and merge or a regular single commit. At some point, <code>next/minor</code> or <code>next/major</code> will get merged into <code>main</code> using a regular Merge  (not squash). This ensures that Features are kept separate, and the <code>next/...</code>branches stay in synch with <code>`main</code>.</p>"},{"location":"faq/contribute/#releases","title":"Releases","text":"<p>As stated, we follow Semantic Versioning. Right after one of the 3 release branches is merged into main, a Tag should be added to the merge commit and pushed to the main branch. The tag has the form <code>v1.2.3</code>. With this tag,  a release with Release Notes must be created.</p> <p>This is our current best practice</p>"},{"location":"user-guide/","title":"FlixOpt Concepts","text":"<p>FlixOpt is built around a set of core concepts that work together to represent and optimize energy and material flow systems. This page provides a high-level overview of these concepts and how they interact.</p>"},{"location":"user-guide/#core-concepts","title":"Core Concepts","text":""},{"location":"user-guide/#flowsystem","title":"FlowSystem","text":"<p>The <code>FlowSystem</code> is the central organizing unit in FlixOpt. Every FlixOpt model starts with creating a FlowSystem. It:</p> <ul> <li>Defines the timesteps for the optimization</li> <li>Contains and connects components, buses, and flows</li> <li>Manages the effects (objectives and constraints)</li> </ul>"},{"location":"user-guide/#flows","title":"Flows","text":"<p><code>Flow</code> objects represent the movement of energy or material between a Bus and a Component in a predefined direction.</p> <ul> <li>Have a <code>size</code> which, generally speaking, defines how fast energy or material can be moved. Usually measured in MW, kW, m\u00b3/h, etc.</li> <li>Have a <code>flow_rate</code>, which is defines how fast energy or material is transported. Usually measured in MW, kW, m\u00b3/h, etc.</li> <li>Have constraints to limit the flow-rate (min/max, total flow hours, on/off etc.)</li> <li>Can have fixed profiles (for demands or renewable generation)</li> <li>Can have Effects associated by their use (operation, investment, on/off, ...)</li> </ul>"},{"location":"user-guide/#flow-hours","title":"Flow Hours","text":"<p>While the Flow Rate defines the rate in which energy or material is transported, the Flow Hours define the amount of energy or material that is transported. Its defined by the flow_rate times the duration of the timestep in hours.</p> <p>Examples:</p> Flow Rate Timestep Flow Hours 10 (MW) 1 hour 10 (MWh) 10 (MW) 6 minutes 0.1 (MWh) 10 (kg/h) 1 hour 10 (kg)"},{"location":"user-guide/#buses","title":"Buses","text":"<p><code>Bus</code> objects represent nodes or connection points in a FlowSystem. They:</p> <ul> <li>Balance incoming and outgoing flows</li> <li>Can represent physical networks like heat, electricity, or gas</li> <li>Handle infeasible balances gently by allowing the balance to be closed in return for a big Penalty (optional)</li> </ul>"},{"location":"user-guide/#components","title":"Components","text":"<p><code>Component</code> objects usually represent physical entities in your system that interact with <code>Flows</code>. They include:</p> <ul> <li><code>LinearConverters</code> - Converts input flows to output flows with (piecewise) linear relationships</li> <li><code>Storages</code> - Stores energy or material over time</li> <li><code>Sources</code> / <code>Sinks</code> / <code>SourceAndSinks</code> - Produce or consume flows. They are usually used to model external demands or supplies.</li> <li><code>Transmissions</code> - Moves flows between locations with possible losses</li> <li>Specialized <code>LinearConverters</code> like <code>Boilers</code>, <code>HeatPumps</code>, <code>CHPs</code>, etc. These simplify the usage of the <code>LinearConverter</code> class and can also be used as blueprint on how to define custom classes or parameterize existing ones.</li> </ul>"},{"location":"user-guide/#effects","title":"Effects","text":"<p><code>Effect</code> objects represent impacts or metrics related to your system, such as:</p> <ul> <li>Costs (investment, operation)</li> <li>Emissions (CO\u2082, NOx, etc.)</li> <li>Resource consumption</li> <li>Area demand</li> </ul> <p>These can be freely defined and crosslink to each other (<code>CO\u2082</code> \u2500\u2500[specific CO\u2082-costs]\u2500\u2192 <code>Costs</code>). One effect is designated as the optimization objective (typically Costs), while others can be constrained. This approach allows for a multi-criteria optimization using both...  - ... the Weigted SumMethod, by Optimizing a theoretical Effect which other Effects crosslink to.  - ... the (\\(\\epsilon\\)-constraint method) by constraining effects.</p>"},{"location":"user-guide/#calculation","title":"Calculation","text":"<p>A <code>FlowSystem</code> can be converted to a Model and optimized by creating a <code>Calculation</code> from it.</p> <p>FlixOpt offers different calculation modes:</p> <ul> <li><code>FullCalculation</code> - Solves the entire problem at once</li> <li><code>SegmentedCalculation</code> - Solves the problem in segments (with optioinal overlap), improving performance for large problems</li> <li><code>AggregatedCalculation</code> - Uses typical periods to reduce computational requirements</li> </ul>"},{"location":"user-guide/#results","title":"Results","text":"<p>The results of a calculation are stored in a <code>CalculationResults</code> object. This object contains the solutions of the optimization as well as all information about the <code>Calculation</code> and the <code>FlowSystem</code> it was created from. The solutions is stored as an <code>xarray.Dataset</code>, but can be accessed through their assotiated Component, Bus or Effect.</p> <p>This <code>CalculationResults</code> object can be saved to file and reloaded from file, allowing you to analyze the results anytime after the solve.</p>"},{"location":"user-guide/#how-these-concepts-work-together","title":"How These Concepts Work Together","text":"<p>The process of working with FlixOpt can be divided into 3 steps:</p> <ol> <li>Create a <code>FlowSystem</code>, containing all the elements and data of your system<ul> <li>Define the time series of your system</li> <li>Add <code>Components</code> like <code>Boilers</code>, <code>HeatPumps</code>, <code>CHPs</code>, etc.</li> <li>Add <code>Buses</code> as connection points in your system</li> <li>Add <code>Effects</code> to represent costs, emissions, etc.</li> <li>This <code>FlowSystem</code> can also be loaded from a netCDF file</li> </ul> </li> <li>Translate the model to a mathematical optimization problem<ul> <li>Create a <code>Calculation</code> from your FlowSystem and choose a Solver</li> <li>...The Calculation is translated internaly to a mathematical optimization problem...</li> <li>...and solved by the chosen solver.</li> </ul> </li> <li>Analyze the results<ul> <li>The results are stored in a <code>CalculationResults</code> object</li> <li>This object can be saved to file and reloaded from file, retaining all information about the calculation</li> <li>As it contains the used <code>FlowSystem</code>, it can be used to start a new calculation</li> </ul> </li> </ol> <p> </p> Conceptual Usage and IO operations of FlixOpt"},{"location":"user-guide/#advanced-usage","title":"Advanced Usage","text":"<p>As flixopt is build on linopy, any model created with FlixOpt can be extended or modified using the great linopy API. This allows to adjust your model to very specific requirements without loosing the convenience of FlixOpt.</p>"},{"location":"user-guide/Mathematical%20Notation/","title":"Mathematical Notation","text":""},{"location":"user-guide/Mathematical%20Notation/#naming-conventions","title":"Naming Conventions","text":"<p>FlixOpt uses the following naming conventions:</p> <ul> <li>All optimization variables are denoted by italic letters (e.g., \\(x\\), \\(y\\), \\(z\\))</li> <li>All parameters and constants are denoted by non italic small letters (e.g., \\(\\text{a}\\), \\(\\text{b}\\), \\(\\text{c}\\))</li> <li>All Sets are denoted by greek capital letters (e.g., \\(\\mathcal{F}\\), \\(\\mathcal{E}\\))</li> <li>All units of a set are denoted by greek small letters (e.g., \\(\\mathcal{f}\\), \\(\\mathcal{e}\\))</li> <li>The letter \\(i\\) is used to denote an index (e.g., \\(i=1,\\dots,\\text n\\))</li> <li>All time steps are denoted by the letter \\(\\text{t}\\) (e.g., \\(\\text{t}_0\\), \\(\\text{t}_1\\), \\(\\text{t}_i\\))</li> </ul>"},{"location":"user-guide/Mathematical%20Notation/#timesteps","title":"Timesteps","text":"<p>Time steps are defined as a sequence of discrete time steps \\(\\text{t}_i \\in \\mathcal{T} \\quad \\text{for} \\quad i \\in \\{1, 2, \\dots, \\text{n}\\}\\) (left-aligned in its timespan). From this sequence, the corresponding time intervals \\(\\Delta \\text{t}_i \\in \\Delta \\mathcal{T}\\) are derived as</p> \\[\\Delta \\text{t}_i = \\text{t}_{i+1} - \\text{t}_i \\quad \\text{for} \\quad i \\in \\{1, 2, \\dots, \\text{n}-1\\}\\] <p>The final time interval \\(\\Delta \\text{t}_\\text n\\) defaults to \\(\\Delta \\text{t}_\\text n = \\Delta \\text{t}_{\\text n-1}\\), but is of course customizable. Non-equidistant time steps are also supported.</p>"},{"location":"user-guide/Mathematical%20Notation/Bus/","title":"Bus","text":"<p>A Bus is a simple nodal balance between its incoming and outgoing flow rates.</p> \\[ \\label{eq:bus_balance}   \\sum_{f_\\text{in} \\in \\mathcal{F}_\\text{in}} p_{f_\\text{in}}(\\text{t}_i) =   \\sum_{f_\\text{out} \\in \\mathcal{F}_\\text{out}} p_{f_\\text{out}}(\\text{t}_i) \\] <p>Optionally, a Bus can have a <code>excess_penalty_per_flow_hour</code> parameter, which allows to penaltize the balance for missing or excess flow-rates. This is usefull as it handles a possible ifeasiblity gently.</p> <p>This changes the balance to</p> \\[ \\label{eq:bus_balance-excess}   \\sum_{f_\\text{in} \\in \\mathcal{F}_\\text{in}} p_{f_ \\text{in}}(\\text{t}_i) + \\phi_\\text{in}(\\text{t}_i) =   \\sum_{f_\\text{out} \\in \\mathcal{F}_\\text{out}} p_{f_\\text{out}}(\\text{t}_i) + \\phi_\\text{out}(\\text{t}_i) \\] <p>The penalty term is defined as</p> \\[ \\label{eq:bus_penalty}   s_{b \\rightarrow \\Phi}(\\text{t}_i) =       \\text a_{b \\rightarrow \\Phi}(\\text{t}_i) \\cdot \\Delta \\text{t}_i       \\cdot [ \\phi_\\text{in}(\\text{t}_i) + \\phi_\\text{out}(\\text{t}_i) ] \\] <p>With:</p> <ul> <li>\\(\\mathcal{F}_\\text{in}\\) and \\(\\mathcal{F}_\\text{out}\\) being the set of all incoming and outgoing flows</li> <li>\\(p_{f_\\text{in}}(\\text{t}_i)\\) and \\(p_{f_\\text{out}}(\\text{t}_i)\\) being the flow-rate at time \\(\\text{t}_i\\) for flow \\(f_\\text{in}\\) and \\(f_\\text{out}\\), respectively</li> <li>\\(\\phi_\\text{in}(\\text{t}_i)\\) and \\(\\phi_\\text{out}(\\text{t}_i)\\) being the missing or excess flow-rate at time \\(\\text{t}_i\\), respectively</li> <li>\\(\\text{t}_i\\) being the time step</li> <li>\\(s_{b \\rightarrow \\Phi}(\\text{t}_i)\\) being the penalty term</li> <li>\\(\\text a_{b \\rightarrow \\Phi}(\\text{t}_i)\\) being the penalty coefficient (<code>excess_penalty_per_flow_hour</code>)</li> </ul>"},{"location":"user-guide/Mathematical%20Notation/Effects%2C%20Penalty%20%26%20Objective/","title":"Effects, Penalty & Objective","text":""},{"location":"user-guide/Mathematical%20Notation/Effects%2C%20Penalty%20%26%20Objective/#effects","title":"Effects","text":"<p><code>Effects</code> are used to allocate things like costs, emissions, or other \"effects\" occurring in the system. These arise from so called Shares, which originate from Elements like Flows.</p> <p>Example:</p> <p><code>Flows</code> have an attribute called <code>effects_per_flow_hour</code>, defining the effect amount of per flow hour. Associated effects could be: - costs - given in [\u20ac/kWh]... - ...or emissions - given in [kg/kWh]. - Effects are allocated separately for investments and operation.</p>"},{"location":"user-guide/Mathematical%20Notation/Effects%2C%20Penalty%20%26%20Objective/#shares-to-effects","title":"Shares to Effects","text":"\\[ \\label{eq:Share_invest} s_{l \\rightarrow e, \\text{inv}} = \\sum_{v \\in \\mathcal{V}_{l, \\text{inv}}} v \\cdot \\text a_{v \\rightarrow e} \\] \\[ \\label{eq:Share_operation} s_{l \\rightarrow e, \\text{op}}(\\text{t}_i) = \\sum_{v \\in \\mathcal{V}_{l,\\text{op}}} v(\\text{t}_i) \\cdot \\text a_{v \\rightarrow e}(\\text{t}_i) \\] <p>With:</p> <ul> <li>\\(\\text{t}_i\\) being the time step</li> <li>\\(\\mathcal{V_l}\\) being the set of all optimization variables of element \\(e\\)</li> <li>\\(\\mathcal{V}_{l, \\text{inv}}\\) being the set of all optimization variables of element \\(e\\) related to investment</li> <li>\\(\\mathcal{V}_{l, \\text{op}}\\) being the set of all optimization variables of element \\(e\\) related to operation</li> <li>\\(v\\) being an optimization variable of the element \\(l\\)</li> <li>\\(v(\\text{t}_i)\\) being an optimization variable of the element \\(l\\) at timestep \\(\\text{t}_i\\)</li> <li>\\(\\text a_{v \\rightarrow e}\\) being the factor between the optimization variable \\(v\\) to effect \\(e\\)</li> <li>\\(\\text a_{v \\rightarrow e}(\\text{t}_i)\\) being the factor between the optimization variable \\(v\\) to effect \\(e\\) for timestep \\(\\text{t}_i\\)</li> <li>\\(s_{l \\rightarrow e, \\text{inv}}\\) being the share of element \\(l\\) to the investment part of effect \\(e\\)</li> <li>\\(s_{l \\rightarrow e, \\text{op}}(\\text{t}_i)\\) being the share of element \\(l\\) to the operation part of effect \\(e\\)</li> </ul>"},{"location":"user-guide/Mathematical%20Notation/Effects%2C%20Penalty%20%26%20Objective/#shares-between-different-effects","title":"Shares between different Effects","text":"<p>Furthermore, the Effect \\(x\\) can contribute a share to another Effect \\({e} \\in \\mathcal{E}\\backslash x\\). This share is defined by the factor \\(\\text r_{x \\rightarrow e}\\).</p> <p>For example, the Effect \"CO\\(_2\\) emissions\" (unit: kg) can cause an additional share to Effect \"monetary costs\" (unit: \u20ac). In this case, the factor \\(\\text a_{x \\rightarrow e}\\) is the specific CO\\(_2\\) price in \u20ac/kg. However, circular references have to be avoided.</p> <p>The overall sum of investment shares of an Effect \\(e\\) is given by \\(\\eqref{eq:Effect_invest}\\)</p> \\[ \\label{eq:Effect_invest} E_{e, \\text{inv}} = \\sum_{l \\in \\mathcal{L}} s_{l \\rightarrow e,\\text{inv}} + \\sum_{x \\in \\mathcal{E}\\backslash e} E_{x, \\text{inv}}  \\cdot \\text{r}_{x \\rightarrow  e,\\text{inv}} \\] <p>The overall sum of operation shares is given by \\(\\eqref{eq:Effect_Operation}\\)</p> \\[ \\label{eq:Effect_Operation} E_{e, \\text{op}}(\\text{t}_{i}) = \\sum_{l \\in \\mathcal{L}} s_{l \\rightarrow e, \\text{op}}(\\text{t}_i) + \\sum_{x \\in \\mathcal{E}\\backslash e} E_{x, \\text{op}}(\\text{t}_i) \\cdot \\text{r}_{x \\rightarrow {e},\\text{op}}(\\text{t}_i) \\] <p>and totals to \\(\\eqref{eq:Effect_Operation_total}\\) $$\\label{eq:Effect_Operation_total} E_{e,\\text{op},\\text{tot}} = \\sum_{i=1}^n  E_{e,\\text{op}}(\\text{t}_{i}) $$</p> <p>With:</p> <ul> <li>\\(\\mathcal{L}\\) being the set of all elements in the FlowSystem</li> <li>\\(\\mathcal{E}\\) being the set of all effects in the FlowSystem</li> <li>\\(\\text r_{x \\rightarrow e, \\text{inv}}\\) being the factor between the invest part of Effect \\(x\\) and Effect \\(e\\)</li> <li> <p>\\(\\text r_{x \\rightarrow e, \\text{op}}(\\text{t}_i)\\) being the factor between the operation part of Effect \\(x\\) and Effect \\(e\\)</p> </li> <li> <p>\\(\\text{t}_i\\) being the time step</p> </li> <li>\\(s_{l \\rightarrow e, \\text{inv}}\\) being the share of element \\(l\\) to the investment part of effect \\(e\\)</li> <li>\\(s_{l \\rightarrow e, \\text{op}}(\\text{t}_i)\\) being the share of element \\(l\\) to the operation part of effect \\(e\\)</li> </ul> <p>The total of an effect \\(E_{e}\\) is given as \\(\\eqref{eq:Effect_Total}\\)</p> \\[ \\label{eq:Effect_Total} E_{e} = E_{\\text{inv},e} +E_{\\text{op},\\text{tot},e} \\]"},{"location":"user-guide/Mathematical%20Notation/Effects%2C%20Penalty%20%26%20Objective/#constraining-effects","title":"Constraining Effects","text":"<p>For each variable \\(v \\in \\{ E_{e,\\text{inv}}, E_{e,\\text{op},\\text{tot}}, E_e\\}\\), a lower bound \\(v^\\text{L}\\) and upper bound \\(v^\\text{U}\\) can be defined as</p> \\[ \\label{eq:Bounds_Single} \\text v^\\text{L} \\leq v \\leq \\text v^\\text{U} \\] <p>Furthermore, bounds for the operational shares can be set for each time step</p> \\[ \\label{eq:Bounds_Time_Steps} \\text E_{e,\\text{op}}^\\text{L}(\\text{t}_i) \\leq E_{e,\\text{op}}(\\text{t}_i) \\leq \\text E_{e,\\text{op}}^\\text{U}(\\text{t}_i) \\]"},{"location":"user-guide/Mathematical%20Notation/Effects%2C%20Penalty%20%26%20Objective/#penalty","title":"Penalty","text":"<p>Additionally to the user defined Effects, a Penalty \\(\\Phi\\) is part of every FlixOpt Model. Its used to prevent unsolvable problems and simplify troubleshooting. Shares to the penalty can originate from every Element and are constructed similarly to \\(\\eqref{Share_invest}\\) and  \\(\\eqref{Share_operation}\\).</p> \\[ \\label{eq:Penalty} \\Phi = \\sum_{l \\in \\mathcal{L}} \\left( s_{l \\rightarrow \\Phi}  +\\sum_{\\text{t}_i \\in \\mathcal{T}} s_{l \\rightarrow \\Phi}(\\text{t}_{i}) \\right) \\] <p>With:</p> <ul> <li>\\(\\mathcal{L}\\) being the set of all elements in the FlowSystem</li> <li>\\(\\mathcal{T}\\) being the set of all timesteps</li> <li>\\(s_{l \\rightarrow \\Phi}\\) being the share of element \\(l\\) to the penalty</li> </ul> <p>At the moment, penalties only occur in Buses</p>"},{"location":"user-guide/Mathematical%20Notation/Effects%2C%20Penalty%20%26%20Objective/#objective","title":"Objective","text":"<p>The optimization objective of a FlixOpt Model is defined as \\(\\eqref{eq:Objective}\\) $$ \\label{eq:Objective} \\min(E_{\\Omega} + \\Phi) $$</p> <p>With:</p> <ul> <li>\\(\\Omega\\) being the chosen Objective Effect (see \\(\\eqref{eq:Effect_Total}\\))</li> <li>\\(\\Phi\\) being the Penalty</li> </ul> <p>This approach allows for a multi-criteria optimization using both...  - ... the Weighted Sum method, as the chosen Objective Effect can incorporate other Effects.  - ... the (\\(\\epsilon\\)-constraint method) by constraining effects.</p>"},{"location":"user-guide/Mathematical%20Notation/Flow/","title":"Flow","text":"<p>The flow_rate is the main optimization variable of the Flow. It's limited by the size of the Flow and relative bounds \\eqref{eq:flow_rate}.</p> \\[ \\label{eq:flow_rate}     \\text P \\cdot \\text p^{\\text{L}}_{\\text{rel}}(\\text{t}_{i})     \\leq p(\\text{t}_{i}) \\leq     \\text P \\cdot \\text p^{\\text{U}}_{\\text{rel}}(\\text{t}_{i}) \\] <p>With:</p> <ul> <li>\\(\\text P\\) being the size of the Flow</li> <li>\\(p(\\text{t}_{i})\\) being the flow-rate at time \\(\\text{t}_{i}\\)</li> <li>\\(\\text p^{\\text{L}}_{\\text{rel}}(\\text{t}_{i})\\) being the relative lower bound (typically 0)</li> <li>\\(\\text p^{\\text{U}}_{\\text{rel}}(\\text{t}_{i})\\) being the relative upper bound (typically 1)</li> </ul> <p>With \\(\\text p^{\\text{L}}_{\\text{rel}}(\\text{t}_{i}) = 0\\) and \\(\\text p^{\\text{U}}_{\\text{rel}}(\\text{t}_{i}) = 1\\), equation \\eqref{eq:flow_rate} simplifies to</p> \\[     0 \\leq p(\\text{t}_{i}) \\leq \\text P \\] <p>This mathematical formulation can be extended by using OnOffParameters to define the on/off state of the Flow, or by using InvestParameters to change the size of the Flow from a constant to an optimization variable.</p>"},{"location":"user-guide/Mathematical%20Notation/InvestParameters/","title":"InvestParameters","text":"<p>This is a work in progress.</p>"},{"location":"user-guide/Mathematical%20Notation/LinearConverter/","title":"LinearConverter","text":"<p><code>LinearConverters</code> define a ratio between incoming and outgoing Flows.</p> \\[ \\label{eq:Linear-Transformer-Ratio}     \\sum_{f_{\\text{in}} \\in \\mathcal F_{in}} \\text a_{f_{\\text{in}}}(\\text{t}_i) \\cdot p_{f_\\text{in}}(\\text{t}_i) = \\sum_{f_{\\text{out}} \\in \\mathcal F_{out}}  \\text b_{f_\\text{out}}(\\text{t}_i) \\cdot p_{f_\\text{out}}(\\text{t}_i) \\] <p>With:</p> <ul> <li>\\(\\mathcal F_{in}\\) and \\(\\mathcal F_{out}\\) being the set of all incoming and outgoing flows</li> <li>\\(p_{f_\\text{in}}(\\text{t}_i)\\) and \\(p_{f_\\text{out}}(\\text{t}_i)\\) being the flow-rate at time \\(\\text{t}_i\\) for flow \\(f_\\text{in}\\) and \\(f_\\text{out}\\), respectively</li> <li>\\(\\text a_{f_\\text{in}}(\\text{t}_i)\\) and \\(\\text b_{f_\\text{out}}(\\text{t}_i)\\) being the ratio of the flow-rate at time \\(\\text{t}_i\\) for flow \\(f_\\text{in}\\) and \\(f_\\text{out}\\), respectively</li> </ul> <p>With one incoming Flow and one outgoing Flow, this can be simplified to:</p> \\[ \\label{eq:Linear-Transformer-Ratio-simple}     \\text a(\\text{t}_i) \\cdot p_{f_\\text{in}}(\\text{t}_i) = p_{f_\\text{out}}(\\text{t}_i) \\] <p>where \\(\\text a\\) can be interpreted as the conversion efficiency of the LinearConverter.</p>"},{"location":"user-guide/Mathematical%20Notation/LinearConverter/#piecewise-conversion-factors","title":"Piecewise Conversion factors","text":"<p>The conversion efficiency can be defined as a piecewise linear approximation. See Piecewise for more details.</p>"},{"location":"user-guide/Mathematical%20Notation/OnOffParameters/","title":"OnOffParameters","text":"<p>This is a work in progress.</p>"},{"location":"user-guide/Mathematical%20Notation/Piecewise/","title":"Piecewise","text":"<p>A Piecewise is a collection of <code>Pieces</code>, which each define a valid range for a variable \\(v\\)</p> \\[ \\label{eq:active_piece}     \\beta_\\text{k} = \\lambda_\\text{0, k} + \\lambda_\\text{1, k} \\] \\[ \\label{eq:piece}     v_\\text{k} = \\lambda_\\text{0, k} * \\text{v}_{\\text{start,k}} + \\lambda_\\text{1,k} * \\text{v}_{\\text{end,k}} \\] \\[ \\label{eq:piecewise_in_pieces} \\sum_{k=1}^k \\beta_{k} = 1 \\] <p>With:</p> <ul> <li>\\(v\\): The variable to be defined by the Piecewise</li> <li>\\(\\text{v}_{\\text{start,k}}\\): the start point of the piece for variable \\(v\\)</li> <li>\\(\\text{v}_{\\text{end,k}}\\): the end point of the piece for variable \\(v\\)</li> <li>\\(\\beta_\\text{k} \\in \\{0, 1\\}\\): defining wether the Piece \\(k\\) is active</li> <li>\\(\\lambda_\\text{0,k} \\in [0, 1]\\): A variable defining the fraction of \\(\\text{v}_{\\text{start,k}}\\) that is active</li> <li>\\(\\lambda_\\text{1,k} \\in [0, 1]\\): A variable defining the fraction of \\(\\text{v}_{\\text{end,k}}\\) that is active</li> </ul> <p>Which can also be described as \\(v \\in 0 \\cup [\\text{v}_\\text{start}, \\text{v}_\\text{end}]\\).</p> <p>Instead of \\eqref{eq:piecewise_in_pieces}, the following constraint is used to also allow all variables to be zero:</p> \\[ \\label{eq:piecewise_in_pieces_zero} \\sum_{k=1}^k \\beta_{k} = \\beta_\\text{zero} \\] <p>With:</p> <ul> <li>\\(\\beta_\\text{zero} \\in \\{0, 1\\}\\).</li> </ul> <p>Which can also be described as \\(v \\in \\{0\\} \\cup [\\text{v}_{\\text{start_k}}, \\text{v}_{\\text{end_k}}]\\)</p>"},{"location":"user-guide/Mathematical%20Notation/Piecewise/#combining-multiple-piecewises","title":"Combining multiple Piecewises","text":"<p>Piecewise allows representing non-linear relationships. This is a powerful technique in linear optimization to model non-linear behaviors while maintaining the problem's linearity.</p> <p>Therefore, each Piecewise must have the same number of Pieces \\(k\\).</p> <p>The variables described in Piecewise are created for each Piece, but nor for each Piecewise. Rather, \\eqref{eq:piece} is the only constraint that is created for each Piecewise, using the start and endpoints \\(\\text{v}_{\\text{start,k}}\\) and \\(\\text{v}_{\\text{end,k}}\\) of each Piece for the corresponding variable \\(v\\)</p>"},{"location":"user-guide/Mathematical%20Notation/Storage/","title":"Storages","text":"<p>Storages have one incoming and one outgoing Flow with a charging and discharging efficiency. A storage has a state of charge \\(c(\\text{t}_i)\\) which is limited by its <code>size</code> \\(\\text C\\) and relative bounds \\(\\eqref{eq:Storage_Bounds}\\).</p> \\[ \\label{eq:Storage_Bounds}     \\text C \\cdot \\text c^{\\text{L}}_{\\text{rel}}(\\text t_{i})     \\leq c(\\text{t}_i) \\leq     \\text C \\cdot \\text c^{\\text{U}}_{\\text{rel}}(\\text t_{i}) \\] <p>Where:</p> <ul> <li>\\(\\text C\\) is the size of the storage</li> <li>\\(c(\\text{t}_i)\\) is the state of charge at time \\(\\text{t}_i\\)</li> <li>\\(\\text c^{\\text{L}}_{\\text{rel}}(\\text t_{i})\\) is the relative lower bound (typically 0)</li> <li>\\(\\text c^{\\text{U}}_{\\text{rel}}(\\text t_{i})\\) is the relative upper bound (typically 1)</li> </ul> <p>With \\(\\text c^{\\text{L}}_{\\text{rel}}(\\text t_{i}) = 0\\) and \\(\\text c^{\\text{U}}_{\\text{rel}}(\\text t_{i}) = 1\\), Equation \\(\\eqref{eq:Storage_Bounds}\\) simplifies to</p> \\[ 0 \\leq c(\\text t_{i}) \\leq \\text C \\] <p>The state of charge \\(c(\\text{t}_i)\\) decreases by a fraction of the prior state of charge. The belonging parameter $ \\dot{ \\text c}_\\text{rel, loss}(\\text{t}_i)$ expresses the \"loss fraction per hour\". The storage balance from  \\(\\text{t}_i\\) to \\(\\text t_{i+1}\\) is</p> \\[ \\begin{align*}     c(\\text{t}_{i+1}) &amp;= c(\\text{t}_{i}) \\cdot (1-\\dot{\\text{c}}_\\text{rel,loss}(\\text{t}_i) \\cdot \\Delta \\text{t}_{i}) \\\\     &amp;\\quad + p_{f_\\text{in}}(\\text{t}_i) \\cdot \\Delta \\text{t}_i \\cdot \\eta_\\text{in}(\\text{t}_i) \\\\     &amp;\\quad - \\frac{p_{f_\\text{out}}(\\text{t}_i) \\cdot \\Delta \\text{t}_i}{\\eta_\\text{out}(\\text{t}_i)}     \\tag{3} \\end{align*} \\] <p>Where:</p> <ul> <li>\\(c(\\text{t}_{i+1})\\) is the state of charge at time \\(\\text{t}_{i+1}\\)</li> <li>\\(c(\\text{t}_{i})\\) is the state of charge at time \\(\\text{t}_{i}\\)</li> <li>\\(\\dot{\\text{c}}_\\text{rel,loss}(\\text{t}_i)\\) is the relative loss rate (self-discharge) per hour</li> <li>\\(\\Delta \\text{t}_{i}\\) is the time step duration in hours</li> <li>\\(p_{f_\\text{in}}(\\text{t}_i)\\) is the input flow rate at time \\(\\text{t}_i\\)</li> <li>\\(\\eta_\\text{in}(\\text{t}_i)\\) is the charging efficiency at time \\(\\text{t}_i\\)</li> <li>\\(p_{f_\\text{out}}(\\text{t}_i)\\) is the output flow rate at time \\(\\text{t}_i\\)</li> <li>\\(\\eta_\\text{out}(\\text{t}_i)\\) is the discharging efficiency at time \\(\\text{t}_i\\)</li> </ul>"},{"location":"user-guide/Mathematical%20Notation/others/","title":"Work in Progress","text":"<p>This is a work in progress.</p>"}]}